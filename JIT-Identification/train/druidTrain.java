String url = dataSource.getUrl();
return dataSource.getUrl();
newSqlStat.setDataSource(this.dataSource.getUrl());
public String getUsername() {
public void setUsername(String user) {
public String getUrl() {
public void setDriverClassName(String driverClass) {
this.url = dataSource.getUrl();
user = dataSource.getUsername();
String getUsername();
String getUrl();
String getUrl();
public String getUrl() {
public class TestUtil {
public static long getYoungGC() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
ObjectName objectName;
if (mbeanServer.isRegistered(new ObjectName("java.lang:type=GarbageCollector,name=ParNew"))) {
objectName = new ObjectName("java.lang:type=GarbageCollector,name=ParNew");
} else if (mbeanServer.isRegistered(new ObjectName("java.lang:type=GarbageCollector,name=Copy"))) {
objectName = new ObjectName("java.lang:type=GarbageCollector,name=Copy");
objectName = new ObjectName("java.lang:type=GarbageCollector,name=PS Scavenge");
return (Long) mbeanServer.getAttribute(objectName, "CollectionCount");
} catch (Exception e) {
throw new RuntimeException("error");
public static long getFullGC() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
ObjectName objectName;
if (mbeanServer.isRegistered(new ObjectName("java.lang:type=GarbageCollector,name=ConcurrentMarkSweep"))) {
objectName = new ObjectName("java.lang:type=GarbageCollector,name=ConcurrentMarkSweep");
} else if (mbeanServer.isRegistered(new ObjectName("java.lang:type=GarbageCollector,name=MarkSweepCompact"))) {
objectName = new ObjectName("java.lang:type=GarbageCollector,name=MarkSweepCompact");
objectName = new ObjectName("java.lang:type=GarbageCollector,name=PS MarkSweep");
return (Long) mbeanServer.getAttribute(objectName, "CollectionCount");
} catch (Exception e) {
throw new RuntimeException("error");
dataSource.setDriverClassName(driverClass);
dataSource.setUsername(user);
dataSource.setDriverClassName(driverClass);
dataSource.setUsername(user);
dataSource.setDriverClassName("com.alibaba.druid.mock.MockDriver");
dataSource.setDriverClassName(driverClass);
dataSource.setDriverClassName(driverClass);
dataSource.setUsername(user);
p0(dataSource, "druid");
System.out.println();
p0(dataSource, "dbcp");
System.out.println();
private void p0(DataSource dataSource, String name) throws SQLException {
long startYGC = TestUtil.getYoungGC();
long startFullGC = TestUtil.getFullGC();
long ygc = TestUtil.getYoungGC() - startYGC;
long fullGC = TestUtil.getFullGC() - startFullGC;
System.out.println(name + " millis : " + NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC);
private static final long serialVersionUID = 1L;
public class TestReplaceLicense extends TestCase {
private String license;
private String lineSeparator;
protected void setUp() throws Exception {
InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("License.txt");
Reader reader = new InputStreamReader(is);
license = JdbcUtils.read(reader);
reader.close();
System.out.println(license);
lineSeparator = (String) java.security.AccessController.doPrivileged(
new sun.security.action.GetPropertyAction("line.separator"));
public void test_0() throws Exception {
File file = new File("/usr/alibaba/workspace/druid");
listFile(file);
public void listFile(File file) throws Exception {
if (file.isDirectory()) {
for (File child : file.listFiles()) {
listFile(child);
if (file.getName().endsWith(".java")) {
listJavaFile(file);
public void listJavaFile(File file) throws Exception {
FileInputStream in = new FileInputStream(file);
InputStreamReader reader = new InputStreamReader(in, "utf-8");
String content = JdbcUtils.read(reader);
reader.close();
if (!content.startsWith(license)) {
String newContent;
int index = content.indexOf("package ");
if (index != -1) {
newContent = license + lineSeparator + content.substring(index);
newContent = license + lineSeparator + content;
FileOutputStream out = new FileOutputStream(file);
Writer writer = new OutputStreamWriter(out, "utf-8");
writer.write(newContent);
writer.close();
final int maxWaitThreadCount = getMaxWaitThreadCount();
public class MiscellaneousFunctionsTest extends TestCase {
public void test_0() throws Exception {
String sql = "UPDATE t SET i = DEFAULT(i)+1 WHERE id < 100;";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("UPDATE t SET i = DEFAULT(i) + 1 WHERE id < 100;", text);
public void test_1() throws Exception {
String sql = "SELECT GET_LOCK('lock1',10);";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT GET_LOCK('lock1', 10);", text);
public void test_2() throws Exception {
String sql = "SELECT INET_ATON('209.207.224.40');";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT INET_ATON('209.207.224.40');", text);
public void test_3() throws Exception {
String sql = "SELECT UUID();";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT UUID();", text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
out.append(";");
return out.toString();
public class Demo0 extends TestCase {
public void test_demo_0() throws Exception {
String sql = "SELECT UUID();";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
out.append(";");
System.out.println(out.toString());
private static final long   serialVersionUID                          = 1L;
public final static int     DEFAULT_INITIAL_SIZE                      = 0;
public final static int     DEFAULT_MAX_ACTIVE_SIZE                   = 8;
public final static int     DEFAULT_MAX_IDLE                          = 8;
public final static int     DEFAULT_MIN_IDLE                          = 0;
public final static int     DEFAULT_MAX_WAIT                          = -1;
public final static String  DEFAULT_VALIDATION_QUERY                  = "SELECT 1";
public final static boolean DEFAULT_TEST_ON_BORROW                    = true;
public final static boolean DEFAULT_TEST_ON_RETURN                    = false;
public final static boolean DEFAULT_WHILE_IDLE                        = false;
public static final long    DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int     DEFAULT_NUM_TESTS_PER_EVICTION_RUN        = 3;
public static final long    DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS    = 1000L * 60L * 30L;
private boolean             defaultAutoCommit                         = false;
private String              defaultCatalog                            = null;
protected Properties        properties                                = new Properties();
protected int               initialSize                               = DEFAULT_INITIAL_SIZE;
protected int               maxActive                                 = DEFAULT_MAX_ACTIVE_SIZE;
protected int               minIdle                                   = DEFAULT_MIN_IDLE;
protected int               maxIdle                                   = DEFAULT_MAX_IDLE;
protected long              maxWait                                   = DEFAULT_MAX_WAIT;
protected String            validationQuery                           = DEFAULT_VALIDATION_QUERY;
protected int               validationQueryTimeout                    = -1;
private boolean             testOnBorrow                              = DEFAULT_TEST_ON_BORROW;
private boolean             testOnReturn                              = DEFAULT_TEST_ON_RETURN;
private boolean             testWhileIdle                             = DEFAULT_WHILE_IDLE;
protected boolean           poolPreparedStatements                    = false;
protected boolean           inited                                    = false;
protected PrintWriter       logWriter                                 = new PrintWriter(System.out);
private final List<Filter>  filters                                   = new ArrayList<Filter>();
protected int               maxWaitThreadCount                        = -1;
protected boolean           accessToUnderlyingConnectionAllowed       = true;
protected long              timeBetweenEvictionRunsMillis             = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
protected int               numTestsPerEvictionRun                    = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
protected long              minEvictableIdleTimeMillis                = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
protected boolean           removeAbandoned;
protected int               removeAbandonedTimeout;
protected boolean           logAbandoned;
protected int               maxOpenPreparedStatements                 = -1;
protected List<String>      connectionInitSqls;
public void addConnectionProperty(String name, String value) {
properties.put(name, value);
public Collection<String> getConnectionInitSqls() {
Collection<String> result = connectionInitSqls;
if (result == null) {
return Collections.emptyList();
return result;
public void setConnectionInitSqls(Collection<Object> connectionInitSqls) {
if ((connectionInitSqls != null) && (connectionInitSqls.size() > 0)) {
ArrayList<String> newVal = null;
for (Iterator<Object> iterator = connectionInitSqls.iterator();
iterator.hasNext();) {
Object o = iterator.next();
if (o != null) {
String s = o.toString();
if (s.trim().length() > 0) {
if (newVal == null) {
newVal = new ArrayList<String>();
newVal.add(s);
this.connectionInitSqls = newVal;
this.connectionInitSqls = null;
public int getMaxOpenPreparedStatements() {
return maxOpenPreparedStatements;
public void setMaxOpenPreparedStatements(int maxOpenPreparedStatements) {
this.maxOpenPreparedStatements = maxOpenPreparedStatements;
public boolean isLogAbandoned() {
return logAbandoned;
public void setLogAbandoned(boolean logAbandoned) {
this.logAbandoned = logAbandoned;
public int getRemoveAbandonedTimeout() {
return removeAbandonedTimeout;
public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
this.removeAbandonedTimeout = removeAbandonedTimeout;
public boolean isRemoveAbandoned() {
return removeAbandoned;
public void setRemoveAbandoned(boolean removeAbandoned) {
this.removeAbandoned = removeAbandoned;
public long getMinEvictableIdleTimeMillis() {
return minEvictableIdleTimeMillis;
public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
public int getNumTestsPerEvictionRun() {
return numTestsPerEvictionRun;
public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
this.numTestsPerEvictionRun = numTestsPerEvictionRun;
public long getTimeBetweenEvictionRunsMillis() {
return timeBetweenEvictionRunsMillis;
public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
public int getValidationQueryTimeout() {
return validationQueryTimeout;
public void setValidationQueryTimeout(int validationQueryTimeout) {
this.validationQueryTimeout = validationQueryTimeout;
public boolean isAccessToUnderlyingConnectionAllowed() {
return accessToUnderlyingConnectionAllowed;
public void setAccessToUnderlyingConnectionAllowed(boolean accessToUnderlyingConnectionAllowed) {
this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
public class DruidDataSourceFactory implements ObjectFactory {
static final int UNKNOWN_TRANSACTIONISOLATION = -1;
private final static String   PROP_DEFAULTAUTOCOMMIT                   = "defaultAutoCommit";
private final static String   PROP_DEFAULTREADONLY                     = "defaultReadOnly";
private final static String   PROP_DEFAULTTRANSACTIONISOLATION         = "defaultTransactionIsolation";
private final static String   PROP_DEFAULTCATALOG                      = "defaultCatalog";
private final static String   PROP_DRIVERCLASSNAME                     = "driverClassName";
private final static String   PROP_MAXACTIVE                           = "maxActive";
private final static String   PROP_MAXIDLE                             = "maxIdle";
private final static String   PROP_MINIDLE                             = "minIdle";
private final static String   PROP_INITIALSIZE                         = "initialSize";
private final static String   PROP_MAXWAIT                             = "maxWait";
private final static String   PROP_TESTONBORROW                        = "testOnBorrow";
private final static String   PROP_TESTONRETURN                        = "testOnReturn";
private final static String   PROP_TIMEBETWEENEVICTIONRUNSMILLIS       = "timeBetweenEvictionRunsMillis";
private final static String   PROP_NUMTESTSPEREVICTIONRUN              = "numTestsPerEvictionRun";
private final static String   PROP_MINEVICTABLEIDLETIMEMILLIS          = "minEvictableIdleTimeMillis";
private final static String   PROP_TESTWHILEIDLE                       = "testWhileIdle";
private final static String   PROP_PASSWORD                            = "password";
private final static String   PROP_URL                                 = "url";
private final static String   PROP_USERNAME                            = "username";
private final static String   PROP_VALIDATIONQUERY                     = "validationQuery";
private final static String   PROP_VALIDATIONQUERY_TIMEOUT             = "validationQueryTimeout";
private final static String   PROP_INITCONNECTIONSQLS                  = "initConnectionSqls";
private final static String   PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
private final static String   PROP_REMOVEABANDONED                     = "removeAbandoned";
private final static String   PROP_REMOVEABANDONEDTIMEOUT              = "removeAbandonedTimeout";
private final static String   PROP_LOGABANDONED                        = "logAbandoned";
private final static String   PROP_POOLPREPAREDSTATEMENTS              = "poolPreparedStatements";
private final static String   PROP_MAXOPENPREPAREDSTATEMENTS           = "maxOpenPreparedStatements";
private final static String   PROP_CONNECTIONPROPERTIES                = "connectionProperties";
private final static String[] ALL_PROPERTIES                           = { PROP_DEFAULTAUTOCOMMIT,
PROP_DEFAULTREADONLY, PROP_DEFAULTTRANSACTIONISOLATION, PROP_DEFAULTCATALOG, PROP_DRIVERCLASSNAME,
PROP_MAXACTIVE, PROP_MAXIDLE, PROP_MINIDLE, PROP_INITIALSIZE, PROP_MAXWAIT, PROP_TESTONBORROW,
PROP_TESTONRETURN, PROP_TIMEBETWEENEVICTIONRUNSMILLIS, PROP_NUMTESTSPEREVICTIONRUN,
PROP_MINEVICTABLEIDLETIMEMILLIS, PROP_TESTWHILEIDLE, PROP_PASSWORD, PROP_URL, PROP_USERNAME,
PROP_VALIDATIONQUERY, PROP_VALIDATIONQUERY_TIMEOUT, PROP_INITCONNECTIONSQLS,
PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED, PROP_REMOVEABANDONED, PROP_REMOVEABANDONEDTIMEOUT,
PROP_LOGABANDONED, PROP_POOLPREPAREDSTATEMENTS, PROP_MAXOPENPREPAREDSTATEMENTS, PROP_CONNECTIONPROPERTIES };
public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment)
throws Exception {
if ((obj == null) || !(obj instanceof Reference)) {
return null;
Reference ref = (Reference) obj;
if (!"javax.sql.DataSource".equals(ref.getClassName())) {
return null;
Properties properties = new Properties();
for (int i = 0; i < ALL_PROPERTIES.length; i++) {
String propertyName = ALL_PROPERTIES[i];
RefAddr ra = ref.get(propertyName);
if (ra != null) {
String propertyValue = ra.getContent().toString();
properties.setProperty(propertyName, propertyValue);
return createDataSource(properties);
public static DataSource createDataSource(Properties properties) throws Exception {
DruidDataSource dataSource = new DruidDataSource();
String value = null;
value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT);
if (value != null) {
dataSource.setDefaultAutoCommit(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_DEFAULTREADONLY);
if (value != null) {
dataSource.setDefaultReadOnly(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION);
if (value != null) {
int level = UNKNOWN_TRANSACTIONISOLATION;
if ("NONE".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_NONE;
} else if ("READ_COMMITTED".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_READ_COMMITTED;
} else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_READ_UNCOMMITTED;
} else if ("REPEATABLE_READ".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_REPEATABLE_READ;
} else if ("SERIALIZABLE".equalsIgnoreCase(value)) {
level = Connection.TRANSACTION_SERIALIZABLE;
level = Integer.parseInt(value);
} catch (NumberFormatException e) {
System.err.println("Could not parse defaultTransactionIsolation: " + value);
System.err.println("WARNING: defaultTransactionIsolation not set");
System.err.println("using default value of database driver");
level = UNKNOWN_TRANSACTIONISOLATION;
dataSource.setDefaultTransactionIsolation(level);
value = properties.getProperty(PROP_DEFAULTCATALOG);
if (value != null) {
dataSource.setDefaultCatalog(value);
value = properties.getProperty(PROP_DRIVERCLASSNAME);
if (value != null) {
dataSource.setDriverClassName(value);
value = properties.getProperty(PROP_MAXACTIVE);
if (value != null) {
dataSource.setMaxActive(Integer.parseInt(value));
value = properties.getProperty(PROP_MAXIDLE);
if (value != null) {
dataSource.setMaxIdle(Integer.parseInt(value));
value = properties.getProperty(PROP_MINIDLE);
if (value != null) {
dataSource.setMinIdle(Integer.parseInt(value));
value = properties.getProperty(PROP_INITIALSIZE);
if (value != null) {
dataSource.setInitialSize(Integer.parseInt(value));
value = properties.getProperty(PROP_MAXWAIT);
if (value != null) {
dataSource.setMaxWait(Long.parseLong(value));
value = properties.getProperty(PROP_TESTONBORROW);
if (value != null) {
dataSource.setTestOnBorrow(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_TESTONRETURN);
if (value != null) {
dataSource.setTestOnReturn(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS);
if (value != null) {
dataSource.setTimeBetweenEvictionRunsMillis(Long.parseLong(value));
value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN);
if (value != null) {
dataSource.setNumTestsPerEvictionRun(Integer.parseInt(value));
value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS);
if (value != null) {
dataSource.setMinEvictableIdleTimeMillis(Long.parseLong(value));
value = properties.getProperty(PROP_TESTWHILEIDLE);
if (value != null) {
dataSource.setTestWhileIdle(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_PASSWORD);
if (value != null) {
dataSource.setPassword(value);
value = properties.getProperty(PROP_URL);
if (value != null) {
dataSource.setUrl(value);
value = properties.getProperty(PROP_USERNAME);
if (value != null) {
dataSource.setUsername(value);
value = properties.getProperty(PROP_VALIDATIONQUERY);
if (value != null) {
dataSource.setValidationQuery(value);
value = properties.getProperty(PROP_VALIDATIONQUERY_TIMEOUT);
if (value != null) {
dataSource.setValidationQueryTimeout(Integer.parseInt(value));
value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED);
if (value != null) {
dataSource.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_REMOVEABANDONED);
if (value != null) {
dataSource.setRemoveAbandoned(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT);
if (value != null) {
dataSource.setRemoveAbandonedTimeout(Integer.parseInt(value));
value = properties.getProperty(PROP_LOGABANDONED);
if (value != null) {
dataSource.setLogAbandoned(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS);
if (value != null) {
dataSource.setPoolPreparedStatements(Boolean.valueOf(value).booleanValue());
value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS);
if (value != null) {
dataSource.setMaxOpenPreparedStatements(Integer.parseInt(value));
value = properties.getProperty(PROP_INITCONNECTIONSQLS);
if (value != null) {
StringTokenizer tokenizer = new StringTokenizer(value, ";");
dataSource.setConnectionInitSqls(Collections.list(tokenizer));
value = properties.getProperty(PROP_CONNECTIONPROPERTIES);
if (value != null) {
Properties p = getProperties(value);
Enumeration<?> e = p.propertyNames();
while (e.hasMoreElements()) {
String propertyName = (String) e.nextElement();
dataSource.addConnectionProperty(propertyName, p.getProperty(propertyName));
if (dataSource.getInitialSize() > 0) {
dataSource.getLogWriter();
return dataSource;
static private Properties getProperties(String propText) throws Exception {
Properties p = new Properties();
if (propText != null) {
p.load(new ByteArrayInputStream(propText.replace(';', 'n').getBytes()));
private int threadCount = 20;
private int loopCount = 5;
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "druid", threadCount);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "dbcp", threadCount);
public PrintWriter getLogWriter() {
protected void printStackTrace(Throwable e) {
if (logWriter != null) {
e.printStackTrace(logWriter);
printStackTrace(e);
printStackTrace(e);
@SuppressWarnings("unused")
@SuppressWarnings("serial")
private static final long   serialVersionUID = 1L;
private final List<SQLExpr> arguments        = new ArrayList<SQLExpr>();
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
protected int             year;
protected int             month;
protected int             dayOfMonth;
protected int             hour;
protected int             minute;
protected int             second;
private static final long serialVersionUID = 1L;
private SQLExpr           expr;
private String            dbLink;
private static final long  serialVersionUID = 1L;
private static final long     serialVersionUID = 1L;
private final List<SQLExpr>   exprList         = new ArrayList<SQLExpr>();
private final List<SQLExpr>   targetExprList   = new ArrayList<SQLExpr>();
private static final long   serialVersionUID = 1L;
private final List<SQLExpr> items            = new ArrayList<SQLExpr>();
private static final long  serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
private SQLExpr           expr;
private static final long serialVersionUID = 1L;
private SQLExpr           expr;
private boolean           outer            = false;
private static final long serialVersionUID = 1L;
private int               milliSecond;
private String            timeZone;
@SuppressWarnings("unused")
public class TransactionContext {
private final TransactionRegistry transactionRegistry;
private final WeakReference transactionRef;
private Connection sharedConnection;
public TransactionContext(TransactionRegistry transactionRegistry, Transaction transaction) {
if (transactionRegistry == null) throw new NullPointerException("transactionRegistry is null");
if (transaction == null) throw new NullPointerException("transaction is null");
this.transactionRegistry = transactionRegistry;
this.transactionRef = new WeakReference(transaction);
public Connection getSharedConnection() {
return sharedConnection;
public void setSharedConnection(Connection sharedConnection) throws SQLException {
if (this.sharedConnection != null) {
throw new IllegalStateException("A shared connection is alredy set");
Transaction transaction = getTransaction();
XAResource xaResource = transactionRegistry.getXAResource(sharedConnection);
transaction.enlistResource(xaResource);
} catch (RollbackException e) {
} catch (SystemException e) {
throw (SQLException) new SQLException("Unable to enlist connection the transaction").initCause(e);
this.sharedConnection = sharedConnection;
public void addTransactionContextListener(final TransactionContextListener listener) throws SQLException {
getTransaction().registerSynchronization(new Synchronization() {
public void beforeCompletion() {
public void afterCompletion(int status) {
listener.afterCompletion(TransactionContext.this, status == Status.STATUS_COMMITTED);
} catch (RollbackException e) {
} catch (Exception e) {
throw (SQLException) new SQLException("Unable to register transaction context listener").initCause(e);
public boolean isActive() throws SQLException {
Transaction transaction = (Transaction) this.transactionRef.get();
if (transaction == null) {
return false;
int status = transaction.getStatus();
return status == Status.STATUS_ACTIVE || status == Status.STATUS_MARKED_ROLLBACK;
} catch (SystemException e) {
throw (SQLException) new SQLException("Unable to get transaction status").initCause(e);
private Transaction getTransaction() throws SQLException {
Transaction transaction = (Transaction) this.transactionRef.get();
if (transaction == null) {
throw new SQLException("Unable to enlist connection because the transaction has been garbage collected");
return transaction;
public interface TransactionContextListener {
void afterCompletion(TransactionContext transactionContext, boolean commited);
public class TransactionRegistry {
private final TransactionManager transactionManager;
private final Map caches = new WeakHashMap();
private final Map xaResources = new WeakHashMap();
public TransactionRegistry(TransactionManager transactionManager) {
this.transactionManager = transactionManager;
public synchronized void registerConnection(Connection connection, XAResource xaResource) {
if (connection == null) throw new NullPointerException("connection is null");
if (xaResource == null) throw new NullPointerException("xaResource is null");
xaResources.put(connection, xaResource);
public synchronized XAResource getXAResource(Connection connection) throws SQLException {
if (connection == null) throw new NullPointerException("connection is null");
XAResource xaResource = (XAResource) xaResources.get(connection);
if (xaResource == null) {
throw new SQLException("Connection does not have a registered XAResource " + connection);
return xaResource;
public TransactionContext getActiveTransactionContext() throws SQLException {
Transaction transaction = null;
transaction = transactionManager.getTransaction();
if (transaction == null) {
return null;
int status = transaction.getStatus();
if (status != Status.STATUS_ACTIVE && status != Status.STATUS_MARKED_ROLLBACK) {
return null;
} catch (SystemException e) {
throw (SQLException) new SQLException("Unable to determine current transaction ").initCause(e);
synchronized (this) {
TransactionContext cache = (TransactionContext) caches.get(transaction);
if (cache == null) {
cache = new TransactionContext(this, transaction);
caches.put(transaction, cache);
return cache;
public synchronized void unregisterConnection(Connection connection) {
xaResources.remove(connection);
public interface XAConnectionFactory extends ConnectionFactory {
TransactionRegistry getTransactionRegistry();
Connection createConnection() throws SQLException;
private final WeakReference<Transaction> transactionRef;
this.transactionRef = new WeakReference<Transaction>(transaction);
private final Map<Transaction, TransactionContext> caches = new WeakHashMap<Transaction, TransactionContext>();
private final Map<Connection, XAResource> xaResources = new WeakHashMap<Connection, XAResource>();
public void setConnectionProperties(String connectionProperties) {
if (connectionProperties == null) throw new NullPointerException("connectionProperties is null");
String[] entries = connectionProperties.split(";");
Properties properties = new Properties();
for (int i = 0; i < entries.length; i++) {
String entry = entries[i];
if (entry.length() > 0) {
int index = entry.indexOf('=');
if (index > 0) {
String name = entry.substring(0, index);
String value = entry.substring(index + 1);
properties.setProperty(name, value);
properties.setProperty(entry, "");
this.connectionProperties = properties;
if (connectionProperties == null) {
throw new NullPointerException("connectionProperties is null");
if (inited) {
throw new UnsupportedOperationException();
if (inited) {
throw new UnsupportedOperationException();
public static final int     DEFAULT_NUM_TESTS_PER_EVICTION_RUN        = 1;
@Deprecated
@SuppressWarnings("deprecation")
dataSource.setStatementsCacheSize(100);
dataSource.setAcquireIncrement(5);
dataSource.setIdleConnectionTestPeriod(0L);
dataSource.setDisableConnectionTracking(true);
private int    threadCount     = 2;
private int    loopCount       = 5;
protected void createPoolableConnectionFactory(ConnectionFactory driverConnectionFactory) throws SQLException {
Assert.assertEquals(6, dataSource.getRawDriverMinorVersion());
protected XADataSource        xaDataSource;
protected String              username;
protected String              password;
public DataSourceXAConnectionFactory(TransactionManager transactionManager, XADataSource xaDataSource){
public DataSourceXAConnectionFactory(TransactionManager transactionManager, XADataSource xaDataSource,
String username, String password){
Class<?> xaDataSourceClass = null;
if (transactionManager == null) {
throw new NullPointerException("transactionManager is null");
if (connectionFactory == null) {
throw new NullPointerException("connectionFactory is null");
public ManagedDataSource(){
public ManagedDataSource(TransactionRegistry transactionRegistry){
if (this.transactionRegistry != null) throw new IllegalStateException("TransactionRegistry already set");
if (transactionRegistry == null) throw new NullPointerException("TransactionRegistry is null");
private final TransactionRegistry        transactionRegistry;
private Connection                       sharedConnection;
public TransactionContext(TransactionRegistry transactionRegistry, Transaction transaction){
private final TransactionManager                   transactionManager;
private final Map<Transaction, TransactionContext> caches      = new WeakHashMap<Transaction, TransactionContext>();
private final Map<Connection, XAResource>          xaResources = new WeakHashMap<Connection, XAResource>();
public TransactionRegistry(TransactionManager transactionManager){
private final AtomicLong    connectNanoSpan = new AtomicLong(0);  
private String   jdbcUrl;
private String   user;
private String   password;
private String   driverClass;
private int      initialSize     = 10;
private int      minPoolSize     = 1;
private int      maxPoolSize     = 2;
private int      maxActive       = 2;
private String   validationQuery = null;
public final int LOOP_COUNT      = 5;
for (int i = 0; i < 2; ++i) {
Connection conn = dataSource.getConnection();
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionstat().getConnectCount());
Assert.assertEquals(0, JdbcStatManager.getInstance().getConnectionstat().getCloseCount());
conn.close();
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionstat().getConnectCount());
Assert.assertEquals(0, JdbcStatManager.getInstance().getConnectionstat().getCloseCount()); 
dataSource.close();
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionstat().getConnectCount());
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionstat().getCloseCount());
for (int i = 0; i < 10; ++i) {
Connection conn = dataSource.getConnection();
conn.close();
public class SpringFilterTest extends TestCase {
public void test_spring() throws Exception {
ApplicationContext context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/spring-config-1.xml");
DataSource dataSource = (DataSource) context.getBean("dataSource");
Connection conn = dataSource.getConnection();
conn.close();
TestFilter filter = (TestFilter) context.getBean("test-filter");
Assert.assertEquals(1, filter.getConnectCount());
public static class TestFilter extends FilterAdapter {
private AtomicLong connectCount = new AtomicLong();
public ConnectionProxy connection_connect(FilterChain chain, Properties info) throws SQLException {
connectCount.incrementAndGet();
return chain.connection_connect(info);
public long getConnectCount() {
return connectCount.get();
private final static String   PROP_FILTERS                             = "filters";
PROP_LOGABANDONED, PROP_POOLPREPAREDSTATEMENTS, PROP_MAXOPENPREPAREDSTATEMENTS, PROP_CONNECTIONPROPERTIES,
PROP_FILTERS                                                  };
value = properties.getProperty(PROP_FILTERS);
if (value != null) {
dataSource.setFilters(value);
if (resultSet == null) {
return null;
if (resultSet == null) {
return null;
if (connection == null) {
return null;
if (statement == null) {
return null;
if (statement == null) {
return null;
if (statement == null) {
return null;
if (clob == null) {
return null;
public NClobProxy wrap(ConnectionProxy connection, NClob nclob) {
if (nclob == null) {
return null;
return new NClobProxyImpl(dataSource, connection, nclob);
} else if ("SELECT NULL".equalsIgnoreCase(sql)) {
rs.getRows().add(new Object[] { null });
return (Ref) getObject(columnIndex);
return (Blob) getObject(columnIndex);
return (Clob) getObject(columnIndex);
public class ClobTest extends TestCase {
public void test_clob() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setFilters("stat");
dataSource.setUrl("jdbc:mock:");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT NULL");
Assert.assertTrue(rs.next());
Clob x = rs.getClob(1);
Assert.assertNull(x);
NClob x = rs.getNClob(1);
Assert.assertNull(x);
Blob x = rs.getBlob(1);
Assert.assertNull(x);
SQLXML x = rs.getSQLXML(1);
Assert.assertNull(x);
String x = rs.getString(1);
Assert.assertNull(x);
Assert.assertNull(rs.getRowId(1));
Assert.assertNull(rs.getBigDecimal(1));
Assert.assertNull(rs.getObject(1));
rs.close();
stmt.close();
conn.close();
public MockArray() {
private int                   rowIndex = -1;
private Statement             statement;
private List<Object[]>        rows     = new ArrayList<Object[]>();
private boolean               wasNull  = false;
private MockResultSetMetaData metaData = new MockResultSetMetaData();
return metaData;
public MockResultSetMetaData(){
private final List<ColumnMetaData> columns = new ArrayList<ColumnMetaData>();
public List<ColumnMetaData> getColumns() {
return columns;
return columns.size();
return columns.get(column - 1).isAutoIncrement();
return columns.get(column - 1).isCaseSensitive();
return columns.get(column - 1).isSearchable();
return columns.get(column - 1).isCurrency();
return columns.get(column - 1).getNullable();
return columns.get(column - 1).isSigned();
return columns.get(column - 1).getColumnDisplaySize();
return columns.get(column - 1).getColumnLabel();
return columns.get(column - 1).getColumnName();
return columns.get(column - 1).getSchemaName();
return columns.get(column - 1).getPrecision();
return columns.get(column - 1).getScale();
return columns.get(column - 1).getTableName();
return columns.get(column - 1).getCatalogName();
return columns.get(column - 1).getColumnType();
return columns.get(column - 1).getColumnTypeName();
return columns.get(column - 1).isReadOnly();
return columns.get(column - 1).isWritable();
return columns.get(column - 1).isDefinitelyWritable();
return columns.get(column - 1).getColumnClassName();
public static class ColumnMetaData {
private boolean autoIncrement = false;
private boolean caseSensitive;
private boolean searchable;
private boolean currency;
private int     nullable      = 0;
private boolean signed;
private int     columnDisplaySize;
private String  columnLabel;
private String  columnName;
private String  schemaName;
private int     precision;
private int     scale;
private String  tableName;
private String  catalogName;
private int     columnType;
private String  columnTypeName;
private boolean readOnly;
private boolean writable;
private boolean definitelyWritable;
private String  columnClassName;
public boolean isAutoIncrement() {
return autoIncrement;
public void setAutoIncrement(boolean autoIncrement) {
this.autoIncrement = autoIncrement;
public boolean isCaseSensitive() {
return caseSensitive;
public void setCaseSensitive(boolean caseSensitive) {
this.caseSensitive = caseSensitive;
public boolean isSearchable() {
return searchable;
public void setSearchable(boolean searchable) {
this.searchable = searchable;
public boolean isCurrency() {
return currency;
public void setCurrency(boolean currency) {
this.currency = currency;
public int getNullable() {
return nullable;
public void setNullable(int nullable) {
this.nullable = nullable;
public boolean isSigned() {
return signed;
public void setSigned(boolean signed) {
this.signed = signed;
public int getColumnDisplaySize() {
return columnDisplaySize;
public void setColumnDisplaySize(int columnDisplaySize) {
this.columnDisplaySize = columnDisplaySize;
public String getColumnLabel() {
return columnLabel;
public void setColumnLabel(String columnLabel) {
this.columnLabel = columnLabel;
public String getColumnName() {
return columnName;
public void setColumnName(String columnName) {
this.columnName = columnName;
public String getSchemaName() {
return schemaName;
public void setSchemaName(String schemaName) {
this.schemaName = schemaName;
public int getPrecision() {
return precision;
public void setPrecision(int precision) {
this.precision = precision;
public int getScale() {
return scale;
public void setScale(int scale) {
this.scale = scale;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
public String getCatalogName() {
return catalogName;
public void setCatalogName(String catalogName) {
this.catalogName = catalogName;
public int getColumnType() {
return columnType;
public void setColumnType(int columnType) {
this.columnType = columnType;
public String getColumnTypeName() {
return columnTypeName;
public void setColumnTypeName(String columnTypeName) {
this.columnTypeName = columnTypeName;
public boolean isReadOnly() {
return readOnly;
public void setReadOnly(boolean readOnly) {
this.readOnly = readOnly;
public boolean isWritable() {
return writable;
public void setWritable(boolean writable) {
this.writable = writable;
public boolean isDefinitelyWritable() {
return definitelyWritable;
public void setDefinitelyWritable(boolean definitelyWritable) {
this.definitelyWritable = definitelyWritable;
public String getColumnClassName() {
return columnClassName;
public void setColumnClassName(String columnClassName) {
this.columnClassName = columnClassName;
@SuppressWarnings("unchecked")
if (ResultSetMetaData.class.isAssignableFrom(iface)) {
return (T) this;
if (MockResultSetMetaData.class.isAssignableFrom(iface)) {
return MockResultSetMetaData.class.isAssignableFrom(iface);
public class MockResultSetMetaDataTest extends TestCase {
public void test_resultSet_metadata() throws Exception {
MockResultSetMetaData meta = new MockResultSetMetaData();
Assert.assertTrue(meta.isWrapperFor(MockResultSetMetaData.class));
Assert.assertFalse(meta.isWrapperFor(BigDecimal.class));
Assert.assertTrue(meta.unwrap(MockResultSetMetaData.class) instanceof MockResultSetMetaData);
public class MockParameterMetaData implements ParameterMetaData {
public MockParameterMetaData(){
private final List<Parameter> parameters = new ArrayList<Parameter>();
public List<Parameter> getParameters() {
return parameters;
public <T> T unwrap(Class<T> iface) throws SQLException {
return null;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
return false;
public int getParameterCount() throws SQLException {
return parameters.size();
public int isNullable(int param) throws SQLException {
return parameters.get(param - 1).getNullable();
public boolean isSigned(int param) throws SQLException {
return parameters.get(param - 1).isSigned();
public int getPrecision(int param) throws SQLException {
return parameters.get(param - 1).getPrecision();
public int getScale(int param) throws SQLException {
return parameters.get(param - 1).getScale();
public int getParameterType(int param) throws SQLException {
return parameters.get(param - 1).getType();
public String getParameterTypeName(int param) throws SQLException {
return parameters.get(param - 1).getTypeName();
public String getParameterClassName(int param) throws SQLException {
return parameters.get(param - 1).getClassName();
public int getParameterMode(int param) throws SQLException {
return parameters.get(param - 1).getMode();
public static class Parameter {
private int     nullable;
private boolean signed;
private int     mode;
private String  className;
private int     type;
private String  typeName;
private int     scale;
private int     precision;
public int getType() {
return type;
public void setType(int type) {
this.type = type;
public int getNullable() {
return nullable;
public void setNullable(int nullable) {
this.nullable = nullable;
public boolean isSigned() {
return signed;
public void setSigned(boolean signed) {
this.signed = signed;
public int getMode() {
return mode;
public void setMode(int mode) {
this.mode = mode;
public String getClassName() {
return className;
public void setClassName(String className) {
this.className = className;
public String getTypeName() {
return typeName;
public void setTypeName(String typeName) {
this.typeName = typeName;
public int getScale() {
return scale;
public void setScale(int scale) {
this.scale = scale;
public int getPrecision() {
return precision;
public void setPrecision(int precision) {
this.precision = precision;
private final String          sql;
private final List<Object>    parameters = new ArrayList<Object>();
private MockParameterMetaData metadata   = new MockParameterMetaData();
private MockResultSetMetaData resultSetMetaData = new MockResultSetMetaData();
return resultSetMetaData;
return metadata;
private int baseType;
return baseType;
private String                  prefix         = "jdbc:fake:";
private String                  mockPrefix     = "jdbc:mock:";
private MockExecuteHandler      executeHandler = new MySqlMockExecuteHandlerImpl();
private final static MockDriver instance       = new MockDriver();
public MockExecuteHandler getExecuteHandler() {
return executeHandler;
public void setExecuteHandler(MockExecuteHandler executeHandler) {
this.executeHandler = executeHandler;
protected ResultSet executeQuery(MockStatement stmt, String sql) throws SQLException {
if (this.executeHandler != null) {
return this.executeHandler.executeQuery(stmt, sql);
rs.getRows().add(new Object[] { null });
return fakeConnection.getDriver().executeQuery(this, sql);
public interface MockExecuteHandler {
ResultSet executeQuery(MockStatement statement, String sql) throws SQLException;
public class MySqlMockExecuteHandlerImpl implements MockExecuteHandler {
public ResultSet executeQuery(MockStatement statement, String sql) throws SQLException {
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
if (stmtList.size() > 1) {
throw new SQLException("not support multi-statment. " + sql);
return null;
if (!acceptsURL(url)) {
return null;
if (url == null) {
return false;
return url.startsWith(prefix) || url.startsWith(mockPrefix);
if ("SELECT value FROM _int_1000_".equalsIgnoreCase(sql)) {
MockResultSet rs = new MockResultSet(stmt);
return rs;
return this.executeHandler.executeQuery(stmt, sql);
if (stmtList.size() == 0) {
throw new SQLException("executeQueryError : " + sql);
SQLStatement stmt = stmtList.get(0);
if (!(stmt instanceof SQLSelectStatement)) {
throw new SQLException("executeQueryError : " + sql);
SQLSelect select = ((SQLSelectStatement) stmt).getSelect();
SQLSelectQuery query = select.getQuery();
if (query instanceof SQLSelectQueryBlock) {
return executeQuery(statement, (SQLSelectQueryBlock) query);
throw new SQLException("TODO");
public ResultSet executeQuery(MockStatement statement, SQLSelectQueryBlock query) throws SQLException {
SQLTableSource from = query.getFrom();
if (from instanceof SQLExprTableSource) {
throw new SQLException("TODO");
} else if (from == null) {
return executeQueryFromDual(statement, query);
throw new SQLException("TODO");
public ResultSet executeQueryFromDual(MockStatement statement, SQLSelectQueryBlock query) throws SQLException {
MockResultSet rs = new MockResultSet(statement);
Object[] row = new Object[query.getSelectList().size()];
for (int i = 0, size = query.getSelectList().size(); i < size; ++i) {
SQLSelectItem item = query.getSelectList().get(i);
SQLExpr expr = item.getExpr();
if (expr instanceof SQLNumericLiteralExpr) {
row[i] = ((SQLNumericLiteralExpr) expr).getNumber();
} else if (expr instanceof SQLNullExpr) {
row[i] = null;
} else if (expr instanceof SQLMethodInvokeExpr) {
SQLMethodInvokeExpr methodInvokeExpr = (SQLMethodInvokeExpr) expr;
if ("NOW".equalsIgnoreCase(methodInvokeExpr.getMethodName())) {
row[i] = new Timestamp(System.currentTimeMillis());
throw new SQLException("TODO");
throw new SQLException("TODO");
rs.getRows().add(row);
return rs;
if (!acceptsURL(url)) {
return null;
public abstract Number getNumber();
public class MockExecuteTest extends TestCase {
public void test_0 () throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 2");
Assert.assertTrue(rs.next());
Assert.assertEquals(2, rs.getInt(1));
rs.close();
stmt.close();
conn.close();
public void test_1 () throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT NULL");
Assert.assertTrue(rs.next());
Assert.assertEquals(0, rs.getInt(1));
Assert.assertEquals(null, rs.getObject(1));
rs.close();
stmt.close();
conn.close();
public void test_2 () throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT NOW()");
Assert.assertTrue(rs.next());
Assert.assertTrue(rs.getObject(1) instanceof Timestamp);
rs.close();
stmt.close();
conn.close();
public MockResultSetMetaData getMockMetaData() throws SQLException {
return metaData;
MockResultSetMetaData metaData = rs.getMockMetaData();
ColumnMetaData column = new ColumnMetaData();
if (expr instanceof SQLIntegerExpr) {
row[i] = ((SQLNumericLiteralExpr) expr).getNumber();
column.setColumnType(Types.INTEGER);
} else if (expr instanceof SQLNumberExpr) {
column.setColumnType(Types.DECIMAL);
metaData.getColumns().add(column);
String sql = "SELECT 1";
config.setRawUrl("jdbc:mock:");
public String getColumnName(int column) throws SQLException {
return "C" + column;
config.setRawUrl("jdbc:mock:");
config.setRawUrl("jdbc:mock:");
config.setRawUrl("jdbc:mock:");
String sql = "SELECT 1";
String sql = "SELECT 1";
config.setRawUrl("jdbc:mock:");
public final static MockExecuteHandler DEFAULT_HANDLER = new MySqlMockExecuteHandlerImpl();
private String                         prefix          = "jdbc:fake:";
private String                         mockPrefix      = "jdbc:mock:";
private MockExecuteHandler             executeHandler  = DEFAULT_HANDLER;
private final static MockDriver        instance        = new MockDriver();
public class Slf4jLogFilter extends LogFilter {
private String dataSourceLoggerName = "druid.sql.DataSource";
private String connectionLoggerName = "druid.sql.Connection";
private String statementLoggerName  = "druid.sql.Statement";
private String resultSetLoggerName  = "druid.sql.ResultSet";
private Logger dataSourceLogger     = LoggerFactory.getLogger(dataSourceLoggerName);
private Logger connectionLogger     = LoggerFactory.getLogger(connectionLoggerName);
private Logger statementLogger      = LoggerFactory.getLogger(statementLoggerName);
private Logger resultSetLogger      = LoggerFactory.getLogger(resultSetLoggerName);
public String getDataSourceLoggerName() {
return dataSourceLoggerName;
public void setDataSourceLoggerName(String dataSourceLoggerName) {
this.dataSourceLoggerName = dataSourceLoggerName;
dataSourceLogger = LoggerFactory.getLogger(dataSourceLoggerName);
public void setDataSourceLogger(Logger dataSourceLogger) {
this.dataSourceLogger = dataSourceLogger;
this.dataSourceLoggerName = dataSourceLogger.getName();
public String getConnectionLoggerName() {
return connectionLoggerName;
public void setConnectionLoggerName(String connectionLoggerName) {
this.connectionLoggerName = connectionLoggerName;
connectionLogger = LoggerFactory.getLogger(connectionLoggerName);
public void setConnectionLogger(Logger connectionLogger) {
this.connectionLogger = connectionLogger;
this.connectionLoggerName = connectionLogger.getName();
public String getStatementLoggerName() {
return statementLoggerName;
public void setStatementLoggerName(String statementLoggerName) {
this.statementLoggerName = statementLoggerName;
statementLogger = LoggerFactory.getLogger(statementLoggerName);
public void setStatementLogger(Logger statementLogger) {
this.statementLogger = statementLogger;
this.statementLoggerName = statementLogger.getName();
public String getResultSetLoggerName() {
return resultSetLoggerName;
public void setResultSetLoggerName(String resultSetLoggerName) {
this.resultSetLoggerName = resultSetLoggerName;
resultSetLogger = LoggerFactory.getLogger(resultSetLoggerName);
public void setResultSetLogger(Logger resultSetLogger) {
this.resultSetLogger = resultSetLogger;
this.resultSetLoggerName = resultSetLogger.getName();
public boolean isConnectionLogErrorEnabled() {
return connectionLogger.isErrorEnabled() && super.isConnectionLogErrorEnabled();
public boolean isDataSourceLogEnabled() {
return dataSourceLogger.isDebugEnabled() && super.isDataSourceLogEnabled();
public boolean isConnectionLogEnabled() {
return connectionLogger.isDebugEnabled() && super.isConnectionLogEnabled();
public boolean isStatementLogEnabled() {
return statementLogger.isDebugEnabled() && super.isStatementLogEnabled();
public boolean isResultSetLogEnabled() {
return resultSetLogger.isDebugEnabled() && super.isResultSetLogEnabled();
public boolean isResultSetLogErrorEnabled() {
return  resultSetLogger.isErrorEnabled() && super.isResultSetLogErrorEnabled();
public boolean isStatementLogErrorEnabled() {
return statementLogger.isErrorEnabled() && super.isStatementLogErrorEnabled();
protected void connectionLog(String message) {
connectionLogger.debug(message);
protected void statementLog(String message) {
statementLogger.debug(message);
protected void resultSetLog(String message) {
resultSetLogger.debug(message);
protected void resultSetLogError(String message, Throwable error) {
resultSetLogger.error(message, error);
protected void statementLogError(String message, Throwable error) {
statementLogger.error(message, error);
} else if (expr instanceof SQLCharExpr) {
row[i] = ((SQLCharExpr) expr).getText();
column.setColumnType(Types.VARCHAR);
} else if (expr instanceof SQLNCharExpr) {
row[i] = ((SQLNCharExpr) expr).getText();
column.setColumnType(Types.NVARCHAR);
SQLExpr expr = ((SQLExprTableSource) from).getExpr();
if (expr instanceof SQLIdentifierExpr) {
String ident = ((SQLIdentifierExpr) expr).getName();
if ("dual".equalsIgnoreCase(ident)) {
return executeQueryFromDual(statement, query);
public void test_3() throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT NOW() FROM DUAL");
Assert.assertTrue(rs.next());
Assert.assertTrue(rs.getObject(1) instanceof Timestamp);
rs.close();
stmt.close();
conn.close();
public void test_4() throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 'ABCDE' FROM DUAL");
Assert.assertTrue(rs.next());
Assert.assertEquals("ABCDE", rs.getString(1));
rs.close();
stmt.close();
conn.close();
} else if (expr instanceof MySqlBooleanExpr) {
row[i] = ((MySqlBooleanExpr) expr).getValue();
column.setColumnType(Types.NVARCHAR);
TRUE("TRUE"), FALSE("FALSE"),
public void test_5() throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT true FROM DUAL");
Assert.assertTrue(rs.next());
Assert.assertEquals(true, rs.getBoolean(1));
rs.close();
stmt.close();
conn.close();
public MySqlBooleanExpr(boolean value){
this.value = value;
public SQLExpr primary() throws ParserException {
final Token tok = lexer.token();
switch (tok) {
lexer.nextToken();
return primaryRest(new MySqlBooleanExpr(true));
lexer.nextToken();
return primaryRest(new MySqlBooleanExpr(false));
return super.primary();
public final static Keywords           DEFAULT_MYSQL_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("TRUE", Token.TRUE);
map.put("FALSE", Token.FALSE);
DEFAULT_MYSQL_KEYWORDS = new Keywords(map);
super.keywods = DEFAULT_MYSQL_KEYWORDS;
super.keywods = DEFAULT_MYSQL_KEYWORDS;
public final static Keywords     DEFAULT_KEYWORDS;
public void test_6() throws Exception {
Connection conn = DriverManager.getConnection("jdbc:mock:");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT false FROM DUAL");
Assert.assertTrue(rs.next());
Assert.assertEquals(false, rs.getBoolean(1));
rs.close();
stmt.close();
conn.close();
public void setPasswordCallback(String passwordCallbackClassName) throws Exception {
Class<?> clazz = Thread.currentThread().getContextClassLoader().loadClass(passwordCallbackClassName);
this.passwordCallback = (PasswordCallback) clazz.newInstance();
public class PasswordCallbackTest extends TestCase {
public void test_0 () throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setPasswordCallback(passwordCallback)
char[] chars = dataSource.getPasswordCallback().getPassword();
if (chars != null) {
password = new String(chars);
password = null;
dataSource.setPasswordCallback(new TestPasswordCallback());
Connection conn = dataSource.getConnection();
conn.close();
public static class TestPasswordCallback extends PasswordCallback {
public TestPasswordCallback() {
super ("test", false);
public TestPasswordCallback(String prompt, boolean echoOn){
super(prompt, echoOn);
private static final long serialVersionUID = 1L;
} else if (rawUrl.startsWith("jdbc:hsqldb:")) {
return "org.hsqldb.jdbcDriver";
} else if (rawUrl.startsWith("jdbc:db2:")) {
return "COM.ibm.db2.jdbc.app.DB2Driver";
private static final long serialVersionUID = 1L;
} else if (rawUrl.startsWith("jdbc:sqlite:")) {
return "org.sqlite.JDBC";
} else if (rawUrl.startsWith("jdbc:ingres:")) {
return "com.ingres.jdbc.IngresDriver";
} else if (rawUrl.startsWith("jdbc:h2:")) {
return "org.h2.Driver";
} else if (rawUrl.startsWith("jdbc:mckoi:")) {
return "com.mckoi.JDBCDriver";
private static final Properties driverUrlMapping = new Properties();
for (Enumeration<URL> e = Thread.currentThread().getContextClassLoader().getResources("META-INF/druid-driver.properties"); e.hasMoreElements();) {
URL url = e.nextElement();
Properties property = new Properties();
InputStream is = null;
is = url.openStream();
property.load(is);
} finally {
JdbcUtils.close(is);
driverUrlMapping.putAll(property);
} catch (Exception e) {
e.printStackTrace(); 
} else if (rawUrl.startsWith("jdbc:sybase:Tds:")) {
return "com.sybase.jdbc2.jdbc.SybDriver";
} else if (rawUrl.startsWith("jdbc:cloudscape:")) {
return "COM.cloudscape.core.JDBCDriver";
} else if (rawUrl.startsWith("jdbc:informix-sqli:")) {
return "com.informix.jdbc.IfxDriver";
} else if (rawUrl.startsWith("jdbc:timesten:")) {
return "com.timesten.jdbc.TimesTenDriver";
} else if (rawUrl.startsWith("jdbc:as400:")) {
return "com.ibm.as400.access.AS400JDBCDriver";
} else if (rawUrl.startsWith("jdbc:sapdb:")) {
return "com.sap.dbtech.jdbc.DriverSapDB";
} else if (rawUrl.startsWith("jdbc:JSQLConnect:")) {
return "com.jnetdirect.jsql.JSQLDriver";
} else if (rawUrl.startsWith("jdbc:JTurbo:")) {
return "com.newatlanta.jturbo.driver.Driver";
} else if (rawUrl.startsWith("jdbc:firebirdsql:")) {
return "org.firebirdsql.jdbc.FBDriver";
} else if (rawUrl.startsWith("jdbc:interbase:")) {
return "interbase.interclient.Driver";
} else if (rawUrl.startsWith("jdbc:pointbase:")) {
return "com.pointbase.jdbc.jdbcUniversalDriver";
} else if (rawUrl.startsWith("jdbc:edbc:")) {
return "ca.edbc.jdbc.EdbcDriver";
} else if (rawUrl.startsWith("jdbc:mimer:multi1:")) {
return "com.mimer.jdbc.Driver";
throw new SQLException("unkow jdbc driver : " + rawUrl);
print(x.getValue() ? "true" : "false");
return false;
Assert.assertEquals("SELECT true, true, false, false;", text);
Assert.assertEquals("SELECT 1 IS true, 0 IS false, NULL IS UNKNOWN;", text);
Assert.assertEquals("SELECT 10 IS true;", text);
Assert.assertEquals("SELECT -10 IS true;", text);
public abstract class DruidAbstractDataSource implements DataSource, DataSourceProxy, Serializable {
private final DruidAbstractDataSource dataSource;
public DruidPoolConnectionFactory(DruidAbstractDataSource dataSource) throws SQLException{
public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, Referenceable {
lowWater.signal();
final int COUNT = 10;
Connection[] connections = new Connection[COUNT];
for (int i = 0; i < COUNT; ++i) {
connections[i] = dataSource.getConnection();
for (int i = 0; i < COUNT; ++i) {
connections[i].close();
public final static int MinorVersion    = 1;
public class Demo0 extends TestCase {
public void test_demo_0() throws Exception {
String sql = "SELECT SYSDATE FROM DUAL";
SQLStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
out.append(";");
System.out.println(out.toString());
public class SQLLexerTest2 extends TestCase {
public void test_lexer() throws Exception {
String sql = "SELECT * FROM T WHERE F1 = ? ORDER BY F2";
SQLLexer lexer = new SQLLexer(sql);
for (;;) {
lexer.nextToken();
Token tok = lexer.token();
if (tok == Token.IDENTIFIER) {
System.out.println(tok.name() + "tt" + lexer.stringVal);
System.out.println(tok.name() + "ttt" + tok.name);
if (tok == Token.EOF) {
Lexer lexer = new Lexer(sql);
public void test_merge_1() throws Exception {
String result = merge();
System.out.println(result);
public void test_merge_2() throws Exception {
String result = merge2();
System.out.println(result);
void perf() {
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 1000; ++i) {
long millis = System.currentTimeMillis() - startMillis;
System.out.println(millis);
private String merge() {
return out.toString();
private String merge2() {
String sql = "INSERT INTO T (F1, F2, F3, F4, F5) VALUES (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?)";
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out) {
public boolean visit(SQLInListExpr x) {
x.getExpr().accept(this);
if (x.isNot()) {
print(" NOT IN (##)");
print(" IN (##)");
return false;
public boolean visit(MySqlInsertStatement x) {
print("INSERT ");
if (x.isLowPriority()) {
print("LOW_PRIORITY ");
if (x.isDelayed()) {
print("DELAYED ");
if (x.isHighPriority()) {
print("HIGH_PRIORITY ");
if (x.isIgnore()) {
print("IGNORE ");
print("INTO ");
x.getTableName().accept(this);
if (x.getColumns().size() > 0) {
print(" (");
for (int i = 0, size = x.getColumns().size(); i < size; ++i) {
if (i != 0) {
print(", ");
x.getColumns().get(i).accept(this);
print(")");
if (x.getValuesList().size() != 0) {
print(" VALUES ");
int size = x.getValuesList().size();
if (size == 0) {
print("()");
for (int i = 0; i < 1; ++i) {
if (i != 0) {
print(", ");
x.getValuesList().get(i).accept(this);
if (x.getQuery() != null) {
print(" ");
x.getQuery().accept(this);
if (x.getDuplicateKeyUpdate().size() != 0) {
print(" ON DUPLICATE KEY UPDATE ");
printAndAccept(x.getDuplicateKeyUpdate(), ", ");
return false;
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.println();
return out.toString();
if (select.getFrom() == null) {
print("DUAL");
for (int i = 0, size = x.getPartitionFor().size(); i < size; ++i) {
for (int i = 0, size = x.getSubPartitionFor().size(); i < size; ++i) {
public class OracleLexerTest extends TestCase {
public void test_hint() throws Exception {
String sql = "SELECT +FIRST_ROWS * FROM T WHERE F1 = ? ORDER BY F2";
OracleLexer lexer = new OracleLexer(sql);
for (;;) {
lexer.nextToken();
Token tok = lexer.token();
switch (tok) {
case IDENTIF
System.out.println(tok.name() + "tt" + lexer.stringVal());
System.out.println(tok.name() + "ttt" + lexer.stringVal());
System.out.println(tok.name() + "ttt" + tok.name);
if (tok == Token.EOF) {
System.out.println(tok.name() + "tt" + lexer.stringVal());
System.out.println(tok.name() + "tt" + lexer.stringVal());
System.out.println(tok.name() + "tt" + lexer.stringVal());
SELECT("SELECT"),
FROM("FROM"),
WHERE("WHERE"),
ORDER("ORDER"),
GROUP("GROUP"),
HAVING("HAVING"),
INSERT("INSERT"),
INTO("INTO"),
NULL("NULL"),
NOT("NOT"),
DELETE("DELETE"),
DISTINCT("DISTINCT"),
UNIQUE("UNIQUE"),
FOREIGN("FOREIGN"),
REFERENCE("REFERENCE"),
REFERENCES("REFERENCES"),
ALL("ALL"),
UNION("UNION"),
INTERSECT("INTERSECT"),
MINUS("MINUS"),
INNER("INNER"),
LEFT("LEFT"),
RIGHT("RIGHT"),
FULL("FULL"),
OUTER("OUTER"),
JOIN("JOIN"),
SCHEMA("SCHEMA"),
CAST("CAST"),
AND("AND"),
XOR("XOR"),
CASE("CASE"),
WHEN("WHEN"),
THEN("THEN"),
ELSE("ELSE"),
END("END"),
EXISTS("EXISTS"),
NEW("NEW"),
ASC("ASC"),
DESC("DESC"),
LIKE("LIKE"),
ESCAPE("ESCAPE"),
BETWEEN("BETWEEN"),
VALUES("VALUES"),
INTERVAL("INTERVAL"),
LOCK("LOCK"),
SOME("SOME"),
ANY("ANY"),
TRUE("TRUE"),
FALSE("FALSE"),
LPAREN("("),
RPAREN(")"),
LBRACE("{"),
RBRACE("}"),
LBRACKET("["),
RBRACKET("]"),
SEMI(";"),
COMMA(","),
BANG("!"),
TILDE("~"),
QUES("?"),
COLON(":"),
COLONEQ(":="),
EQEQ("=="),
LTEQ("<="),
LTEQGT("<=>"),
LTGT("<>"),
GTEQ(">="),
BANGEQ("!="),
BANGGT("!>"),
BANGLT("!<"),
AMPAMP("&&"),
BARBAR("||"),
PLUS("+"),
STAR("*"),
SLASH("/"),
CARET("^"),
PERCENT("%"),
LTLT("<<"),
GTGT(">>"),
token = Token.VARIANT;
int nextChar = buf[bp + 1];
if (nextChar == '/' || nextChar == '*') {
scanComment();
if ((token() == Token.LINE_COMMENT || token() == Token.MULTI_LINE_COMMENT) && skipComment) {
token = Token.SLASH;
scanChar();
public class OracleSQLParserTest extends TestCase {
public void test_0() throws Exception {
String sql = "UPDATE employees SET salary = salary * 1.1 WHERE employee_id IN (SELECT employee_id FROM job_history);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
OracleUpdateStatement statement = (OracleUpdateStatement) statementList.get(0);
Assert.assertEquals(0, statement.getHints().size());
OracleUpdateSetListClause setList = (OracleUpdateSetListClause) statement.getSetClause();
Assert.assertEquals(1, setList.getItems().size());
OracleUpdateSetListSingleColumnItem item = (OracleUpdateSetListSingleColumnItem) setList.getItems().get(0);
SQLIdentifierExpr column = (SQLIdentifierExpr) item.getColumn();
Assert.assertEquals("salary", column.getName());
SQLBinaryOpExpr value = (SQLBinaryOpExpr) item.getValue();
Assert.assertEquals(SQLBinaryOperator.Multiply, value.getOperator());
output(statementList);
private void output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
visitor.println();
System.out.println(out.toString());
String text = output(statementList);
System.out.println(text);
public void test_1() throws Exception {
String sql = "SELECT employees_seq.nextval FROM DUAL;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
String text = output(statementList);
System.out.println(text);
private String output(List<SQLStatement> stmtList) {
return out.toString();
private boolean           prior            = false;
public boolean isPrior() {
return prior;
public void setPrior(boolean prior) {
this.prior = prior;
if (x.isPrior()) {
print("PRIOR ");
public final static Keywords           DEFAULT_ORACLE_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("START", Token.START);
map.put("CONNECT", Token.CONNECT);
map.put("PRIOR", Token.PRIOR);
DEFAULT_ORACLE_KEYWORDS = new Keywords(map);
super.keywods = DEFAULT_ORACLE_KEYWORDS;
super.keywods = DEFAULT_ORACLE_KEYWORDS;
if (lexer.token() == Token.START) {
if (lexer.token() == Token.CONNECT) {
if (lexer.token() == Token.PRIOR) {
lexer.nextToken();
hierachical.setPrior(true);
START("START"),
PRIOR("PRIOR"),
CONNECT("CONNECT"),
public void test_2() throws Exception {
String sql = "SELECT LPAD(' ',2*(LEVEL-1)) || last_name org_chart, employee_id, manager_id, job_id FROM employees WHERE job_id != 'FI_MGR' START WITH job_id = 'AD_VP' CONNECT BY PRIOR employee_id = manager_id; ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
String text = output(statementList);
System.out.println(text);
public class OracleInsertStatement extends SQLInsertStatement {
private static final long serialVersionUID = 1L;
} else if (lexer.token() == Token.IDENTIFIER) {
String name = lexer.stringVal();
if (name.startsWith("B")) {
lexer.nextToken();
return new SQLVariantRefExpr(":" + name);
throw new ParserException("syntax error : " + lexer.token());
protected SQLExprParser createExprParser() {
return new OracleExprParser(lexer);
SQLQueryExpr queryExpr = (SQLQueryExpr) this.createExprParser().expr();
public void f_test_1() throws Exception {
private static final String[] _aggregateFunctions = {
"AVG", "CORR", "COVAR_POP", "COVAR_SAMP", "COUNT"
, "CUME_DIST", "DENSE_RANK", "FIRST", "FIRST_VALUE"
, "LAG", "LAST", "LAST_VALUE", "LEAD", "MAX"
, "MIN", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC"
, "RANK", "RATIO_TO_REPORT", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT"
, "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY"
, "REGR_SXY", "ROW_NUMBER", "STDDEV", "STDDEV_POP", "STDDEV_SAMP"
, "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"
public class OracleSQLParserResourceTest2 extends TestCase {
public void f_test_1() throws Exception {
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream("bvt/parser/oracle-0.txt");
Reader reader = new InputStreamReader(is);
String sql = JdbcUtils.read(reader);
JdbcUtils.close(reader);
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
String text = output(statementList);
System.out.println(text);
public void test_2() throws Exception {
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream("bvt/parser/oracle-1.txt");
Reader reader = new InputStreamReader(is);
String sql = JdbcUtils.read(reader);
JdbcUtils.close(reader);
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
String text = output(statementList);
System.out.println(text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public void test_0() throws Exception {
String sql = "UPDATE employees SET salary = salary * 1.1 WHERE employee_id IN (SELECT employee_id FROM job_history);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
Assert.assertEquals(1, statementList.size());
OracleUpdateStatement statement = (OracleUpdateStatement) statementList.get(0);
Assert.assertEquals(0, statement.getHints().size());
OracleUpdateSetListClause setList = (OracleUpdateSetListClause) statement.getSetClause();
Assert.assertEquals(1, setList.getItems().size());
OracleUpdateSetListSingleColumnItem item = (OracleUpdateSetListSingleColumnItem) setList.getItems().get(0);
SQLIdentifierExpr column = (SQLIdentifierExpr) item.getColumn();
Assert.assertEquals("salary", column.getName());
SQLBinaryOpExpr value = (SQLBinaryOpExpr) item.getValue();
Assert.assertEquals(SQLBinaryOperator.Multiply, value.getOperator());
String text = output(statementList);
System.out.println(text);
public void test_1() throws Exception {
String sql = "SELECT employees_seq.nextval FROM DUAL;";
String sql = "SELECT LPAD(' ',2*(LEVEL-1)) || last_name org_chart, employee_id, manager_id, job_id FROM employees WHERE job_id != 'FI_MGR' START WITH job_id = 'AD_VP' CONNECT BY PRIOR employee_id = manager_id; ";
if (lexer.token() == (Token.COMMA)) {
lexer.nextToken();
joinType = OracleSelectJoin.JoinType.COMMA;
exec_test("bvt/parser/oracle-0.txt");
exec_test("bvt/parser/oracle-1.txt");
exec_test("bvt/parser/oracle-2.txt");
exec_test("bvt/parser/oracle-3.txt");
exec_test("bvt/parser/oracle-4.txt");
exec_test("bvt/parser/oracle-5.txt");
public void exec_test(String resource) throws Exception {
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Assert.assertEquals(expect, text.trim());
String sql = "SELECT +FIRST_ROWS * FROM T WHERE F1 = ? ORDER BY F2";
OracleLexer lexer = new OracleLexer(sql);
for (;;) {
lexer.nextToken();
Token tok = lexer.token();
switch (tok) {
case IDENTIF
System.out.println(tok.name() + "tt" + lexer.stringVal());
System.out.println(tok.name() + "ttt" + lexer.stringVal());
System.out.println(tok.name() + "ttt" + tok.name);
if (tok == Token.EOF) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, columns);
visitor.endVisit(this);
acceptChild(visitor, name);
acceptChild(visitor, columns);
visitor.visit(this);
visitor.visit(this);
visitor.visit(this);
if (Boolean.TRUE.equals(x.getForce())) {
print("FORCE ");
} else if (Boolean.FALSE.equals(x.getForce())) {
if (x.isEnable()) {
print("ENABLE ALL TRIGGERS");
for (int i = 0, size = nodes.size(); i < size; ++i) {
if (x.isNot()) {
print(" NOT BETWEEN ");
if (SQLSetQuantifier.ALL == select.getDistionOption()) {
print("ALL ");
} else if (SQLSetQuantifier.DISTINCT == select.getDistionOption()) {
print("DISTINCT ");
} else if (SQLSetQuantifier.UNIQUE == select.getDistionOption()) {
public class SampleClause extends OracleSQLObject {
private static final long serialVersionUID = 1L;
private boolean           block            = false;
private int               percent;
private SQLExpr           seedValue;
public boolean isBlock() {
return block;
public void setBlock(boolean block) {
this.block = block;
public int getPercent() {
return percent;
public void setPercent(int percent) {
this.percent = percent;
public SQLExpr getSeedValue() {
return seedValue;
public void setSeedValue(SQLExpr seedValue) {
this.seedValue = seedValue;
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, seedValue);
visitor.endVisit(this);
protected SampleClause          sampleClause;
public SampleClause getSampleClause() {
return sampleClause;
public void setSampleClause(SampleClause sampleClause) {
this.sampleClause = sampleClause;
acceptChild(visitor, this.sampleClause);
if ((this.alias != null) && (this.alias.length() != 0)) {
buf.append(this.alias);
boolean visit(SampleClause x);
void endVisit(SampleClause x);
boolean visit(OracleSelectTableReference x);
void endVisit(OracleSelectTableReference x);
if (x.getSampleClause() != null) {
print(" ");
x.getSampleClause().accept(this);
public boolean visit(SampleClause x) {
print("SAMPLE ");
if (x.isBlock()) {
print("BLOCK ");
print("(");
print(x.getPercent());
print(")");
if (x.getSeedValue() != null) {
print(" SEED ");
x.getSeedValue().accept(this);
return false;
public void endVisit(SampleClause x) {
public void endVisit(OracleSelectTableReference x) {
if (identifierEquals("SAMPLE")) {
lexer.nextToken();
SampleClause sample = new SampleClause();
if (identifierEquals("BLOCK")) {
sample.setBlock(true);
accept(Token.LPAREN);
if (lexer.token() != Token.LITERAL_INT) {
throw new ParserException("syntax error : " + lexer.token());
sample.setPercent(lexer.integerValue().intValue());
lexer.nextToken();
accept(Token.RPAREN);
if (identifierEquals("SEED")) {
lexer.nextToken();
accept(Token.LPAREN);
sample.setSeedValue(expr());
accept(Token.RPAREN);
tableReference.setSampleClause(sample);
exec_test("bvt/parser/oracle-7.txt");
print(" SEED (");
print(")");
exec_test("bvt/parser/oracle-8.txt");
Reader reader = new InputStreamReader(is, "UTF-8");
protected SQLExprParser createExprParser() {
return new OracleExprParser(lexer);
exec_test("bvt/parser/oracle-11.txt");
exec_test("bvt/parser/oracle-0.txt");
exec_test("bvt/parser/oracle-1.txt");
exec_test("bvt/parser/oracle-2.txt");
exec_test("bvt/parser/oracle-3.txt");
exec_test("bvt/parser/oracle-4.txt");
exec_test("bvt/parser/oracle-5.txt");
exec_test("bvt/parser/oracle-6.txt"); 
exec_test("bvt/parser/oracle-7.txt");
exec_test("bvt/parser/oracle-8.txt");
exec_test("bvt/parser/oracle-9.txt");
exec_test("bvt/parser/oracle-10.txt");
exec_test("bvt/parser/oracle-11.txt");
exec_test("bvt/parser/oracle-12.txt");
exec_test("bvt/parser/oracle-13.txt");
exec_test("bvt/parser/oracle-14.txt");
exec_test("bvt/parser/oracle-15.txt");
exec_test("bvt/parser/oracle-16.txt");
exec_test("bvt/parser/oracle-17.txt");
exec_test("bvt/parser/oracle-18.txt");
exec_test("bvt/parser/oracle-19.txt");
exec_test("bvt/parser/oracle-20.txt");
exec_test("bvt/parser/oracle-21.txt");
exec_test("bvt/parser/oracle-22.txt");
exec_test("bvt/parser/oracle-23.txt");
exec_test("bvt/parser/oracle-24.txt");
exec_test("bvt/parser/oracle-25.txt");
exec_test("bvt/parser/oracle-26.txt");
exec_test("bvt/parser/oracle-27.txt");
String alias = null;
alias = '"' + lexer.stringVal() + '"';
return alias;
alias = lexer.stringVal();
return alias;
alias = '"' + lexer.stringVal() + '"';
alias = lexer.stringVal();
alias = "'" + lexer.stringVal() + "'";
return alias;
exec_test("bvt/parser/mysql-0.txt");
exec_test("bvt/parser/mysql-1.txt");
exec_test("bvt/parser/mysql-2.txt");
exec_test("bvt/parser/mysql-3.txt");
exec_test("bvt/parser/mysql-4.txt");
exec_test("bvt/parser/mysql-5.txt");
exec_test("bvt/parser/mysql-6.txt");
exec_test("bvt/parser/mysql-7.txt");
printSelectList(select.getSelectList());
printSelectList(select.getSelectList());
protected void printSelectList(List<SQLSelectItem> selectList) {
incrementIndent();
for (int i = 0, size = selectList.size(); i < size; ++i) {
if (i != 0) {
if (i % 5 == 0) {
println();
print(", ");
selectList.get(i).accept(this);
decrementIndent();
printSelectList(select.getSelectList());
System.out.println();
((OracleOrderByItem) this.items.get(i)).output(buf);
((OracleOrderByItem) this.items.get(i)).output(buf);
public class CycleClause extends OracleSQLObject {
private static final long   serialVersionUID = 1L;
private final List<SQLExpr> aliases          = new ArrayList<SQLExpr>();
private SQLExpr             mark;
private SQLExpr             value;
private SQLExpr             defaultValue;
public SQLExpr getMark() {
return mark;
public void setMark(SQLExpr mark) {
this.mark = mark;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public SQLExpr getDefaultValue() {
return defaultValue;
public void setDefaultValue(SQLExpr defaultValue) {
this.defaultValue = defaultValue;
public List<SQLExpr> getAliases() {
return aliases;
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, aliases);
acceptChild(visitor, mark);
acceptChild(visitor, value);
acceptChild(visitor, defaultValue);
visitor.endVisit(this);
public class SearchClause extends OracleSQLObject {
private static final long serialVersionUID = 1L;
public static enum Type {
DEPTH, BREADTH
private Type                          type;
private final List<OracleOrderByItem> items = new ArrayList<OracleOrderByItem>();
private SQLIdentifierExpr             orderingColumn;
public Type getType() {
return type;
public void setType(Type type) {
this.type = type;
public List<OracleOrderByItem> getItems() {
return items;
public SQLIdentifierExpr getOrderingColumn() {
return orderingColumn;
public void setOrderingColumn(SQLIdentifierExpr orderingColumn) {
this.orderingColumn = orderingColumn;
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, items);
acceptChild(visitor, orderingColumn);
visitor.endVisit(this);
public class SubqueryFactoringClause extends OracleSQLObject {
private static final long serialVersionUID = 1L;
private final List<Entry> entries          = new ArrayList<Entry>();
public List<Entry> getEntries() {
return entries;
public static class Entry extends OracleSQLObject {
private static final long   serialVersionUID = 1L;
private SQLIdentifierExpr   name;
private final List<SQLName> columns          = new ArrayList<SQLName>();
private SQLSelectQuery      subQuery;
private SearchClause        searchClause;
private CycleClause         cycleClause;
public CycleClause getCycleClause() {
return cycleClause;
public void setCycleClause(CycleClause cycleClause) {
this.cycleClause = cycleClause;
public SearchClause getSearchClause() {
return searchClause;
public void setSearchClause(SearchClause searchClause) {
this.searchClause = searchClause;
public SQLIdentifierExpr getName() {
return name;
public void setName(SQLIdentifierExpr name) {
this.name = name;
public SQLSelectQuery getSubQuery() {
return subQuery;
public void setSubQuery(SQLSelectQuery subQuery) {
this.subQuery = subQuery;
public List<SQLName> getColumns() {
return columns;
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, columns);
acceptChild(visitor, subQuery);
visitor.endVisit(this);
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, entries);
visitor.endVisit(this);
public class OracleOrderByItem extends SQLSelectOrderByItem {
public OracleOrderByItem(){
private SubqueryFactoringClause factoring;
public SubqueryFactoringClause getFactoring() {
return factoring;
public void setFactoring(SubqueryFactoringClause factoring) {
this.factoring = factoring;
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
acceptChild(visitor, this.factoring);
void endVisit(OracleOrderByItem x);
boolean visit(OracleOrderByItem x);
boolean visit(SubqueryFactoringClause x);
void endVisit(SubqueryFactoringClause x);
boolean visit(SubqueryFactoringClause.Entry x);
void endVisit(SubqueryFactoringClause.Entry x);
boolean visit(SearchClause x);
void endVisit(SearchClause x);
boolean visit(CycleClause x);
void endVisit(CycleClause x);
if (x.getFactoring() != null) {
x.getFactoring().accept(this);
println();
public boolean visit(OracleOrderByItem x) {
public void endVisit(OracleOrderByItem x) {
public boolean visit(SubqueryFactoringClause.Entry x) {
x.getName().accept(this);
if (x.getColumns().size() > 0) {
print(" (");
printAndAccept(x.getColumns(), ", ");
print(")");
println();
print("AS");
println();
print("(");
incrementIndent();
println();
x.getSubQuery().accept(this);
decrementIndent();
println();
print(")");
if (x.getSearchClause() != null) {
println();
x.getSearchClause().accept(this);
if (x.getCycleClause() != null) {
println();
x.getCycleClause().accept(this);
return false;
public void endVisit(SubqueryFactoringClause.Entry x) {
public boolean visit(SubqueryFactoringClause x) {
print("WITH");
incrementIndent();
println();
printlnAndAccept(x.getEntries(), ", ");
decrementIndent();
return false;
public void endVisit(SubqueryFactoringClause x) {
public boolean visit(SearchClause x) {
print("SEARCH ");
print(x.getType().name());
print(" FIRST BY ");
printAndAccept(x.getItems(), ", ");
print(" SET ");
x.getOrderingColumn().accept(this);
return false;
public void endVisit(SearchClause x) {
public boolean visit(CycleClause x) {
print("CYCLE ");
printAndAccept(x.getAliases(), ", ");
print(" SET ");
x.getMark().accept(this);
print(" TO ");
x.getValue().accept(this);
print(" DEFAULT ");
x.getDefaultValue().accept(this);
return false;
public void endVisit(CycleClause x) {
public OracleOrderByItem parseSelectOrderByItem() {
OracleOrderByItem item = new OracleOrderByItem();
item.setNullsOrderType(OracleOrderByItem.NullsOrderType.NullsFirst);
item.setNullsOrderType(OracleOrderByItem.NullsOrderType.NullsLast);
map.put("WITH", Token.WITH);
protected OracleExprParser createExprParser() {
if (lexer.token() == Token.WITH) {
lexer.nextToken();
SubqueryFactoringClause subqueryFactoringClause = new SubqueryFactoringClause();
for (;;) {
SubqueryFactoringClause.Entry entry = new SubqueryFactoringClause.Entry();
entry.setName((SQLIdentifierExpr) createExprParser().name());
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
createExprParser().names(entry.getColumns());
accept(Token.RPAREN);
accept(Token.AS);
accept(Token.LPAREN);
entry.setSubQuery(query());
accept(Token.RPAREN);
if (identifierEquals("SEARCH")) {
lexer.nextToken();
SearchClause searchClause = new SearchClause();
if (lexer.token() != Token.IDENTIFIER) {
throw new SQLParseException("syntax erorr : " + lexer.token());
searchClause.setType(SearchClause.Type.valueOf(lexer.stringVal()));
lexer.nextToken();
acceptIdentifier("FIRST");
accept(Token.BY);
searchClause.getItems().add((OracleOrderByItem) createExprParser().parseSelectOrderByItem());
while (lexer.token() == (Token.COMMA)) {
lexer.nextToken();
searchClause.getItems().add((OracleOrderByItem) createExprParser().parseSelectOrderByItem());
accept(Token.SET);
searchClause.setOrderingColumn((SQLIdentifierExpr) createExprParser().name());
entry.setSearchClause(searchClause);
if (identifierEquals("CYCLE")) {
lexer.nextToken();
CycleClause cycleClause = new CycleClause();
createExprParser().exprList(cycleClause.getAliases());
accept(Token.SET);
cycleClause.setMark(createExprParser().expr());
acceptIdentifier("TO");
cycleClause.setValue(createExprParser().expr());
accept(Token.DEFAULT);
cycleClause.setDefaultValue(createExprParser().expr());
entry.setCycleClause(cycleClause);
subqueryFactoringClause.getEntries().add(entry);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
select.setFactoring(subqueryFactoringClause);
if (lexer.token() == Token.WITH) {
accept(Token.WITH);
if (lexer.token() == Token.WITH) {
statementList.add(new SQLSelectStatement(new OracleSelectParser(this.lexer).select()));
public SQLSelectOrderByItem parseSelectOrderByItem() throws ParserException {
WITH("WITH"),
exec_test("bvt/parser/oracle-29.txt");
exec_test("bvt/parser/oracle-30.txt");
public class PivotClause {
private boolean             xml;
private final List<Entry>   entries  = new ArrayList<Entry>();
private final List<SQLName> pivotFor = new ArrayList<SQLName>();
private final List<SQLName> pivotIn  = new ArrayList<SQLName>();
public List<Entry> getEntries() {
return entries;
public List<SQLName> getPivotFor() {
return pivotFor;
public List<SQLName> getPivotIn() {
return pivotIn;
public static class Entry {
private OracleAggregateExpr aggregateExpr;
private String              alias;
public OracleAggregateExpr getAggregateExpr() {
return aggregateExpr;
public void setAggregateExpr(OracleAggregateExpr aggregateExpr) {
this.aggregateExpr = aggregateExpr;
public String getAlias() {
return alias;
public void setAlias(String alias) {
this.alias = alias;
public boolean isXml() {
return xml;
public void setXml(boolean xml) {
this.xml = xml;
exec_test("bvt/parser/oracle-31.txt");
case EXTRAC
lexer.nextToken();
OracleExtractExpr extract = new OracleExtractExpr();
accept(Token.LPAREN);
extract.setUnit(OracleDateTimeUnit.valueOf(lexer.stringVal()));
lexer.nextToken();
accept(Token.FROM);
extract.setFrom(expr());
accept(Token.RPAREN);
return primaryRest(extract);
map.put("EXTRACT", Token.EXTRACT);
accept(Token.FOR);
accept(Token.IN);
if (lexer.token() == (Token.LPAREN)) {
throw new ParserException("TODO");
if (lexer.token() == (Token.SELECT)) {
throw new ParserException("TODO");
for (;;) {
if (lexer.token() != Token.COMMA) {
EXTRACT("EXTRACT"),
accept(Token.FOR);
accept(Token.IN);
if (lexer.token() == (Token.LPAREN)) {
throw new ParserException("TODO");
if (lexer.token() == (Token.SELECT)) {
throw new ParserException("TODO");
for (;;) {
if (lexer.token() != Token.COMMA) {
protected final String as() throws ParserException {
if (lexer.token() == Token.LITERAL_CHARS) {
alias = "'" + lexer.stringVal() + "'";
} else if (lexer.token() == Token.LITERAL_CHARS) {
alias = "'" + lexer.stringVal() + "'";
exec_test("bvt/parser/oracle-32.txt");
exec_test("bvt/parser/oracle-33.txt");
exec_test("bvt/parser/oracle-34.txt");
if (x.getJoinType() == JoinType.COMMA) {
print(",");
print(" ");
print(JoinType.toString(x.getJoinType()));
switch (lexer.token()) {
alias = lexer.token().name();
lexer.nextToken();
return alias;
throw new ParserException("Error : " + lexer.token());
switch (lexer.token()) {
alias = lexer.token().name();
lexer.nextToken();
return alias;
if (x.getJoinType() == JoinType.COMMA) {
print(",");
print(" ");
print(JoinType.toString(x.getJoinType()));
exec_test("bvt/parser/oracle-0.txt");
exec_test("bvt/parser/oracle-1.txt");
exec_test("bvt/parser/oracle-2.txt");
exec_test("bvt/parser/oracle-3.txt");
exec_test("bvt/parser/oracle-4.txt");
exec_test("bvt/parser/oracle-5.txt");
exec_test("bvt/parser/oracle-6.txt"); 
exec_test("bvt/parser/oracle-7.txt");
exec_test("bvt/parser/oracle-8.txt");
exec_test("bvt/parser/oracle-9.txt");
exec_test("bvt/parser/oracle-10.txt");
exec_test("bvt/parser/oracle-11.txt");
exec_test("bvt/parser/oracle-12.txt");
exec_test("bvt/parser/oracle-13.txt");
exec_test("bvt/parser/oracle-14.txt");
exec_test("bvt/parser/oracle-15.txt");
exec_test("bvt/parser/oracle-16.txt");
exec_test("bvt/parser/oracle-17.txt");
exec_test("bvt/parser/oracle-18.txt");
exec_test("bvt/parser/oracle-19.txt");
exec_test("bvt/parser/oracle-20.txt");
exec_test("bvt/parser/oracle-21.txt");
exec_test("bvt/parser/oracle-22.txt");
exec_test("bvt/parser/oracle-23.txt");
exec_test("bvt/parser/oracle-24.txt");
exec_test("bvt/parser/oracle-25.txt");
exec_test("bvt/parser/oracle-26.txt");
exec_test("bvt/parser/oracle-27.txt");
exec_test("bvt/parser/oracle-28.txt");
exec_test("bvt/parser/oracle-29.txt");
exec_test("bvt/parser/oracle-30.txt");
exec_test("bvt/parser/oracle-31.txt");
exec_test("bvt/parser/oracle-35.txt");
println();
print("(");
print("VALUES");
Assert.assertEquals("INSERT INTO tnVALUESn(1, AES_ENCRYPT('text', 'password'));", text);
Assert.assertEquals("INSERT INTO tbl_namenVALUESn();", text);
Assert.assertEquals("INSERT INTO tbl_nament(col1, col2)nVALUESn(15, col1 * 2);", text);
Assert.assertEquals("INSERT INTO tbl_nament(col1, col2)nVALUESn(col2 * 2, 15);", text);
Assert.assertEquals("INSERT INTO tbl_nament(a, b, c)nVALUESn(1, 2, 3), (4, 5, 6), (7, 8, 9);", text);
Assert.assertEquals("INSERT INTO tbl_nament(a, b, c)nVALUESn(1, 2, 3, 4, 5nt, 6, 7, 8, 9);", text);
Assert.assertEquals("INSERT LOW_PRIORITY DELAYED HIGH_PRIORITY IGNORE INTO tbl_nament(a, b, c)nVALUESn(1, 2, 3);", text);
Assert.assertEquals("INSERT INTO tbl_nament(a, b, c)nVALUESn(1, 2, 3) ON DUPLICATE KEY UPDATE c = c + 1;", text);
for (int i = 0; i <= 46; ++i) {
String resource = "bvt/parser/oracle-" + i + ".txt";
exec_test(resource);
protected String sql;
protected void setUp() throws Exception {
sql = "SELECT mark for picman * FROM WP_ALBUM WHERE MEMBER_ID = ? AND ID IN (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
sql = "SELECT * FROM my_table WHERE TRUNC(SYSDATE) = DATE '2002-10-03';";
public void test_perf() {
for (int i = 0; i < 10; ++i) {
Assert.assertEquals("SELECT *nFROM t1nWHERE column1 = (ntSELECT column1ntFROM t2nt);", text);
for (int i = 0; i <= 53; ++i) {
public class PerfTest extends TestCase {
public void test_perf() throws Exception {
for (int i = 0; i < 10; ++i) {
perf(loadSql("bvt/parser/oracle-23.txt"));
String loadSql(String resource) throws Exception {
InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = JdbcUtils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[1].trim();
return sql;
void perf(String sql) {
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 1000; ++i) {
merge(sql);
long millis = System.currentTimeMillis() - startMillis;
System.out.println(millis);
private String merge(String sql) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.println();
return out.toString();
exec(sql);
private String exec(String sql) {
if (errPos > errorEndPos) {
errorEndPos = errPos;
private String           dbType;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
SimpleType.STRING, SimpleType.DATE, SimpleType.STRING };
"LastErrorMessage", "LastErrorClass", "LastErrorStackTrace", "LastErrorTime", "DbType" };
map.put("DbType", dbType);
@SuppressWarnings("unused")
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
perfOracle("SELECT * FROM T");
perfMySql("SELECT * FROM T");
void perfOracle(String sql) {
execOracle(sql);
System.out.println("Oraclet" + millis);
void perfMySql(String sql) {
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 1000; ++i) {
execMySql(sql);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("MySqlt" + millis);
private String execOracle(String sql) {
private String execMySql(String sql) {
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.println();
return out.toString();
public final static int MinorVersion    = 2;
public final static int MinorVersion    = 1;
public final static int RevisionVersion = 1;
public void validateConnection(Connection conn) throws SQLException {
String query = getValidationQuery();
if (conn.isClosed()) {
throw new SQLException("validateConnection: connection closed");
if (null != query) {
Statement stmt = null;
ResultSet rset = null;
stmt = conn.createStatement();
if (getValidationQueryTimeout() > 0) {
stmt.setQueryTimeout(getValidationQueryTimeout());
rset = stmt.executeQuery(query);
if (!rset.next()) {
throw new SQLException("validationQuery didn't return a row");
} finally {
if (rset != null) {
rset.close();
} catch (Exception t) {
if (stmt != null) {
stmt.close();
} catch (Exception t) {
protected boolean testConnection(Connection conn) {
String query = getValidationQuery();
if (conn.isClosed()) {
return false;
if (null != query) {
Statement stmt = null;
ResultSet rset = null;
stmt = conn.createStatement();
if (getValidationQueryTimeout() > 0) {
stmt.setQueryTimeout(getValidationQueryTimeout());
rset = stmt.executeQuery(query);
if (!rset.next()) {
return false;
} finally {
if (rset != null) {
rset.close();
} catch (Exception t) {
if (stmt != null) {
stmt.close();
} catch (Exception t) {
return true;
} catch (SQLException ex) {
return false;
dataSource.validateConnection(conn);
public class Case3_ValidateQuery {
final int      LOOP_COUNT      = 1000 * 1000;
dataSource.setTestOnBorrow(false);
dataSource.setTestOnBorrow(false);
for (int i = 0; i < LOOP_COUNT; ++i) {
final ConcurrentMap<String, JdbcSqlStat> sqlStatMap = dataSourceStat.getSqlStatMap();
JdbcSqlStat sqlStat = sqlStatMap.get(sql);
return dataSourceStat.getSqlStat(id);
public JdbcSqlStat getSqlStat(String sql) {
public static StatFilter getStatFilter(DataSourceProxy dataSource) {
public JdbcSqlStat getSqlStat(long id) {
ConcurrentMap<String, JdbcSqlStat> statMap = dataSource.getSqlStatMap();
private static final long        serialVersionUID = 1L;
protected JSplitPane             mainSplit;
protected JTree                  tree;
protected JPanel                 sheet;
protected DefaultMutableTreeNode rootNode;
protected DefaultMutableTreeNode dataSourcesNode;
rootNode = new DefaultMutableTreeNode("root", true);
dataSourcesNode = new DefaultMutableTreeNode("DataSources", true);
rootNode.add(dataSourcesNode);
tree = new JTree(rootNode);
tree.setRootVisible(false);
ManagementFactory.getPlatformMBeanServer().registerMBean(JdbcStatManager.getInstance(), new ObjectName("com.alibaba.druid:type=JdbcStatManager"));
DruidDataSource dataSource = new DruidDataSource();
ManagementFactory.getPlatformMBeanServer().registerMBean(dataSource, new ObjectName("com.alibaba.druid:type=DataSource"));
dataSource.setUrl("jdbc:mock:");
dataSource.setFilters("stat,trace");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1");
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
} catch (Exception ex) {
List<ObjectInstance> dataSourceInstances = new ArrayList<ObjectInstance>();
if ("com.alibaba.druid.pool.DruidDataSource".equals(info.getClassName())) {
dataSourceInstances.add(instance);
for (ObjectInstance dataSourceInstance : dataSourceInstances) {
String name = (String) conn.getAttribute(dataSourceInstance.getObjectName(), "Name");
DefaultMutableTreeNode dataSource = new DefaultMutableTreeNode(name, true);
DefaultMutableTreeNode connections = new DefaultMutableTreeNode("Connections", true);
dataSource.add(connections);
DefaultMutableTreeNode sqlListNode = new DefaultMutableTreeNode("SQL", true);
dataSource.add(sqlListNode);
dataSourcesNode.add(dataSource);
if (name == null) {
return "DataSource-" + System.identityHashCode(this);
String getName();
private static final String ATTR_PARAMS_SKIP = "_params.skip_";
print(" NOT IN (?)");
print(" IN (?)");
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr) {
x.getLeft().getAttributes().put(ATTR_PARAMS_SKIP, true);
x.getRight().getAttributes().put(ATTR_PARAMS_SKIP, true);
x = new SQLBinaryOpExpr(merge((SQLBinaryOpExpr) x.getLeft()), x.getOperator(), x.getRight());
if ((left.getLeft() instanceof SQLPropertyExpr) && (right.getLeft() instanceof SQLPropertyExpr)) {
String leftColumn = left.getLeft().toString();
String rightColumn = right.getLeft().toString();
if (leftColumn.equals(rightColumn)) {
if ((left.getRight() instanceof SQLVariantRefExpr) && (right.getRight() instanceof SQLVariantRefExpr)) {
return left; 
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
private static final String ATTR_PARAMS_SKIP = "_params.skip_";
print(" NOT IN (?)");
print(" IN (?)");
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr) {
x.getLeft().getAttributes().put(ATTR_PARAMS_SKIP, true);
x.getRight().getAttributes().put(ATTR_PARAMS_SKIP, true);
if ((left.getLeft() instanceof SQLPropertyExpr) && (right.getLeft() instanceof SQLPropertyExpr)) {
String leftColumn = left.getLeft().toString();
String rightColumn = right.getLeft().toString();
if (leftColumn.equals(rightColumn)) {
if ((left.getRight() instanceof SQLVariantRefExpr) && (right.getRight() instanceof SQLVariantRefExpr)) {
return left; 
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
if (Boolean.TRUE.equals(x.getAttribute(ATTR_PARAMS_SKIP))) {
return super.visit(x);
validate("SELECT * FROM T WHERE ID IN (?, ?, ?)", "SELECT * FROM T WHERE ID IN (?)");
validate("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT * FROM T WHERE A.ID = ?");
validateOracle("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT * FROM T WHERE A.ID = ?; ");
void validateOracle(String sql, String expect) {
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out);
statemen.accept(visitor);
Assert.assertEquals(expect, out.toString());
exec_test("bvt/parser/mysql-9.txt");
String mergeExpect = null;
if (items.length == 3) {
mergeExpect = items[2].trim();
if (mergeExpect != null) {
mergValidate(sql, mergeExpect);
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
System.out.println("SELECT * FORM A WHERE ID = (##)".replaceAll("##", "?"));
if (mergeEqual(left, right)) {
return left;
if (isLiteralExpr(left.getLeft()) && left.getOperator() == SQLBinaryOperator.BooleanOr) {
if (mergeEqual(left.getRight(), right)) {
return left;
private boolean mergeEqual(SQLExpr a, SQLExpr b) {
if (!(a instanceof SQLBinaryOpExpr)) {
return false;
if (!(b instanceof SQLBinaryOpExpr)) {
return false;
SQLBinaryOpExpr binaryA = (SQLBinaryOpExpr) a;
SQLBinaryOpExpr binaryB = (SQLBinaryOpExpr) b;
if (binaryA.getOperator() != SQLBinaryOperator.Equality) {
return false;
if (binaryB.getOperator() != SQLBinaryOperator.Equality) {
return false;
if (!(binaryA.getRight() instanceof SQLLiteralExpr || binaryA.getRight() instanceof SQLVariantRefExpr)) {
return false;
if (!(binaryB.getRight() instanceof SQLLiteralExpr || binaryB.getRight() instanceof SQLVariantRefExpr)) {
return false;
return binaryA.getLeft().toString().equals(binaryB.getLeft().toString());
private boolean isLiteralExpr(SQLExpr expr) {
if (expr instanceof SQLLiteralExpr) {
return true;
if (expr instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binary = (SQLBinaryOpExpr) expr;
return isLiteralExpr(binary.getLeft()) && isLiteralExpr(binary.getRight());
return false;
validate("SELECT * FROM T WHERE 1 = 0 OR a.id = ? OR a.id = ? OR a.id = ?", "SELECT * FROM T WHERE 1 = 0 OR a.id = ?");
validate("SELECT * FROM T WHERE 1 = 0 OR a.id = ? OR a.id = ? OR a.id = ? OR a.id = ?", "SELECT * FROM T WHERE 1 = 0 OR a.id = ?");
x = new SQLBinaryOpExpr(merge((SQLBinaryOpExpr) x.getLeft()), x.getOperator(), x.getRight());
if (mergeEqual(left, right)) {
return left;
if (isLiteralExpr(left.getLeft()) && left.getOperator() == SQLBinaryOperator.BooleanOr) {
if (mergeEqual(left.getRight(), right)) {
return left;
private boolean mergeEqual(SQLExpr a, SQLExpr b) {
if (!(a instanceof SQLBinaryOpExpr)) {
return false;
if (!(b instanceof SQLBinaryOpExpr)) {
return false;
SQLBinaryOpExpr binaryA = (SQLBinaryOpExpr) a;
SQLBinaryOpExpr binaryB = (SQLBinaryOpExpr) b;
if (binaryA.getOperator() != SQLBinaryOperator.Equality) {
return false;
if (binaryB.getOperator() != SQLBinaryOperator.Equality) {
return false;
if (!(binaryA.getRight() instanceof SQLLiteralExpr || binaryA.getRight() instanceof SQLVariantRefExpr)) {
return false;
if (!(binaryB.getRight() instanceof SQLLiteralExpr || binaryB.getRight() instanceof SQLVariantRefExpr)) {
return false;
return binaryA.getLeft().toString().equals(binaryB.getLeft().toString());
private boolean isLiteralExpr(SQLExpr expr) {
if (expr instanceof SQLLiteralExpr) {
return true;
if (expr instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binary = (SQLBinaryOpExpr) expr;
return isLiteralExpr(binary.getLeft()) && isLiteralExpr(binary.getRight());
return false;
validateOracle("SELECT * FROM T WHERE 1 = 0 OR a.id = ? OR a.id = ? OR a.id = ? OR a.id = ?", "SELECT * FROM T WHERE 1 = 0 OR a.id = ?; ");
logWriter.flush();
notEmpty.signal();
properties.put("url", "jdbc:mock:");
properties.put("validationQuery", "SELECT 1");
for (ObjectInstance statInstance : stats) {
TabularData tabularValue = (TabularData) conn.getAttribute(statInstance.getObjectName(), "DataSourceList");
for (Object item : tabularValue.values()) {
CompositeData rowData = (CompositeData) item;
String name = (String) rowData.get("Name");
DefaultMutableTreeNode dataSourceNode = new DefaultMutableTreeNode(name, true);
DefaultMutableTreeNode connections = new DefaultMutableTreeNode("Connections", true);
dataSourceNode.add(connections);
DefaultMutableTreeNode sqlListNode = new DefaultMutableTreeNode("SQL", true);
dataSourceNode.add(sqlListNode);
dataSourcesNode.add(dataSourceNode);
exec_test("bvt/parser/mysql-10.txt");
public class DataSourceInfo {
private long         id;
private String       name;
private String       url;
private List<String> filters = new ArrayList<String>();
private Date         createdTime;
private String       rawDriverClassName;
private String       rawUrl;
private String       rawDriverMajorVersion;
private String       rawDriverMinorVersion;
private String       properties;
public DataSourceInfo(){
public DataSourceInfo(CompositeData data){
this.id = ((Number) data.get("ID")).longValue();
this.name = (String) data.get("Name");
this.url = (String) data.get("URL");
for (String item : (String[]) data.get("FilterClasses")) {
filters.add(item);
this.createdTime = (Date) data.get("CreatedTime");
this.rawDriverClassName = (String) data.get("RawDriverClassName");
this.rawUrl = (String) data.get("RawUrl");
this.rawDriverMajorVersion = (String) data.get("RawDriverMajorVersion");
this.rawDriverMinorVersion = (String) data.get("RawDriverMinorVersion");
this.properties = (String) data.get("Properties");
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getUrl() {
return url;
public void setUrl(String url) {
this.url = url;
public List<String> getFilters() {
return filters;
public void setFilters(List<String> filters) {
this.filters = filters;
public Date getCreatedTime() {
return createdTime;
public void setCreatedTime(Date createdTime) {
this.createdTime = createdTime;
public String getRawDriverClassName() {
return rawDriverClassName;
public void setRawDriverClassName(String rawDriverClassName) {
this.rawDriverClassName = rawDriverClassName;
public String getRawUrl() {
return rawUrl;
public void setRawUrl(String rawUrl) {
this.rawUrl = rawUrl;
public String getRawDriverMajorVersion() {
return rawDriverMajorVersion;
public void setRawDriverMajorVersion(String rawDriverMajorVersion) {
this.rawDriverMajorVersion = rawDriverMajorVersion;
public String getRawDriverMinorVersion() {
return rawDriverMinorVersion;
public void setRawDriverMinorVersion(String rawDriverMinorVersion) {
this.rawDriverMinorVersion = rawDriverMinorVersion;
public String getProperties() {
return properties;
public void setProperties(String properties) {
this.properties = properties;
TreePath path = new TreePath(dataSourcesNode.children());
tree.scrollPathToVisible(path);
public final static Log                LOG                  = LogFactory.getLog(JdbcTraceManager.class);
private boolean                        traceEnable          = false;
private final static JdbcTraceManager  instance             = new JdbcTraceManager();
private final List<TraceEventListener> eventListeners       = new ArrayList<TraceEventListener>();
private final AtomicLong               fireEventCount       = new AtomicLong();
private final AtomicLong               skipEventCount       = new AtomicLong();
private boolean                        notificationEnable   = false;
private final NotificationTraceEventListener notificationListener = new NotificationTraceEventListener();
public boolean isNotificationEnable() {
return notificationEnable;
public void setNotificationEnable(boolean notificationEnable) {
this.notificationEnable = notificationEnable;
public NotificationTraceEventListener getNotificationListener() {
return notificationListener;
if (isNotificationEnable()) {
notificationListener.fireEvent(event);
sendNotification(notification);
return new ConnectionProxyImpl(dataSource, connection, info, dataSource.createConnectionId());
return new StatementProxyImpl(connection, statement, dataSource.createStatementId());
return new PreparedStatementProxyImpl(connection, statement, sql, dataSource.createStatementId());
return new CallableStatementProxyImpl(connection, statement, sql, dataSource.createStatementId());
return new ResultSetProxyImpl(statement, resultSet, dataSource.createResultSetId(), statement.getLastExecuteSql());
private final AtomicLong connectionIdSeed = new AtomicLong(10000);
private final AtomicLong statementIdSeed  = new AtomicLong(20000);
private final AtomicLong resultSetIdSeed  = new AtomicLong(50000);
public long createConnectionId() {
return connectionIdSeed.incrementAndGet();
public long createStatementId() {
return statementIdSeed.getAndIncrement();
public long createResultSetId() {
return resultSetIdSeed.getAndIncrement();
long createConnectionId();
long createStatementId();
long createResultSetId();
private final AtomicLong            connectionIdSeed  = new AtomicLong(10000);
private final AtomicLong            statementIdSeed   = new AtomicLong(20000);
private final AtomicLong            resultSetIdSeed   = new AtomicLong(50000);
public long createConnectionId() {
return connectionIdSeed.incrementAndGet();
public long createStatementId() {
return statementIdSeed.getAndIncrement();
public long createResultSetId() {
return resultSetIdSeed.getAndIncrement();
Notification notification = new Notification(event.getEventType(), JdbcTraceManager.class.getName(), sequenceNumber++);
boolean isNotificationEnable();
private long                  id;
private String                name;
private String                url;
private List<String>          filters = new ArrayList<String>();
private Date                  createdTime;
private String                rawDriverClassName;
private String                rawUrl;
private int                   rawDriverMajorVersion;
private int                   rawDriverMinorVersion;
private String                properties;
private MBeanServerConnection connection;
public DataSourceInfo(MBeanServerConnection conn, CompositeData data){
this.connection = conn;
public MBeanServerConnection getConnection() {
return connection;
public void setConnection(MBeanServerConnection connection) {
this.connection = connection;
private DataSourceInfo    dataSourceInfo;
private JTable            table;
private String[]          columns          = new String[] { "Name", "Value" };
public DataSourcePanel(DataSourceInfo dataSourceInfo){
this.dataSourceInfo = dataSourceInfo;
Object[][] rows = new Object[][] {
{ "ID", dataSourceInfo.getId() },
{ "Name", dataSourceInfo.getName() },
{ "URL", dataSourceInfo.getUrl() },
{ "Filters", dataSourceInfo.getFilters() },
{ "CreatedTime", dataSourceInfo.getCreatedTime() },
{ "RawDriverClassName", dataSourceInfo.getRawDriverClassName() },
{ "RawUrl", dataSourceInfo.getRawUrl() },
{ "RawDriverMajorVersion", dataSourceInfo.getRawDriverMajorVersion() },
{ "RawDriverMinorVersion", dataSourceInfo.getRawDriverMinorVersion() },
{ "Properties", dataSourceInfo.getProperties() },
table = new JTable(rows, columns);
JScrollPane tableScrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
this.setLayout(new BorderLayout());
this.add(tableScrollPane, BorderLayout.CENTER);
public DataSourceInfo getDataSourceInfo() {
return dataSourceInfo;
public void setDataSourceInfo(DataSourceInfo dataSourceInfo) {
this.dataSourceInfo = dataSourceInfo;
tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getPath().getLastPathComponent();
Object userData = node.getUserObject();
if (userData instanceof DataSourceInfo) {
DataSourceInfo dataSourceInfo = (DataSourceInfo) userData;
mainSplit.setRightComponent(new DataSourcePanel(dataSourceInfo));
mainSplit.setRightComponent(sheet);
DataSourceInfo dataSourceInfo = new DataSourceInfo(conn, rowData);
dataSourceNode.setUserObject(new NodeInfo(conn, NodeType.DataSource));
sqlListNode.setUserObject(new NodeInfo(conn, NodeType.SQL));
public class NodeInfo {
private MBeanServerConnection connection;
private NodeType              type;
public NodeInfo(MBeanServerConnection connection, NodeType type){
this.connection = connection;
this.type = type;
public MBeanServerConnection getConnection() {
return connection;
public NodeType getType() {
return type;
public enum NodeType {
DataSource,
public class SQLPanel extends JPanel {
private static final long serialVersionUID = 1L;
public SQLPanel(){
public final static String                                      JMX_PREFIX               = "jmx=";
if (restUrl.startsWith(JMX_PREFIX)) {
int pos = restUrl.indexOf(':', JMX_PREFIX.length());
String jmxOption = restUrl.substring(JMX_PREFIX.length(), pos);
config.setJmxOption(jmxOption);
restUrl = restUrl.substring(pos + 1);
if (config.isJmxOption()) {
JMXUtils.register("com.alibaba.druid:type=JdbcStat", JdbcStatManager.getInstance());
private boolean            jmx;
public boolean isJmxOption() {
return jmx;
public void setJmxOption(boolean jmx) {
this.jmx = jmx;
public void setJmxOption(String jmx) {
this.jmx = Boolean.parseBoolean(jmx);
dataSourcesNode = new DefaultMutableTreeNode(new NodeInfo(null, NodeType.DataSources, null, "DataSources"), true);
Object userObject = node.getUserObject();
NodeInfo nodeInfo = (NodeInfo) userObject;
if (nodeInfo == null) {
mainSplit.setRightComponent(sheet);
if (nodeInfo.getType() == NodeType.DataSource) {
DataSourceInfo dataSourceInfo = (DataSourceInfo) nodeInfo.getData();
DefaultMutableTreeNode dataSourceNode = new DefaultMutableTreeNode(new NodeInfo(conn, NodeType.DataSource, dataSourceInfo,
dataSourceInfo.getName()), true);
DefaultMutableTreeNode connections = new DefaultMutableTreeNode(new NodeInfo(conn, NodeType.Connections, "Connections", "Connections"), true);
DefaultMutableTreeNode sqlListNode = new DefaultMutableTreeNode(new NodeInfo(conn, NodeType.SQL, dataSourceInfo.getName(), "SQL"), true);
DefaultMutableTreeNode connections = new DefaultMutableTreeNode(new NodeInfo(conn, NodeType.Connections, "Connections", "Connections"), true);
DefaultMutableTreeNode sqlListNode = new DefaultMutableTreeNode(new NodeInfo(conn, NodeType.SQL, name, "SQL"), true);
private Object                data;
private String                name;
public NodeInfo(MBeanServerConnection connection, NodeType type, Object data, String name){
this.data = data;
this.name = name;
public Object getData() {
return data;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String toString() {
return name;
DataSources,
Connections
public class ConnectionsPanel extends JPanel {
private static final long     serialVersionUID = 1L;
private MBeanServerConnection connection;
private ObjectName            objectName;
public ConnectionsPanel(MBeanServerConnection connection, ObjectName objectName){
this.connection = connection;
this.objectName = objectName;
public MBeanServerConnection getConnection() {
return connection;
public ObjectName getObjectName() {
return objectName;
dataSourcesNode = new DefaultMutableTreeNode(new NodeInfo(null, null, NodeType.DataSources, null, "DataSources"), true);
NodeInfo dataSourceNodeInfo = new NodeInfo(conn, statInstance, NodeType.DataSource, dataSourceInfo, dataSourceInfo.getName());
DefaultMutableTreeNode dataSourceNode = new DefaultMutableTreeNode(dataSourceNodeInfo, true);
NodeInfo connectionsNodeInfo = new NodeInfo(conn, statInstance, NodeType.Connections, "Connections", "Connections");
DefaultMutableTreeNode connections = new DefaultMutableTreeNode(connectionsNodeInfo, true);
NodeInfo sqlNodeInfo = new NodeInfo(conn, statInstance, NodeType.SQL, dataSourceInfo.getName(), "SQL");
DefaultMutableTreeNode sqlListNode = new DefaultMutableTreeNode(sqlNodeInfo, true);
private ObjectInstance        objectInstance;
public NodeInfo(MBeanServerConnection connection, ObjectInstance objectInstance, NodeType type, Object data, String name){
public ObjectInstance getObjectInstance() {
return objectInstance;
private ObjectInstance        objectInstance;
private DataSourceInfo        dataSourceInfo;
public ConnectionsPanel(MBeanServerConnection connection, ObjectInstance objectInstance, DataSourceInfo dataSourceInfo){
this.objectInstance = objectInstance;
this.dataSourceInfo = dataSourceInfo;
public ObjectInstance getObjectInstance() {
return objectInstance;
public DataSourceInfo getDataSourceInfo() {
return dataSourceInfo;
} else if (nodeInfo.getType() == NodeType.Connections) {
DataSourceInfo dataSourceInfo = (DataSourceInfo) nodeInfo.getData();
ConnectionsPanel connectionsPanel = new ConnectionsPanel(nodeInfo.getConnection(), nodeInfo.getObjectInstance(), dataSourceInfo);
mainSplit.setRightComponent(connectionsPanel);
NodeInfo connectionsNodeInfo = new NodeInfo(conn, statInstance, NodeType.Connections, dataSourceInfo, "Connections");
NodeInfo sqlNodeInfo = new NodeInfo(conn, statInstance, NodeType.SQL, dataSourceInfo, "SQL");
private JTable                table;
private String[]              columns          = new String[] { "id", "connectTime", "connectTimespan", "establishTime", "aliveTimespan", "lastSql",
"lastError", "lastErrorTime", "connectStatckTrace", "lastStatementStackTrace", "dataSource" };
TabularData connectionTabularData = (TabularData) connection.getAttribute(objectInstance.getObjectName(), "ConnectionList");
Object[][] rows = new Object[connectionTabularData.size()][];
int rowIndex = 0;
for (Object item : connectionTabularData.values()) {
CompositeData rowData = (CompositeData) item;
Object[] row = new Object[columns.length];
row[0] = rowData.get("id");
row[1] = rowData.get("connectTime");
row[2] = rowData.get("connectTimespan");
row[3] = rowData.get("establishTime");
row[4] = rowData.get("aliveTimespan");
row[5] = rowData.get("lastSql");
row[6] = rowData.get("lastError");
row[7] = rowData.get("lastErrorTime");
row[8] = rowData.get("connectStatckTrace");
row[9] = rowData.get("lastStatementStackTrace");
row[10] = rowData.get("dataSource");
rows[rowIndex++] = row;
table = new JTable(rows, columns);
JScrollPane tableScrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
this.setLayout(new BorderLayout());
this.add(tableScrollPane, BorderLayout.CENTER);
} catch (Exception e) {
e.printStackTrace();
this.objectInstance = objectInstance;
private static final long     serialVersionUID = 1L;
private MBeanServerConnection connection;
private ObjectInstance        objectInstance;
private DataSourceInfo        dataSourceInfo;
private JTable                table;
private String[]              columns          = { "ID", "DataSource", "SQL", "ExecuteCount", "ErrorCount", "TotalTime", "LastTime", "MaxTimespan",
"LastError", "EffectedRowCount", "FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal", "ConcurrentMax", "RunningCount",
"Name", "File", "LastErrorMessage", "LastErrorClass", "LastErrorStackTrace", "LastErrorTime", "DbType" };
public SQLPanel(MBeanServerConnection connection, ObjectInstance objectInstance, DataSourceInfo dataSourceInfo){
this.connection = connection;
this.objectInstance = objectInstance;
this.dataSourceInfo = dataSourceInfo;
TabularData connectionTabularData = (TabularData) connection.getAttribute(objectInstance.getObjectName(), "ConnectionList");
Object[][] rows = new Object[connectionTabularData.size()][];
int rowIndex = 0;
for (Object item : connectionTabularData.values()) {
CompositeData rowData = (CompositeData) item;
Object[] row = new Object[columns.length];
row[0] = rowData.get("id");
row[1] = rowData.get("connectTime");
row[2] = rowData.get("connectTimespan");
row[3] = rowData.get("establishTime");
row[4] = rowData.get("aliveTimespan");
row[5] = rowData.get("lastSql");
row[6] = rowData.get("lastError");
row[7] = rowData.get("lastErrorTime");
row[8] = rowData.get("connectStatckTrace");
row[9] = rowData.get("lastStatementStackTrace");
row[10] = rowData.get("dataSource");
rows[rowIndex++] = row;
table = new JTable(rows, columns);
JScrollPane tableScrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
this.setLayout(new BorderLayout());
this.add(tableScrollPane, BorderLayout.CENTER);
} catch (Exception e) {
e.printStackTrace();
public MBeanServerConnection getConnection() {
return connection;
public ObjectInstance getObjectInstance() {
return objectInstance;
public DataSourceInfo getDataSourceInfo() {
return dataSourceInfo;
} else if (nodeInfo.getType() == NodeType.SQL) {
DataSourceInfo dataSourceInfo = (DataSourceInfo) nodeInfo.getData();
SQLPanel connectionsPanel = new SQLPanel(nodeInfo.getConnection(), nodeInfo.getObjectInstance(), dataSourceInfo);
mainSplit.setRightComponent(connectionsPanel);
private String[]              columns          = { "ID", "DataSource", "SQL", "ExecuteCount", "ErrorCount",
"TotalTime", "LastTime", "MaxTimespan", "LastError", "EffectedRowCount",
"FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal", "ConcurrentMax",
"RunningCount", "Name", "File", "LastErrorMessage", "LastErrorClass",
"LastErrorStackTrace", "LastErrorTime", "DbType" };
TabularData connectionTabularData = (TabularData) connection.getAttribute(objectInstance.getObjectName(), "SqlList");
int columnIndex = 0;
row[columnIndex++] = rowData.get("ID");
row[columnIndex++] = rowData.get("DataSource");
row[columnIndex++] = rowData.get("SQL");
row[columnIndex++] = rowData.get("ExecuteCount");
row[columnIndex++] = rowData.get("ErrorCount");
row[columnIndex++] = rowData.get("TotalTime");
row[columnIndex++] = rowData.get("LastTime");
row[columnIndex++] = rowData.get("MaxTimespan");
row[columnIndex++] = rowData.get("LastError");
row[columnIndex++] = rowData.get("EffectedRowCount");
row[columnIndex++] = rowData.get("FetchRowCount");
row[columnIndex++] = rowData.get("MaxTimespanOccurTime");
row[columnIndex++] = rowData.get("BatchSizeMax");
row[columnIndex++] = rowData.get("BatchSizeTotal");
row[columnIndex++] = rowData.get("ConcurrentMax");
row[columnIndex++] = rowData.get("RunningCount");
row[columnIndex++] = rowData.get("Name");
row[columnIndex++] = rowData.get("File");
row[columnIndex++] = rowData.get("LastErrorMessage");
row[columnIndex++] = rowData.get("LastErrorClass");
row[columnIndex++] = rowData.get("LastErrorStackTrace");
row[columnIndex++] = rowData.get("LastErrorTime");
row[columnIndex++] = rowData.get("DbType");
private String[]              columns          = { "ID", "DataSource", "SQL", "ExecuteCount", "ErrorCount",
"TotalTime", "LastTime", "MaxTimespan", "LastError", "EffectedRowCount",
"FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal", "ConcurrentMax",
"RunningCount", "Name", "File", "LastErrorMessage", "LastErrorClass",
"LastErrorStackTrace", "LastErrorTime", "DbType" };
List<Object[]> rowList = new ArrayList<Object[]>();
String url = (String) rowData.get("DataSource");
if (!dataSourceInfo.getUrl().equals(url)) {
rowList.add(row);
Object[][] rows = new Object[rowList.size()][];
rowList.toArray(rows);
public class SQLDetailPanel extends JPanel {
private static final long serialVersionUID = 1L;
public class SQLDetailDialog extends JDialog {
private static final long serialVersionUID = 1L;
public SQLDetailDialog(Object[] row) {
private Object[] row;
public SQLDetailPanel(Object[] row) {
this.row = row;
private String[]              columns          = { "ID", "Name", "File", "SQL", "ExecuteCount",
"ErrorCount", "TotalTime", "LastTime", "MaxTimespan", "LastError",
"EffectedRowCount", "FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal",
"ConcurrentMax", "RunningCount", "LastErrorMessage", "LastErrorClass", "LastErrorStackTrace",
"LastErrorTime"};
row[columnIndex++] = rowData.get("Name");
row[columnIndex++] = rowData.get("File");
row[columnIndex++] = rowData.get("ErrorCount");
row[columnIndex++] = rowData.get("EffectedRowCount");
row[columnIndex++] = rowData.get("ConcurrentMax");
table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
table.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
tableMouseClicked(e);
public void tableMouseClicked(MouseEvent e) {
if (e.getClickCount() < 2) {
int rowIndex = table.getSelectedRow();
if (rowIndex < 0) {
Object[] row = new Object[columns.length];
for (int i = 0; i < row.length; ++i) {
row[i] = table.getModel().getValueAt(rowIndex, i);
SQLDetailDialog dialog = new SQLDetailDialog(row);
dialog.setVisible(true);
public Object[] getRow() {
return row;
private String[]              columns          = { "ID", "File", "Name", "SQL", "ExecuteCount",
row[columnIndex++] = rowData.get("Name");
private String[]              columnNames      = { "ID", "File", "Name", "SQL", "ExecuteCount",
"ErrorCount", "TotalTime", "LastTime", "MaxTimespan", "LastError",
"EffectedRowCount", "FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal",
"ConcurrentMax", "RunningCount", "LastErrorMessage", "LastErrorClass", "LastErrorStackTrace",
"LastErrorTime" };
Object[] row = new Object[columnNames.length];
TableColumnModel columnModel = new TableColumnModel();
table = new JTable(new SQLTableModel(rows), columnModel);
table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
public class IDCellRender extends DefaultTableCellRenderer implements TableCellRenderer {
private static final long serialVersionUID = 1L;
public IDCellRender(){
this.addMouseListener(new MouseAdapter() {
public void mouseEntered(MouseEvent e) {
public void mouseExited(MouseEvent e) {
public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
this.setText(value.toString());
return this;
class SQLTableModel extends AbstractTableModel {
private static final long serialVersionUID = 1L;
private Object[][]        rowData;
public SQLTableModel(Object[][] rows){
this.rowData = rows;
public String getColumnName(int column) {
return columnNames[column].toString();
public int getRowCount() {
return rowData.length;
public int getColumnCount() {
return columnNames.length;
public Object getValueAt(int row, int col) {
return rowData[row][col];
public boolean isCellEditable(int row, int column) {
if (column == 0) {
return false;
return true;
public void setValueAt(Object value, int row, int col) {
rowData[row][col] = value;
fireTableCellUpdated(row, col);
class TableColumnModel extends DefaultTableColumnModel {
private static final long serialVersionUID = 1L;
public TableColumnModel(){
for (int i = 0; i < columnNames.length; ++i) {
TableColumn column = new TableColumn();
column.setModelIndex(i);
column.setHeaderValue(columnNames[i]);
this.addColumn(column);
TableColumn column = getColumn(0);
column.setCellRenderer(new IDCellRender());
private String[]              columnNames      = { "ID", "File", "Name", "SQL", "ExecCount",
"EffectedRowCount", "FetchRowCount", "ConcurrentMax", "Running" };
table.setAutoResizeMode(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);
table.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
tableMouseClicked(e);
public void tableMouseClicked(MouseEvent e) {
if (e.getClickCount() < 2) {
int rowIndex = table.getSelectedRow();
if (rowIndex < 0) {
Object[] row = new Object[columnNames.length];
for (int i = 0; i < columnNames.length; ++i) {
row[i] = table.getValueAt(rowIndex, i);
SQLDetailDialog dialog = new SQLDetailDialog(row);
dialog.setVisible(true);
column.setMinWidth(50);
column.setMaxWidth(50);
TableColumn column = getColumn(3);
column.setPreferredWidth(400);
TableColumn column = getColumn(4);
column.setPreferredWidth(60);
TableColumn column = getColumn(7);
column.setCellRenderer(new DateRenderer());
column.setPreferredWidth(120);
static class DateRenderer extends DefaultTableCellRenderer {
private static final long serialVersionUID = 1L;
DateFormat formatter;
public DateRenderer(){
public void setValue(Object value) {
if (formatter == null) {
formatter = new SimpleDateFormat("MM-dd HH:mm:ss");
setText((value == null) ? "" : formatter.format(value));
private JTextArea textArea;
public SQLDetailDialog(CompositeData rowData) {
textArea = new JTextArea();
JScrollPane textAreaScrollPane = new JScrollPane(textArea, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
this.getContentPane().add(textAreaScrollPane);
String sql = (String) rowData.get("SQL");
sql = format(sql);
textArea.setText(sql);
public static String format(String sql) {
if (sql == null || sql.length() == 0) {
return sql;
return mergeMySql(sql);
} catch (Exception ex) {
return mergeOracle(sql);
} catch (Exception ex) {
return sql; 
public static String mergeMySql(String sql) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.isTrue(1 == statementList.size());
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
statemen.accept(visitor);
return out.toString();
public static String mergeOracle(String sql) {
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.isTrue(1 == statementList.size());
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
statemen.accept(visitor);
return out.toString();
row[columnIndex++] = rowData;
CompositeData rowData = (CompositeData) table.getValueAt(rowIndex, 0);
SQLDetailDialog dialog = new SQLDetailDialog(rowData);
Toolkit kit = Toolkit.getDefaultToolkit();
Dimension screenSize = kit.getScreenSize();
int width = (int) screenSize.getWidth();
int height = (int) screenSize.getHeight();
dialog.setSize(800, 600);
int w = dialog.getWidth();
int h = dialog.getHeight();
dialog.setLocation((width - w) / 2, (height - h) / 2);
column.setCellRenderer(new IDRender());
DateFormat                formatter;
static class IDRender extends DefaultTableCellRenderer {
private static final long serialVersionUID = 1L;
public void setValue(Object value) {
CompositeData rowData = (CompositeData) value;
Object id = rowData.get("ID");
setText((id == null) ? "" : id.toString());
private SQLTableModel tableModel;
tableModel = new SQLTableModel(rows);
table = new JTable(tableModel, columnModel);
void refresh() {
TabularData connectionTabularData = (TabularData) connection.getAttribute(objectInstance.getObjectName(), "SqlList");
List<Object[]> rowList = new ArrayList<Object[]>();
for (Object item : connectionTabularData.values()) {
CompositeData rowData = (CompositeData) item;
String url = (String) rowData.get("DataSource");
if (!dataSourceInfo.getUrl().equals(url)) {
Object[] row = new Object[columnNames.length];
int columnIndex = 0;
row[columnIndex++] = rowData;
row[columnIndex++] = rowData.get("File");
row[columnIndex++] = rowData.get("Name");
row[columnIndex++] = rowData.get("SQL");
row[columnIndex++] = rowData.get("ExecuteCount");
row[columnIndex++] = rowData.get("ErrorCount");
row[columnIndex++] = rowData.get("TotalTime");
row[columnIndex++] = rowData.get("LastTime");
row[columnIndex++] = rowData.get("MaxTimespan");
row[columnIndex++] = rowData.get("LastError");
row[columnIndex++] = rowData.get("EffectedRowCount");
row[columnIndex++] = rowData.get("FetchRowCount");
row[columnIndex++] = rowData.get("ConcurrentMax");
row[columnIndex++] = rowData.get("RunningCount");
rowList.add(row);
Object[][] rows = new Object[rowList.size()][];
rowList.toArray(rows);
int rowCount = tableModel.getRowCount();
tableModel.setRowData(rows);
tableModel.fireTableRowsDeleted(0, rowCount - 1);
tableModel.setRowData(rows);
tableModel.fireTableRowsInserted(0, rows.length);
} catch (Exception e) {
e.printStackTrace();
public void setRowData(Object[][] rowData) {
this.rowData = rowData;
public class HADataSource implements DataSource {
private int         loginTimeout = 0;
private PrintWriter logWriter    = new PrintWriter(System.out);
public PrintWriter getLogWriter() throws SQLException {
return logWriter;
public void setLogWriter(PrintWriter out) throws SQLException {
this.logWriter = out;
public void setLoginTimeout(int seconds) throws SQLException {
loginTimeout = seconds;
public int getLoginTimeout() throws SQLException {
return loginTimeout;
public <T> T unwrap(Class<T> iface) throws SQLException {
return null;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
return false;
public Connection getConnection() throws SQLException {
return null;
public Connection getConnection(String username, String password) throws SQLException {
return null;
private final List<DataSource> dataSources  = new CopyOnWriteArrayList<DataSource>();
private int              loginTimeout = 0;
private PrintWriter      logWriter    = new PrintWriter(System.out);
public List<DataSource> getDataSources() {
return dataSources;
private int                    loginTimeout = 0;
private PrintWriter            logWriter    = new PrintWriter(System.out);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
return false;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
return null;
throw new UnsupportedOperationException();
final String urlPath = "/jndi/rmi:
private SQLTableModel         tableModel;
column.setCellRenderer(new SQLRenderer());
static class SQLRenderer extends DefaultTableCellRenderer {
private static final long serialVersionUID = 1L;
public SQLRenderer(){
public void setValue(Object value) {
String sql = (String) value;
String formattedSql = SQLDetailDialog.format(sql);
setText(sql);
setToolTipText("<html><pre>" + formattedSql + "</pre>");
setToolTipText("<html><pre>" + formattedSql + "</pre></html>");
final String urlPath = "/jndi/rmi:
private SQLTableRowSorter     sorter;
"TotalTime", "EffectedRows", "FetchRowCount", "Running", "ConcurrentMax",
"MaxTimespan", "LastTime", "LastError","ErrorCount",  };
row[columnIndex++] = rowData.get("ConcurrentMax");
row[columnIndex++] = rowData.get("MaxTimespan");
row[columnIndex++] = rowData.get("LastTime");
row[columnIndex++] = rowData.get("LastError");
row[columnIndex++] = rowData.get("ErrorCount");
sorter = new SQLTableRowSorter(tableModel);
table.setRowSorter(sorter);
TableColumn column = getColumn(11);
setToolTipText("<html><pre>" + formattedSql + "</pre></html>");
static class SQLTableRowSorter extends TableRowSorter<SQLTableModel> {
public SQLTableRowSorter(SQLTableModel model){
super(model);
public Comparator<?> getComparator(int column) {
switch (column) {
return new LongComparator();
return super.getComparator(column);
static class LongComparator implements Comparator<Object> {
public int compare(Object a, Object b) {
long aValue = Long.parseLong(a.toString());
long bValue = Long.parseLong(b.toString());
if (aValue == bValue) {
return aValue > bValue ? 1 : -1;
count.set(0);
public final static int RevisionVersion = 2;
String getValidationQuery();
int getValidationQueryTimeout();
int getMaxWaitThreadCount();
long getTimeBetweenEvictionRunsMillis();
long getMinEvictableIdleTimeMillis();
private final DruidAbstractDataSource               dataSource;
public DruidAbstractDataSource getDataSource() {
public Driver getRawDriver() {
return driver;
private final AtomicLong connectionIdSeed = new AtomicLong(10000);
private final AtomicLong statementIdSeed  = new AtomicLong(20000);
private final AtomicLong resultSetIdSeed  = new AtomicLong(50000);
public long createConnectionId() {
return connectionIdSeed.incrementAndGet();
public long createStatementId() {
return statementIdSeed.getAndIncrement();
public long createResultSetId() {
return resultSetIdSeed.getAndIncrement();
void initStatement(Statement stmt) throws SQLException {
if (queryTimeout > 0) {
stmt.setQueryTimeout(queryTimeout);
protected abstract void recycle(PoolableConnection pooledConnection) throws SQLException;
public class DruidDataSource2 extends DruidAbstractDataSource {
private static final long serialVersionUID = 1L;
public Connection getConnection() throws SQLException {
return null;
public Connection getConnection(String username, String password) throws SQLException {
return null;
void incrementCreateCount() {
protected void recycle(PoolableConnection pooledConnection) throws SQLException {
public class LinkedTransferQueue<E> extends AbstractQueue<E>
implements TransferQueue<E>, java.io.Serializable {
private static final long serialVersionUID = -3223113410248163686L;
private static final boolean MP =
Runtime.getRuntime().availableProcessors() > 1;
private static final int FRONT_SPINS   = 1 << 7;
private static final int CHAINED_SPINS = FRONT_SPINS >>> 1;
static final int SWEEP_THRESHOLD = 32;
static final class Node {
final boolean isData;   
volatile Object item;   
volatile Node next;
volatile Thread waiter; 
final boolean casNext(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
final boolean casItem(Object cmp, Object val) {
return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
Node(Object item, boolean isData) {
UNSAFE.putObject(this, itemOffset, item); 
this.isData = isData;
final void forgetNext() {
UNSAFE.putObject(this, nextOffset, this);
final void forgetContents() {
UNSAFE.putObject(this, itemOffset, this);
UNSAFE.putObject(this, waiterOffset, null);
final boolean isMatched() {
Object x = item;
return (x == this) || ((x == null) == isData);
final boolean isUnmatchedRequest() {
return !isData && item == null;
final boolean cannotPrecede(boolean haveData) {
boolean d = isData;
return d != haveData && (x = item) != this && (x != null) == d;
final boolean tryMatchData() {
Object x = item;
if (x != null && x != this && casItem(x, null)) {
LockSupport.unpark(waiter);
return true;
return false;
private static final long serialVersionUID = -3375979862319811754L;
private static final sun.misc.Unsafe UNSAFE;
private static final long itemOffset;
private static final long nextOffset;
private static final long waiterOffset;
UNSAFE = getUnsafe();
Class k = Node.class;
itemOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("item"));
nextOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("next"));
waiterOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("waiter"));
} catch (Exception e) {
throw new Error(e);
transient volatile Node head;
private transient volatile Node tail;
private transient volatile int sweepVotes;
private boolean casTail(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
private boolean casHead(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);
private boolean casSweepVotes(int cmp, int val) {
return UNSAFE.compareAndSwapInt(this, sweepVotesOffset, cmp, val);
private static final int NOW   = 0; 
private static final int ASYNC = 1; 
private static final int SYNC  = 2; 
private static final int TIMED = 3; 
@SuppressWarnings("unchecked")
static <E> E cast(Object item) {
return (E) item;
private E xfer(E e, boolean haveData, int how, long nanos) {
if (haveData && (e == null))
throw new NullPointerException();
Node s = null;                        
for (;;) {                            
for (Node h = head, p = h; p != null;) { 
boolean isData = p.isData;
Object item = p.item;
if (item != p && (item != null) == isData) { 
if (isData == haveData)   
if (p.casItem(item, e)) { 
for (Node q = p; q != h;) {
Node n = q.next;  
if (head == h && casHead(h, n == null ? q : n)) {
h.forgetNext();
}                 
if ((h = head)   == null ||
(q = h.next) == null || !q.isMatched())
break;        
LockSupport.unpark(p.waiter);
return this.<E>cast(item);
Node n = p.next;
p = (p != n) ? n : (h = head); 
if (how != NOW) {                 
if (s == null)
s = new Node(e, haveData);
Node pred = tryAppend(s, haveData);
if (pred == null)
continue retry;           
if (how != ASYNC)
return awaitMatch(s, pred, e, (how == TIMED), nanos);
return e; 
private Node tryAppend(Node s, boolean haveData) {
for (Node t = tail, p = t;;) {        
Node n, u;                        
if (p == null && (p = head) == null) {
if (casHead(null, s))
return s;                 
else if (p.cannotPrecede(haveData))
return null;                  
else if ((n = p.next) != null)    
p = p != t && t != (u = tail) ? (t = u) : 
(p != n) ? n : null;      
else if (!p.casNext(null, s))
p = p.next;                   
if (p != t) {                 
while ((tail != t || !casTail(t, s)) &&
(t = tail)   != null &&
(s = t.next) != null && 
(s = s.next) != null && s != t);
private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {
long lastTime = timed ? System.nanoTime() : 0L;
Thread w = Thread.currentThread();
int spins = -1; 
ThreadLocalRandom randomYields = null; 
for (;;) {
Object item = s.item;
if (item != e) {                  
s.forgetContents();           
return this.<E>cast(item);
if ((w.isInterrupted() || (timed && nanos <= 0)) &&
s.casItem(e, s)) {        
unsplice(pred, s);
if (spins < 0) {                  
if ((spins = spinsFor(pred, s.isData)) > 0)
randomYields = ThreadLocalRandom.current();
else if (spins > 0) {             
if (randomYields.nextInt(CHAINED_SPINS) == 0)
Thread.yield();           
else if (s.waiter == null) {
s.waiter = w;                 
else if (timed) {
long now = System.nanoTime();
if ((nanos -= now - lastTime) > 0)
LockSupport.parkNanos(this, nanos);
lastTime = now;
LockSupport.park(this);
private static int spinsFor(Node pred, boolean haveData) {
if (MP && pred != null) {
if (pred.isData != haveData)      
return FRONT_SPINS + CHAINED_SPINS;
if (pred.isMatched())             
return FRONT_SPINS;
if (pred.waiter == null)          
return CHAINED_SPINS;
final Node succ(Node p) {
Node next = p.next;
return (p == next) ? head : next;
private Node firstOfMode(boolean isData) {
for (Node p = head; p != null; p = succ(p)) {
if (!p.isMatched())
return (p.isData == isData) ? p : null;
return null;
private E firstDataItem() {
for (Node p = head; p != null; p = succ(p)) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p)
return this.<E>cast(item);
else if (item == null)
return null;
return null;
private int countOfMode(boolean data) {
int count = 0;
for (Node p = head; p != null; ) {
if (!p.isMatched()) {
if (p.isData != data)
if (++count == Integer.MAX_VALUE) 
Node n = p.next;
if (n != p)
count = 0;
return count;
final class Itr implements Iterator<E> {
private Node nextNode;   
private E nextItem;      
private Node lastRet;    
private Node lastPred;   
private void advance(Node prev) {
Node r, b; 
if ((r = lastRet) != null && !r.isMatched())
lastPred = r;    
else if ((b = lastPred) == null || b.isMatched())
lastPred = null; 
Node s, n;       
while ((s = b.next) != null &&
s != b && s.isMatched() &&
(n = s.next) != null && n != s)
b.casNext(s, n);
this.lastRet = prev;
for (Node p = prev, s, n;;) {
s = (p == null) ? head : p.next;
if (s == null)
else if (s == p) {
Object item = s.item;
if (s.isData) {
if (item != null && item != s) {
nextItem = LinkedTransferQueue.<E>cast(item);
nextNode = s;
else if (item == null)
if (p == null)
else if ((n = s.next) == null)
else if (s == n)
p.casNext(s, n);
nextNode = null;
nextItem = null;
advance(null);
public final boolean hasNext() {
return nextNode != null;
public final E next() {
Node p = nextNode;
if (p == null) throw new NoSuchElementException();
E e = nextItem;
advance(p);
public final void remove() {
final Node lastRet = this.lastRet;
if (lastRet == null)
throw new IllegalStateException();
this.lastRet = null;
if (lastRet.tryMatchData())
unsplice(lastPred, lastRet);
final void unsplice(Node pred, Node s) {
s.forgetContents(); 
if (pred != null && pred != s && pred.next == s) {
Node n = s.next;
if (n == null ||
(n != s && pred.casNext(s, n) && pred.isMatched())) {
for (;;) {               
Node h = head;
if (h == pred || h == s || h == null)
return;          
if (!h.isMatched())
Node hn = h.next;
if (hn == null)
return;          
if (hn != h && casHead(h, hn))
h.forgetNext();  
if (pred.next != pred && s.next != s) { 
for (;;) {           
int v = sweepVotes;
if (v < SWEEP_THRESHOLD) {
if (casSweepVotes(v, v + 1))
else if (casSweepVotes(v, 0)) {
private void sweep() {
for (Node p = head, s, n; p != null && (s = p.next) != null; ) {
if (!s.isMatched())
else if ((n = s.next) == null) 
else if (s == n)    
p.casNext(s, n);
private boolean findAndRemove(Object e) {
if (e != null) {
for (Node pred = null, p = head; p != null; ) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p && e.equals(item) &&
p.tryMatchData()) {
unsplice(pred, p);
return true;
else if (item == null)
if ((p = p.next) == pred) { 
pred = null;
return false;
public LinkedTransferQueue() {
public LinkedTransferQueue(Collection<? extends E> c) {
addAll(c);
public void put(E e) {
xfer(e, true, ASYNC, 0);
public boolean offer(E e, long timeout, TimeUnit unit) {
xfer(e, true, ASYNC, 0);
return true;
public boolean offer(E e) {
xfer(e, true, ASYNC, 0);
return true;
public boolean add(E e) {
xfer(e, true, ASYNC, 0);
return true;
public boolean tryTransfer(E e) {
return xfer(e, true, NOW, 0) == null;
public void transfer(E e) throws InterruptedException {
if (xfer(e, true, SYNC, 0) != null) {
Thread.interrupted(); 
throw new InterruptedException();
public boolean tryTransfer(E e, long timeout, TimeUnit unit)
throws InterruptedException {
if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)
return true;
if (!Thread.interrupted())
return false;
throw new InterruptedException();
public E take() throws InterruptedException {
E e = xfer(null, false, SYNC, 0);
if (e != null)
Thread.interrupted();
throw new InterruptedException();
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
E e = xfer(null, false, TIMED, unit.toNanos(timeout));
if (e != null || !Thread.interrupted())
throw new InterruptedException();
public E poll() {
return xfer(null, false, NOW, 0);
public int drainTo(Collection<? super E> c) {
if (c == null)
throw new NullPointerException();
if (c == this)
throw new IllegalArgumentException();
int n = 0;
while ( (e = poll()) != null) {
public int drainTo(Collection<? super E> c, int maxElements) {
if (c == null)
throw new NullPointerException();
if (c == this)
throw new IllegalArgumentException();
int n = 0;
while (n < maxElements && (e = poll()) != null) {
public Iterator<E> iterator() {
return new Itr();
public E peek() {
return firstDataItem();
public boolean isEmpty() {
for (Node p = head; p != null; p = succ(p)) {
if (!p.isMatched())
return !p.isData;
return true;
public boolean hasWaitingConsumer() {
return firstOfMode(false) != null;
public int size() {
return countOfMode(true);
public int getWaitingConsumerCount() {
return countOfMode(false);
public boolean remove(Object o) {
return findAndRemove(o);
public boolean contains(Object o) {
if (o == null) return false;
for (Node p = head; p != null; p = succ(p)) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p && o.equals(item))
return true;
else if (item == null)
return false;
public int remainingCapacity() {
return Integer.MAX_VALUE;
private void writeObject(java.io.ObjectOutputStream s)
throws java.io.IOException {
s.defaultWriteObject();
for (E e : this)
s.writeObject(e);
s.writeObject(null);
private void readObject(java.io.ObjectInputStream s)
throws java.io.IOException, ClassNotFoundException {
s.defaultReadObject();
for (;;) {
@SuppressWarnings("unchecked") E item = (E) s.readObject();
if (item == null)
offer(item);
private static final sun.misc.Unsafe UNSAFE;
private static final long headOffset;
private static final long tailOffset;
private static final long sweepVotesOffset;
UNSAFE = getUnsafe();
Class k = LinkedTransferQueue.class;
headOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("head"));
tailOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("tail"));
sweepVotesOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("sweepVotes"));
} catch (Exception e) {
throw new Error(e);
static sun.misc.Unsafe getUnsafe() {
return sun.misc.Unsafe.getUnsafe();
} catch (SecurityException se) {
return java.security.AccessController.doPrivileged
(new java.security
.PrivilegedExceptionAction<sun.misc.Unsafe>() {
public sun.misc.Unsafe run() throws Exception {
java.lang.reflect.Field f = sun.misc
.Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
return (sun.misc.Unsafe) f.get(null);
} catch (java.security.PrivilegedActionException e) {
throw new RuntimeException("Could not initialize intrinsics",
e.getCause());
public interface TransferQueue<E> extends BlockingQueue<E> {
boolean tryTransfer(E e);
void transfer(E e) throws InterruptedException;
boolean tryTransfer(E e, long timeout, TimeUnit unit)
throws InterruptedException;
boolean hasWaitingConsumer();
int getWaitingConsumerCount();
public class TestLinkedTransferQueue extends TestCase {
public void test_0() throws Exception {
final LinkedTransferQueue<Object> q = new LinkedTransferQueue<Object>();
Thread takeThread = new Thread("Take Thread") {
public void run() {
for (;;) {
} catch (InterruptedException e) {
e.printStackTrace();
takeThread.start();
System.out.println(q.size());
private static String[] indexNames        = { "ID", "ConnectTime", "ConnectTimespan", "EstablishTime", "AliveTimespan", "LastSql", "LastError",
"LastErrorTime", "ConnectStatckTrace", "LastStatementStackTrace", "DataSource" };
map.put("ID", id);
map.put("ConnectTime", getConnectTime());
map.put("ConnectTimespan", getConnectTimespanNano() / (1000 * 1000));
map.put("EstablishTime", getEstablishTime());
map.put("AliveTimespan", (System.nanoTime() - getEstablishNano()) / (1000 * 1000));
map.put("LastSql", getLastSql());
map.put("LastError", JMXUtils.getErrorCompositeData(this.lastError));
map.put("LastErrorTime", getLastErrorTime());
map.put("ConnectStatckTrace", getConnectStackTrace());
map.put("LastStatementStackTrace", getLastStatementStatckTrace());
map.put("DataSource", this.getDataSource());
SimpleType.STRING, SimpleType.DATE, SimpleType.STRING, SimpleType.STRING };
"LastErrorMessage", "LastErrorClass", "LastErrorStackTrace", "LastErrorTime", "DbType", "URL" };
public Map<String, Object> getData() throws JMException {
map.put("URL", null);
return map;
public CompositeDataSupport getCompositeData() throws JMException {
return new CompositeDataSupport(getCompositeType(), getData());
Map<String, Object> map = entry.getValue().getData();
map.put("URL", dataSource.getUrl());
data.put(new CompositeDataSupport(JdbcSqlStat.getCompositeType(), map));
public class LockTest extends TestCase {
public void test_0() throws Exception {
Lock lock = new ReentrantLock();
lock.lock();
lock.unlock();
String catalog = conn.getCatalog();
System.out.println(catalog);
stmt.close();
if (x.getFrom() instanceof SQLSubqueryTableSource) {
x.getFrom().accept(this);
return false;
public class MySqlSchemaStatVisitorTest_Subquery extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT id2, name2 FROM (select id, name from users limit 10) a";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public boolean visit(SQLSubqueryTableSource x) {
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap != null) {
if (x.getAlias() != null) {
aliasMap.put(x.getAlias(), null);
return true;
if (owner != null) {
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap != null) {
String table = aliasMap.get(owner);
if (table != null) {
fields.add(new Column(table, x.getName()));
public class MySqlSchemaStatVisitorTest_Subquery2 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT a.id, a.name, b.name groupName FROM (select id, name, groupId from users limit 10) a inner join groups b on a.groupId = b.id";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("groups"));
Assert.assertEquals(5, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("groups", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("groups", "name")));
int tableHashCode = table != null ? table.toLowerCase().hashCode() : 0;
int nameHashCode = name != null ? name.toLowerCase().hashCode() : 0;
if (!table.equalsIgnoreCase(column.getTable())) {
if (!name.equalsIgnoreCase(column.getName())) {
public class MySqlResourceTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/mysql-0.txt");
exec_test("bvt/parser/mysql-1.txt");
exec_test("bvt/parser/mysql-2.txt");
exec_test("bvt/parser/mysql-3.txt");
exec_test("bvt/parser/mysql-4.txt");
exec_test("bvt/parser/mysql-5.txt");
exec_test("bvt/parser/mysql-6.txt");
exec_test("bvt/parser/mysql-7.txt");
exec_test("bvt/parser/mysql-8.txt");
exec_test("bvt/parser/mysql-9.txt");
exec_test("bvt/parser/mysql-10.txt");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = JdbcUtils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
System.out.println();
System.out.println();
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("usergroups"));
Assert.assertEquals(4, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "name")));
public void test_1() throws Exception {
String sql = "select a.name, b.name FROM users a, usergroups b on a.groupId = b.id where a.groupID = ?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
stat.incrementDeleteCount();
stat.incrementInsertCount();
stat.incrementUpdateCount();
stat.incrementSelectCount();
stat.incrementUpdateCount();
stat.incrementDeleteCount();
stat.incrementInsertCount();
stat.incrementInsertCount();
public class TableStat {
int selectCount = 0;
int updateCount = 0;
int deleteCount = 0;
int insertCount = 0;
public int getSelectCount() {
return selectCount;
public void incrementSelectCount() {
selectCount++;
public void setSelectCount(int selectCount) {
this.selectCount = selectCount;
public int getUpdateCount() {
return updateCount;
public void incrementUpdateCount() {
updateCount++;
public void setUpdateCount(int updateCount) {
this.updateCount = updateCount;
public int getDeleteCount() {
return deleteCount;
public void incrementDeleteCount() {
this.deleteCount++;
public void setDeleteCount(int deleteCount) {
this.deleteCount = deleteCount;
public void incrementInsertCount() {
this.insertCount++;
public int getInsertCount() {
return insertCount;
public void setInsertCount(int insertCount) {
this.insertCount = insertCount;
public String toString() {
StringBuilder buf = new StringBuilder(4);
if (insertCount > 0) {
buf.append("C");
if (updateCount > 0) {
buf.append("U");
if (selectCount > 0) {
buf.append("R");
if (deleteCount > 0) {
buf.append("D");
return buf.toString();
public static class Column {
private String table;
private String name;
public Column(){
public Column(String table, String name){
this.table = table;
this.name = name;
public String getTable() {
return table;
public void setTable(String table) {
this.table = table;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public int hashCode() {
int tableHashCode = table != null ? table.toLowerCase().hashCode() : 0;
int nameHashCode = name != null ? name.toLowerCase().hashCode() : 0;
return tableHashCode + nameHashCode;
public String toString() {
if (table != null) {
return table + "." + name;
return name;
public boolean equals(Object obj) {
Column column = (Column) obj;
if (table == null) {
if (column.getTable() != null) {
return false;
if (!table.equalsIgnoreCase(column.getTable())) {
return false;
if (name == null) {
if (column.getName() != null) {
return false;
if (!name.equalsIgnoreCase(column.getName())) {
return false;
return true;
public static enum Mode {
Insert(1), Update(2), Delete(4), Select(8);
public final int mark;
private Mode(int mark){
this.mark = mark;
return visit((SQLDeleteStatement) x);
public void endVisit(OracleDeleteStatement x) {
aliasLocal.set(null);
public boolean visit(SQLDeleteStatement x) {
TableStat stat = tableStats.get(ident);
if (stat == null) {
stat = new TableStat();
tableStats.put(ident, stat);
stat.incrementDeleteCount();
public void endVisit(SQLDeleteStatement x) {
public class OracleSchemaStatVisitorTest1 extends TestCase {
public void test_0() throws Exception {
String sql = "select a.name, b.name FROM users a, usergroups b on a.groupId = b.id";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("usergroups"));
Assert.assertEquals(4, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "name")));
public void test_1() throws Exception {
String sql = "select a.name, b.name FROM users a, usergroups b on a.groupId = b.id where a.groupID = ?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("usergroups"));
Assert.assertEquals(4, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("usergroups", "name")));
public class OracleSchemaStatVisitorTest2 extends TestCase {
public void test_0() throws Exception {
String sql = "select id, name FROM users";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public void test_2() throws Exception {
String sql = "select id, name FROM users a";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public void test_3() throws Exception {
String sql = "select id, a.name FROM users a";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public class OracleSchemaStatVisitorTest3 extends TestCase {
public void test_0() throws Exception {
String sql = "insert into users2 (id2, name2) select id, name FROM users where loginCount > 1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("users2"));
Assert.assertEquals(5, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "loginCount")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users2", "name2")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users2", "id2")));
public class OracleSchemaStatVisitorTest4 extends TestCase {
public void test_0() throws Exception {
String sql = "insert into users (id, name) values(?, ?)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public class OracleSchemaStatVisitorTest_Delete extends TestCase {
public void test_0() throws Exception {
String sql = "delete from users where id = ? or name = ?";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public class OracleSchemaStatVisitorTest_Subquery extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT id2, name2 FROM (select id, name from users limit 10) a";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
public class OracleSchemaStatVisitorTest_Subquery2 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT a.id, a.name, b.name groupName FROM (select id, name, groupId from users WHERE ROWNUM < 10) a inner join groups b on a.groupId = b.id";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(true, visitor.getTables().containsKey("groups"));
Assert.assertEquals(5, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("groups", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("groups", "name")));
public class OracleSchemaStatVisitorTest_Update extends TestCase {
public void test_0() throws Exception {
String sql = "update users set loginCount = loginCount + 1 where id = ?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.getTables().containsKey("users"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("users", "loginCount")));
public boolean visit(OracleUpdateStatement x) {
aliasLocal.set(new HashMap<String, String>());
if (x.getTable() instanceof SQLIdentifierExpr) {
String ident = x.getTable().toString();
currentTableLocal.set(ident);
TableStat stat = tableStats.get(ident);
if (stat == null) {
stat = new TableStat();
tableStats.put(ident, stat);
stat.incrementUpdateCount();
Map<String, String> aliasMap = aliasLocal.get();
aliasMap.put(ident, ident);
accept(x.getTable());
accept(x.getSetClause());
accept(x.getWhere());
return false;
public void endVisit(OracleUpdateStatement x) {
aliasLocal.set(null);
endVisit((SQLSelectQueryBlock) x);
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
OracleStatementParser parser = new OracleStatementParser(sql);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
printStackTrace(ex);
public boolean visit(OracleSelect x) {
return true;
public void endVisit(OracleSelect x) {
boolean visit(OracleSelect x);
void endVisit(OracleSelect x);
public void endVisit(OracleSelect x) {
public void endVisit(OracleSelect x) {
public boolean visit(OracleSelect x) {
accept(x.getFactoring());
accept(x.getQuery());
String originalTable = currentTableLocal.get();
currentTableLocal.set((String) x.getQuery().getAttribute("table"));
x.putAttribute("_old_local_", originalTable);
accept(x.getOrderBy());
currentTableLocal.set(originalTable);
return false;
exec_test("bvt/parser/oracle-29.txt");
InvertBits("~", 100),
if (x.getOperator() == SQLBinaryOperator.Equality || x.getOperator() == SQLBinaryOperator.NotEqual) {
x.getLeft().getAttributes().put(ATTR_PARAMS_SKIP, true);
x.getRight().getAttributes().put(ATTR_PARAMS_SKIP, true);
accept(x.getExpr());
if (x.getOperator() == SQLBinaryOperator.Equality || x.getOperator() == SQLBinaryOperator.NotEqual) {
x.getLeft().getAttributes().put(ATTR_PARAMS_SKIP, true);
x.getRight().getAttributes().put(ATTR_PARAMS_SKIP, true);
accept(x.getExpr());
return false;
accept(x.getExpr());
if ("SYSDATE".equalsIgnoreCase(x.getName())) {
return false;
if ("+".equalsIgnoreCase(x.getName())) {
return false;
if (lexer.token() == Token.BAR) {
expr = bitAndRest(expr);
} else if (lexer.token() == Token.TILDE) {
lexer.nextToken();
SQLExpr rightExp = bitAnd();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.InvertBits, rightExp);
expr = bitAndRest(expr);
exec_test("bvt/parser/mysql-11.txt");
exec_test("bvt/parser/mysql-12.txt");
exec_test("bvt/parser/oracle-53.txt");
exec_test("bvt/parser/mysql-13.txt");
if (identifierEquals("CALL")) {
statementList.add(this.parseCall());
public class CallTest extends TestCase {
public void test_select() throws Exception {
String sql = "CALL test(1)";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
output(statementList);
private void output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
visitor.println();
System.out.println(out.toString());
System.out.println(JSON.toJSONString(sqlList));
Assert.assertEquals(true, sqlList.size() > 0);
public final static String  DEFAULT_VALIDATION_QUERY                  = null; 
@SuppressWarnings("rawtypes")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private static ClassLoader defaultClassLoader;
private static Charset     charset;
private Resources(){
public static ClassLoader getDefaultClassLoader() {
return defaultClassLoader;
public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
Resources.defaultClassLoader = defaultClassLoader;
public static URL getResourceURL(String resource) throws IOException {
return getResourceURL(getClassLoader(), resource);
public static URL getResourceURL(ClassLoader loader, String resource) throws IOException {
URL url = null;
if (loader != null) url = loader.getResource(resource);
if (url == null) url = ClassLoader.getSystemResource(resource);
if (url == null) throw new IOException("Could not find resource " + resource);
return url;
public static InputStream getResourceAsStream(String resource) throws IOException {
return getResourceAsStream(getClassLoader(), resource);
public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {
InputStream in = null;
if (loader != null) in = loader.getResourceAsStream(resource);
if (in == null) in = ClassLoader.getSystemResourceAsStream(resource);
if (in == null) throw new IOException("Could not find resource " + resource);
return in;
public static Properties getResourceAsProperties(String resource) throws IOException {
Properties props = new Properties();
InputStream in = null;
String propfile = resource;
in = getResourceAsStream(propfile);
props.load(in);
in.close();
return props;
public static Properties getResourceAsProperties(ClassLoader loader, String resource) throws IOException {
Properties props = new Properties();
InputStream in = null;
String propfile = resource;
in = getResourceAsStream(loader, propfile);
props.load(in);
in.close();
return props;
public static Reader getResourceAsReader(String resource) throws IOException {
Reader reader;
if (charset == null) {
reader = new InputStreamReader(getResourceAsStream(resource));
reader = new InputStreamReader(getResourceAsStream(resource), charset);
return reader;
public static Reader getResourceAsReader(ClassLoader loader, String resource) throws IOException {
Reader reader;
if (charset == null) {
reader = new InputStreamReader(getResourceAsStream(loader, resource));
reader = new InputStreamReader(getResourceAsStream(loader, resource), charset);
return reader;
public static File getResourceAsFile(String resource) throws IOException {
return new File(getResourceURL(resource).getFile());
public static File getResourceAsFile(ClassLoader loader, String resource) throws IOException {
return new File(getResourceURL(loader, resource).getFile());
public static InputStream getUrlAsStream(String urlString) throws IOException {
URL url = new URL(urlString);
URLConnection conn = url.openConnection();
return conn.getInputStream();
public static Reader getUrlAsReader(String urlString) throws IOException {
return new InputStreamReader(getUrlAsStream(urlString));
public static Properties getUrlAsProperties(String urlString) throws IOException {
Properties props = new Properties();
InputStream in = null;
String propfile = urlString;
in = getUrlAsStream(propfile);
props.load(in);
in.close();
return props;
public static Class<?> classForName(String className) throws ClassNotFoundException {
Class<?> clazz = null;
clazz = getClassLoader().loadClass(className);
} catch (Exception e) {
if (clazz == null) {
clazz = Class.forName(className);
return clazz;
public static Object instantiate(String className) throws ClassNotFoundException, InstantiationException,
IllegalAccessException {
return instantiate(classForName(className));
public static Object instantiate(Class<?> clazz) throws InstantiationException, IllegalAccessException {
return clazz.newInstance();
private static ClassLoader getClassLoader() {
if (defaultClassLoader != null) {
return defaultClassLoader;
return Thread.currentThread().getContextClassLoader();
public static Charset getCharset() {
return charset;
public static void setCharset(Charset charset) {
Resources.charset = charset;
private static final long      serialVersionUID                          = 1L;
public final static int        DEFAULT_INITIAL_SIZE                      = 0;
public final static int        DEFAULT_MAX_ACTIVE_SIZE                   = 8;
public final static int        DEFAULT_MAX_IDLE                          = 8;
public final static int        DEFAULT_MIN_IDLE                          = 0;
public final static int        DEFAULT_MAX_WAIT                          = -1;
public final static String     DEFAULT_VALIDATION_QUERY                  = null;                                     
public final static boolean    DEFAULT_TEST_ON_BORROW                    = true;
public final static boolean    DEFAULT_TEST_ON_RETURN                    = false;
public final static boolean    DEFAULT_WHILE_IDLE                        = false;
public static final long       DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final long       DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS = 30 * 1000;
public static final int        DEFAULT_NUM_TESTS_PER_EVICTION_RUN        = 1;
public static final long       DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS    = 1000L * 60L * 30L;
protected boolean              defaultAutoCommit                         = false;
protected Boolean              defaultReadOnly;
protected Integer              defaultTransactionIsolation;
protected String               defaultCatalog                            = null;
protected String               name;
protected String               username;
protected String               password;
protected String               jdbcUrl;
protected String               driverClass;
protected Properties           connectionProperties                      = new Properties();
protected PasswordCallback     passwordCallback;
protected NameCallback         userCallback;
protected ConnectionFactory    connectionFactory;
protected int                  initialSize                               = DEFAULT_INITIAL_SIZE;
protected int                  maxActive                                 = DEFAULT_MAX_ACTIVE_SIZE;
protected int                  minIdle                                   = DEFAULT_MIN_IDLE;
protected int                  maxIdle                                   = DEFAULT_MAX_IDLE;
protected long                 maxWait                                   = DEFAULT_MAX_WAIT;
protected String               validationQuery                           = DEFAULT_VALIDATION_QUERY;
protected int                  validationQueryTimeout                    = -1;
private boolean                testOnBorrow                              = DEFAULT_TEST_ON_BORROW;
private boolean                testOnReturn                              = DEFAULT_TEST_ON_RETURN;
private boolean                testWhileIdle                             = DEFAULT_WHILE_IDLE;
protected boolean              poolPreparedStatements                    = false;
protected boolean              inited                                    = false;
protected PrintWriter          logWriter                                 = new PrintWriter(System.out);
protected List<Filter>         filters                                   = new ArrayList<Filter>();
protected Driver               driver;
protected int                  queryTimeout;
protected long                 createErrorCount;
protected long                 createTimespan;
protected int                  maxWaitThreadCount                        = -1;
protected boolean              accessToUnderlyingConnectionAllowed       = true;
protected long                 timeBetweenEvictionRunsMillis             = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
protected int                  numTestsPerEvictionRun                    = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
protected long                 minEvictableIdleTimeMillis                = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
protected boolean              removeAbandoned;
protected int                  removeAbandonedTimeout;
protected boolean              logAbandoned;
protected int                  maxOpenPreparedStatements                 = -1;
protected List<String>         connectionInitSqls;
protected String               dbType;
protected long                 timeBetweenConnectErrorMillis             = DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS;
private ValidConnectionChecker validConnectionChecker                    = null;
public ValidConnectionChecker getValidConnectionChecker() {
return validConnectionChecker;
public void setValidConnectionChecker(ValidConnectionChecker validConnectionChecker) {
this.validConnectionChecker = validConnectionChecker;
if (validConnectionChecker != null) {
return validConnectionChecker.isValidConnection(conn);
if (null == query) {
return true;
Statement stmt = null;
ResultSet rset = null;
stmt = conn.createStatement();
if (getValidationQueryTimeout() > 0) {
stmt.setQueryTimeout(getValidationQueryTimeout());
rset = stmt.executeQuery(query);
if (!rset.next()) {
return false;
} finally {
if (rset != null) {
rset.close();
} catch (Exception t) {
if (stmt != null) {
stmt.close();
} catch (Exception t) {
private final CountDownLatch                                                 initedLatch                 = new CountDownLatch(
throw new SQLException("maxWaitThreadCount " + maxWaitThreadCount + ", current wait Thread count "
+ lock.getQueueLength());
activeConnections.put(poolalbeConnection,
new ActiveConnectionTraceInfo(poolalbeConnection, System.currentTimeMillis(),
stackTrace));
boolean isValidConnection(Connection c);
public boolean isValidConnection(final Connection c) {
return true;
} catch (SQLException e) {
return false;
public boolean isValidConnection(Connection c) {
return true;
LOG.warn("Unexpected error in ping", e);
return false;
Statement stmt = null;
ResultSet rs = null;
stmt = c.createStatement();
rs = stmt.executeQuery("SELECT 1");
return true;
} catch (SQLException e) {
return false;
} catch (Exception e) {
LOG.warn("Unexpected error in ping", e);
return false;
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
public boolean isValidConnection(Connection c) {
if (status.intValue() < 0) {
return false;
return true;
this.validConnectionChecker = new MySqlValidConnectionChecker1();
public class MySqlValidConnectionChecker1 implements ValidConnectionChecker, Serializable {
private static final Log  LOG                 = LogFactory.getLog(MySqlValidConnectionChecker1.class);
public MySqlValidConnectionChecker1(){
this.validConnectionChecker = new MySqlValidConnectionChecker();
public class MySqlValidConnectionChecker implements ValidConnectionChecker, Serializable {
private static final Log  LOG                 = LogFactory.getLog(MySqlValidConnectionChecker.class);
public MySqlValidConnectionChecker(){
public interface ExceptionSorter {
boolean isExceptionFatal(SQLException e);
public class MySqlExceptionSorter implements ExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
String state = e.getSQLState();
if (state != null && state.startsWith("08")) { 
return true;
final int errorCode = e.getErrorCode();
switch (errorCode) {
case 1040: 
case 1042: 
case 1043: 
case 1047: 
case 1081: 
case 1129: 
case 1130: 
case 1045: 
case 1004: 
case 1005: 
case 1015: 
case 1021: 
case 1041: 
case 1037: 
case 1038: 
return true;
return false;
public class OracleExceptionSorter implements ExceptionSorter, Serializable {
private static final long serialVersionUID = -9146226891418913174L;
public OracleExceptionSorter(){
public boolean isExceptionFatal(final SQLException e) {
final int error_code = Math.abs(e.getErrorCode()); 
if ((error_code == 28) 
|| (error_code == 600) 
|| (error_code == 1012) 
|| (error_code == 1014) 
|| (error_code == 1033) 
|| (error_code == 1034) 
|| (error_code == 1035) 
|| (error_code == 1089) 
|| (error_code == 1090) 
|| (error_code == 1092) 
|| (error_code == 1094) 
|| (error_code == 2396) 
|| (error_code == 3106) 
|| (error_code == 3111) 
|| (error_code == 3113) 
|| (error_code == 3114) 
|| (error_code >= 12100 && error_code <= 12299) 
return true;
final String error_text = (e.getMessage()).toUpperCase();
if ((error_code < 20000 || error_code >= 21000)
&& ((error_text.indexOf("SOCKET") > -1) 
|| (error_text.indexOf("CONNECTION HAS ALREADY BEEN CLOSED") > -1) || (error_text.indexOf("BROKEN PIPE") > -1))) {
return true;
return false;
private static final long        serialVersionUID                          = 1L;
public final static int          DEFAULT_INITIAL_SIZE                      = 0;
public final static int          DEFAULT_MAX_ACTIVE_SIZE                   = 8;
public final static int          DEFAULT_MAX_IDLE                          = 8;
public final static int          DEFAULT_MIN_IDLE                          = 0;
public final static int          DEFAULT_MAX_WAIT                          = -1;
public final static String       DEFAULT_VALIDATION_QUERY                  = null;                                     
public final static boolean      DEFAULT_TEST_ON_BORROW                    = true;
public final static boolean      DEFAULT_TEST_ON_RETURN                    = false;
public final static boolean      DEFAULT_WHILE_IDLE                        = false;
public static final long         DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final long         DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS = 30 * 1000;
public static final int          DEFAULT_NUM_TESTS_PER_EVICTION_RUN        = 1;
public static final long         DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS    = 1000L * 60L * 30L;
protected boolean                defaultAutoCommit                         = false;
protected Boolean                defaultReadOnly;
protected Integer                defaultTransactionIsolation;
protected String                 defaultCatalog                            = null;
protected String                 name;
protected String                 username;
protected String                 password;
protected String                 jdbcUrl;
protected String                 driverClass;
protected Properties             connectionProperties                      = new Properties();
protected PasswordCallback       passwordCallback;
protected NameCallback           userCallback;
protected ConnectionFactory      connectionFactory;
protected int                    initialSize                               = DEFAULT_INITIAL_SIZE;
protected int                    maxActive                                 = DEFAULT_MAX_ACTIVE_SIZE;
protected int                    minIdle                                   = DEFAULT_MIN_IDLE;
protected int                    maxIdle                                   = DEFAULT_MAX_IDLE;
protected long                   maxWait                                   = DEFAULT_MAX_WAIT;
protected String                 validationQuery                           = DEFAULT_VALIDATION_QUERY;
protected int                    validationQueryTimeout                    = -1;
private boolean                  testOnBorrow                              = DEFAULT_TEST_ON_BORROW;
private boolean                  testOnReturn                              = DEFAULT_TEST_ON_RETURN;
private boolean                  testWhileIdle                             = DEFAULT_WHILE_IDLE;
protected boolean                poolPreparedStatements                    = false;
protected boolean                inited                                    = false;
protected PrintWriter            logWriter                                 = new PrintWriter(System.out);
protected List<Filter>           filters                                   = new ArrayList<Filter>();
protected List<ExceptionSorter>  exceptionSoters                           = new ArrayList<ExceptionSorter>();
protected Driver                 driver;
protected int                    queryTimeout;
protected long                   createErrorCount;
protected long                   createTimespan;
protected int                    maxWaitThreadCount                        = -1;
protected boolean                accessToUnderlyingConnectionAllowed       = true;
protected long                   timeBetweenEvictionRunsMillis             = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
protected int                    numTestsPerEvictionRun                    = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
protected long                   minEvictableIdleTimeMillis                = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
protected boolean                removeAbandoned;
protected int                    removeAbandonedTimeout;
protected boolean                logAbandoned;
protected int                    maxOpenPreparedStatements                 = -1;
protected List<String>           connectionInitSqls;
protected String                 dbType;
protected long                   timeBetweenConnectErrorMillis             = DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS;
public List<ExceptionSorter> getExceptionSoters() {
return exceptionSoters;
public void setExceptionSoters(List<ExceptionSorter> exceptionSoters) {
this.exceptionSoters = exceptionSoters;
public void setExceptionSoters(String exceptionSorters) throws Exception {
this.exceptionSoters.clear();
if (exceptionSorters == null || exceptionSorters.length() == 0) {
String[] sorterArray = exceptionSorters.split("\,");
for (String item : sorterArray) {
Class<?> clazz = DruidLoaderUtils.loadClass(item);
ExceptionSorter sorter = (ExceptionSorter) clazz.newInstance();
exceptionSoters.add(sorter);
dataSource.setExceptionSoters(OracleExceptionSorter.class.getName());
public void setValidConnectionChecker(String validConnectionCheckerClass) throws Exception {
Class<?> clazz = DruidLoaderUtils.loadClass(validConnectionCheckerClass);
ValidConnectionChecker validConnectionChecker = (ValidConnectionChecker) clazz.newInstance();
this.validConnectionChecker = validConnectionChecker;
private static final long   serialVersionUID = 1L;
private static final String QUERY            = "SELECT 1";
if (t instanceof SQLException) {
throw (SQLException) t;
throw new SQLException("Error", t);
clazz = DruidLoaderUtils.loadClass("oracle.jdbc.driver.OracleConnection");
dataSource.setExceptionSoter(OracleExceptionSorter.class.getName());
public class SybaseExceptionSorter implements ExceptionSorter, Serializable {
private static final long serialVersionUID = 2742592563671255116L;
public boolean isExceptionFatal(SQLException e) {
boolean result = false;
String errorText = (e.getMessage()).toUpperCase();
if ((errorText.indexOf("JZ0C0") > -1) || 
(errorText.indexOf("JZ0C1") > -1) 
result = true;
return result;
String sqlState = e.getSQLState();
if (sqlState != null && sqlState.startsWith("08")) { 
private final static String   PROP_EXCEPTION_SORTER                    = "exceptionSorter";
private final static String   PROP_EXCEPTION_SORTER_CLASS_NAME         = "exception-sorter-class-name";
private final static String[] ALL_PROPERTIES                           = { PROP_DEFAULTAUTOCOMMIT,
PROP_DEFAULTREADONLY, PROP_DEFAULTTRANSACTIONISOLATION, PROP_DEFAULTCATALOG, PROP_DRIVERCLASSNAME,
PROP_MAXACTIVE, PROP_MAXIDLE, PROP_MINIDLE, PROP_INITIALSIZE, PROP_MAXWAIT, PROP_TESTONBORROW,
PROP_TESTONRETURN, PROP_TIMEBETWEENEVICTIONRUNSMILLIS, PROP_NUMTESTSPEREVICTIONRUN,
PROP_MINEVICTABLEIDLETIMEMILLIS, PROP_TESTWHILEIDLE, PROP_PASSWORD, PROP_URL, PROP_USERNAME,
PROP_VALIDATIONQUERY, PROP_VALIDATIONQUERY_TIMEOUT, PROP_INITCONNECTIONSQLS,
PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED, PROP_REMOVEABANDONED, PROP_REMOVEABANDONEDTIMEOUT,
PROP_LOGABANDONED, PROP_POOLPREPAREDSTATEMENTS, PROP_MAXOPENPREPAREDSTATEMENTS, PROP_CONNECTIONPROPERTIES,
PROP_FILTERS, PROP_EXCEPTION_SORTER, PROP_EXCEPTION_SORTER_CLASS_NAME };
public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment)
throws Exception {
value = properties.getProperty(PROP_EXCEPTION_SORTER);
if (value != null) {
dataSource.setExceptionSoter(value);
value = properties.getProperty(PROP_EXCEPTION_SORTER_CLASS_NAME);
if (value != null) {
dataSource.setExceptionSoter(value);
public void setExceptionSorterClassName(String exceptionSorter) throws Exception {
this.setExceptionSoter(exceptionSorter);
ping.invoke(conn);
dataSource.setExceptionSoter(MySqlExceptionSorter.class.getName());
public class InformixExceptionSorter implements ExceptionSorter, Serializable {
private static final long serialVersionUID = -5175884111768095263L;
public boolean isExceptionFatal(SQLException e) {
switch (e.getErrorCode()) {
case -710: 
case -79716: 
case -79730: 
case -79734: 
case -79735: 
case -79736: 
case -79756: 
case -79757: 
case -79758: 
case -79759: 
case -79760: 
case -79788: 
case -79811: 
case -79812: 
case -79836: 
case -79837: 
case -79879: 
return true;
return false;
if (clazz.isAssignableFrom(c.getClass())) {
conn = (Connection) c.unwrap(clazz);
} catch (SQLException e) {
LOG.warn("Unexpected error in ping", e);
return false;
private static final long     serialVersionUID = -2227528634302168877L;
private static final Log      LOG              = LogFactory.getLog(OracleValidConnectionChecker.class);
private final Class<?>        clazz;
private final Method          ping;
private final static Object[] params           = new Object[] { new Integer(5000) };
if (!clazz.isAssignableFrom(c.getClass())) {
Connection conn = (Connection) c.unwrap(clazz);
if (conn != null) {
Integer status = (Integer) ping.invoke(c, params);
if (status.intValue() < 0) {
return false;
dataSource.setValidationQuery(validationQuery);
dataSource.setConnectionTestStatement(validationQuery);
, SimpleType.LONG, SimpleType.LONG, SimpleType.DATE, SimpleType.STRING, SimpleType.STRING 
, "ConnectionOpenningCount", "ConnectionOpenningCountMax", "ConnectionCloseCount", "ConnectionCommitCount", "ConnectionRollbackCount" 
, "ConnectionConnectLastTime", "ConnectionConnectErrorCount", "ConnectLastErrorTime", "ConnectLastErrorMessage", "ConnectLastErrorStackTrace" 
, "ResultSetOpenCount", "ResultSetOpenningCount", "ResultSetOpenningMax", "ResultSetFetchRowCount", "ResultSetLastOpenTime" 
, "ResultSetErrorCount", "ResultSetOpenningMillisTotal", "ResultSetLastErrorTime", "ResultSetLastErrorMessage", "ResultSetLastErrorStackTrace"
map.put("ConnectionOpenningCount", stat.getConnectionActiveCount());
map.put("ConnectionOpenningCountMax", stat.getConnectionStat().getActiveMax());
map.put("ConnectionConnectLastTime", stat.getConnectionStat().getLastConnectTime());
map.put("ConnectionConnectErrorCount", stat.getConnectionStat().getErrorCount());
map.put("ResultSetOpenningCount", stat.getResultSetStat().getOpenningCount());
map.put("ResultSetOpenningMax", stat.getResultSetStat().getOpenningMax());
map.put("ResultSetErrorCount", stat.getResultSetStat().getErrorCount());
map.put("ResultSetOpenningMillisTotal", stat.getResultSetStat().getOpenningMillisTotal());
map.put("ResultSetLastErrorTime", stat.getResultSetStat().getLastErrorTime());
Throwable lastResultSetError = stat.getResultSetStat().getLastError();
if (lastResultSetError != null) {
map.put("ResultSetLastErrorMessage", lastResultSetError.getMessage());
StringWriter buf = new StringWriter();
lastResultSetError.printStackTrace(new PrintWriter(buf));
map.put("ResultSetLastErrorStackTrace", buf.toString());
map.put("ResultSetLastErrorMessage", null);
map.put("ResultSetLastErrorStackTrace", null);
map.put("ConnectionOpenningCount", null);
map.put("ConnectionOpenningCountMax", null);
map.put("ConnectionConnectLastTime", null);
map.put("ConnectionConnectErrorCount", null);
map.put("ResultSetLastErrorCount", null);
map.put("ResultSetOpenningMillisTotal", null);
map.put("ResultSetLastErrorTime", null);
map.put("ResultSetLastErrorMessage", null);
map.put("ResultSetLastErrorStackTrace", null);
private final AtomicLong    openningNanoTotal       = new AtomicLong();
private long                lastOpenTime  = 0;
private final AtomicLong    fetchRowCount = new AtomicLong(0);  
openningNanoTotal.set(0);
lastOpenTime = 0;
fetchRowCount.set(0);
closeCount.set(0);
lastOpenTime = System.currentTimeMillis();
public int getOpenningCount() {
public int getOpenningMax() {
if (lastOpenTime == 0) {
return new Date(lastOpenTime);
public long getOpenningNanoTotal() {
return openningNanoTotal.get();
public long getOpenningMillisTotal() {
return openningNanoTotal.get() / (1000 * 1000);
openningNanoTotal.addAndGet(nanoSpan);
return JdbcStatManager.getInstance().getResultSetStat().getOpenningNanoTotal() / (1000 * 1000);
return fetchRowCount.get();
fetchRowCount.addAndGet(fetchCount);
int getOpenningCount();
int getOpenningMax();
, SimpleType.LONG, SimpleType.DATE, SimpleType.LONG, SimpleType.LONG
, "ConnectionConnectCount", "ConnectionErrorLastMessage", "ConnectionErrorLastStackTrace", "ConnectionConnectMillisTotal", "ConnectionConnectingCountMax" 
, "ConnectionConnectMillisMax", "ConnectionErrorLastTime", "ConnectionAliveMillisMax", "ConnectionAliveMillisMin"
map.put("ConnectionConnectMillisTotal", stat.getConnectionStat().getConnectMillis());
map.put("ConnectionErrorLastTime", stat.getConnectionStat().getErrorLastTime());
map.put("ConnectionAliveMillisMax", stat.getConnectionStat().getAliveMillisMax());
map.put("ConnectionAliveMillisMin", stat.getConnectionStat().getAliveMillisMin());
map.put("ConnectionConnectMillisTotal", null);
map.put("ConnectionErrorLastTime", null);
map.put("ConnectionAliveMillisMax", null);
map.put("ConnectionAliveMillisMin", null);
private final AtomicLong    aliveNanoTotal         = new AtomicLong();
private final AtomicLong aliveNanoMin     = new AtomicLong();
private final AtomicLong aliveNanoMax     = new AtomicLong();
aliveNanoTotal.set(0);
aliveNanoMin.set(0);
aliveNanoMax.set(0);
public long getAliveTotal() {
return aliveNanoTotal.get();
public long getAliveNanoMin() {
return aliveNanoMin.get();
public long getAliveMillisMin() {
return aliveNanoMin.get() / (1000 * 1000);
public long getAliveNanoMax() {
return aliveNanoMax.get();
public long getAliveMillisMax() {
return aliveNanoMax.get() / (1000 * 1000);
public void afterClose(long aliveNano) {
aliveNanoTotal.addAndGet(aliveNano);
for (;;) {
long max = aliveNanoMax.get();
if (aliveNano > max) {
if (aliveNanoMax.compareAndSet(max, aliveNano)) {
for (;;) {
long min = aliveNanoMin.get();
if (aliveNano < min) {
if (aliveNanoMax.compareAndSet(min, aliveNano)) {
long aliveNanoSpan = this.getConnectionStat().getAliveTotal();
map.put("ResultSetOpenningMillisTotal", stat.getResultSetStat().getAliveMillisTotal());
private final AtomicLong    aliveNanoTotal       = new AtomicLong();
aliveNanoTotal.set(0);
public long getAliveNanoTotal() {
return aliveNanoTotal.get();
public long getAliveMillisTotal() {
return aliveNanoTotal.get() / (1000 * 1000);
aliveNanoTotal.addAndGet(nanoSpan);
return JdbcStatManager.getInstance().getResultSetStat().getAliveNanoTotal() / (1000 * 1000);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1 FROM DUAL");
rs.next();
rs.close();
stmt.close();
map.put("ConnectionAliveMillisMax", stat.getConnectionConnectAliveMillisMax());
map.put("ConnectionAliveMillisMin", stat.getConnectionConnectAliveMillisMin());
map.put("ConnectionAliveMillisMax", stat.getConnectionConnectAliveMillisMax());
map.put("ConnectionAliveMillisMin", stat.getConnectionConnectAliveMillisMin());
public long getConnectionConnectAliveMillisMax() {
long nowNano = System.nanoTime();
long max = this.getConnectionStat().getAliveNanoMax();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano > max) {
max = connectionAliveNano;
return max / (1000 * 1000);
public long getConnectionConnectAliveMillisMin() {
long nowNano = System.nanoTime();
long min = this.getConnectionStat().getAliveNanoMin();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano < min || min == 0) {
min = connectionAliveNano;
return min / (1000 * 1000);
map.put("ConnectionCount_Alive_0_1_Seconds", stat.getConnectionCount_Alive_0_1_Seconds());
map.put("ConnectionCount_Alive_1_5_Seconds", stat.getConnectionCount_Alive_1_5_Seconds());
map.put("ConnectionCount_Alive_5_10_Seconds", stat.getConnectionCount_Alive_5_10_Seconds());
map.put("ConnectionCount_Alive_10_30_Seconds", stat.getConnectionCount_Alive_10_30_Seconds());
map.put("ConnectionCount_Alive_30_60_Seconds", stat.getConnectionCount_Alive_30_60_Seconds());
map.put("ConnectionCount_Alive_1_5_Minutes", stat.getConnectionCount_Alive_1_5_Minutes());
map.put("ConnectionCount_Alive_5_10_Minutes", stat.getConnectionCount_Alive_5_10_Minutes());
map.put("ConnectionCount_Alive_10_30_Minutes", stat.getConnectionCount_Alive_10_30_Minutes());
map.put("ConnectionCount_Alive_30_60_Minutes", stat.getConnectionCount_Alive_30_60_Minutes());
map.put("ConnectionCount_Alive_1_3_Hours", stat.getConnectionCount_Alive_1_3_Hours());
map.put("ConnectionCount_Alive_3_6_Hours", stat.getConnectionCount_Alive_3_6_Hours());
map.put("ConnectionCount_Alive_6_12_Hours", stat.getConnectionCount_Alive_6_12_Hours());
map.put("ConnectionCount_Alive_12_24_Hours", stat.getConnectionCount_Alive_12_24_Hours());
map.put("ConnectionCount_Alive_1_3_Day", stat.getConnectionCount_Alive_1_3_Day());
map.put("ConnectionCount_Alive_3_more_Day", stat.getConnectionCount_Alive_3_more_Day());
map.put("ConnectionCount_Alive_0_1_Seconds", null);
map.put("ConnectionCount_Alive_1_5_Seconds", null);
map.put("ConnectionCount_Alive_5_10_Seconds", null);
map.put("ConnectionCount_Alive_10_30_Seconds", null);
map.put("ConnectionCount_Alive_30_60_Seconds", null);
map.put("ConnectionCount_Alive_1_5_Minutes", null);
map.put("ConnectionCount_Alive_5_10_Minutes", null);
map.put("ConnectionCount_Alive_10_30_Minutes", null);
map.put("ConnectionCount_Alive_30_60_Minutes", null);
map.put("ConnectionCount_Alive_1_3_Hours", null);
map.put("ConnectionCount_Alive_3_6_Hours", null);
map.put("ConnectionCount_Alive_6_12_Hours", null);
map.put("ConnectionCount_Alive_12_24_Hours", null);
map.put("ConnectionCount_Alive_1_3_Day", null);
map.put("ConnectionCount_Alive_3_more_Day", null);
map.put("ConnectionCount_Alive_0_1_Seconds", stat.getConnectionCount_Alive_0_1_Seconds());
map.put("ConnectionCount_Alive_1_5_Seconds", stat.getConnectionCount_Alive_1_5_Seconds());
map.put("ConnectionCount_Alive_5_10_Seconds", stat.getConnectionCount_Alive_5_10_Seconds());
map.put("ConnectionCount_Alive_10_30_Seconds", stat.getConnectionCount_Alive_10_30_Seconds());
map.put("ConnectionCount_Alive_30_60_Seconds", stat.getConnectionCount_Alive_30_60_Seconds());
map.put("ConnectionCount_Alive_1_5_Minutes", stat.getConnectionCount_Alive_1_5_Minutes());
map.put("ConnectionCount_Alive_5_10_Minutes", stat.getConnectionCount_Alive_5_10_Minutes());
map.put("ConnectionCount_Alive_10_30_Minutes", stat.getConnectionCount_Alive_10_30_Minutes());
map.put("ConnectionCount_Alive_30_60_Minutes", stat.getConnectionCount_Alive_30_60_Minutes());
map.put("ConnectionCount_Alive_1_3_Hours", stat.getConnectionCount_Alive_1_3_Hours());
map.put("ConnectionCount_Alive_3_6_Hours", stat.getConnectionCount_Alive_3_6_Hours());
map.put("ConnectionCount_Alive_6_12_Hours", stat.getConnectionCount_Alive_6_12_Hours());
map.put("ConnectionCount_Alive_12_24_Hours", stat.getConnectionCount_Alive_12_24_Hours());
map.put("ConnectionCount_Alive_1_3_Day", stat.getConnectionCount_Alive_1_3_Day());
map.put("ConnectionCount_Alive_3_more_Day", stat.getConnectionCount_Alive_3_more_Day());
map.put("ConnectionCount_Alive_0_1_Seconds", null);
map.put("ConnectionCount_Alive_1_5_Seconds", null);
map.put("ConnectionCount_Alive_5_10_Seconds", null);
map.put("ConnectionCount_Alive_10_30_Seconds", null);
map.put("ConnectionCount_Alive_30_60_Seconds", null);
map.put("ConnectionCount_Alive_1_5_Minutes", null);
map.put("ConnectionCount_Alive_5_10_Minutes", null);
map.put("ConnectionCount_Alive_10_30_Minutes", null);
map.put("ConnectionCount_Alive_30_60_Minutes", null);
map.put("ConnectionCount_Alive_1_3_Hours", null);
map.put("ConnectionCount_Alive_3_6_Hours", null);
map.put("ConnectionCount_Alive_6_12_Hours", null);
map.put("ConnectionCount_Alive_12_24_Hours", null);
map.put("ConnectionCount_Alive_1_3_Day", null);
map.put("ConnectionCount_Alive_3_more_Day", null);
private final AtomicInteger activeCount               = new AtomicInteger();
private final AtomicInteger activeCountMax            = new AtomicInteger();
private final AtomicInteger connectingCount           = new AtomicInteger();
private final AtomicInteger connectingMax             = new AtomicInteger();
private final AtomicLong    connectCount              = new AtomicLong();
private final AtomicLong    connectErrorCount         = new AtomicLong();
private final AtomicLong    connectNanoTotal          = new AtomicLong(0);  
private final AtomicLong    connectNanoMax            = new AtomicLong(0);  
private final AtomicLong    errorCount                = new AtomicLong();
private final AtomicLong    aliveNanoTotal            = new AtomicLong();
private long                connectLastTime           = 0;
private final AtomicLong    closeCount                = new AtomicLong(0);  
private final AtomicLong    commitCount               = new AtomicLong(0);  
private final AtomicLong    rollbackCount             = new AtomicLong(0);  
private final AtomicLong    aliveNanoMin              = new AtomicLong();
private final AtomicLong    aliveNanoMax              = new AtomicLong();
private final AtomicLong    count_Alive_0_1_Seconds   = new AtomicLong();
private final AtomicLong    count_Alive_1_5_Seconds   = new AtomicLong();
private final AtomicLong    count_Alive_5_10_Seconds  = new AtomicLong();
private final AtomicLong    count_Alive_10_30_Seconds = new AtomicLong();
private final AtomicLong    count_Alive_30_60_Seconds = new AtomicLong();
private final AtomicLong    count_Alive_1_5_Minutes   = new AtomicLong();
private final AtomicLong    count_Alive_5_10_Minutes  = new AtomicLong();
private final AtomicLong    count_Alive_10_30_Minutes = new AtomicLong();
private final AtomicLong    count_Alive_30_60_Minutes = new AtomicLong();
private final AtomicLong    count_Alive_1_3_Hours     = new AtomicLong();
private final AtomicLong    count_Alive_3_6_Hours     = new AtomicLong();
private final AtomicLong    count_Alive_6_12_Hours    = new AtomicLong();
private final AtomicLong    count_Alive_12_24_Hours   = new AtomicLong();
private final AtomicLong    count_Alive_1_3_Day       = new AtomicLong();
private final AtomicLong    count_Alive_3_more_Day    = new AtomicLong();
count_Alive_0_1_Seconds.set(0);
count_Alive_1_5_Seconds.set(0);
count_Alive_5_10_Seconds.set(0);
count_Alive_10_30_Seconds.set(0);
count_Alive_30_60_Seconds.set(0);
count_Alive_1_5_Minutes.set(0);
count_Alive_5_10_Minutes.set(0);
count_Alive_10_30_Minutes.set(0);
count_Alive_30_60_Minutes.set(0);
count_Alive_1_3_Hours.set(0);
count_Alive_3_6_Hours.set(0);
count_Alive_6_12_Hours.set(0);
count_Alive_12_24_Hours.set(0);
count_Alive_1_3_Day.set(0);
count_Alive_3_more_Day.set(0);
final long SECOND = 1000 * 1000 * 1000;
final long MINUTE = SECOND * 60;
final long HOUR = MINUTE * 60;
final long DAY = HOUR * 24;
if (aliveNano < 1 * SECOND) {
count_Alive_0_1_Seconds.incrementAndGet();
} else if (aliveNano < 5 * SECOND) {
count_Alive_1_5_Seconds.incrementAndGet();
} else if (aliveNano < 10 * SECOND) {
count_Alive_5_10_Seconds.incrementAndGet();
} else if (aliveNano < 30 * SECOND) {
count_Alive_10_30_Seconds.incrementAndGet();
} else if (aliveNano < 60 * SECOND) {
count_Alive_30_60_Seconds.incrementAndGet();
} else if (aliveNano < 5 * MINUTE) {
count_Alive_1_5_Minutes.incrementAndGet();
} else if (aliveNano < 10 * MINUTE) {
count_Alive_5_10_Minutes.incrementAndGet();
} else if (aliveNano < 30 * MINUTE) {
count_Alive_10_30_Minutes.incrementAndGet();
} else if (aliveNano < 60 * MINUTE) {
count_Alive_30_60_Minutes.incrementAndGet();
} else if (aliveNano < 3 * HOUR) {
count_Alive_1_3_Hours.incrementAndGet();
} else if (aliveNano < 6 * HOUR) {
count_Alive_3_6_Hours.incrementAndGet();
} else if (aliveNano < 12 * HOUR) {
count_Alive_6_12_Hours.incrementAndGet();
} else if (aliveNano < 24 * HOUR) {
count_Alive_12_24_Hours.incrementAndGet();
} else if (aliveNano < 3 * DAY) {
count_Alive_1_3_Day.incrementAndGet();
count_Alive_3_more_Day.incrementAndGet();
public long getCount_Alive_0_1_Seconds() {
return count_Alive_0_1_Seconds.get();
public long getCount_Alive_1_5_Seconds() {
return count_Alive_1_5_Seconds.get();
public long getCount_Alive_5_10_Seconds() {
return count_Alive_5_10_Seconds.get();
public long getCount_Alive_10_30_Seconds() {
return count_Alive_10_30_Seconds.get();
public long getCount_Alive_30_60_Seconds() {
return count_Alive_30_60_Seconds.get();
public long getCount_Alive_1_5_Minutes() {
return count_Alive_1_5_Minutes.get();
public long getCount_Alive_5_10_Minutes() {
return count_Alive_5_10_Minutes.get();
public long getCount_Alive_10_30_Minutes() {
return count_Alive_10_30_Minutes.get();
public long getCount_Alive_30_60_Minutes() {
return count_Alive_30_60_Minutes.get();
public long getCount_Alive_1_3_Hours() {
return count_Alive_1_3_Hours.get();
public long getCount_Alive_3_6_Hours() {
return count_Alive_3_6_Hours.get();
public long getCount_Alive_6_12_Hours() {
return count_Alive_6_12_Hours.get();
public long getCount_Alive_12_24_Hours() {
return count_Alive_12_24_Hours.get();
public long getCount_Alive_1_3_Day() {
return count_Alive_1_3_Day.get();
public long getCount_Alive_3_more_Day() {
return count_Alive_3_more_Day.get();
long nowNano = System.nanoTime();
long nowNano = System.nanoTime();
final static long SECOND = 1000 * 1000 * 1000;
final static long MINUTE = SECOND * 60;
final static long HOUR   = MINUTE * 60;
final static long DAY    = HOUR * 24;
public long getConnectionCount_Alive_0_1_Seconds() {
long count = this.getConnectionStat().getCount_Alive_0_1_Seconds();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano < SECOND) {
return count;
public long getConnectionCount_Alive_1_5_Seconds() {
long count = this.getConnectionStat().getCount_Alive_1_5_Seconds();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= SECOND && connectionAliveNano < 5 * SECOND) {
return count;
public long getConnectionCount_Alive_5_10_Seconds() {
long count = this.getConnectionStat().getCount_Alive_5_10_Seconds();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 5 * SECOND && connectionAliveNano < 10 * SECOND) {
return count;
public long getConnectionCount_Alive_10_30_Seconds() {
long count = this.getConnectionStat().getCount_Alive_10_30_Seconds();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 10 * SECOND && connectionAliveNano < 30 * SECOND) {
return count;
public long getConnectionCount_Alive_30_60_Seconds() {
long count = this.getConnectionStat().getCount_Alive_30_60_Seconds();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 30 * SECOND && connectionAliveNano < 60 * SECOND) {
return count;
public long getConnectionCount_Alive_1_5_Minutes() {
long count = this.getConnectionStat().getCount_Alive_1_5_Minutes();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 1 * MINUTE && connectionAliveNano < 5 * MINUTE) {
return count;
public long getConnectionCount_Alive_5_10_Minutes() {
long count = this.getConnectionStat().getCount_Alive_5_10_Minutes();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 5 * MINUTE && connectionAliveNano < 10 * MINUTE) {
return count;
public long getConnectionCount_Alive_10_30_Minutes() {
long count = this.getConnectionStat().getCount_Alive_10_30_Minutes();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 10 * MINUTE && connectionAliveNano < 30 * MINUTE) {
return count;
public long getConnectionCount_Alive_30_60_Minutes() {
long count = this.getConnectionStat().getCount_Alive_30_60_Minutes();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 30 * MINUTE && connectionAliveNano < 60 * MINUTE) {
return count;
public long getConnectionCount_Alive_1_3_Hours() {
long count = this.getConnectionStat().getCount_Alive_1_3_Hours();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 1 * HOUR && connectionAliveNano < 3 * HOUR) {
return count;
public long getConnectionCount_Alive_3_6_Hours() {
long count = this.getConnectionStat().getCount_Alive_3_6_Hours();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 3 * HOUR && connectionAliveNano < 6 * HOUR) {
return count;
public long getConnectionCount_Alive_6_12_Hours() {
long count = this.getConnectionStat().getCount_Alive_6_12_Hours();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 6 * HOUR && connectionAliveNano < 12 * HOUR) {
return count;
public long getConnectionCount_Alive_12_24_Hours() {
long count = this.getConnectionStat().getCount_Alive_12_24_Hours();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 12 * HOUR && connectionAliveNano < 24 * HOUR) {
return count;
public long getConnectionCount_Alive_1_3_Day() {
long count = this.getConnectionStat().getCount_Alive_1_3_Day();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 1 * DAY && connectionAliveNano < 2 * DAY) {
return count;
public long getConnectionCount_Alive_3_more_Day() {
long count = this.getConnectionStat().getCount_Alive_3_more_Day();
long nowNano = System.nanoTime();
for (JdbcConnectionStat.Entry connection : connections.values()) {
long connectionAliveNano = nowNano - connection.getEstablishNano();
if (connectionAliveNano >= 2 * DAY) {
return count;
, SimpleType.LONG, SimpleType.DATE, SimpleType.LONG, SimpleType.LONG 
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
String[] indexNames = { "ID", "URL", "Name", "FilterClasses", "CreatedTime", 
"RawUrl", "RawDriverClassName", "RawDriverMajorVersion", "RawDriverMinorVersion", "Properties" 
, "ConnectionActiveCount", "ConnectionActiveCountMax", "ConnectionCloseCount", "ConnectionCommitCount", "ConnectionRollbackCount" 
, "ConnectionConnectLastTime", "ConnectionConnectErrorCount", "ConnectionConnectErrorLastTime", "ConnectionConnectErrorLastMessage", "ConnectionConnectErrorLastStackTrace" 
, "StatementCreateCount", "StatementPrepareCount", "StatementPreCallCount", "StatementExecuteCount", "StatementRunningCount" 
, "StatementConcurrentMax", "StatementCloseCount", "StatementErrorCount", "StatementLastErrorTime", "StatementLastErrorMessage" 
, "StatementLastErrorStackTrace", "StatementExecuteMillis", "ConnectionConnectingCount", "StatementExecuteLastTime", "ResultSetCloseCount" 
, "ResultSetOpenCount", "ResultSetOpenningCount", "ResultSetOpenningMax", "ResultSetFetchRowCount", "ResultSetLastOpenTime" 
, "ResultSetErrorCount", "ResultSetOpenningMillisTotal", "ResultSetLastErrorTime", "ResultSetLastErrorMessage", "ResultSetLastErrorStackTrace", "ConnectionConnectCount", "ConnectionErrorLastMessage", "ConnectionErrorLastStackTrace", "ConnectionConnectMillisTotal", "ConnectionConnectingCountMax" 
, "ConnectionConnectMillisMax", "ConnectionErrorLastTime", "ConnectionAliveMillisMax", "ConnectionAliveMillisMin" 
, "ConnectionCount_Alive_0_1_Seconds", "ConnectionCount_Alive_1_5_Seconds", "ConnectionCount_Alive_5_10_Seconds", "ConnectionCount_Alive_10_30_Seconds", "ConnectionCount_Alive_30_60_Seconds" 
, "ConnectionCount_Alive_1_5_Minutes", "ConnectionCount_Alive_5_10_Minutes", "ConnectionCount_Alive_10_30_Minutes", "ConnectionCount_Alive_30_60_Minutes", "ConnectionCount_Alive_1_3_Hours" 
, "ConnectionCount_Alive_3_6_Hours", "ConnectionCount_Alive_6_12_Hours", "ConnectionCount_Alive_12_24_Hours", "ConnectionCount_Alive_1_3_Day", "ConnectionCount_Alive_3_more_Day" 
map.put("ConnectionCount_Alive_1_6_Hours", stat.getConnectionCount_Alive_1_6_Hours());
map.put("ConnectionCount_Alive_6_24_Hours", stat.getConnectionCount_Alive_6_24_Hours());
map.put("ConnectionCount_Alive_1_7_Day", stat.getConnectionCount_Alive_1_7_day());
map.put("ConnectionCount_Alive_7_30_Day", stat.getConnectionCount_Alive_7_30_Day());
map.put("ConnectionCount_Alive_30_90_Day", stat.getConnectionCount_Alive_30_90_Day());
map.put("ConnectionCount_Alive_90_more_Day", stat.getConnectionCount_Alive_90_more_Day());
map.put("ConnectionCount_Alive_1_6_Hours", null);
map.put("ConnectionCount_Alive_6_24_Hours", null);
map.put("ConnectionCount_Alive_1_7_Day", null);
map.put("ConnectionCount_Alive_7_30_Day", null);
map.put("ConnectionCount_Alive_30_90_Day", null);
map.put("ConnectionCount_Alive_90_more_Day", null);
map.put("ConnectionCount_Alive_1_6_Hours", stat.getConnectionCount_Alive_1_6_Hours());
map.put("ConnectionCount_Alive_6_24_Hours", stat.getConnectionCount_Alive_6_24_Hours());
map.put("ConnectionCount_Alive_1_7_Day", stat.getConnectionCount_Alive_1_7_day());
map.put("ConnectionCount_Alive_7_30_Day", stat.getConnectionCount_Alive_7_30_Day());
map.put("ConnectionCount_Alive_30_90_Day", stat.getConnectionCount_Alive_30_90_Day());
map.put("ConnectionCount_Alive_90_more_Day", stat.getConnectionCount_Alive_90_more_Day());
map.put("ConnectionCount_Alive_1_6_Hours", null);
map.put("ConnectionCount_Alive_6_24_Hours", null);
map.put("ConnectionCount_Alive_1_7_Day", null);
map.put("ConnectionCount_Alive_7_30_Day", null);
map.put("ConnectionCount_Alive_30_90_Day", null);
map.put("ConnectionCount_Alive_90_more_Day", null);
private final AtomicLong    count_Alive_1_6_Hours     = new AtomicLong();
private final AtomicLong    count_Alive_6_24_Hours    = new AtomicLong();
private final AtomicLong    count_Alive_1_7_Day       = new AtomicLong();
private final AtomicLong    count_Alive_7_30_Day      = new AtomicLong();
private final AtomicLong    count_Alive_30_90_Day     = new AtomicLong();
private final AtomicLong    count_Alive_90_more_Day   = new AtomicLong();
count_Alive_1_6_Hours.set(0);
count_Alive_6_24_Hours.set(0);
count_Alive_1_7_Day.set(0);
count_Alive_7_30_Day.set(0);
count_Alive_30_90_Day.set(0);
count_Alive_90_more_Day.set(0);
count_Alive_1_6_Hours.incrementAndGet();
count_Alive_6_24_Hours.incrementAndGet();
} else if (aliveNano < 7 * DAY) {
count_Alive_1_7_Day.incrementAndGet();
} else if (aliveNano < 30 * DAY) {
count_Alive_7_30_Day.incrementAndGet();
} else if (aliveNano < 90 * DAY) {
count_Alive_30_90_Day.incrementAndGet();
count_Alive_90_more_Day.incrementAndGet();
private static String[] indexNames        = { "ID", "ConnectTime", "ConnectTimespan", "EstablishTime", "AliveTimespan", "LastSql", "LastError", "LastErrorTime", "ConnectStatckTrace", "LastStatementStackTrace", "DataSource" };
public long getCount_Alive_1_6_Hours() {
return count_Alive_1_6_Hours.get();
public long getCount_Alive_6_24_Hours() {
return count_Alive_6_24_Hours.get();
public long getCount_Alive_1_7_Day() {
return count_Alive_1_7_Day.get();
public long getCount_Alive_7_30_Day() {
return count_Alive_7_30_Day.get();
public long getCount_Alive_30_90_Day() {
return count_Alive_30_90_Day.get();
public long getCount_Alive_90_more_Day() {
return count_Alive_90_more_Day.get();
public long getConnectionCount_Alive_1_6_Hours() {
long count = this.getConnectionStat().getCount_Alive_1_6_Hours();
if (connectionAliveNano >= 1 * HOUR && connectionAliveNano < 6 * HOUR) {
public long getConnectionCount_Alive_6_24_Hours() {
long count = this.getConnectionStat().getCount_Alive_6_24_Hours();
if (connectionAliveNano >= 6 * HOUR && connectionAliveNano < 24 * HOUR) {
public long getConnectionCount_Alive_1_7_day() {
long count = this.getConnectionStat().getCount_Alive_1_7_Day();
if (connectionAliveNano >= 1 * DAY && connectionAliveNano < 7 * DAY) {
public long getConnectionCount_Alive_7_30_Day() {
long count = this.getConnectionStat().getCount_Alive_7_30_Day();
if (connectionAliveNano >= 7 * DAY && connectionAliveNano < 30 * DAY) {
public long getConnectionCount_Alive_30_90_Day() {
long count = this.getConnectionStat().getCount_Alive_30_90_Day();
if (connectionAliveNano >= 30 * DAY && connectionAliveNano < 90 * DAY) {
public long getConnectionCount_Alive_90_more_Day() {
long count = this.getConnectionStat().getCount_Alive_90_more_Day();
if (connectionAliveNano >= 90 * DAY) {
, "ConnectionCount_Alive_1_5_Minutes", "ConnectionCount_Alive_5_10_Minutes", "ConnectionCount_Alive_10_30_Minutes", "ConnectionCount_Alive_30_60_Minutes", "ConnectionCount_Alive_1_6_Hours" 
, "ConnectionCount_Alive_6_24_Hours", "ConnectionCount_Alive_1_7_Day", "ConnectionCount_Alive_7_30_Day", "ConnectionCount_Alive_30_90_Day", "ConnectionCount_Alive_90_more_Day" 
private final AtomicLong    closeCount       = new AtomicLong(0);  
private final AtomicInteger runningCount     = new AtomicInteger();
public void afterExecute(long nanoSpan) {
runningCount.decrementAndGet();
nanoTotal.addAndGet(nanoSpan);
map.put("StatementExecuteCount_0_1_Millis", stat.getStatementStat().getCount_0_1_Millis());
map.put("StatementExecuteCount_1_2_Millis", stat.getStatementStat().getCount_1_2_Millis());
map.put("StatementExecuteCount_2_5_Millis", stat.getStatementStat().getCount_2_5_Millis());
map.put("StatementExecuteCount_5_10_Millis", stat.getStatementStat().getCount_5_10_Millis());
map.put("StatementExecuteCount_10_20_Millis", stat.getStatementStat().getCount_10_20_Millis());
map.put("StatementExecuteCount_20_50_Millis", stat.getStatementStat().getCount_20_50_Millis());
map.put("StatementExecuteCount_50_100_Millis", stat.getStatementStat().getCount_50_100_Millis());
map.put("StatementExecuteCount_100_200_Millis", stat.getStatementStat().getCount_100_200_Millis());
map.put("StatementExecuteCount_200_500_Millis", stat.getStatementStat().getCount_200_500_Millis());
map.put("StatementExecuteCount_500_1000_Millis", stat.getStatementStat().getCount_500_1000_Millis());
map.put("StatementExecuteCount_1000_2000_Millis", stat.getStatementStat().getCount_1000_2000_Millis());
map.put("StatementExecuteCount_2000_5000_Millis", stat.getStatementStat().getCount_2000_5000_Millis());
map.put("StatementExecuteCount_5000_10000_Millis", stat.getStatementStat().getCount_5000_10000_Millis());
map.put("StatementExecuteCount_10000_20000_Millis", stat.getStatementStat().getCount_10000_20000_Millis());
map.put("StatementExecuteCount_20000_more_Millis", stat.getStatementStat().getCount_20000_more_Millis());
map.put("StatementExecuteCount_0_1_Millis", null);
map.put("StatementExecuteCount_1_2_Millis", null);
map.put("StatementExecuteCount_2_5_Millis", null);
map.put("StatementExecuteCount_5_10_Millis", null);
map.put("StatementExecuteCount_10_20_Millis", null);
map.put("StatementExecuteCount_20_50_Millis", null);
map.put("StatementExecuteCount_50_100_Millis", null);
map.put("StatementExecuteCount_100_200_Millis", null);
map.put("StatementExecuteCount_200_500_Millis", null);
map.put("StatementExecuteCount_500_1000_Millis", null);
map.put("StatementExecuteCount_1000_2000_Millis", null);
map.put("StatementExecuteCount_2000_5000_Millis", null);
map.put("StatementExecuteCount_5000_10000_Millis", null);
map.put("StatementExecuteCount_10000_20000_Millis", null);
map.put("StatementExecuteCount_20000_more_Millis", null);
map.put("StatementExecuteCount_0_1_Millis", stat.getStatementStat().getCount_0_1_Millis());
map.put("StatementExecuteCount_1_2_Millis", stat.getStatementStat().getCount_1_2_Millis());
map.put("StatementExecuteCount_2_5_Millis", stat.getStatementStat().getCount_2_5_Millis());
map.put("StatementExecuteCount_5_10_Millis", stat.getStatementStat().getCount_5_10_Millis());
map.put("StatementExecuteCount_10_20_Millis", stat.getStatementStat().getCount_10_20_Millis());
map.put("StatementExecuteCount_20_50_Millis", stat.getStatementStat().getCount_20_50_Millis());
map.put("StatementExecuteCount_50_100_Millis", stat.getStatementStat().getCount_50_100_Millis());
map.put("StatementExecuteCount_100_200_Millis", stat.getStatementStat().getCount_100_200_Millis());
map.put("StatementExecuteCount_200_500_Millis", stat.getStatementStat().getCount_200_500_Millis());
map.put("StatementExecuteCount_500_1000_Millis", stat.getStatementStat().getCount_500_1000_Millis());
map.put("StatementExecuteCount_1000_2000_Millis", stat.getStatementStat().getCount_1000_2000_Millis());
map.put("StatementExecuteCount_2000_5000_Millis", stat.getStatementStat().getCount_2000_5000_Millis());
map.put("StatementExecuteCount_5000_10000_Millis", stat.getStatementStat().getCount_5000_10000_Millis());
map.put("StatementExecuteCount_10000_20000_Millis", stat.getStatementStat().getCount_10000_20000_Millis());
map.put("StatementExecuteCount_20000_more_Millis", stat.getStatementStat().getCount_20000_more_Millis());
map.put("StatementExecuteCount_0_1_Millis", null);
map.put("StatementExecuteCount_1_2_Millis", null);
map.put("StatementExecuteCount_2_5_Millis", null);
map.put("StatementExecuteCount_5_10_Millis", null);
map.put("StatementExecuteCount_10_20_Millis", null);
map.put("StatementExecuteCount_20_50_Millis", null);
map.put("StatementExecuteCount_50_100_Millis", null);
map.put("StatementExecuteCount_100_200_Millis", null);
map.put("StatementExecuteCount_200_500_Millis", null);
map.put("StatementExecuteCount_500_1000_Millis", null);
map.put("StatementExecuteCount_1000_2000_Millis", null);
map.put("StatementExecuteCount_2000_5000_Millis", null);
map.put("StatementExecuteCount_5000_10000_Millis", null);
map.put("StatementExecuteCount_10000_20000_Millis", null);
map.put("StatementExecuteCount_20000_more_Millis", null);
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, "StatementExecuteCount_0_1_Millis", "StatementExecuteCount_1_2_Millis", "StatementExecuteCount_2_5_Millis", "StatementExecuteCount_5_10_Millis", "StatementExecuteCount_10_20_Millis"
, "StatementExecuteCount_20_50_Millis", "StatementExecuteCount_50_100_Millis", "StatementExecuteCount_100_200_Millis", "StatementExecuteCount_200_500_Millis", "StatementExecuteCount_500_1000_Millis"
, "StatementExecuteCount_1000_2000_Millis", "StatementExecuteCount_2000_5000_Millis", "StatementExecuteCount_5000_10000_Millis", "StatementExecuteCount_10000_20000_Millis", "StatementExecuteCount_20000_more_Millis"
private final AtomicLong    createCount       = new AtomicLong(0);  
private final AtomicLong    prepareCount      = new AtomicLong(0);  
private final AtomicLong    prepareCallCount  = new AtomicLong(0);  
private final AtomicLong    closeCount        = new AtomicLong(0);  
private final AtomicInteger runningCount      = new AtomicInteger();
private final AtomicInteger concurrentMax     = new AtomicInteger();
private final AtomicLong    count             = new AtomicLong();
private final AtomicLong    errorCount        = new AtomicLong();
private final AtomicLong    nanoTotal         = new AtomicLong();
private long                lastSampleTime    = 0;
private AtomicLong          count_0_1         = new AtomicLong();
private AtomicLong          count_1_2         = new AtomicLong();
private AtomicLong          count_2_5         = new AtomicLong();
private AtomicLong          count_5_10        = new AtomicLong();
private AtomicLong          count_10_20       = new AtomicLong();
private AtomicLong          count_20_50       = new AtomicLong();
private AtomicLong          count_50_100      = new AtomicLong();
private AtomicLong          count_100_200     = new AtomicLong();
private AtomicLong          count_200_500     = new AtomicLong();
private AtomicLong          count_500_1000    = new AtomicLong();
private AtomicLong          count_1000_2000   = new AtomicLong();
private AtomicLong          count_2000_5000   = new AtomicLong();
private AtomicLong          count_5000_10000  = new AtomicLong();
private AtomicLong          count_10000_20000 = new AtomicLong();
private AtomicLong          count_20000_more  = new AtomicLong();
count_0_1.set(0);
count_1_2.set(0);
count_2_5.set(0);
count_5_10.set(0);
count_10_20.set(0);
count_20_50.set(0);
count_50_100.set(0);
count_100_200.set(0);
count_200_500.set(0);
count_500_1000.set(0);
count_1000_2000.set(0);
count_2000_5000.set(0);
count_5000_10000.set(0);
count_10000_20000.set(0);
count_20000_more.set(0);
public void afterExecute(long nanoSpan) {
runningCount.decrementAndGet();
nanoTotal.addAndGet(nanoSpan);
final long MILLIS = 1000 * 100;
if (nanoSpan < MILLIS) {
count_0_1.incrementAndGet();
} else if (nanoSpan < 2 * MILLIS) {
count_1_2.incrementAndGet();
} else if (nanoSpan < 5 * MILLIS) {
count_2_5.incrementAndGet();
} else if (nanoSpan < 10 * MILLIS) {
count_5_10.incrementAndGet();
} else if (nanoSpan < 20 * MILLIS) {
count_10_20.incrementAndGet();
} else if (nanoSpan < 50 * MILLIS) {
count_20_50.incrementAndGet();
} else if (nanoSpan < 100 * MILLIS) {
count_50_100.incrementAndGet();
} else if (nanoSpan < 200 * MILLIS) {
count_100_200.incrementAndGet();
} else if (nanoSpan < 500 * MILLIS) {
count_200_500.incrementAndGet();
} else if (nanoSpan < 1000 * MILLIS) {
count_500_1000.incrementAndGet();
} else if (nanoSpan < 2000 * MILLIS) {
count_1000_2000.incrementAndGet();
} else if (nanoSpan < 5000 * MILLIS) {
count_2000_5000.incrementAndGet();
} else if (nanoSpan < 10000 * MILLIS) {
count_5000_10000.incrementAndGet();
} else if (nanoSpan < 20000 * MILLIS) {
count_10000_20000.incrementAndGet();
count_20000_more.incrementAndGet();
public long getCount_0_1_Millis() {
return count_0_1.get();
public long getCount_1_2_Millis() {
return count_1_2.get();
public long getCount_2_5_Millis() {
return count_2_5.get();
public long getCount_5_10_Millis() {
return count_5_10.get();
public long getCount_10_20_Millis() {
return count_10_20.get();
public long getCount_20_50_Millis() {
return count_20_50.get();
public long getCount_50_100_Millis() {
return count_50_100.get();
public long getCount_100_200_Millis() {
return count_100_200.get();
public long getCount_200_500_Millis() {
return count_200_500.get();
public long getCount_500_1000_Millis() {
return count_500_1000.get();
public long getCount_1000_2000_Millis() {
return count_1000_2000.get();
public long getCount_2000_5000_Millis() {
return count_2000_5000.get();
public long getCount_5000_10000_Millis() {
return count_5000_10000.get();
public long getCount_10000_20000_Millis() {
return count_10000_20000.get();
public long getCount_20000_more_Millis() {
return count_20000_more.get();
map.put("StatementExecuteCount_1_2_Seconds", stat.getStatementStat().getCount_1_2_Seconds());
map.put("StatementExecuteCount_2_5_Seconds", stat.getStatementStat().getCount_2_5_Seconds());
map.put("StatementExecuteCount_5_10_Seconds", stat.getStatementStat().getCount_5_10_Seconds());
map.put("StatementExecuteCount_10_30_Seconds", stat.getStatementStat().getCount_10_30_Seconds());
map.put("StatementExecuteCount_30_60_Seconds", stat.getStatementStat().getCount_30_60_Seconds());
map.put("StatementExecuteCount_1_2_Minutes", stat.getStatementStat().getCount_1_2_minutes());
map.put("StatementExecuteCount_2_5_Minutes", stat.getStatementStat().getCount_2_5_minutes());
map.put("StatementExecuteCount_5_10_Minutes", stat.getStatementStat().getCount_5_10_minutes());
map.put("StatementExecuteCount_10_30_Minutes", stat.getStatementStat().getCount_10_30_minutes());
map.put("StatementExecuteCount_30_more_Minutes", stat.getStatementStat().getCount_30_more_minutes());
map.put("StatementExecuteCount_1_2_Seconds", null);
map.put("StatementExecuteCount_2_5_Seconds", null);
map.put("StatementExecuteCount_5_10_Seconds", null);
map.put("StatementExecuteCount_10_30_Seconds", null);
map.put("StatementExecuteCount_30_60_Seconds", null);
map.put("StatementExecuteCount_1_2_Minutes", null);
map.put("StatementExecuteCount_2_5_Minutes", null);
map.put("StatementExecuteCount_5_10_Minutes", null);
map.put("StatementExecuteCount_10_30_Minutes", null);
map.put("StatementExecuteCount_30_more_Minutes", null);
map.put("StatementExecuteCount_1_2_Seconds", stat.getStatementStat().getCount_1_2_Seconds());
map.put("StatementExecuteCount_2_5_Seconds", stat.getStatementStat().getCount_2_5_Seconds());
map.put("StatementExecuteCount_5_10_Seconds", stat.getStatementStat().getCount_5_10_Seconds());
map.put("StatementExecuteCount_10_30_Seconds", stat.getStatementStat().getCount_10_30_Seconds());
map.put("StatementExecuteCount_30_60_Seconds", stat.getStatementStat().getCount_30_60_Seconds());
map.put("StatementExecuteCount_1_2_Minutes", stat.getStatementStat().getCount_1_2_minutes());
map.put("StatementExecuteCount_2_5_Minutes", stat.getStatementStat().getCount_2_5_minutes());
map.put("StatementExecuteCount_5_10_Minutes", stat.getStatementStat().getCount_5_10_minutes());
map.put("StatementExecuteCount_10_30_Minutes", stat.getStatementStat().getCount_10_30_minutes());
map.put("StatementExecuteCount_30_more_Minutes", stat.getStatementStat().getCount_30_more_minutes());
map.put("StatementExecuteCount_1_2_Seconds", null);
map.put("StatementExecuteCount_2_5_Seconds", null);
map.put("StatementExecuteCount_5_10_Seconds", null);
map.put("StatementExecuteCount_10_30_Seconds", null);
map.put("StatementExecuteCount_30_60_Seconds", null);
map.put("StatementExecuteCount_1_2_Minutes", null);
map.put("StatementExecuteCount_2_5_Minutes", null);
map.put("StatementExecuteCount_5_10_Minutes", null);
map.put("StatementExecuteCount_10_30_Minutes", null);
map.put("StatementExecuteCount_30_more_Minutes", null);
private AtomicLong          count_0_1_Millis             = new AtomicLong();
private AtomicLong          count_1_2_Millis             = new AtomicLong();
private AtomicLong          count_2_5_Millis             = new AtomicLong();
private AtomicLong          count_5_10_Millis            = new AtomicLong();
private AtomicLong          count_10_20_Millis           = new AtomicLong();
private AtomicLong          count_20_50_Millis           = new AtomicLong();
private AtomicLong          count_50_100_Millis          = new AtomicLong();
private AtomicLong          count_100_200_Millis         = new AtomicLong();
private AtomicLong          count_200_500_Millis         = new AtomicLong();
private AtomicLong          count_500_1000_Millis        = new AtomicLong();
private AtomicLong          count_1_2_Seconds       = new AtomicLong();
private AtomicLong          count_2_5_Seconds       = new AtomicLong();
private AtomicLong          count_5_10_Seconds      = new AtomicLong();
private AtomicLong          count_10_30_Seconds     = new AtomicLong();
private AtomicLong          count_30_60_Seconds     = new AtomicLong();
private AtomicLong          count_1_2_minutes     = new AtomicLong();
private AtomicLong          count_2_5_minutes     = new AtomicLong();
private AtomicLong          count_5_10_minutes    = new AtomicLong();
private AtomicLong          count_10_30_minutes   = new AtomicLong();
private AtomicLong          count_30_more_minutes = new AtomicLong();
count_0_1_Millis.set(0);
count_1_2_Millis.set(0);
count_2_5_Millis.set(0);
count_5_10_Millis.set(0);
count_10_20_Millis.set(0);
count_20_50_Millis.set(0);
count_50_100_Millis.set(0);
count_100_200_Millis.set(0);
count_200_500_Millis.set(0);
count_500_1000_Millis.set(0);
count_1_2_Seconds.set(0);
count_2_5_Seconds.set(0);
count_5_10_Seconds.set(0);
count_10_30_Seconds.set(0);
count_30_60_Seconds.set(0);
count_1_2_minutes.set(0);
count_2_5_minutes.set(0);
count_5_10_minutes.set(0);
count_10_30_minutes.set(0);
count_30_more_minutes.set(0);
final long MILLIS = 1000 * 1000;
final long SECOND = 1000 * MILLIS;
final long MINUTE = 60 * SECOND;
if (nanoSpan < MILLIS) {
count_0_1_Millis.incrementAndGet();
} else if (nanoSpan < 2 * MILLIS) {
count_1_2_Millis.incrementAndGet();
} else if (nanoSpan < 5 * MILLIS) {
count_2_5_Millis.incrementAndGet();
} else if (nanoSpan < 10 * MILLIS) {
count_5_10_Millis.incrementAndGet();
} else if (nanoSpan < 20 * MILLIS) {
count_10_20_Millis.incrementAndGet();
} else if (nanoSpan < 50 * MILLIS) {
count_20_50_Millis.incrementAndGet();
} else if (nanoSpan < 100 * MILLIS) {
count_50_100_Millis.incrementAndGet();
} else if (nanoSpan < 200 * MILLIS) {
count_100_200_Millis.incrementAndGet();
} else if (nanoSpan < 500 * MILLIS) {
count_200_500_Millis.incrementAndGet();
} else if (nanoSpan < 1000 * MILLIS) {
count_500_1000_Millis.incrementAndGet();
} else if (nanoSpan < 2 * SECOND) {
count_1_2_Seconds.incrementAndGet();
} else if (nanoSpan < 5 * SECOND) {
count_2_5_Seconds.incrementAndGet();
} else if (nanoSpan < 10 * SECOND) {
count_5_10_Seconds.incrementAndGet();
} else if (nanoSpan < 30 * SECOND) {
count_10_30_Seconds.incrementAndGet();
} else if (nanoSpan < 60 * SECOND) {
count_30_60_Seconds.incrementAndGet();
} else if (nanoSpan < 2 * MINUTE) {
count_1_2_minutes.incrementAndGet();
} else if (nanoSpan < 5 * MINUTE) {
count_2_5_minutes.incrementAndGet();
} else if (nanoSpan < 10 * MINUTE) {
count_5_10_minutes.incrementAndGet();
} else if (nanoSpan < 30 * MINUTE) {
count_10_30_minutes.incrementAndGet();
count_30_more_minutes.incrementAndGet();
public long getCount_0_1_Millis() {
return count_0_1_Millis.get();
public long getCount_1_2_Millis() {
return count_1_2_Millis.get();
public long getCount_2_5_Millis() {
return count_2_5_Millis.get();
public long getCount_5_10_Millis() {
return count_5_10_Millis.get();
public long getCount_10_20_Millis() {
return count_10_20_Millis.get();
public long getCount_20_50_Millis() {
return count_20_50_Millis.get();
public long getCount_50_100_Millis() {
return count_50_100_Millis.get();
public long getCount_100_200_Millis() {
return count_100_200_Millis.get();
public long getCount_200_500_Millis() {
return count_200_500_Millis.get();
public long getCount_500_1000_Millis() {
return count_500_1000_Millis.get();
public long getCount_1_2_Seconds() {
return count_1_2_Seconds.get();
public long getCount_2_5_Seconds() {
return count_2_5_Seconds.get();
public long getCount_5_10_Seconds() {
return count_5_10_Seconds.get();
public long getCount_10_30_Seconds() {
return count_10_30_Seconds.get();
public long getCount_30_60_Seconds() {
return count_30_60_Seconds.get();
public long getCount_1_2_minutes() {
return count_1_2_minutes.get();
public long getCount_2_5_minutes() {
return count_2_5_minutes.get();
public long getCount_5_10_minutes() {
return count_5_10_minutes.get();
public long getCount_10_30_minutes() {
return count_10_30_minutes.get();
public long getCount_30_more_minutes() {
return count_30_more_minutes.get();
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG  
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG  
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG  
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG  
String[] indexNames = { "ID", "DataSource", "SQL", "ExecuteCount", "ErrorCount" 
, "TotalTime", "LastTime", "MaxTimespan", "LastError", "EffectedRowCount" 
, "FetchRowCount", "MaxTimespanOccurTime", "BatchSizeMax", "BatchSizeTotal", "ConcurrentMax" 
, "RunningCount", "Name", "File" , "LastErrorMessage", "LastErrorClass" 
, "LastErrorStackTrace", "LastErrorTime", "DbType", "URL" 
, "ExecuteCount_0_1_Millis", "ExecuteCount_1_2_Millis", "ExecuteCount_2_5_Millis", "ExecuteCount_5_10_Millis", "ExecuteCount_10_20_Millis"
, "ExecuteCount_20_50_Millis", "ExecuteCount_50_100_Millis", "ExecuteCount_100_200_Millis", "ExecuteCount_200_500_Millis", "ExecuteCount_500_1000_Millis"
, "ExecuteCount_1_2_Seconds", "ExecuteCount_2_5_Seconds", "ExecuteCount_5_10_Seconds", "ExecuteCount_10_30_Seconds", "ExecuteCount_30_60_Seconds"
, "ExecuteCount_1_2_Minutes", "ExecuteCount_2_5_Minutes", "ExecuteCount_5_10_Minutes", "ExecuteCount_10_30_Minutes", "ExecuteCount_30_more_Minutes"
map.put("ExecuteCount_0_1_Millis", this.getCount_0_1_Millis());
map.put("ExecuteCount_1_2_Millis", this.getCount_1_2_Millis());
map.put("ExecuteCount_2_5_Millis", this.getCount_2_5_Millis());
map.put("ExecuteCount_5_10_Millis", this.getCount_5_10_Millis());
map.put("ExecuteCount_10_20_Millis", this.getCount_10_20_Millis());
map.put("ExecuteCount_20_50_Millis", this.getCount_20_50_Millis());
map.put("ExecuteCount_50_100_Millis", this.getCount_50_100_Millis());
map.put("ExecuteCount_100_200_Millis", this.getCount_100_200_Millis());
map.put("ExecuteCount_200_500_Millis", this.getCount_200_500_Millis());
map.put("ExecuteCount_500_1000_Millis", this.getCount_500_1000_Millis());
map.put("ExecuteCount_1_2_Seconds", this.getCount_1_2_Seconds());
map.put("ExecuteCount_2_5_Seconds", this.getCount_2_5_Seconds());
map.put("ExecuteCount_5_10_Seconds", this.getCount_5_10_Seconds());
map.put("ExecuteCount_10_30_Seconds", this.getCount_10_30_Seconds());
map.put("ExecuteCount_30_60_Seconds", this.getCount_30_60_Seconds());
map.put("ExecuteCount_1_2_Minutes", this.getCount_1_2_minutes());
map.put("ExecuteCount_2_5_Minutes", this.getCount_2_5_minutes());
map.put("ExecuteCount_5_10_Minutes", this.getCount_5_10_minutes());
map.put("ExecuteCount_10_30_Minutes", this.getCount_10_30_minutes());
map.put("ExecuteCount_30_more_Minutes", this.getCount_30_more_minutes());
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG 
, "StatementExecuteCount_1_2_Seconds", "StatementExecuteCount_2_5_Seconds", "StatementExecuteCount_5_10_Seconds", "StatementExecuteCount_10_30_Seconds", "StatementExecuteCount_30_60_Seconds"
, "StatementExecuteCount_1_2_Minutes", "StatementExecuteCount_2_5_Minutes", "StatementExecuteCount_5_10_Minutes", "StatementExecuteCount_10_30_Minutes", "StatementExecuteCount_30_more_Minutes"
private final AtomicLong    createCount           = new AtomicLong(0);  
private final AtomicLong    prepareCount          = new AtomicLong(0);  
private final AtomicLong    prepareCallCount      = new AtomicLong(0);  
private final AtomicLong    closeCount            = new AtomicLong(0);  
private final AtomicInteger runningCount          = new AtomicInteger();
private final AtomicInteger concurrentMax         = new AtomicInteger();
private final AtomicLong    count                 = new AtomicLong();
private final AtomicLong    errorCount            = new AtomicLong();
private final AtomicLong    nanoTotal             = new AtomicLong();
private long                lastSampleTime        = 0;
private AtomicLong          count_0_1_Millis             = new AtomicLong();
private AtomicLong          count_1_2_Millis             = new AtomicLong();
private AtomicLong          count_2_5_Millis             = new AtomicLong();
private AtomicLong          count_5_10_Millis            = new AtomicLong();
private AtomicLong          count_10_20_Millis           = new AtomicLong();
private AtomicLong          count_20_50_Millis           = new AtomicLong();
private AtomicLong          count_50_100_Millis          = new AtomicLong();
private AtomicLong          count_100_200_Millis         = new AtomicLong();
private AtomicLong          count_200_500_Millis         = new AtomicLong();
private AtomicLong          count_500_1000_Millis        = new AtomicLong();
private AtomicLong          count_1_2_Seconds       = new AtomicLong();
private AtomicLong          count_2_5_Seconds       = new AtomicLong();
private AtomicLong          count_5_10_Seconds      = new AtomicLong();
private AtomicLong          count_10_30_Seconds     = new AtomicLong();
private AtomicLong          count_30_60_Seconds     = new AtomicLong();
private AtomicLong          count_1_2_minutes     = new AtomicLong();
private AtomicLong          count_2_5_minutes     = new AtomicLong();
private AtomicLong          count_5_10_minutes    = new AtomicLong();
private AtomicLong          count_10_30_minutes   = new AtomicLong();
private AtomicLong          count_30_more_minutes = new AtomicLong();
count_0_1_Millis.set(0);
count_1_2_Millis.set(0);
count_2_5_Millis.set(0);
count_5_10_Millis.set(0);
count_10_20_Millis.set(0);
count_20_50_Millis.set(0);
count_50_100_Millis.set(0);
count_100_200_Millis.set(0);
count_200_500_Millis.set(0);
count_500_1000_Millis.set(0);
count_1_2_Seconds.set(0);
count_2_5_Seconds.set(0);
count_5_10_Seconds.set(0);
count_10_30_Seconds.set(0);
count_30_60_Seconds.set(0);
count_1_2_minutes.set(0);
count_2_5_minutes.set(0);
count_5_10_minutes.set(0);
count_10_30_minutes.set(0);
count_30_more_minutes.set(0);
final long MILLIS = 1000 * 1000;
final long SECOND = 1000 * MILLIS;
final long MINUTE = 60 * SECOND;
count_0_1_Millis.incrementAndGet();
count_1_2_Millis.incrementAndGet();
count_2_5_Millis.incrementAndGet();
count_5_10_Millis.incrementAndGet();
count_10_20_Millis.incrementAndGet();
count_20_50_Millis.incrementAndGet();
count_50_100_Millis.incrementAndGet();
count_100_200_Millis.incrementAndGet();
count_200_500_Millis.incrementAndGet();
count_500_1000_Millis.incrementAndGet();
} else if (nanoSpan < 2 * SECOND) {
count_1_2_Seconds.incrementAndGet();
} else if (nanoSpan < 5 * SECOND) {
count_2_5_Seconds.incrementAndGet();
} else if (nanoSpan < 10 * SECOND) {
count_5_10_Seconds.incrementAndGet();
} else if (nanoSpan < 30 * SECOND) {
count_10_30_Seconds.incrementAndGet();
} else if (nanoSpan < 60 * SECOND) {
count_30_60_Seconds.incrementAndGet();
} else if (nanoSpan < 2 * MINUTE) {
count_1_2_minutes.incrementAndGet();
} else if (nanoSpan < 5 * MINUTE) {
count_2_5_minutes.incrementAndGet();
} else if (nanoSpan < 10 * MINUTE) {
count_5_10_minutes.incrementAndGet();
} else if (nanoSpan < 30 * MINUTE) {
count_10_30_minutes.incrementAndGet();
count_30_more_minutes.incrementAndGet();
return count_0_1_Millis.get();
return count_1_2_Millis.get();
return count_2_5_Millis.get();
return count_5_10_Millis.get();
return count_10_20_Millis.get();
return count_20_50_Millis.get();
return count_50_100_Millis.get();
return count_100_200_Millis.get();
return count_200_500_Millis.get();
return count_500_1000_Millis.get();
public long getCount_1_2_Seconds() {
return count_1_2_Seconds.get();
public long getCount_2_5_Seconds() {
return count_2_5_Seconds.get();
public long getCount_5_10_Seconds() {
return count_5_10_Seconds.get();
public long getCount_10_30_Seconds() {
return count_10_30_Seconds.get();
public long getCount_30_60_Seconds() {
return count_30_60_Seconds.get();
public long getCount_1_2_minutes() {
return count_1_2_minutes.get();
public long getCount_2_5_minutes() {
return count_2_5_minutes.get();
public long getCount_5_10_minutes() {
return count_5_10_minutes.get();
public long getCount_10_30_minutes() {
return count_10_30_minutes.get();
public long getCount_30_more_minutes() {
return count_30_more_minutes.get();
for (Object item : JdbcStatManager.getInstance().getDataSourceList().values()) {
String text = JSON.toJSONString(item, SerializerFeature.UseISO8601DateFormat);
System.out.println(JSON.toJSONString(JSON.parseObject(text, TreeMap.class), true));
for (Object item : JdbcStatManager.getInstance().getSqlList().values()) {
public class TestOracle_DruidDataSource extends TestCase {
final int       LOOP_COUNT      = 1000 * 1;
final String SQL = "SELECT SYSDATE FROM DUAL";
final DruidDataSource dataSource = new DruidDataSource();
final int COUNT = 100;
final int THREAD_COUNT = 1000;
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);
for (int i = 0; i < THREAD_COUNT; ++i) {
Thread thread = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < COUNT; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(SQL);
rs.next();
rs.close();
stmt.close();
conn.close();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
thread.start();
startLatch.countDown();
endLatch.await();
final int COUNT = 100 * 100;
final int THREAD_COUNT = 10;
public class JakartaCommonsLoggingImpl implements com.alibaba.druid.logging.Log {
private Log log;
public JakartaCommonsLoggingImpl(Class clazz){
log = LogFactory.getLog(clazz);
public boolean isDebugEnabled() {
return log.isDebugEnabled();
public void error(String s, Throwable e) {
log.error(s, e);
public void error(String s) {
log.error(s);
public void debug(String s) {
log.debug(s);
public void warn(String s) {
log.warn(s);
public void warn(String s, Throwable e) {
log.warn(s, e);
"com.alibaba.druid.logging.JakartaCommonsLoggingImpl");
public JakartaCommonsLoggingImpl(Class<?> clazz){
boolean isEnable();
void setEnable(boolean enable);
Connection conn = dataSource.getConnection();
conn.close();
dataSource.setEnable(false);
SQLException error = null;
dataSource.getConnection();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
dataSource.setEnable(true);
Connection conn = dataSource.getConnection();
conn.close();
private int      minIdle         = 0;
private int      maxIdle         = 8;
private int      maxActive       = 8;
private String   validationQuery = "SELECT 1";
private boolean  testOnBorrow    = false;
public final int COUNT           = 1000 * 1;
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
dataSource.setMinIdle(minIdle);
dataSource.setMaxIdle(maxIdle);
dataSource.setTestOnBorrow(testOnBorrow);
dataSource.setMinIdle(minIdle);
dataSource.setMaxIdle(maxIdle);
dataSource.setTestOnBorrow(testOnBorrow);
dataSource.setMinConnectionsPerPartition(minIdle);
dataSource.setMaxConnectionsPerPartition(maxIdle);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.close();
stmt.close();
lineSeparator = "n"; 
private final static ConcurrentMap<String, DataSourceProxyImpl> proxyDataSources         = new ConcurrentHashMap<String, DataSourceProxyImpl>();
DataSourceProxy oldDataSource = proxyDataSources.putIfAbsent(url, newDataSource); 
if (oldDataSource == null) {
DriverManager.getConnection("jdbc:mock:aaa");
dataSource.setEnable(false);
SQLException error = null;
dataSource.getConnection();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
final int       LOOP_COUNT      = 1000 * 10;
if (validConnectionChecker != null) {
return validConnectionChecker.isValidConnection(conn);
private int     threadCount     = 40;
private int     loopCount       = 5;
final int       LOOP_COUNT      = 1000 * 10;
private boolean testOnBorrow    = false;
final int       LOOP_COUNT      = 1000 * 100;
private String  validationQuery = null; 
dataSource.setValidationQuery(validationQuery);
this.validConnectionChecker = null;
private String  validationQuery = "SELECT 1";
private boolean testOnBorrow    = true;
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
public long getIdelCheckCount() {
return idleCheckCount;
long getIdleCheckCount();
public long getIdleCheckCount() {
if (!closed) {
closed = true;
if (driver != null) {
driver.afterConnectionClose(this);
public final static MockExecuteHandler DEFAULT_HANDLER      = new MySqlMockExecuteHandlerImpl();
private String                         prefix               = "jdbc:fake:";
private String                         mockPrefix           = "jdbc:mock:";
private MockExecuteHandler             executeHandler       = DEFAULT_HANDLER;
private final static MockDriver        instance             = new MockDriver();
private final AtomicLong               connectCount         = new AtomicLong();
private final AtomicLong               connectionCloseCount = new AtomicLong();
protected void incrementConnectionCloseCount() {
connectionCloseCount.incrementAndGet();
public long getConnectionCloseCount() {
return connectionCloseCount.get();
protected void afterConnectionClose(MockConnection conn) {
connectionCloseCount.incrementAndGet();
connectCount.incrementAndGet();
connectCount.incrementAndGet();
connectCount.incrementAndGet();
public Properties getConnectProperties() {
public void setConnectProperties(Properties connectionProperties) {
Properties properties = dataSource.getConnectProperties();
this.info = new Properties(dataSource.getConnectProperties());
Assert.assertEquals(dataSource.getConnectProperties(), passwordCallback.getProperties());
private int     maxIdle              = 40;
private int     maxActive            = 50;
private int     maxWait              = -1;
private String  validationQuery      = null;                                                                                      
private int     threadCount          = 5;
private int     TEST_COUNT           = 3;
final int       LOOP_COUNT           = 1000 * 1000;
private boolean testOnBorrow         = false;
private String  connectionProperties = "bigStringTryClob=true;clientEncoding=GBK;defaultRowPrefetch=50;serverEncoding=ISO-8859-1";
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1");
while (rs.next()) {
rs.getInt(1);
rs.close();
stmt.close();
private JLabel                                  lbTestOnBorrow                = new JLabel("TestOnBorrow : ");
private JTextField                              txtTestOnBorrow               = new JTextField("false");
mainPanel.add(lbTestOnBorrow);
layout.putConstraint(SpringLayout.NORTH, lbTestOnBorrow, 10, SpringLayout.SOUTH, lbTestWhileIdle);
layout.putConstraint(SpringLayout.WEST, lbTestOnBorrow, 0, SpringLayout.WEST, lbUrl);
layout.putConstraint(SpringLayout.EAST, lbTestOnBorrow, 0, SpringLayout.EAST, lbUrl);
mainPanel.add(txtTestOnBorrow);
layout.putConstraint(SpringLayout.VERTICAL_CENTER, txtTestOnBorrow, 0, SpringLayout.VERTICAL_CENTER, lbTestOnBorrow);
layout.putConstraint(SpringLayout.WEST, txtTestOnBorrow, 0, SpringLayout.WEST, txtUrl);
layout.putConstraint(SpringLayout.EAST, txtTestOnBorrow, 0, SpringLayout.EAST, txtUrl);
layout.putConstraint(SpringLayout.NORTH, btnInitDataSource, 10, SpringLayout.SOUTH, lbTestOnBorrow);
Statement stmt = conn.createStatement();
stmt.setQueryTimeout(5);
ResultSet rs = stmt.executeQuery("SELECT * FROM address LIMIT 10");
while (rs.next()) {
rs.getObject(1);
rs.close();
stmt.close();
dataSource.setTestOnBorrow(Boolean.parseBoolean(txtTestOnBorrow.getText().trim()));
this.connectionProperties.clear();
private int     threadCount          = 40;
final int       LOOP_COUNT           = 1000 * 10;
private String  connectionProperties = ""; 
private String  sql                  = "SELECT 1";
ResultSet rs = stmt.executeQuery(sql);
private int     threadCount          = 10;
final int       LOOP_COUNT           = 1000 * 100;
private int     threadCount          = 40;
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
if (count >= maxIdle) {
lock.lock();
JdbcUtils.close(conn);
destroyCount++;
closeCount++;
decrementActiveCount();
} finally {
lock.unlock();
if (count == 0) {
final int       LOOP_COUNT           = 1000 * 1;
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
private JButton                                 btnCase_0                     = new JButton("Case 0");
btnCase_0.setEnabled(false);
mainPanel.add(btnCase_0);
layout.putConstraint(SpringLayout.VERTICAL_CENTER, btnCase_0, 0, SpringLayout.VERTICAL_CENTER, txtReleaseStep);
layout.putConstraint(SpringLayout.WEST, btnCase_0, 10, SpringLayout.EAST, txtReleaseStep);
btnCase_0.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
} catch (Exception e1) {
e1.printStackTrace();
btnCase_0.setEnabled(false);
btnCase_0.setEnabled(true);
public void case_0() throws Exception {
Runnable task = new Runnable() {
public void run() {
final int threadCount = 40;
final int LOOP_COUNT = 1000 * 1000;
final String sql = "SELECT 1";
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(1);
for (int i = 0; i < threadCount; ++i) {
Thread thread = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < LOOP_COUNT; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
while (rs.next()) {
rs.getInt(1);
rs.close();
stmt.close();
conn.close();
} catch (Exception ex) {
ex.printStackTrace();
endLatch.countDown();
thread.start();
long startMillis = System.currentTimeMillis();
long startYGC = TestUtil.getYoungGC();
long startFullGC = TestUtil.getFullGC();
startLatch.countDown();
endLatch.await();
} catch (InterruptedException e) {
e.printStackTrace();
long millis = System.currentTimeMillis() - startMillis;
long ygc = TestUtil.getYoungGC() - startYGC;
long fullGC = TestUtil.getFullGC() - startFullGC;
System.out.println("thread " + threadCount + " druid millis : " + NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC);
executor.submit(task);
final int       LOOP_COUNT           = 1000 * 10;
private boolean testOnBorrow         = true;
private int     maxActive            = 40;
private int     maxWait              = 500;
private String  validationQuery      = "SELECT 1";                                                                                      
private boolean testOnBorrow         = false;
private int     maxWait              = -1;
private int     minIdle              = 10;
dataSource.setMinIdle(minIdle);
dataSource.setMinIdle(minIdle);
private int     threadCount          = 10;
private int     initialSize          = 1;
private int     minIdle              = 1;
private int     maxIdle              = 14;
private int     maxActive            = 14;
private String  validationQuery      = "SELECT 1"; 
private String  connectionProperties = "";        
dataSource.setInitialSize(initialSize);
dataSource.setInitialSize(initialSize);
private Properties connectProperties;
public MockConnection(){
this(null);
this(driver, new Properties());
public MockConnection(MockDriver driver, Properties connectProperties){
this.connectProperties = connectProperties;
public Properties getConnectProperties() {
return connectProperties;
if (info != null) {
Object val = info.get("connectSleep");
if (val != null) {
long millis = Long.parseLong(val.toString());
Thread.sleep(millis);
} catch (InterruptedException e) {
MockConnection conn = new MockConnection(this, info);
MockConnection conn = stmt.getMockConnection();
if (conn != null) {
if (conn.getConnectProperties() != null) {
Object propertyValue = conn.getConnectProperties().get("executeSleep");
if (propertyValue != null) {
long millis = Long.parseLong(propertyValue.toString());
Thread.sleep(millis);
} catch (InterruptedException e) {
if (mockConnection != null && mockConnection.getDriver() != null) {
return mockConnection.getDriver().createResultSet(this);
protected MockConnection   mockConnection;
mockConnection = (MockConnection) connection;
public MockConnection getMockConnection() {
return mockConnection;
this.mockConnection = fakeConnection;
if (mockConnection != null && mockConnection.getDriver() != null) {
return mockConnection.getDriver().executeQuery(this, sql);
final int       LOOP_COUNT           = 1000 * 1;
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
connectionProperties = "connectSleep=3;executeSleep=1";
final int threadCount = 10;
private int     initialSize                   = 1;
private int     minIdle                       = 1;
private int     maxIdle                       = 14;
private int     maxActive                     = 14;
private int     maxWait                       = -1;
private String  validationQuery               = "SELECT 1"; 
private int     threadCount                   = 1;
private int     TEST_COUNT                    = 3;
final int       LOOP_COUNT                    = 1000 * 10;
private boolean testOnBorrow                  = false;
private String  connectionProperties          = "";        
private String  sql                           = "SELECT 1";
private long    timeBetweenEvictionRunsMillis = 60000;
private long    minEvictableIdleTimeMillis    = 60000;
connectionProperties = "connectSleep=3;executeSleep=0";
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
public void boneCP() throws Exception {
BoneCPDataSource dataSource = new BoneCPDataSource();
dataSource.setMinConnectionsPerPartition(minIdle);
dataSource.setMaxConnectionsPerPartition(maxIdle);
dataSource.setDriverClass(driverClass);
dataSource.setJdbcUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setConnectionTestStatement(validationQuery);
dataSource.setPartitionCount(1);
Properties connectionProperties = new Properties();
connectionProperties.put("connectSleep", "3");
connectionProperties.put("executeSleep", "1");
dataSource.setDriverProperties(connectionProperties);
for (int i = 0; i < TEST_COUNT; ++i) {
p0(dataSource, "boneCP", threadCount);
System.out.println();
dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
final int LOOP_COUNT = 1000 * 100;
final int       LOOP_COUNT                    = 1000 * 100;
private int     threadCount                   = 10;
final int       LOOP_COUNT                    = 1000 * 10;
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
final AtomicInteger count = new AtomicInteger();
System.out.println("thread " + threadCount + " " + name + " millis : " + NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC + ", TX " + count.get());
count.incrementAndGet();
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
final AtomicInteger errorCount = new AtomicInteger();
} catch (Throwable ex) {
errorCount.incrementAndGet();
} finally {
endLatch.countDown();
Thread.sleep(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
driverClass = "com.mysql.jdbc.Driver";
final CountDownLatch endLatch = new CountDownLatch(threadCount);
Assert.assertEquals(LOOP_COUNT * threadCount, count.get());
System.out.println("thread " + threadCount + " " + name + " millis : " + NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
public String toString() {
return clob.toString();
public class DruidLobCreator implements LobCreator {
public void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte[] content) throws SQLException {
Blob blob = ps.getConnection().createBlob();
blob.setBytes(1, content);
ps.setBlob(paramIndex, blob);
public void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, InputStream contentStream, int contentLength) throws SQLException {
ps.setBlob(paramIndex, contentStream, contentLength);
public void setClobAsString(PreparedStatement ps, int paramIndex, String content) throws SQLException {
Clob clob = ps.getConnection().createClob();
clob.setString(1, content);
ps.setClob(paramIndex, clob);
public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, InputStream asciiStream, int contentLength) throws SQLException {
if (asciiStream != null) {
Clob clob = ps.getConnection().createClob();
OutputStream out = clob.setAsciiStream(1);
final int BUFFER_SIZE = 4096;
int byteCount = 0;
byte[] buffer = new byte[BUFFER_SIZE];
int bytesRead = -1;
while ((bytesRead = asciiStream.read(buffer)) != -1) {
out.write(buffer, 0, bytesRead);
byteCount += bytesRead;
out.flush();
} catch (Exception e) {
throw new SQLException("setClob error", e);
} finally {
JdbcUtils.close(asciiStream);
JdbcUtils.close(out);
ps.setClob(paramIndex, clob);
ps.setClob(paramIndex, (Clob) null);
public void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, Reader characterStream, int contentLength) throws SQLException {
ps.setClob(paramIndex, characterStream, contentLength);
public void close() {
public class DruidLobHandler extends AbstractLobHandler {
public byte[] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException {
Blob blob = rs.getBlob(columnIndex);
if (blob == null) {
return null;
return blob.getBytes(1, (int) blob.length());
public InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {
Blob blob = rs.getBlob(columnIndex);
if (blob == null) {
return null;
return blob.getBinaryStream();
public String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {
Clob clob = rs.getClob(columnIndex);
if (clob == null) {
return null;
return clob.getSubString(1, (int) clob.length());
public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {
Clob clob = rs.getClob(columnIndex);
if (clob == null) {
return null;
return clob.getAsciiStream();
public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {
Clob clob = rs.getClob(columnIndex);
if (clob == null) {
return null;
return clob.getCharacterStream();
public LobCreator getLobCreator() {
return new DruidLobCreator();
boolean validate = testConnection(poolalbeConnection.getConnection());
public CallableStatement getCallableStatementRaw() {
return stmt;
public class DruidNativeJdbcExtractor implements NativeJdbcExtractor {
public boolean isNativeConnectionNecessaryForNativeStatements() {
return true;
public boolean isNativeConnectionNecessaryForNativePreparedStatements() {
return true;
public boolean isNativeConnectionNecessaryForNativeCallableStatements() {
return true;
public Connection getNativeConnection(Connection conn) throws SQLException {
if (conn instanceof PoolableConnection) {
conn = ((PoolableConnection) conn).getConnection();
if (conn instanceof ConnectionProxy) {
conn = ((ConnectionProxy) conn).getConnectionRaw();
return conn;
public Connection getNativeConnectionFromStatement(Statement stmt) throws SQLException {
Connection conn = stmt.getConnection();
return getNativeConnection(conn);
public Statement getNativeStatement(Statement stmt) throws SQLException {
if (stmt instanceof PoolableStatement) {
stmt = ((PoolableStatement) stmt).getStatement();
if (stmt instanceof StatementProxy) {
stmt = ((StatementProxy) stmt).getStatementRaw();
return stmt;
public PreparedStatement getNativePreparedStatement(PreparedStatement stmt) throws SQLException {
if (stmt instanceof PoolablePreparedStatement) {
stmt = ((PoolablePreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof PreparedStatementProxy) {
stmt = ((PreparedStatementProxy) stmt).getRawPreparedStatement();
return stmt;
public CallableStatement getNativeCallableStatement(CallableStatement stmt) throws SQLException {
if (stmt instanceof PoolableCallableStatement) {
stmt = ((PoolableCallableStatement) stmt).getCallableStatementRaw();
if (stmt instanceof CallableStatementProxy) {
stmt = ((CallableStatementProxy) stmt).getRawCallableStatement();
return stmt;
public ResultSet getNativeResultSet(ResultSet rs) throws SQLException {
if (rs instanceof PoolableResultSet) {
rs = ((PoolableResultSet) rs).getRawResultSet();
if (rs instanceof ResultSetProxy) {
rs = ((ResultSetProxy) rs).getResultSetRaw();
return rs;
ResultSet rawResultSet = result.getResultSetRaw();
ResultSetMetaData metadata = rawResultSet.getMetaData();
int columnType = metadata.getColumnType(columnIndex);
Object value = null;
switch (columnType) {
case Types.CH
value = super.resultSet_getString(chain, result, columnIndex);
case Types.CLOB
value = super.resultSet_getString(chain, result, columnIndex);
case Types.LONGVARCH
value = super.resultSet_getString(chain, result, columnIndex);
case Types.VARCH
value = super.resultSet_getString(chain, result, columnIndex);
value = super.resultSet_getObject(chain, result, columnIndex);
Assert.assertEquals(1, stat.getActiveMax());
Assert.assertEquals(2, stat.getActiveMax());
Assert.assertEquals(0L, row.get("ExecuteCount_30_more_Minutes"));
manager.setSize(820, 580);
int w = (Toolkit.getDefaultToolkit().getScreenSize().width - manager.getWidth()) / 2;
int h = (Toolkit.getDefaultToolkit().getScreenSize().height - manager.getHeight()) / 2;
manager.setLocation(w, h);
ResultSet rawResultSet = result.getResultSetRaw();
ResultSetMetaData metadata = rawResultSet.getMetaData();
int columnType = metadata.getColumnType(columnIndex);
Object value = null;
switch (columnType) {
case Types.CH
value = super.resultSet_getString(chain, result, columnIndex);
case Types.CLOB
value = super.resultSet_getString(chain, result, columnIndex);
case Types.LONGVARCH
value = super.resultSet_getString(chain, result, columnIndex);
case Types.VARCH
value = super.resultSet_getString(chain, result, columnIndex);
value = super.resultSet_getObject(chain, result, columnIndex, map);
ResultSet rawResultSet = result.getResultSetRaw();
ResultSetMetaData metadata = rawResultSet.getMetaData();
int columnIndex = rawResultSet.findColumn(columnLabel);
int columnType = metadata.getColumnType(columnIndex);
Object value = null;
switch (columnType) {
case Types.CH
value = super.resultSet_getString(chain, result, columnLabel);
case Types.CLOB
value = super.resultSet_getString(chain, result, columnLabel);
case Types.LONGVARCH
value = super.resultSet_getString(chain, result, columnLabel);
case Types.VARCH
value = super.resultSet_getString(chain, result, columnLabel);
value = super.resultSet_getObject(chain, result, columnLabel);
ResultSet rawResultSet = result.getResultSetRaw();
ResultSetMetaData metadata = rawResultSet.getMetaData();
int columnIndex = rawResultSet.findColumn(columnLabel);
int columnType = metadata.getColumnType(columnIndex);
Object value = null;
switch (columnType) {
case Types.CH
value = super.resultSet_getString(chain, result, columnLabel);
case Types.CLOB
value = super.resultSet_getString(chain, result, columnLabel);
case Types.LONGVARCH
value = super.resultSet_getString(chain, result, columnLabel);
case Types.VARCH
value = super.resultSet_getString(chain, result, columnLabel);
value = super.resultSet_getObject(chain, result, columnLabel, map);
public class Test_kyline extends TestCase {
private String url      = "jdbc:mysql:
private String user     = "root";
private String password = "12345";
private String driver = "com.mysql.jdbc.Driver";
public void test_0() throws Exception {
DruidDataSource ds = new DruidDataSource();
ds.setUrl(url);
ds.setUsername(user);
ds.setPassword(password);
ds.setDriverClassName(driver);
Connection conn = ds.getConnection();
conn.close();
ds.close();
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(true, rs.isClosed());
if (!this.closed) {
clearResultSet();
stmt.close();
this.closed = true;
conn.getConnectionHolder().removeTrace(this);
rs.close();
stmt.close();
Connection conn = dataSource.getConnection();
connectCount.incrementAndGet();
conn.close();
closeCount.incrementAndGet();
} catch (Exception ex) {
ex.printStackTrace();
return dataSource.getProxyFilters();
for (Filter filter : dataSource.getProxyFilters()) {
public List<Filter> getProxyFilters() {
public void setProxyFilters(List<Filter> filters) {
if (dataSource.getProxyFilters().size() != 0) {
List<Filter> filterConfigList = getProxyFilters();
for (Filter filter : this.getProxyFilters()) {
List<Filter> getProxyFilters();
public List<Filter> getProxyFilters() {
for (Filter filter : this.getProxyFilters()) {
for (Filter filter : dataSource.getProxyFilters()) {
Assert.assertEquals(0, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(0, dataSource.getProxyFilters().size());
Assert.assertEquals(2, dataSource.getProxyFilters().size());
Assert.assertEquals(0, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(0, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(0, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(1, dataSource_1.getProxyFilters().size());
Assert.assertEquals(1, dataSource_2.getProxyFilters().size());
Assert.assertEquals(1, dataSource_3.getProxyFilters().size());
dataSource_4.getProxyFilters().toString();
Assert.assertEquals(1, dataSource_4.getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(0, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(1, conn.getDirectDataSource().getProxyFilters().size());
Assert.assertEquals(4, dataSource.getProxyFilters().size());
final int       LOOP_COUNT                    = 1000 * 1000;
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
public class DruidException extends Exception {
private static final long serialVersionUID = 1L;
public DruidException(){
public DruidException(String message, Throwable cause){
super(message, cause);
public DruidException(String message){
super(message);
public DruidException(Throwable cause){
super(cause);
public class DruidRuntimeException extends RuntimeException {
private static final long serialVersionUID = 1L;
public DruidRuntimeException(){
public DruidRuntimeException(String message, Throwable cause){
super(message, cause);
public DruidRuntimeException(String message){
super(message);
public DruidRuntimeException(Throwable cause){
super(cause);
public class SQLParseException extends DruidRuntimeException {
private final static Log LOG = LogFactory.getLog(JdbcUtils.class);
LOG.error("load druid-driver.properties error", e);
} catch (Exception e) {
LOG.error("close connection error", e);
} catch (Exception e) {
LOG.error("close statement error", e);
} catch (Exception e) {
LOG.error("close resultset error", e);
} catch (Exception e) {
LOG.error("close error", e);
private final static Log                               LOG      = LogFactory.getLog(FilterManager.class);
} catch (Exception e) {
LOG.error("load filter config error", e);
map.put("ConnectionConnectErrorLastStackTrace", JdbcUtils.getStackTrace(lastConnectionConnectError));
map.put("StatementLastErrorStackTrace", JdbcUtils.getStackTrace(lastStatementError));
map.put("ResultSetLastErrorStackTrace", JdbcUtils.getStackTrace(lastResultSetError));
map.put("ConnectionErrorLastStackTrace", JdbcUtils.getStackTrace(lastConnectionError));
map.put("ConnectionConnectErrorLastStackTrace", JdbcUtils.getStackTrace(lastConnectionConnectError));
map.put("StatementLastErrorStackTrace", JdbcUtils.getStackTrace(lastStatementError));
map.put("ResultSetLastErrorStackTrace", JdbcUtils.getStackTrace(lastResultSetError));
map.put("ConnectionErrorLastStackTrace", JdbcUtils.getStackTrace(lastConnectionError));
map.put("LastErrorStackTrace", JdbcUtils.getStackTrace(lastError));
THROWABLE_COMPOSITE_TYPE = new CompositeType("Throwable", "Throwable", THROWABLE_COMPOSITE_INDEX_NAMES, THROWABLE_COMPOSITE_INDEX_DESCRIPTIONS, THROWABLE_COMPOSITE_INDEX_TYPES);
map.put("stackTrace", JdbcUtils.getStackTrace(error));
private final static Log        LOG              = LogFactory.getLog(JdbcUtils.class);
public static String getStackTrace(Throwable ex) {
StringWriter buf = new StringWriter();
ex.printStackTrace(new PrintWriter(buf));
return buf.toString();
private int                         loginTimeout = 0;
private PrintWriter                 logWriter    = new PrintWriter(System.out);
private AtomicInteger                  requestCount        = new AtomicInteger();
int requestNumber = requestCount.getAndIncrement();
int size = dataSources.size();
int index = requestNumber % size;
DruidDataSource dataSource = dataSources.get(index);
return dataSource.getConnection();
private AtomicInteger               requestCount = new AtomicInteger();
Connection conn = dataSource.getConnection();
return conn;
public class HADataSource extends MultiDataSource implements DataSource {
private AtomicInteger requestCount = new AtomicInteger();
public abstract class MultiDataSource implements DataSource {
protected final List<DruidDataSource> dataSources  = new CopyOnWriteArrayList<DruidDataSource>();
private int                           loginTimeout = 0;
private PrintWriter                   logWriter    = new PrintWriter(System.out);
public List<DruidDataSource> getDataSources() {
return dataSources;
public PrintWriter getLogWriter() throws SQLException {
return logWriter;
public void setLogWriter(PrintWriter out) throws SQLException {
this.logWriter = out;
public void setLoginTimeout(int seconds) throws SQLException {
loginTimeout = seconds;
public int getLoginTimeout() throws SQLException {
return loginTimeout;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
return false;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
return null;
public Connection getConnection(String username, String password) throws SQLException {
throw new UnsupportedOperationException();
private final static Log              LOG                     = LogFactory.getLog(HADataSource.class);
private AtomicInteger                 requestCount            = new AtomicInteger();
protected final List<DruidDataSource> notAvailableDatasources = new CopyOnWriteArrayList<DruidDataSource>();
public HADataSource() {
super(new ArrayList<DruidDataSource>());
int requestNumber = requestCount.getAndIncrement();
if (!dataSource.isEnable()) {
boolean removed = dataSources.remove(dataSource);
if (removed) {
notAvailableDatasources.add(dataSource);
protected final List<DruidDataSource> dataSources;
public MultiDataSource() {
dataSources  = new CopyOnWriteArrayList<DruidDataSource>();
public MultiDataSource(List<DruidDataSource> dataSources) {
this.dataSources  = dataSources;
public void debug(String s, Throwable e) {
log.debug(s, e);
public void debug(String s, Throwable e) {
log.log(Level.FINE, s, e);
public void debug(String s, Throwable e);
public void debug(String s, Throwable e) {
log.debug(s, e);
public void debug(String s, Throwable e) {
public class DataSourceAdapter implements DataSource {
private int         loginTimeout = 0;
private PrintWriter logWriter    = new PrintWriter(System.out);
public DataSourceAdapter(){
public PrintWriter getLogWriter() throws SQLException {
return logWriter;
public void setLogWriter(PrintWriter out) throws SQLException {
this.logWriter = out;
public void setLoginTimeout(int seconds) throws SQLException {
loginTimeout = seconds;
public int getLoginTimeout() throws SQLException {
return loginTimeout;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
return false;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
return null;
public Connection getConnection() throws SQLException {
throw new UnsupportedOperationException();
public Connection getConnection(String username, String password) throws SQLException {
throw new UnsupportedOperationException();
private final AtomicInteger           requestCount            = new AtomicInteger();
private final AtomicInteger           indexErrorCount         = new AtomicInteger();
public HADataSource(){
if (size == 0) {
throw new SQLException("can not get connection, no availabe datasources");
DruidDataSource dataSource = null;
dataSource = dataSources.get(index);
} catch (Exception ex) {
indexErrorCount.incrementAndGet();
if (LOG.isDebugEnabled()) {
LOG.debug("getDataSource error, index : " + index, ex);
assert dataSource != null;
public long getIndexErrorCount() {
return indexErrorCount.get();
public abstract class MultiDataSource extends DataSourceAdapter {
protected ArrayList<DruidDataSource> dataSources;
public MultiDataSource(){
dataSources = new ArrayList<DruidDataSource>();
public Connection getConnection() throws SQLException {
handleNotAwailableDatasource(dataSource);
void handleNotAwailableDatasource(DruidDataSource dataSource) {
boolean removed = dataSources.remove(dataSource);
if (removed) {
notAvailableDatasources.add(dataSource);
public List<DruidDataSource> getDataSources() {
return Collections.unmodifiableList(dataSources);
public void setDataSources(List<DruidDataSource> dataSources) {
this.dataSources = new ArrayList<DruidDataSource>(dataSources);;
public abstract Connection getConnection() throws SQLException;
public class DataSourceAdapter extends WrapperAdapter implements DataSource {
public class WrapperAdapter implements Wrapper {
public WrapperAdapter(){
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
return false;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
return null;
public class HAConnection extends WrapperAdapter implements Connection, ConnectionProxy {
private final HADataSource    haDataSource;
private Connection            conn;
private final int             id;
private Boolean               autoCommit       = null;
private Boolean               readOnly         = null;
private String                catalog          = null;
private Integer               transactionLeval = null;
private Map<String, Class<?>> typeMap          = null;
private Integer               holdability      = null;
private Properties            clientInfo       = null;
private Map<String, Object>   attributes       = null;
private Date                  connectedTime    = new Date();
public HAConnection(HADataSource haDataSource, int id){
this.haDataSource = haDataSource;
this.id = id;
public HADataSource getHaDataSource() {
return haDataSource;
private void checkConnection(String sql) throws SQLException {
if (conn == null) {
conn = haDataSource.getConnectionInternal(id);
public String nativeSQL(String sql) throws SQLException {
checkConnection(sql);
return conn.nativeSQL(sql);
public void setAutoCommit(boolean autoCommit) throws SQLException {
if (conn != null) {
conn.setAutoCommit(autoCommit);
this.autoCommit = Boolean.valueOf(autoCommit);
public boolean getAutoCommit() throws SQLException {
if (conn != null) {
return conn.getAutoCommit();
if (this.autoCommit != null) {
return this.autoCommit.booleanValue();
return false;
public void commit() throws SQLException {
if (conn != null) {
conn.commit();
public void rollback() throws SQLException {
if (conn != null) {
conn.rollback();
public void close() throws SQLException {
if (conn != null) {
conn.close();
public boolean isClosed() throws SQLException {
if (conn != null) {
return conn.isClosed();
return false;
public DatabaseMetaData getMetaData() throws SQLException {
if (conn != null) {
return conn.getMetaData();
throw new SQLException("connection not init");
public void setReadOnly(boolean readOnly) throws SQLException {
if (conn != null) {
conn.setReadOnly(readOnly);
this.readOnly = Boolean.valueOf(readOnly);
public boolean isReadOnly() throws SQLException {
if (conn != null) {
return conn.isReadOnly();
if (this.readOnly != null) {
return this.readOnly.booleanValue();
return false;
public void setCatalog(String catalog) throws SQLException {
if (conn != null) {
conn.setCatalog(catalog);
this.catalog = catalog;
public String getCatalog() throws SQLException {
if (conn != null) {
return conn.getCatalog();
return this.catalog;
public void setTransactionIsolation(int level) throws SQLException {
if (conn != null) {
conn.setTransactionIsolation(level);
this.transactionLeval = level;
public int getTransactionIsolation() throws SQLException {
if (conn != null) {
return conn.getTransactionIsolation();
if (this.transactionLeval != null) {
return this.transactionLeval;
return TRANSACTION_NONE;
public SQLWarning getWarnings() throws SQLException {
if (conn != null) {
return conn.getWarnings();
return null;
public void clearWarnings() throws SQLException {
if (conn != null) {
conn.clearWarnings();
public Map<String, Class<?>> getTypeMap() throws SQLException {
if (conn != null) {
return conn.getTypeMap();
return typeMap;
public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
if (conn != null) {
conn.setTypeMap(map);
this.typeMap = map;
public void setHoldability(int holdability) throws SQLException {
if (conn != null) {
conn.setHoldability(holdability);
this.holdability = holdability;
public int getHoldability() throws SQLException {
if (conn != null) {
return conn.getHoldability();
if (this.holdability != null) {
return this.holdability;
public Savepoint setSavepoint() throws SQLException {
if (conn != null) {
return conn.setSavepoint();
throw new SQLException("connection not init");
public Savepoint setSavepoint(String name) throws SQLException {
if (conn != null) {
return conn.setSavepoint(name);
throw new SQLException("connection not init");
public void rollback(Savepoint savepoint) throws SQLException {
if (conn != null) {
conn.rollback(savepoint);
throw new SQLException("connection not init");
public void releaseSavepoint(Savepoint savepoint) throws SQLException {
if (conn != null) {
conn.releaseSavepoint(savepoint);
throw new SQLException("connection not init");
public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
long stmtId = haDataSource.createStatementId();
HAStatement stmt = new HAStatement(this, stmtId, resultSetType, resultSetConcurrency);
return stmt;
public Statement createStatement() throws SQLException {
long stmtId = haDataSource.createStatementId();
HAStatement stmt = new HAStatement(this, stmtId);
return stmt;
public PreparedStatement prepareStatement(String sql) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public CallableStatement prepareCall(String sql) throws SQLException {
checkConnection(sql);
CallableStatement stmt = conn.prepareCall(sql);
long stmtId = haDataSource.createStatementId();
return new CallableStatementProxyImpl(this, stmt, sql, stmtId);
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
checkConnection(sql);
CallableStatement stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency);
long stmtId = haDataSource.createStatementId();
return new CallableStatementProxyImpl(this, stmt, sql, stmtId);
public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
long stmtId = haDataSource.createStatementId();
HAStatement stmt = new HAStatement(this, stmtId, resultSetType, resultSetConcurrency, resultSetHoldability);
return stmt;
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
checkConnection(sql);
CallableStatement stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
long stmtId = haDataSource.createStatementId();
return new CallableStatementProxyImpl(this, stmt, sql, stmtId);
public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql, autoGeneratedKeys);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql, columnIndexes);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
checkConnection(sql);
PreparedStatement stmt = conn.prepareStatement(sql, columnNames);
long stmtId = haDataSource.createStatementId();
return new PreparedStatementProxyImpl(this, stmt, sql, stmtId);
public Clob createClob() throws SQLException {
if (conn != null) {
return conn.createClob();
throw new SQLException("connection not init");
public Blob createBlob() throws SQLException {
if (conn != null) {
return conn.createBlob();
throw new SQLException("connection not init");
public NClob createNClob() throws SQLException {
if (conn != null) {
return conn.createNClob();
throw new SQLException("connection not init");
public SQLXML createSQLXML() throws SQLException {
if (conn != null) {
return conn.createSQLXML();
throw new SQLException("connection not init");
public boolean isValid(int timeout) throws SQLException {
if (conn != null) {
return conn.isValid(timeout);
return true;
public void setClientInfo(String name, String value) throws SQLClientInfoException {
if (conn != null) {
conn.setClientInfo(name, value);
if (clientInfo == null) {
clientInfo = new Properties();
clientInfo.setProperty(name, value);
public void setClientInfo(Properties properties) throws SQLClientInfoException {
if (conn != null) {
conn.setClientInfo(properties);
this.clientInfo = properties;
public String getClientInfo(String name) throws SQLException {
if (conn != null) {
return conn.getClientInfo(name);
if (clientInfo == null) {
return null;
return clientInfo.getProperty(name);
public Properties getClientInfo() throws SQLException {
if (conn != null) {
return conn.getClientInfo();
return clientInfo;
public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
if (conn != null) {
return conn.createArrayOf(typeName, elements);
throw new SQLException("connection not init");
public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
if (conn != null) {
return conn.createStruct(typeName, attributes);
throw new SQLException("connection not init");
public long getId() {
return id;
public Object getRawObject() {
return conn;
public Map<String, Object> getAttributes() {
if (attributes == null) {
attributes = new HashMap<String, Object>();
return attributes;
public Connection getConnectionRaw() {
return conn;
public Properties getProperties() {
return haDataSource.getProperties();
public DataSourceProxy getDirectDataSource() {
throw new UnsupportedOperationException();
public Date getConnectedTime() {
return connectedTime;
private final AtomicInteger           connectionIdSeed        = new AtomicInteger();
private final AtomicInteger           statementIdSeed         = new AtomicInteger();
int requestNumber = connectionIdSeed.getAndIncrement();
return new HAConnection(this, requestNumber);
public int createStatementId() {
return statementIdSeed.getAndIncrement();
public Connection getConnectionInternal(int requestNumber) throws SQLException {
public class HAStatement extends WrapperAdapter implements Statement {
private final HAConnection conn;
private final long         id;
private Integer            resultSetType;
private Integer            resultSetConcurrency;
private Integer            resultSetHoldability;
public HAStatement(HAConnection conn, long id){
this.conn = conn;
this.id = id;
public HAStatement(HAConnection conn, long id, int resultSetType, int resultSetConcurrency){
this.conn = conn;
this.id = id;
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
public HAStatement(HAConnection conn, long id, int resultSetType, int resultSetConcurrency, int resultSetHoldability){
this.conn = conn;
this.id = id;
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
this.resultSetHoldability = resultSetHoldability;
public HAConnection getConn() {
return conn;
public long getId() {
return id;
public ResultSet executeQuery(String sql) throws SQLException {
return null;
public int executeUpdate(String sql) throws SQLException {
public void close() throws SQLException {
public int getMaxFieldSize() throws SQLException {
public void setMaxFieldSize(int max) throws SQLException {
public int getMaxRows() throws SQLException {
public void setMaxRows(int max) throws SQLException {
public void setEscapeProcessing(boolean enable) throws SQLException {
public int getQueryTimeout() throws SQLException {
public void setQueryTimeout(int seconds) throws SQLException {
public void cancel() throws SQLException {
public SQLWarning getWarnings() throws SQLException {
return null;
public void clearWarnings() throws SQLException {
public void setCursorName(String name) throws SQLException {
public boolean execute(String sql) throws SQLException {
return false;
public ResultSet getResultSet() throws SQLException {
return null;
public int getUpdateCount() throws SQLException {
public boolean getMoreResults() throws SQLException {
return false;
public void setFetchDirection(int direction) throws SQLException {
public int getFetchDirection() throws SQLException {
public void setFetchSize(int rows) throws SQLException {
public int getFetchSize() throws SQLException {
public int getResultSetConcurrency() throws SQLException {
public int getResultSetType() throws SQLException {
public void addBatch(String sql) throws SQLException {
public void clearBatch() throws SQLException {
public int[] executeBatch() throws SQLException {
return null;
public Connection getConnection() throws SQLException {
return null;
public boolean getMoreResults(int current) throws SQLException {
return false;
public ResultSet getGeneratedKeys() throws SQLException {
return null;
public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
public int executeUpdate(String sql, String[] columnNames) throws SQLException {
public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
return false;
public boolean execute(String sql, int[] columnIndexes) throws SQLException {
return false;
public boolean execute(String sql, String[] columnNames) throws SQLException {
return false;
public int getResultSetHoldability() throws SQLException {
public boolean isClosed() throws SQLException {
return false;
public void setPoolable(boolean poolable) throws SQLException {
public boolean isPoolable() throws SQLException {
return false;
private Properties                   properties = new Properties();
this.dataSources = new ArrayList<DruidDataSource>(dataSources);
public Properties getProperties() {
return properties;
private Date                  connectedTime    = null;
public void checkConnection(String sql) throws SQLException {
if (autoCommit != null) {
conn.setAutoCommit(autoCommit);
if (readOnly != null) {
conn.setReadOnly(readOnly);
if (catalog != null) {
conn.setCatalog(catalog);
if (transactionLeval != null) {
conn.setTransactionIsolation(transactionLeval);
if (typeMap != null) {
conn.setTypeMap(typeMap);
if (holdability != null) {
conn.setHoldability(holdability);
if (clientInfo != null) {
conn.setClientInfo(clientInfo);
connectedTime = new Date();
public HADataSource getHaDataSource() {
return haDataSource;
private Statement          stmt;
private Integer            maxFieldSize;
private Integer            maxRows;
private Boolean            escapeProcessing;
private Integer            queryTimeout;
private String             cursorName;
private Integer            fetchDirection;
private Integer            fetchSize;
void checkStatement(String sql) throws SQLException {
conn.checkConnection(sql);
if (resultSetType != null && resultSetConcurrency != null && resultSetHoldability != null) {
stmt = conn.getConnectionRaw().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
} else if (resultSetType != null && resultSetConcurrency != null) {
stmt = conn.getConnectionRaw().createStatement(resultSetType, resultSetConcurrency);
stmt = conn.getConnectionRaw().createStatement();
if (maxFieldSize != null) {
stmt.setMaxFieldSize(maxFieldSize);
if (maxRows != null) {
stmt.setMaxRows(maxRows);
if (escapeProcessing != null) {
stmt.setEscapeProcessing(escapeProcessing);
if (queryTimeout != null) {
stmt.setQueryTimeout(queryTimeout);
if (cursorName != null) {
stmt.setCursorName(cursorName);
if (fetchDirection != null) {
stmt.setFetchDirection(fetchDirection);
if (fetchSize != null) {
stmt.setFetchSize(fetchSize);
checkStatement(sql);
return stmt.executeQuery(sql);
checkStatement(sql);
return stmt.executeUpdate(sql);
if (stmt != null) {
stmt.close();
if (stmt != null) {
return stmt.getMaxFieldSize();
if (maxFieldSize == null) {
return maxFieldSize;
if (stmt != null) {
stmt.setMaxFieldSize(max);
this.maxFieldSize = max;
if (stmt != null) {
return stmt.getMaxRows();
if (maxRows == null) {
return maxRows;
if (stmt != null) {
stmt.setMaxRows(max);
this.maxRows = max;
if (stmt != null) {
stmt.setEscapeProcessing(enable);
this.escapeProcessing = enable;
if (stmt != null) {
return stmt.getQueryTimeout();
if (queryTimeout == null) {
return queryTimeout;
if (stmt != null) {
stmt.setQueryTimeout(seconds);
this.queryTimeout = seconds;
if (stmt != null) {
stmt.cancel();
if (stmt != null) {
return stmt.getWarnings();
if (stmt != null) {
stmt.clearWarnings();
if (stmt != null) {
stmt.setCursorName(name);
this.cursorName = name;
checkStatement(sql);
return stmt.execute(sql);
if (stmt != null) {
return stmt.getResultSet();
if (stmt != null) {
return stmt.getUpdateCount();
if (stmt != null) {
return stmt.getMoreResults();
if (stmt != null) {
stmt.setFetchDirection(direction);
this.fetchDirection = direction;
if (stmt != null) {
return stmt.getFetchDirection();
return this.fetchDirection;
if (stmt != null) {
stmt.setFetchSize(rows);
this.fetchSize = rows;
if (stmt != null) {
return stmt.getFetchSize();
return this.fetchSize;
if (stmt != null) {
return stmt.getResultSetConcurrency();
if (resultSetConcurrency != null) {
return resultSetConcurrency;
if (stmt != null) {
return stmt.getResultSetType();
return resultSetType;
checkStatement(sql);
stmt.addBatch(sql);
if (stmt != null) {
stmt.clearBatch();
if (stmt != null) {
return stmt.executeBatch();
return new int[0];
public HAConnection getConnection() throws SQLException {
return conn;
if (stmt != null) {
return stmt.getMoreResults(current);
if (stmt != null) {
return stmt.getGeneratedKeys();
checkStatement(sql);
return stmt.executeUpdate(sql, autoGeneratedKeys);
checkStatement(sql);
return stmt.executeUpdate(sql, columnIndexes);
checkStatement(sql);
return stmt.executeUpdate(sql, columnNames);
checkStatement(sql);
return stmt.execute(sql, autoGeneratedKeys);
checkStatement(sql);
return stmt.execute(sql, columnIndexes);
checkStatement(sql);
return stmt.execute(sql, columnNames);
if (stmt != null) {
return stmt.getResultSetHoldability();
if (resultSetHoldability != null) {
return resultSetHoldability;
if (stmt != null) {
return stmt.isClosed();
throw new SQLException("not supported");
conn = haDataSource.getConnectionInternal(id, sql);
public Connection getConnectionInternal(int connectionId, String sql) throws SQLException {
int index = connectionId % size;
private final MultiDataSource    haDataSource;
public MultiDataSource getHaDataSource() {
return new HAConnection(this, createConnectionId());
private Properties                   properties       = new Properties();
private final AtomicInteger          connectionIdSeed = new AtomicInteger();
private final AtomicInteger          statementIdSeed  = new AtomicInteger();
public int createConnectionId() {
return connectionIdSeed.getAndIncrement();
public int createStatementId() {
return statementIdSeed.getAndIncrement();
public abstract Connection getConnectionInternal(int connectionId, String sql) throws SQLException;
return new MultiDataSourceConnection(this, createConnectionId());
public class MultiDataSourceConnection extends WrapperAdapter implements Connection, ConnectionProxy {
public MultiDataSourceConnection(HADataSource haDataSource, int id){
MultiDataSourceStatement stmt = new MultiDataSourceStatement(this, stmtId, resultSetType, resultSetConcurrency);
MultiDataSourceStatement stmt = new MultiDataSourceStatement(this, stmtId);
MultiDataSourceStatement stmt = new MultiDataSourceStatement(this, stmtId, resultSetType, resultSetConcurrency, resultSetHoldability);
public class MultiDataSourceStatement extends WrapperAdapter implements Statement {
private final MultiDataSourceConnection conn;
public MultiDataSourceStatement(MultiDataSourceConnection conn, long id){
public MultiDataSourceStatement(MultiDataSourceConnection conn, long id, int resultSetType, int resultSetConcurrency){
public MultiDataSourceStatement(MultiDataSourceConnection conn, long id, int resultSetType, int resultSetConcurrency, int resultSetHoldability){
public MultiDataSourceConnection getConnection() throws SQLException {
protected ArrayList<DruidDataSource>  dataSources;
dataSources = new ArrayList<DruidDataSource>();
public List<DruidDataSource> getDataSources() {
return Collections.unmodifiableList(dataSources);
public void setDataSources(List<DruidDataSource> dataSources) {
this.dataSources = new ArrayList<DruidDataSource>(dataSources);
public MultiDataSource(){
public abstract List<DruidDataSource> getDataSources();
public abstract void setDataSources(List<DruidDataSource> dataSources);
protected ArrayList<DruidDataSource>  dataSources             = new ArrayList<DruidDataSource>();
protected int indexFor(MultiDataSourceConnection multiDataSourceConnection, String sql) {
int size = dataSources.size();
int connectionId = (int) multiDataSourceConnection.getId();
return connectionId % size;
public Connection getConnectionInternal(MultiDataSourceConnection multiDataSourceConnection, String sql) throws SQLException {
int index = indexFor(multiDataSourceConnection, sql);
public abstract Connection getConnectionInternal(MultiDataSourceConnection conn, String sql) throws SQLException;
conn = haDataSource.getConnectionInternal(this, sql);
protected int indexFor(MultiDataSourceConnection multiDataSourceConnection, String sql) throws SQLException {
public interface BalancePolicy {
int indexFor(MultiDataSourceConnection connection, String sql) throws SQLException;
public class RoundRobinBlancePolicy implements BalancePolicy {
public int indexFor(MultiDataSourceConnection connection, String sql) throws SQLException {
MultiDataSource dataSource = connection.getHaDataSource();
int size = dataSource.getDataSources().size();
long connectionId = (int) connection.getId();
return (int) (connectionId % size);
protected Balancer                    balancer                = new RoundRobinBlancer();
public Balancer getBalancer() {
return balancer;
public void setBalancer(Balancer balancer) {
this.balancer = balancer;
protected int indexFor(MultiDataSourceConnection connection, String sql) throws SQLException {
return balancer.indexFor(connection, sql);
public interface Balancer {
public class RoundRobinBlancer implements Balancer {
public Connection getConnectionInternal(MultiDataSourceConnection connection, String sql) throws SQLException {
return this.balancer.getConnection(connection, sql);
public void handleNotAwailableDatasource(DruidDataSource dataSource) {
public abstract void handleNotAwailableDatasource(DruidDataSource dataSource);
Connection getConnection(MultiDataSourceConnection connectionProxy, String sql) throws SQLException;
private final static Log    LOG             = LogFactory.getLog(RoundRobinBlancer.class);
private final AtomicInteger indexErrorCount = new AtomicInteger();
public RoundRobinBlancer(){
public Connection getConnection(MultiDataSourceConnection connectionProxy, String sql) throws SQLException {
MultiDataSource multiDataSource = connectionProxy.getHaDataSource();
int tryCount = 0;
for (;;) {
int size = multiDataSource.getDataSources().size();
long connectionId = (int) connectionProxy.getId();
if (size == 0) {
throw new SQLException("can not get connection, no availabe datasources");
int index = (int) (connectionId % size);
DruidDataSource dataSource = null;
dataSource = multiDataSource.getDataSources().get(index);
} catch (Exception ex) {
indexErrorCount.incrementAndGet();
if (LOG.isDebugEnabled()) {
LOG.debug("getDataSource error, index : " + index, ex);
assert dataSource != null;
if (!dataSource.isEnable()) {
multiDataSource.handleNotAwailableDatasource(dataSource);
Connection conn = null;
tryCount++;
conn = dataSource.getConnection();
} catch (SQLException ex) {
LOG.error("getConnection error", ex);
if (tryCount >= size) {
return conn;
public long getIndexErrorCount() {
return indexErrorCount.get();
public class SimpleBalancer implements Balancer {
private int maxActive = 8;
public int getMaxActive() {
return maxActive;
public void setMaxActive(int maxActive) {
this.maxActive = maxActive;
public Connection getConnection(MultiDataSourceConnection connectionProxy, String sql) throws SQLException {
MultiDataSource multiDataSource = connectionProxy.getHaDataSource();
Object[] array = multiDataSource.getDataSources().toArray();
DruidDataSource minDataSource = null;
int min = 0;
for (Object item : array) {
DruidDataSource dataSource = (DruidDataSource) item;
if (!dataSource.isEnable()) {
int activeCount = dataSource.getActiveCount();
if (minDataSource == null || activeCount < min) {
minDataSource = dataSource;
min = activeCount;
if (activeCount >= maxActive) {
return dataSource.getConnection();
if (minDataSource != null) {
return minDataSource.getConnection();
throw new SQLException("can not get connection, no availabe datasources");
return this.closed;
return closed;
public class Case3 extends TestCase {
public void test_1() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mysql:
dataSource.setUsername("root");
dataSource.setPassword("root");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.next();
conn.close();
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(true, rs.isClosed());
rs.close();
stmt.close();
dataSource.close();
public class TestClose_2 extends TestCase {
public void test_close() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setPoolPreparedStatements(true);
dataSource.setUrl("jdbc:mock:xxx");
String sql = "SELECT 1";
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
Assert.assertEquals(false, rs.isClosed());
Assert.assertEquals(false, stmt.isClosed());
stmt.close();
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(true, rs.isClosed());
CallableStatement stmt2 = conn.prepareCall(sql);
Assert.assertEquals(false, stmt.isClosed());
Assert.assertEquals(stmt, stmt2);
conn.close();
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(true, rs.isClosed());
rs.close();
stmt.close();
dataSource.close();
if (conn == null) {
return null;
super(rs);
private final static Log        LOG            = LogFactory.getLog(PoolableStatement.class);
super(stmt);
private final Wrapper wraaper;
public PoolableWrapper(Wrapper wraaper){
this.wraaper = wraaper;
if (iface.isInstance(wraaper)) {
return true;
return wraaper.isWrapperFor(iface);
if (iface.isInstance(wraaper)) {
return (T) wraaper;
return wraaper.unwrap(iface);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(false, mockStmt.isClosed());
Assert.assertEquals(true, mockStmt.isClosed());
stmt.execute("SELECT 1");
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
protected void checkOpen() throws SQLException {
if (closed) {
throw new SQLException("statement is closed");
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
checkOpen();
SQLException error = null;
stmt.execute("SELECT 1");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
private int     maxIdle                       = 20;
private int     maxActive                     = 20;
final int       LOOP_COUNT                    = 1000 * 1;
private boolean testWhileIdle                 = true;
private boolean testOnBorrow                  = false;
private boolean testOnReturn                  = false;
private long    minEvictableIdleTimeMillis    = 1800000;
private int     numTestsPerEvictionRun        = 20;
driverClass = "com.mysql.jdbc.Driver";
for (int i = 0; i < 100; ++i) {
dataSource.setTestOnBorrow(testWhileIdle);
dataSource.setTestOnBorrow(testOnReturn);
dataSource.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
dataSource.setTestOnBorrow(testWhileIdle);
dataSource.setTestOnBorrow(testOnReturn);
dataSource.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
PreparedStatement stmt = conn.prepareStatement("SELECT 1");
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getInt(1);
rs.close();
stmt.close();
final int       LOOP_COUNT                    = 1000 * 10;
for (int i = 0; i < 5; ++i) {
jdbcUrl = "dbc:oracle:thin:@A010.20.153.104:1521:orcl";
user = "DRUID";
password = "DRUID";
driverClass = "racle.jdbc.driver.OracleDriver";
driverClass = "oracle.jdbc.driver.OracleDriver";
jdbcUrl = "dbc:oracle:thin:@10.20.153.104:1521:orcl";
jdbcUrl = "jdbc:oracle:thin:10.20.153.104:1521:orcl";
jdbcUrl = "jdbc:oracle:thin:@10.20.144.80:1521:orcl";
PreparedStatement stmt = conn.prepareStatement("SELECT 1 FROM DUAL");
private int     threadCount                   = 15;
final int       LOOP_COUNT                    = 1000 * 100;
final int       LOOP_COUNT                    = 1000 * 10;
jdbcUrl = "jdbc:oracle:thin:@10.20.149.85:1521:ocnauto";
user = "alibaba";
password = "ccbuauto";
final int       LOOP_COUNT                    = 1000 * 100;
if (validConnectionChecker != null) {
if (!validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout)) {
throw new SQLException("validateConnection false");
return validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout);
boolean isValidConnection(Connection c, String query, int validationQueryTimeout);
public boolean isValidConnection(final Connection c, String valiateQuery, int validationQueryTimeout) {
stmt.setQueryTimeout(validationQueryTimeout);
public boolean isValidConnection(Connection c, String valiateQuery, int validationQueryTimeout) {
stmt.setQueryTimeout(validationQueryTimeout);
rs = stmt.executeQuery(valiateQuery);
public boolean isValidConnection(Connection c, String valiateQuery, int validationQueryTimeout) {
if (c instanceof PoolableConnection) {
c = ((PoolableConnection) c).getConnection();
if (c instanceof ConnectionProxy) {
c = ((ConnectionProxy) c).getConnectionRaw();
if (clazz.isAssignableFrom(c.getClass())) {
Integer status = (Integer) ping.invoke(c, params);
if (status.intValue() < 0) {
return false;
return true;
Statement stmt = null;
ResultSet rs = null;
stmt = c.createStatement();
rs = stmt.executeQuery(valiateQuery);
return true;
} catch (SQLException e) {
return false;
} catch (Exception e) {
LOG.warn("Unexpected error in ping", e);
return false;
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
private String oracleDriverClass = "com.alibaba.china.jdbc.SimpleDriver";
dataSource.setDriverClassName(oracleDriverClass);
if (driverHasPingMethod) {
if (c instanceof PoolableConnection) {
c = ((PoolableConnection) c).getConnection();
if (c instanceof ConnectionProxy) {
c = ((ConnectionProxy) c).getConnectionRaw();
if (clazz.isAssignableFrom(c.getClass())) {
ping.invoke(conn);
return true;
} catch (Exception e) {
LOG.warn("Unexpected error in ping", e);
return false;
final int       LOOP_COUNT                    = 1000 * 10;
private String  validateQuery                 = "SELECT 1 FROM DUAL";
dataSource.setFilters("encoding");
final int       LOOP_COUNT                    = 1000 * 100;
ping.invoke(c);
private final DruidAbstractDataSource       dataSource;
private final List<Statement>               statementTrace           = new ArrayList<Statement>();
jdbcUrl = "jdbc:mysql:
user = "root";
password = "root";
driverClass = "com.mysql.jdbc.Driver";
private String  validationQuery               = null;                                 
private String  validateQuery                 = null;
private String  oracleDriverClass             = "com.alibaba.china.jdbc.SimpleDriver";
boolean isRemoveAbandoned();
private final static Log                                                     LOG                   = LogFactory.getLog(DruidDataSource.class);
private static final Object                                                  PRESENT               = new Object();
private static final IdentityHashMap<DruidDataSource, Object>                instances             = new IdentityHashMap<DruidDataSource, Object>();
private static final long                                                    serialVersionUID      = 1L;
private final ReentrantLock                                                  lock                  = new ReentrantLock();
private final Condition                                                      notEmpty              = lock.newCondition();
private final Condition                                                      notMaxActive          = lock.newCondition();
private final Condition                                                      lowWater              = lock.newCondition();
private long                                                                 connectCount          = 0;
private long                                                                 closeCount            = 0;
private long                                                                 connectErrorCount     = 0;
private long                                                                 recycleCount          = 0;
private long                                                                 createConnectionCount = 0L;
private long                                                                 destroyCount          = 0;
private int                                                                  count                 = 0;
private int                                                                  activeCount           = 0;
private long                                                                 idleCheckCount        = 0;
private boolean                                                              removeAbandoned       = false;
private final IdentityHashMap<PoolableConnection, ActiveConnectionTraceInfo> activeConnections     = new IdentityHashMap<PoolableConnection, ActiveConnectionTraceInfo>();
private final CountDownLatch                                                 initedLatch           = new CountDownLatch(2);
private boolean                                                              enable                = true;
if (removeAbandoned) {
StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
activeConnections.put(poolalbeConnection, new ActiveConnectionTraceInfo(poolalbeConnection, System.currentTimeMillis(), stackTrace));
if (removeAbandoned) {
Assert.assertEquals(1, dataSource.getPoolingCount());
for (int i = 0; i < numTestsPerEvictionRun && i < count; ++i) {
private String  validationQuery               = null;    
long startMillis = System.currentTimeMillis();
long seconds = (System.currentTimeMillis() - startMillis) / 1000L;
System.out.println("seconds : " + seconds);
protected boolean                                                                        defaultAutoCommit                         = true;
conn.setAutoCommit(autoCommit);
} catch (SQLException ex) {
handleException(ex);
conn.commit();
} catch (SQLException ex) {
handleException(ex);
conn.rollback();
} catch (SQLException ex) {
handleException(ex);
conn.rollback(savepoint);
} catch (SQLException ex) {
handleException(ex);
conn.releaseSavepoint(savepoint);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql, columnIndexes);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt  = null;
stmt = conn.prepareStatement(sql, columnNames);
} catch (SQLException ex) {
handleException(ex);
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql, autoGeneratedKeys);
} catch (SQLException ex) {
handleException(ex);
CallableStatement stmt = null;
stmt = conn.prepareCall(sql);
} catch (SQLException ex) {
handleException(ex);
CallableStatement stmt = null;
stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
} catch (SQLException ex) {
handleException(ex);
CallableStatement stmt = null;
stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency);
} catch (SQLException ex) {
handleException(ex);
Statement stmt = null;
stmt = conn.createStatement();
} catch (SQLException ex) {
handleException(ex);
Statement stmt = null;
stmt = conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
} catch (SQLException ex) {
handleException(ex);
Statement stmt = null;
stmt = conn.createStatement(resultSetType, resultSetConcurrency);
} catch (SQLException ex) {
handleException(ex);
} else if (rawUrl.startsWith("jdbc:sqlserver:")) {
return "com.microsoft.jdbc.sqlserver.SQLServerDriver";
public boolean visit(SQLNullExpr x) {
print('?');
return false;
public boolean visit(SQLNullExpr x) {
print('?');
return false;
if (count - evictList.size() <= minIdle) {
if (idleMillis >= minEvictableIdleTimeMillis) {
int removeCount = evictList.size();
Assert.assertEquals(1, dataSource.getPoolingCount());
public final static String         ATTR_TRANSACTION          = "stat.tx";
public void connection_setAutoCommit(FilterChain chain, ConnectionProxy connection, boolean autoCommit)
throws SQLException {
Map<String, Object> attributes = connection.getAttributes();
if (!autoCommit) {
TransactionInfo transInfo = (TransactionInfo) attributes.get(ATTR_TRANSACTION);
if (transInfo == null) {
long transactionId = connection.getDirectDataSource().createTransactionId();
transInfo = new TransactionInfo(transactionId);
attributes.put(ATTR_TRANSACTION, transInfo);
dataSourceStat.getConnectionStat().incrementConnectionCommitCount();
attributes.remove(ATTR_TRANSACTION);
chain.connection_setAutoCommit(connection, autoCommit);
handleEndTransaction(connection);
private void handleEndTransaction(ConnectionProxy connection) {
Map<String, Object> attributes = connection.getAttributes();
TransactionInfo transInfo = (TransactionInfo) attributes.remove(ATTR_TRANSACTION);
if (transInfo != null) {
transInfo.setEndTimeMillis(System.currentTimeMillis());
handleEndTransaction(connection);
handleEndTransaction(connection);
private JTextField                              txtUrl                        = new JTextField("jdbc:oracle:thin:@10.20.36.18:1521:ocndb");
private JTextField                              txtInitialSize                = new JTextField("1");
private JTextField                              txtMaxActive                  = new JTextField("14");
private JTextField                              txtMaxIdle                    = new JTextField("14");
private JTextField                              txtMinIdle                    = new JTextField("1");
ResultSet rs = stmt.executeQuery("SELECT 1 FROM DUAL");
dataSource.setTimeBetweenEvictionRunsMillis(60000);
dataSource.setNumTestsPerEvictionRun(20);
final int threadCount = 20;
final int LOOP_COUNT = 1000 * 1;
final String sql = "SELECT 1 FROM DUAL";
exec_test("bvt/parser/oracle-55.txt");
Connection conn = DriverManager.getConnection(url, "DRUID", "DRUID");
conn.setAutoCommit(false);
this.decrementActiveCountWithLock();
this.decrementActiveCountWithLock();
this.decrementActiveCountWithLock();
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(i + 1, dataSource.getActiveCount());
Assert.assertEquals(count - i - 1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getActiveCount());
int count = 4;
Connection[] connections = new Connection[4];
for (int i = 0; i < count; ++i) {
connections[i] = dataSource.getConnection();
Assert.assertEquals(i + 1, dataSource.getActiveCount());
Assert.assertEquals(4, driver.getConnections().size());
for (int i = 0; i < count; ++i) {
connections[i].close();
Assert.assertEquals(count - i - 1, dataSource.getActiveCount());
Assert.assertEquals(4, driver.getConnections().size());
Assert.assertEquals(0, dataSource.getActiveCount());
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(dataSource.getMinIdle(), driver.getConnections().size());
Assert.assertEquals(0, dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(dataSource.getInitialSize(), dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getDestroyCount());
Assert.assertEquals(dataSource.getMaxActive(), dataSource.getCreateCount());
Assert.assertEquals(dataSource.getMaxActive(), dataSource.getCreateCount());
if (LOG.isDebugEnabled()) {
LOG.debug("connect, url " + url + ", id " + conn.getId());
if (activeCount >= maxActive) {
lowWater.signal(); 
for (Map.Entry<Long, JdbcConnectionStat.Entry> entry : connections.entrySet()) {
data.put(entry.getValue().getCompositeData());
for (DruidDataSource instance : DruidDataSource.getInstances()) {
for (Filter filter : instance.getProxyFilters()) {
if (filter instanceof StatFilter) {
StatFilter countFilter = (StatFilter) filter;
ConcurrentMap<Long, JdbcConnectionStat.Entry> connections = countFilter.getConnections();
if (this.getStatementPool() != null) {
buf.append("", CachedStatementCount:");
buf.append(this.getStatementPool().getMap().size());
lock.lock();
lock.lock();
lock.lock();
private long                                                            connectCount          = 0L;
private long                                                            closeCount            = 0L;
private long                                                            connectErrorCount     = 0L;
private long                                                            recycleCount          = 0L;
private long                                                            destroyCount          = 0L;
private final CountDownLatch                                            initedLatch           = new CountDownLatch(2);
public class TestIdle2 extends TestCase {
public class TestIdle3 extends TestCase {
public class TestIdle3_Concurrent_MaxActive extends TestCase {
int max = maxActive > maxIdle ? maxActive : maxIdle;
if (activeCount + poolingCount >= max) {
lowWater.signal(); 
nanos = notMaxActive.awaitNanos(nanos);
estimate = notMaxActive.awaitNanos(estimate); 
estimate = notEmpty.awaitNanos(estimate); 
notMaxActive.await(); 
notEmpty.await(); 
lowWater.signal(); 
if (activeCount >= maxActive) {
if (poolingCount == 0) {
notEmpty.signal(); 
if (poolingCount == 0) {
lowWater.signal(); 
notEmpty.await(); 
while (activeCount >= maxActive) {
notMaxActive.await(); 
} catch (InterruptedException ie) {
notMaxActive.signal(); 
while (activeCount >= maxActive) {
estimate = notMaxActive.awaitNanos(estimate); 
} catch (InterruptedException ie) {
notMaxActive.signal(); 
if (estimate <= 0) {
return null;
if (poolingCount >= minIdle) {
if (minIdle > 0 && poolingCount >= minIdle) {
for (int i = 0; i < poolingCount; ++i) {
final int checkCount = poolingCount - minIdle;
for (int i = 0; i < checkCount; ++i) {
int waitThreadCount = lock.getWaitQueueLength(notEmpty);
if (waitThreadCount == 0) {
if (minIdle > 0 && (poolingCount - waitThreadCount) >= minIdle) {
Assert.assertEquals(1, driver.getConnections().size());
Assert.assertEquals(1, dataSource.getCreateCount());
JdbcUtils.close(conn);
JdbcUtils.close(conn);
int max = maxActive;;
int capacity = maxActive;
dataSource.setMaxActive(10);
abstract void decrementActiveCountWithLock();
if (holder != null) {
dataSource.decrementActiveCountWithLock();
this.holder = null; 
dataSource.setInitialSize(14);
dataSource.setMinIdle(14);
Assert.assertEquals(true, dataSource.getPoolingCount() == driver.getConnections().size());
Assert.assertEquals(true, dataSource.getPoolingCount() == dataSource.getMaxActive());
if (activeCount + poolingCount >= maxActive) {
public class TestGraceShutdown extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
public void test_close() throws Exception {
final int threadCount = 100;
Thread[] threads = new Thread[threadCount];
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
for (int i = 0; i < threadCount; ++i) {
threads[i] = new Thread("thread-" + i) {
public void run() {
startLatch.await();
Connection conn = dataSource.getConnection();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
startLatch.countDown();
for (int i = 0; i < threadCount; ++i) {
threads[i].start();
Thread.sleep(1000);
new Thread("close thread") {
public void run() {
dataSource.close();
}.start();
endLatch.await();
public class TestDisable extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
public void test_close() throws Exception {
final int threadCount = 100;
Thread[] threads = new Thread[threadCount];
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
for (int i = 0; i < threadCount; ++i) {
threads[i] = new Thread("thread-" + i) {
public void run() {
startLatch.await();
Connection conn = dataSource.getConnection();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
startLatch.countDown();
for (int i = 0; i < threadCount; ++i) {
threads[i].start();
Thread.sleep(1000);
new Thread("close thread") {
public void run() {
dataSource.setEnable(false);
}.start();
endLatch.await();
empty.await(1, TimeUnit.SECONDS); 
ManagementFactory.getPlatformMBeanServer().registerMBean(dataSource,
new ObjectName("com.alibaba:type=DataSource"));
if (poolingCount >= waitThreadCount) {
notEmpty.signal();
empty.await(); 
notEmpty.signal(); 
empty.await();
connections[poolingCount++] = new ConnectionHolder(DruidDataSource.this, connection);
public class TestIdle3_Concurrent_Starvation extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(14);
dataSource.setMaxIdle(14);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
public void test_idle2() throws Exception {
ManagementFactory.getPlatformMBeanServer().registerMBean(dataSource,
new ObjectName("com.alibaba:type=DataSource"));
Assert.assertEquals(0, dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Connection conn = dataSource.getConnection();
Assert.assertEquals(dataSource.getInitialSize(), dataSource.getCreateCount());
Assert.assertEquals(dataSource.getInitialSize(), driver.getConnections().size());
Assert.assertEquals(1, dataSource.getActiveCount());
conn.close();
Assert.assertEquals(0, dataSource.getDestroyCount());
Assert.assertEquals(1, driver.getConnections().size());
Assert.assertEquals(1, dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getActiveCount());
for (int i = 0; i < 1; ++i) {
final int threadCount = 10;
concurrent(threadCount);
for (int i = 0; i < 1000; ++i) {
Assert.assertEquals(0, dataSource.getActiveCount());
Connection conn = dataSource.getConnection();
Assert.assertEquals(1, dataSource.getActiveCount());
conn.close();
dataSource.close();
private void concurrent(final int threadCount) throws Exception {
Thread[] threads = new Thread[threadCount];
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
final AtomicInteger pass = new AtomicInteger();
final CyclicBarrier closedBarrier = new CyclicBarrier(threadCount, new Runnable() {
public void run() {
Assert.assertEquals(threadCount, dataSource.getPoolingCount());
dataSource.shrink(false);
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(dataSource.getMinIdle(), dataSource.getPoolingCount());
if (pass.getAndIncrement() % 10000 == 0) {
System.out.println("pass : " + pass.get());
final CyclicBarrier closeBarrier = new CyclicBarrier(threadCount, new Runnable() {
public void run() {
Assert.assertEquals(threadCount, dataSource.getActiveCount());
for (int i = 0; i < threadCount; ++i) {
threads[i] = new Thread("thread-" + i) {
public void run() {
startLatch.await();
for (int i = 0; i < 1000 * 1000; ++i) {
Connection conn = dataSource.getConnection();
closeBarrier.await();
conn.close();
closedBarrier.await();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
startLatch.countDown();
for (int i = 0; i < threadCount; ++i) {
threads[i].start();
endLatch.await();
dataSource.setMaxActive(100);
dataSource.setMaxIdle(100);
final int threadCount = 100;
if (pass.getAndIncrement() % 100 == 0) {
for (int i = 0; i < 1000 * 1; ++i) {
protected void tearDown() throws Exception {
ManagementFactory.getPlatformMBeanServer().unregisterMBean(new ObjectName("com.alibaba:type=DataSource"));
public void test_idle2() throws Exception {
ManagementFactory.getPlatformMBeanServer().registerMBean(dataSource,
new ObjectName("com.alibaba:type=DataSource"));
protected void tearDown() throws Exception {
ManagementFactory.getPlatformMBeanServer().unregisterMBean(new ObjectName("com.alibaba:type=DataSource"));
public class TestIdle3_Concurrent_Starvation_Longtime extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(100);
dataSource.setMaxIdle(100);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
ManagementFactory.getPlatformMBeanServer().registerMBean(dataSource,
new ObjectName("com.alibaba:type=DataSource"));
protected void tearDown() throws Exception {
ManagementFactory.getPlatformMBeanServer().unregisterMBean(new ObjectName("com.alibaba:type=DataSource"));
public void test_idle2() throws Exception {
Assert.assertEquals(0, dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Connection conn = dataSource.getConnection();
Assert.assertEquals(dataSource.getInitialSize(), dataSource.getCreateCount());
Assert.assertEquals(dataSource.getInitialSize(), driver.getConnections().size());
Assert.assertEquals(1, dataSource.getActiveCount());
conn.close();
Assert.assertEquals(0, dataSource.getDestroyCount());
Assert.assertEquals(1, driver.getConnections().size());
Assert.assertEquals(1, dataSource.getCreateCount());
Assert.assertEquals(0, dataSource.getActiveCount());
for (int i = 0; i < 1; ++i) {
final int threadCount = 100;
concurrent(threadCount);
for (int i = 0; i < 1000; ++i) {
Assert.assertEquals(0, dataSource.getActiveCount());
Connection conn = dataSource.getConnection();
Assert.assertEquals(1, dataSource.getActiveCount());
conn.close();
dataSource.close();
private void concurrent(final int threadCount) throws Exception {
Thread[] threads = new Thread[threadCount];
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
final AtomicInteger pass = new AtomicInteger();
final CyclicBarrier closedBarrier = new CyclicBarrier(threadCount, new Runnable() {
public void run() {
Assert.assertEquals(threadCount, dataSource.getPoolingCount());
dataSource.shrink(false);
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(dataSource.getMinIdle(), dataSource.getPoolingCount());
if (pass.getAndIncrement() % 100 == 0) {
System.out.println("pass : " + pass.get());
final CyclicBarrier closeBarrier = new CyclicBarrier(threadCount, new Runnable() {
public void run() {
Assert.assertEquals(threadCount, dataSource.getActiveCount());
for (int i = 0; i < threadCount; ++i) {
threads[i] = new Thread("thread-" + i) {
public void run() {
startLatch.await();
for (int i = 0; i < 1000 * 1; ++i) {
Connection conn = dataSource.getConnection();
closeBarrier.await();
conn.close();
closedBarrier.await();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
startLatch.countDown();
for (int i = 0; i < threadCount; ++i) {
threads[i].start();
endLatch.await();
dataSource.setMaxActive(1000);
dataSource.setMaxIdle(1000);
final int threadCount = 1000;
for (int i = 0; i < 1000 * 1000 * 10; ++i) {
public final static int RevisionVersion = 8;
public class DruidC3P0WrapDataSource implements DataSource {
private DruidDataSource dataSource;
public DruidC3P0WrapDataSource(){
dataSource = new DruidDataSource();
public PrintWriter getLogWriter() throws SQLException {
return dataSource.getLogWriter();
public void setLogWriter(PrintWriter out) throws SQLException {
dataSource.setLogWriter(out);
public void setLoginTimeout(int seconds) throws SQLException {
dataSource.setLoginTimeout(seconds);
public int getLoginTimeout() throws SQLException {
return dataSource.getLoginTimeout();
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == DruidC3P0WrapDataSource.class) {
return (T) this;
return dataSource.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == DruidC3P0WrapDataSource.class) {
return true;
return dataSource.isWrapperFor(iface);
public Connection getConnection() throws SQLException {
return dataSource.getConnection();
public Connection getConnection(String username, String password) throws SQLException {
return dataSource.getConnection(username, password);
public String getUser() {
return dataSource.getUsername();
public void setUser(String user) {
dataSource.setUsername(user);
public String getPassword() {
return dataSource.getPassword();
public void setPassword(String password) {
dataSource.setPassword(password);
public int getCheckoutTimeout() {
return (int) dataSource.getMaxWait();
public void setCheckoutTimeout(int checkoutTimeout) {
dataSource.setMaxWait(checkoutTimeout);
public boolean isAutoCommitOnClose() {
return dataSource.isDefaultAutoCommit();
public void setAutoCommitOnClose(boolean autoCommitOnClose) {
this.dataSource.setDefaultAutoCommit(autoCommitOnClose);
public int getIdleConnectionTestPeriod() {
return (int) dataSource.getTimeBetweenEvictionRunsMillis();
public void setIdleConnectionTestPeriod(int idleConnectionTestPeriod) {
dataSource.setTimeBetweenEvictionRunsMillis(idleConnectionTestPeriod);
public int getInitialPoolSize() {
return dataSource.getInitialSize();
public void setInitialPoolSize(int initialPoolSize) {
dataSource.setInitialSize(initialPoolSize);
public int getMaxIdleTime() {
return (int) dataSource.getMinEvictableIdleTimeMillis();
public void setMaxIdleTime(int maxIdleTime) {
dataSource.setMinEvictableIdleTimeMillis(maxIdleTime);
public int getMaxPoolSize() {
return dataSource.getMaxActive();
public void setMaxPoolSize(int maxPoolSize) {
dataSource.setMaxActive(maxPoolSize);
public int getMinPoolSize() {
return dataSource.getMinIdle();
public void setMinPoolSize(int minPoolSize) {
dataSource.setMinIdle(minPoolSize);
public boolean isTestConnectionOnCheckout() {
return dataSource.isTestOnBorrow();
public void setTestConnectionOnCheckout(boolean testConnectionOnCheckout) {
dataSource.setTestOnBorrow(testConnectionOnCheckout);
public boolean isTestConnectionOnCheckin() {
return dataSource.isTestOnReturn();
public void setTestConnectionOnCheckin(boolean testConnectionOnCheckin) {
dataSource.setTestOnReturn(testConnectionOnCheckin);
public String getPreferredTestQuery() {
return dataSource.getValidationQuery();
public void setPreferredTestQuery(String preferredTestQuery) {
dataSource.setValidationQuery(preferredTestQuery);
private int     maxStatementsPerConnection;
private String  overrideDefaultUser;
private String  overrideDefaultPassword;
private int     propertyCycle;
private boolean breakAfterAcquireFailure;
private boolean usesTraditionalReflectiveProxies;
private String  userOverridesAsString;
private int     maxAdministrativeTaskTime;
private int     maxIdleTimeExcessConnections;
private int     maxConnectionAge;
private String  connectionCustomizerClassName;
private int     unreturnedConnectionTimeout;
private boolean debugUnreturnedConnectionStackTraces;
private String  factoryClassLocation;
private int     acquireIncrement = 1;
private int     acquireRetryDelay;
private int     acquireRetryAttempts;
private String  connectionTesterClassName;
private String  automaticTestTable;
private int     maxStatements;
public int getMaxStatements() {
return maxStatements;
public void setMaxStatements(int maxStatements) {
this.maxStatements = maxStatements;
public int getMaxStatementsPerConnection() {
return maxStatementsPerConnection;
public void setMaxStatementsPerConnection(int maxStatementsPerConnection) {
this.maxStatementsPerConnection = maxStatementsPerConnection;
public String getConnectionTesterClassName() {
return connectionTesterClassName;
public void setConnectionTesterClassName(String connectionTesterClassName) {
this.connectionTesterClassName = connectionTesterClassName;
public String getAutomaticTestTable() {
return automaticTestTable;
public void setAutomaticTestTable(String automaticTestTable) {
this.automaticTestTable = automaticTestTable;
private boolean forceIgnoreUnresolvedTransactions;
public boolean isForceIgnoreUnresolvedTransactions() {
return forceIgnoreUnresolvedTransactions;
public void setForceIgnoreUnresolvedTransactions(boolean forceIgnoreUnresolvedTransactions) {
this.forceIgnoreUnresolvedTransactions = forceIgnoreUnresolvedTransactions;
public boolean isUsesTraditionalReflectiveProxies() {
return usesTraditionalReflectiveProxies;
public void setUsesTraditionalReflectiveProxies(boolean usesTraditionalReflectiveProxies) {
this.usesTraditionalReflectiveProxies = usesTraditionalReflectiveProxies;
public String getUserOverridesAsString() {
return userOverridesAsString;
public void setUserOverridesAsString(String userOverridesAsString) {
this.userOverridesAsString = userOverridesAsString;
public int getMaxAdministrativeTaskTime() {
return maxAdministrativeTaskTime;
public void setMaxAdministrativeTaskTime(int maxAdministrativeTaskTime) {
this.maxAdministrativeTaskTime = maxAdministrativeTaskTime;
public int getMaxIdleTimeExcessConnections() {
return maxIdleTimeExcessConnections;
public void setMaxIdleTimeExcessConnections(int maxIdleTimeExcessConnections) {
this.maxIdleTimeExcessConnections = maxIdleTimeExcessConnections;
public int getMaxConnectionAge() {
return maxConnectionAge;
public void setMaxConnectionAge(int maxConnectionAge) {
this.maxConnectionAge = maxConnectionAge;
public String getConnectionCustomizerClassName() {
return connectionCustomizerClassName;
public void setConnectionCustomizerClassName(String connectionCustomizerClassName) {
this.connectionCustomizerClassName = connectionCustomizerClassName;
public int getUnreturnedConnectionTimeout() {
return unreturnedConnectionTimeout;
public void setUnreturnedConnectionTimeout(int unreturnedConnectionTimeout) {
this.unreturnedConnectionTimeout = unreturnedConnectionTimeout;
public boolean isDebugUnreturnedConnectionStackTraces() {
return debugUnreturnedConnectionStackTraces;
public void setDebugUnreturnedConnectionStackTraces(boolean debugUnreturnedConnectionStackTraces) {
this.debugUnreturnedConnectionStackTraces = debugUnreturnedConnectionStackTraces;
public String getFactoryClassLocation() {
return factoryClassLocation;
public void setFactoryClassLocation(String factoryClassLocation) {
this.factoryClassLocation = factoryClassLocation;
public int getAcquireIncrement() {
return acquireIncrement;
public void setAcquireIncrement(int acquireIncrement) {
this.acquireIncrement = acquireIncrement;
public int getAcquireRetryAttempts() {
return acquireRetryAttempts;
public void setAcquireRetryAttempts(int acquireRetryAttempts) {
this.acquireRetryAttempts = acquireRetryAttempts;
public int getAcquireRetryDelay() {
return acquireRetryDelay;
public void setAcquireRetryDelay(int acquireRetryDelay) {
this.acquireRetryDelay = acquireRetryDelay;
public String getOverrideDefaultUser() {
return overrideDefaultUser;
public void setOverrideDefaultUser(String overrideDefaultUser) {
this.overrideDefaultUser = overrideDefaultUser;
public String getOverrideDefaultPassword() {
return overrideDefaultPassword;
public void setOverrideDefaultPassword(String overrideDefaultPassword) {
this.overrideDefaultPassword = overrideDefaultPassword;
public int getPropertyCycle() {
return propertyCycle;
public void setPropertyCycle(int propertyCycle) {
this.propertyCycle = propertyCycle;
public boolean isBreakAfterAcquireFailure() {
return breakAfterAcquireFailure;
public void setBreakAfterAcquireFailure(boolean breakAfterAcquireFailure) {
this.breakAfterAcquireFailure = breakAfterAcquireFailure;
dataSource.setMaxActive(14);
dataSource.setMaxIdle(14);
final int threadCount = 5;
public class DruidC3P0WrapDataSource implements DataSource, DruidC3P0WrapDataSourceMBean {
public boolean isEnable() {
return dataSource.isEnable();
public void shrink() {
dataSource.shrink();
public int getWaitThreadCount() {
return dataSource.getWaitThreadCount();
public int getLockQueueLength() {
return dataSource.getLockQueueLength();
public interface DruidC3P0WrapDataSourceMBean {
String getUser();
int getCheckoutTimeout();
boolean isAutoCommitOnClose();
int getIdleConnectionTestPeriod();
int getInitialPoolSize();
int getMaxIdleTime();
int getMaxPoolSize();
int getMinPoolSize();
boolean isTestConnectionOnCheckout();
boolean isTestConnectionOnCheckin();
String getPreferredTestQuery();
boolean isEnable();
void shrink();
String toString();
int getWaitThreadCount();
int getLockQueueLength();
public String getDataSourceName() {
return dataSource.getName();
public int getNumConnections() {
return dataSource.getActiveCount() + dataSource.getPoolingCount();
public int getNumIdleConnections() {
return dataSource.getPoolingCount();
public int getNumBusyConnections() {
return dataSource.getActiveCount();
public int getNumUnclosedOrphanedConnections() {
public int getNumConnectionsDefaultUser() {
return getNumConnections();
public int getNumIdleConnectionsDefaultUser() {
return getNumIdleConnections();
public int getNumBusyConnectionsDefaultUser() {
return getNumBusyConnections();
public void close() {
dataSource.close();
int getNumIdleConnections();
int getNumConnections();
String getDataSourceName();
int getNumBusyConnections();
void close();
public class DruidDataSourceC3P0Wrap implements DataSource, DruidDataSourceC3P0WrapMBean {
public DruidDataSourceC3P0Wrap(){
if (iface == DruidDataSourceC3P0Wrap.class) {
if (iface == DruidDataSourceC3P0Wrap.class) {
public interface DruidDataSourceC3P0WrapMBean {
public class DruidDataSourceC3P0Adapter implements DataSource, DruidDataSourceC3P0AdapterMBean {
private DruidDataSource dataSource;
public DruidDataSourceC3P0Adapter(){
dataSource = new DruidDataSource();
public PrintWriter getLogWriter() throws SQLException {
return dataSource.getLogWriter();
public void setLogWriter(PrintWriter out) throws SQLException {
dataSource.setLogWriter(out);
public void setLoginTimeout(int seconds) throws SQLException {
dataSource.setLoginTimeout(seconds);
public int getLoginTimeout() throws SQLException {
return dataSource.getLoginTimeout();
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == DruidDataSourceC3P0Adapter.class) {
return (T) this;
return dataSource.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == DruidDataSourceC3P0Adapter.class) {
return true;
return dataSource.isWrapperFor(iface);
public Connection getConnection() throws SQLException {
return dataSource.getConnection();
public Connection getConnection(String username, String password) throws SQLException {
return dataSource.getConnection(username, password);
public String getUser() {
return dataSource.getUsername();
public void setUser(String user) {
dataSource.setUsername(user);
public String getPassword() {
return dataSource.getPassword();
public void setPassword(String password) {
dataSource.setPassword(password);
public int getCheckoutTimeout() {
return (int) dataSource.getMaxWait();
public void setCheckoutTimeout(int checkoutTimeout) {
dataSource.setMaxWait(checkoutTimeout);
public boolean isAutoCommitOnClose() {
return dataSource.isDefaultAutoCommit();
public void setAutoCommitOnClose(boolean autoCommitOnClose) {
this.dataSource.setDefaultAutoCommit(autoCommitOnClose);
public int getIdleConnectionTestPeriod() {
return (int) dataSource.getTimeBetweenEvictionRunsMillis();
public void setIdleConnectionTestPeriod(int idleConnectionTestPeriod) {
dataSource.setTimeBetweenEvictionRunsMillis(idleConnectionTestPeriod);
public int getInitialPoolSize() {
return dataSource.getInitialSize();
public void setInitialPoolSize(int initialPoolSize) {
dataSource.setInitialSize(initialPoolSize);
public int getMaxIdleTime() {
return (int) dataSource.getMinEvictableIdleTimeMillis();
public void setMaxIdleTime(int maxIdleTime) {
dataSource.setMinEvictableIdleTimeMillis(maxIdleTime);
public int getMaxPoolSize() {
return dataSource.getMaxActive();
public void setMaxPoolSize(int maxPoolSize) {
dataSource.setMaxActive(maxPoolSize);
public int getMinPoolSize() {
return dataSource.getMinIdle();
public void setMinPoolSize(int minPoolSize) {
dataSource.setMinIdle(minPoolSize);
public boolean isTestConnectionOnCheckout() {
return dataSource.isTestOnBorrow();
public void setTestConnectionOnCheckout(boolean testConnectionOnCheckout) {
dataSource.setTestOnBorrow(testConnectionOnCheckout);
public boolean isTestConnectionOnCheckin() {
return dataSource.isTestOnReturn();
public void setTestConnectionOnCheckin(boolean testConnectionOnCheckin) {
dataSource.setTestOnReturn(testConnectionOnCheckin);
public String getPreferredTestQuery() {
return dataSource.getValidationQuery();
public void setPreferredTestQuery(String preferredTestQuery) {
dataSource.setValidationQuery(preferredTestQuery);
public String getDataSourceName() {
return dataSource.getName();
public int getNumConnections() {
return dataSource.getActiveCount() + dataSource.getPoolingCount();
public int getNumIdleConnections() {
return dataSource.getPoolingCount();
public int getNumBusyConnections() {
return dataSource.getActiveCount();
public int getNumUnclosedOrphanedConnections() {
public int getNumConnectionsDefaultUser() {
return getNumConnections();
public int getNumIdleConnectionsDefaultUser() {
return getNumIdleConnections();
public int getNumBusyConnectionsDefaultUser() {
return getNumBusyConnections();
public boolean isEnable() {
return dataSource.isEnable();
public void shrink() {
dataSource.shrink();
public int getWaitThreadCount() {
return dataSource.getWaitThreadCount();
public int getLockQueueLength() {
return dataSource.getLockQueueLength();
public void close() {
dataSource.close();
private int     maxStatementsPerConnection;
private String  overrideDefaultUser;
private String  overrideDefaultPassword;
private int     propertyCycle;
private boolean breakAfterAcquireFailure;
private boolean usesTraditionalReflectiveProxies;
private String  userOverridesAsString;
private int     maxAdministrativeTaskTime;
private int     maxIdleTimeExcessConnections;
private int     maxConnectionAge;
private String  connectionCustomizerClassName;
private int     unreturnedConnectionTimeout;
private boolean debugUnreturnedConnectionStackTraces;
private String  factoryClassLocation;
private int     acquireIncrement = 1;
private int     acquireRetryDelay;
private int     acquireRetryAttempts;
private String  connectionTesterClassName;
private String  automaticTestTable;
private int     maxStatements;
public int getMaxStatements() {
return maxStatements;
public void setMaxStatements(int maxStatements) {
this.maxStatements = maxStatements;
public int getMaxStatementsPerConnection() {
return maxStatementsPerConnection;
public void setMaxStatementsPerConnection(int maxStatementsPerConnection) {
this.maxStatementsPerConnection = maxStatementsPerConnection;
public String getConnectionTesterClassName() {
return connectionTesterClassName;
public void setConnectionTesterClassName(String connectionTesterClassName) {
this.connectionTesterClassName = connectionTesterClassName;
public String getAutomaticTestTable() {
return automaticTestTable;
public void setAutomaticTestTable(String automaticTestTable) {
this.automaticTestTable = automaticTestTable;
private boolean forceIgnoreUnresolvedTransactions;
public boolean isForceIgnoreUnresolvedTransactions() {
return forceIgnoreUnresolvedTransactions;
public void setForceIgnoreUnresolvedTransactions(boolean forceIgnoreUnresolvedTransactions) {
this.forceIgnoreUnresolvedTransactions = forceIgnoreUnresolvedTransactions;
public boolean isUsesTraditionalReflectiveProxies() {
return usesTraditionalReflectiveProxies;
public void setUsesTraditionalReflectiveProxies(boolean usesTraditionalReflectiveProxies) {
this.usesTraditionalReflectiveProxies = usesTraditionalReflectiveProxies;
public String getUserOverridesAsString() {
return userOverridesAsString;
public void setUserOverridesAsString(String userOverridesAsString) {
this.userOverridesAsString = userOverridesAsString;
public int getMaxAdministrativeTaskTime() {
return maxAdministrativeTaskTime;
public void setMaxAdministrativeTaskTime(int maxAdministrativeTaskTime) {
this.maxAdministrativeTaskTime = maxAdministrativeTaskTime;
public int getMaxIdleTimeExcessConnections() {
return maxIdleTimeExcessConnections;
public void setMaxIdleTimeExcessConnections(int maxIdleTimeExcessConnections) {
this.maxIdleTimeExcessConnections = maxIdleTimeExcessConnections;
public int getMaxConnectionAge() {
return maxConnectionAge;
public void setMaxConnectionAge(int maxConnectionAge) {
this.maxConnectionAge = maxConnectionAge;
public String getConnectionCustomizerClassName() {
return connectionCustomizerClassName;
public void setConnectionCustomizerClassName(String connectionCustomizerClassName) {
this.connectionCustomizerClassName = connectionCustomizerClassName;
public int getUnreturnedConnectionTimeout() {
return unreturnedConnectionTimeout;
public void setUnreturnedConnectionTimeout(int unreturnedConnectionTimeout) {
this.unreturnedConnectionTimeout = unreturnedConnectionTimeout;
public boolean isDebugUnreturnedConnectionStackTraces() {
return debugUnreturnedConnectionStackTraces;
public void setDebugUnreturnedConnectionStackTraces(boolean debugUnreturnedConnectionStackTraces) {
this.debugUnreturnedConnectionStackTraces = debugUnreturnedConnectionStackTraces;
public String getFactoryClassLocation() {
return factoryClassLocation;
public void setFactoryClassLocation(String factoryClassLocation) {
this.factoryClassLocation = factoryClassLocation;
public int getAcquireIncrement() {
return acquireIncrement;
public void setAcquireIncrement(int acquireIncrement) {
this.acquireIncrement = acquireIncrement;
public int getAcquireRetryAttempts() {
return acquireRetryAttempts;
public void setAcquireRetryAttempts(int acquireRetryAttempts) {
this.acquireRetryAttempts = acquireRetryAttempts;
public int getAcquireRetryDelay() {
return acquireRetryDelay;
public void setAcquireRetryDelay(int acquireRetryDelay) {
this.acquireRetryDelay = acquireRetryDelay;
public String getOverrideDefaultUser() {
return overrideDefaultUser;
public void setOverrideDefaultUser(String overrideDefaultUser) {
this.overrideDefaultUser = overrideDefaultUser;
public String getOverrideDefaultPassword() {
return overrideDefaultPassword;
public void setOverrideDefaultPassword(String overrideDefaultPassword) {
this.overrideDefaultPassword = overrideDefaultPassword;
public int getPropertyCycle() {
return propertyCycle;
public void setPropertyCycle(int propertyCycle) {
this.propertyCycle = propertyCycle;
public boolean isBreakAfterAcquireFailure() {
return breakAfterAcquireFailure;
public void setBreakAfterAcquireFailure(boolean breakAfterAcquireFailure) {
this.breakAfterAcquireFailure = breakAfterAcquireFailure;
public interface DruidDataSourceC3P0AdapterMBean {
String getUser();
int getCheckoutTimeout();
boolean isAutoCommitOnClose();
int getIdleConnectionTestPeriod();
int getInitialPoolSize();
int getMaxIdleTime();
int getMaxPoolSize();
int getMinPoolSize();
boolean isTestConnectionOnCheckout();
boolean isTestConnectionOnCheckin();
String getPreferredTestQuery();
int getNumIdleConnections();
int getNumConnections();
String getDataSourceName();
int getNumBusyConnections();
boolean isEnable();
void shrink();
String toString();
int getWaitThreadCount();
int getLockQueueLength();
void close();
public String getDriverClass() {
return dataSource.getDriverClassName();
public void setDriverClass(String driverClass) {
dataSource.setDriverClassName(driverClass);
public String getJdbcUrl() {
return dataSource.getUrl();
public void setJdbcUrl(String jdbcUrl) {
dataSource.setUrl(jdbcUrl);
public Properties getProperties() {
return dataSource.getConnectProperties();
public void setProperties(Properties properties) {
dataSource.setConnectProperties(properties);
return (int) (dataSource.getTimeBetweenEvictionRunsMillis() / 1000);
dataSource.setTimeBetweenEvictionRunsMillis(((long) idleConnectionTestPeriod) * 1000L);
return (int) dataSource.getMinEvictableIdleTimeMillis() / 1000;
dataSource.setMinEvictableIdleTimeMillis(((long) maxIdleTime) * 1000L);
String getDriverClass();
String getJdbcUrl();
Properties getProperties();
protected int                                                                            maxPoolPreparedStatementPerConnectionSize              = -1;
protected Date                                                                           createdTime;
public int getMaxPoolPreparedStatementPerConnectionSize() {
return maxPoolPreparedStatementPerConnectionSize;
public void setMaxPoolPreparedStatementPerConnectionSize(int maxPoolPreparedStatementPerConnectionSize) {
this.maxPoolPreparedStatementPerConnectionSize = maxPoolPreparedStatementPerConnectionSize;
public abstract void handleConnectionException(PoolableConnection pooledConnection, Throwable t)
throws SQLException;
public int getMaxStatementsPerConnection() {
return dataSource.getMaxPoolPreparedStatementPerConnectionSize();
public void setMaxStatementsPerConnection(int maxStatementsPerConnection) {
dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxStatementsPerConnection);
public enum StatementCacheAlgorithm {
LRU, Fixed
map.put("ResultSetErrorCount", null);
public class TestStat extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
protected void tearDown() throws Exception {
dataSource.close();
public void test_stat() throws Exception {
String sql = "SELECT 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
conn.close();
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(true, rs.isClosed());
rs.close();
stmt.close();
JdbcStatManager.getInstance().getDataSourceList();
for (DruidDataSource instance : DruidDataSource.getInstances()) {
for (Filter filter : instance.getProxyFilters()) {
if (filter instanceof StatFilter) {
StatFilter countFilter = (StatFilter) filter;
countFilter.reset();
private final static DruidDataSourceStatManager                         instance  = new DruidDataSourceStatManager();
public static DruidDataSourceStatManager getInstance() {
return instance;
public static Set<DruidDataSource> getDruidDataSourceInstances() {
public TabularData getDataSourceList() throws JMException {
CompositeType rowType = getDruidDataSourceCompositeType();
String[] indexNames = rowType.keySet().toArray(new String[rowType.keySet().size()]);
TabularType tabularType = new TabularType("DruidDataSourceStat", "DruidDataSourceStat", rowType, indexNames);
TabularData data = new TabularDataSupport(tabularType);
final Set<DruidDataSource> dataSources = getDruidDataSourceInstances();
for (DruidDataSource dataSource : dataSources) {
data.put(getCompositeData(dataSource));
return data;
public CompositeDataSupport getCompositeData(DruidDataSource dataSource) throws JMException {
CompositeType rowType = getDruidDataSourceCompositeType();
Map<String, Object> map = new HashMap<String, Object>();
map.put("Name", dataSource.getName());
map.put("URL", dataSource.getUrl());
map.put("CreateCount", dataSource.getCreateCount());
map.put("DestroyCount", dataSource.getDestroyCount());
map.put("ConnectCount", dataSource.getConnectCount());
map.put("CloseCount", dataSource.getCloseCount());
map.put("ActiveCount", dataSource.getActiveCount());
map.put("PoolingCount", dataSource.getPoolingCount());
map.put("LockQueueLength", dataSource.getLockQueueLength());
map.put("WaitThreadCount", dataSource.getWaitThreadCount());
map.put("InitialSize", dataSource.getInitialSize());
map.put("MaxActive", dataSource.getMaxActive());
map.put("MinIdle", dataSource.getMinIdle());
map.put("PoolPreparedStatements", dataSource.isPoolPreparedStatements());
map.put("TestOnBorrow", dataSource.isTestOnBorrow());
map.put("TestOnReturn", dataSource.isTestOnReturn());
map.put("MinEvictableIdleTimeMillis", dataSource.getMinEvictableIdleTimeMillis());
map.put("ConnectErrorCount", dataSource.getConnectErrorCount());
map.put("CreateTimespanMillis", dataSource.getCreateTimespanMillis());
map.put("DbType", dataSource.getDbType());
map.put("ValidationQuery", dataSource.getValidationQuery());
map.put("ValidationQueryTimeout", dataSource.getValidationQueryTimeout());
map.put("DriverClassName", dataSource.getDriverClassName());
map.put("Username", dataSource.getUsername());
return new CompositeDataSupport(rowType, map);
private static CompositeType COMPOSITE_TYPE = null;
public static CompositeType getDruidDataSourceCompositeType() throws JMException {
if (COMPOSITE_TYPE != null) {
return COMPOSITE_TYPE;
OpenType<?>[] indexTypes = new OpenType<?>[] {
SimpleType.STRING, SimpleType.STRING, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, 
SimpleType.LONG, SimpleType.INTEGER, SimpleType.INTEGER, SimpleType.INTEGER, SimpleType.INTEGER, 
SimpleType.INTEGER, SimpleType.INTEGER, SimpleType.INTEGER, SimpleType.BOOLEAN, SimpleType.BOOLEAN, 
SimpleType.BOOLEAN, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.STRING, 
SimpleType.STRING, SimpleType.INTEGER, SimpleType.STRING, SimpleType.STRING,
String[] indexNames = {
"Name", "URL", "CreateCount", "DestroyCount", "ConnectCount", 
"CloseCount", "ActiveCount", "PoolingCount", "LockQueueLength", "WaitThreadCount", 
"InitialSize", "MaxActive", "MinIdle", "PoolPreparedStatements", "TestOnBorrow", 
"TestOnReturn", "MinEvictableIdleTimeMillis", "ConnectErrorCount", "CreateTimespanMillis", "DbType", 
"ValidationQuery", "ValidationQueryTimeout", "DriverClassName", "Username"
String[] indexDescriptions = indexNames;
COMPOSITE_TYPE = new CompositeType("DataSourceStatistic", "DataSource Statistic", indexNames,
indexDescriptions, indexTypes);
return COMPOSITE_TYPE;
TabularData getDataSourceList() throws JMException;
final Set<DruidDataSource> dataSources = DruidDataSourceStatManager.getDruidDataSourceInstances();
for (DruidDataSource instance : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
for (DruidDataSource instance : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
DruidDataSourceStatManager.getInstance().getDataSourceList();
public final class ConnectionHolder implements PooledConnection {
public void close() throws SQLException {
this.reset();
JdbcUtils.close(this.conn);
public void addConnectionEventListener(ConnectionEventListener listener) {
connectionEventListeners.add(listener);
public void removeConnectionEventListener(ConnectionEventListener listener) {
connectionEventListeners.remove(listener);
public void addStatementEventListener(StatementEventListener listener) {
statementEventListeners.add(listener);
public void removeStatementEventListener(StatementEventListener listener) {
statementEventListeners.remove(listener);
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
ManagementFactory.getPlatformMBeanServer().registerMBean(DruidDataSourceStatManager.getInstance(), new ObjectName("com.alibaba.druid:type=DruidDataSourceStat"));
public TabularData getDruidDataSourceList() throws JMException {
return DruidDataSourceStatManager.getInstance().getDataSourceList();
DruidDataSourceStatManager.getInstance().reset();
public TabularData getDruidDataSourceList() throws JMException;
this.setInitialPoolSize(3);
this.setAcquireIncrement(3);
this.setAcquireIncrement(30);
this.setAcquireRetryDelay(1000);
this.setAutoCommitOnClose(false);
this.setAutomaticTestTable(null);
this.setCheckoutTimeout(0);
this.setDebugUnreturnedConnectionStackTraces(false);
this.setMaxIdleTime(0);
this.setMaxPoolSize(15);
this.setMaxStatements(0);
this.setMaxStatementsPerConnection(0);
this.setMinPoolSize(3);
this.setTestConnectionOnCheckin(false);
this.setTestConnectionOnCheckout(false);
return (int) dataSource.getTimeBetweenConnectErrorMillis();
dataSource.setTimeBetweenConnectErrorMillis(acquireRetryDelay);
if (activeCount + poolingCount >= maxActive) {
if (poolingCount >= waitThreadCount) {
notEmpty.signal(); 
int waitThreadCount = lock.getWaitQueueLength(notEmpty);
private final static Log                                                LOG        = LogFactory.getLog(DruidDataSourceStatManager.class);
private final static DruidDataSourceStatManager                         instance   = new DruidDataSourceStatManager();
private static final Object                                             PRESENT    = new Object();
private static final ConcurrentIdentityHashMap<DruidDataSource, Object> instances  = new ConcurrentIdentityHashMap<DruidDataSource, Object>();
private final static String                                             MBEAN_NAME = "com.alibaba.druid:type=DruidDataSourceStat";
public synchronized static void add(DruidDataSource dataSource) {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
if (instances.size() == 0) {
mbeanServer.registerMBean(instance, new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("register mbean error", ex);
int id = System.identityHashCode(dataSource);
mbeanServer.registerMBean(dataSource, new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + id));
} catch (JMException ex) {
LOG.error("register mbean error", ex);
public synchronized static void remove(DruidDataSource dataSource) {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
int id = System.identityHashCode(dataSource);
mbeanServer.unregisterMBean(new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + id));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
if (instances.size() == 0) {
mbeanServer.unregisterMBean(new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
public String getNameInternal() {
return this.name;
private final static Log                                                    LOG        = LogFactory.getLog(DruidDataSourceStatManager.class);
private final static DruidDataSourceStatManager                             instance   = new DruidDataSourceStatManager();
private static final ConcurrentIdentityHashMap<DruidDataSource, ObjectName> instances  = new ConcurrentIdentityHashMap<DruidDataSource, ObjectName>();
private final static String                                                 MBEAN_NAME = "com.alibaba.druid:type=DruidDataSourceStat";
ObjectName objectName = null;
if (dataSource.getNameInternal() != null) {
objectName = new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + dataSource.getNameInternal());
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
if (objectName == null) {
int id = System.identityHashCode(dataSource);
objectName = new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + id);
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
instances.put(dataSource, objectName);
ObjectName objectName = instances.remove(dataSource);
if (objectName != null) {
mbeanServer.unregisterMBean(objectName);
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
dataSource.close();
dataSource.close();
dataSource.close();
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/spring-config-1.xml");
context.close();
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
dataSource.close();
dataSource.close();
dataSource.setName("com.alibaba.dragoon.monitor");
private final static Log                                                    LOG         = LogFactory.getLog(DruidDataSourceStatManager.class);
private final static DruidDataSourceStatManager                             instance    = new DruidDataSourceStatManager();
private final AtomicLong                                                    resetCount  = new AtomicLong();
private static final ConcurrentIdentityHashMap<DruidDataSource, ObjectName> dataSources = new ConcurrentIdentityHashMap<DruidDataSource, ObjectName>();
private final static String                                                 MBEAN_NAME  = "com.alibaba.druid:type=DruidDataSourceStat";
if (dataSources.size() == 0) {
dataSources.put(dataSource, objectName);
ObjectName objectName = dataSources.remove(dataSource);
if (dataSources.size() == 0) {
return dataSources.keySet();
resetCount.incrementAndGet();
public long getResetCount() {
return resetCount.get();
long getResetCount();
LOG.error(buf.toString());
ConnectionHolder holder = this.holder;
LOG.error("dup close");
this.holder = null;
rs.close();
long currentMillis = System.currentTimeMillis();
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-09-09 20:33";
public int getRemoveAbandonedTimeoutMillis() {
return removeAbandonedTimeoutMillis;
int getRemoveAbandonedTimeoutMillis();
buf.append("abandon connection, open stackTracen");
protected long                                                                           removeAbandonedTimeoutMillis              = 300 * 1000;
boolean isLogAbandoned();
dataSource.setRemoveAbandonedTimeoutMillis(10);
Assert.assertEquals(1, dataSource.getRemoveAbandonedCount());
public class TestPoolPreparedStatement extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(10); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_removeAbandoned() throws Exception {
MockPreparedStatement raw;
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT ?");
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT ?");
Assert.assertTrue(raw == stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
long getDupCloseCount();
boolean isBreakAfterAcquireFailure();
int getConnectionErrorRetryAttempts();
int getMaxPoolPreparedStatementPerConnectionSize();
String getProperties();
int getRawDriverMinorVersion();
int getRawDriverMajorVersion();
Date getCreatedTime();
public final static String         ATTR_TRANSACTION           = "stat.tx";
protected final AtomicLong         resetCount                 = new AtomicLong();
resetCount.incrementAndGet();
public long getResetCount() {
return resetCount.get();
transInfo = new TransactionInfo(transactionId);
long getResetCount();
dataSource.setMaxActive(1000);
dataSource.setMaxIdle(1000);
final int threadCount = 1000;
for (int i = 0; i < 10; ++i) {
for (int i = 0; i < 10; ++i) {
} catch (DataSourceDisableException ex) {
dataSource.setTimeBetweenEvictionRunsMillis(10);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000);
Thread.sleep(200);
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
for (int i = 0; i < 1000 * 1; ++i) {
if (objectName == null) {
for (int i = 0; i < 3; ++i) {
for (int i = 0; i < 3; ++i) {
for (int i = 0; i < 3; ++i) {
for (int i = 0; i < 3; ++i) {
for (int i = 0; i < 3; ++i) {
for (int i = 0; i < 3; ++i) {
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public String getValidConnectionCheckerClassName() {
if (validConnectionChecker == null) {
return null;
return validConnectionChecker.getClass().getName();
public void setValidConnectionCheckerClassName(String validConnectionCheckerClass) throws Exception {
String getValidConnectionCheckerClassName();
protected final AtomicLong                                                               commitCount                               = new AtomicLong();
protected final AtomicLong                                                               rollbackCount                             = new AtomicLong();
public long getCommitCount() {
return commitCount.get();
public void incrementCommitCount() {
commitCount.incrementAndGet();
public long getRollbackCount() {
return rollbackCount.get();
public void incrementRollbackCount() {
rollbackCount.incrementAndGet();
long getCommitCount();
long getRollbackCount();
holder.getDataSource().incrementCommitCount();
holder.getDataSource().incrementRollbackCount();
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-09-11 17:31";
private long loginTimeoutMillis = 0;
loginTimeoutMillis = seconds * 1000;
public int getLoginTimeout() {
return (int) loginTimeoutMillis * 1000;
int getLoginTimeout();
DriverManager.setLoginTimeout(seconds);
return DriverManager.getLoginTimeout();
public void setLoginTimeout(int seconds) {
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
dataSource.close();
map.put("ResultSetErrorCount", null);
private final static Log   LOG                        = LogFactory.getLog(PoolableConnection.class);
protected long             startTransactionTimeMillis = 0;
PreparedStatement stmt = null;
startTransactionTimeMillis = System.currentTimeMillis();
} finally {
startTransactionTimeMillis = 0;
public long getStartTransactionTimeMillis() {
return startTransactionTimeMillis;
public class PoolableResultSetTest extends TestCase {
public void test_0() throws Exception {
PoolableStatement stmt = new PoolableStatement(null, null) {
protected SQLException checkException(Throwable error) throws SQLException {
if (error instanceof SQLException) {
return (SQLException) error;
return new SQLException(error);
MockResultSet raw = new MockResultSet(null);
raw.getRows().add(new Object[] {null});
PoolableResultSet resultSet = new PoolableResultSet(stmt, raw);
Assert.assertTrue(stmt == resultSet.getPoolableStatement());
Assert.assertTrue(raw == resultSet.getRawResultSet());
Assert.assertTrue(resultSet.next());
Assert.assertTrue(resultSet.wasNull() == false);
resultSet.getString(1);
Assert.assertTrue(resultSet.wasNull());
resultSet.getBoolean(1);
resultSet.getByte(1);
resultSet.getShort(1);
resultSet.getInt(1);
resultSet.getLong(1);
resultSet.getFloat(1);
resultSet.getDouble(1);
resultSet.getBigDecimal(1);
resultSet.getBigDecimal(1, 1);
resultSet.getBytes(1);
resultSet.getDate(1);
resultSet.getTime(1);
resultSet.getTimestamp(1);
resultSet.getAsciiStream(1);
resultSet.getUnicodeStream(1);
resultSet.getBinaryStream(1);
resultSet.getString("1");
resultSet.getBoolean("1");
resultSet.getByte("1");
resultSet.getShort("1");
resultSet.getInt("1");
resultSet.getLong("1");
resultSet.getFloat("1");
resultSet.getDouble("1");
resultSet.getBigDecimal("1");
resultSet.getBigDecimal("1", 1);
resultSet.getBytes("1");
resultSet.getDate("1");
resultSet.getTime("1");
resultSet.getTimestamp("1");
resultSet.getAsciiStream("1");
resultSet.getUnicodeStream("1");
resultSet.getBinaryStream("1");
raw.getRows().add(new Object[] { null });
SQLException error = null;
resultSet.getString(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBoolean(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getByte(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getShort(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getInt(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getLong(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getFloat(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getDouble(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBigDecimal(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBigDecimal(0, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBytes(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getDate(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTime(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTimestamp(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getAsciiStream(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getUnicodeStream(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBinaryStream(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
concurrent(driver, dataSource, 30);
return (BigDecimal) getObject(columnIndex);
public class TraceFilterTest extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("trace");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_exuecute() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1");
stmt.close();
conn.close();
public void test_exuecuteQuery() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.next();
rs.close();
stmt.close();
conn.close();
public void test_preExuecuteQuery() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT ?");
stmt.setInt(1, 123);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
private TraceFilter filter;
filter = (TraceFilter) dataSource.getProxyFilters().get(0);
JdbcStatContext statContext = new JdbcStatContext();
statContext.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(statContext);
JdbcStatManager.getInstance().setStatContext(null);
@SuppressWarnings("deprecation")
SQLException error = null;
resultSet.getString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBoolean("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getByte("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getShort("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getInt("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getLong("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getFloat("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getDouble("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBigDecimal("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBigDecimal("0", 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBytes("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getDate("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTime("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTimestamp("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getAsciiStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getUnicodeStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBinaryStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return getString(Integer.parseInt(columnLabel));
return getBoolean(Integer.parseInt(columnLabel));
return getByte(Integer.parseInt(columnLabel));
return getShort(Integer.parseInt(columnLabel));
return getInt(Integer.parseInt(columnLabel));
return getLong(Integer.parseInt(columnLabel));
return getFloat(Integer.parseInt(columnLabel));
return getDouble(Integer.parseInt(columnLabel));
return getBigDecimal(Integer.parseInt(columnLabel), scale);
return getBytes(Integer.parseInt(columnLabel));
return getDate(Integer.parseInt(columnLabel));
return getTime(Integer.parseInt(columnLabel));
return getTimestamp(Integer.parseInt(columnLabel));
return getAsciiStream(Integer.parseInt(columnLabel));
return getUnicodeStream(Integer.parseInt(columnLabel));
return getBinaryStream(Integer.parseInt(columnLabel));
return getBigDecimal(Integer.parseInt(columnLabel));
public class PoolableCallableStatementTest extends TestCase {
public void test_callableStmt() throws Exception {
MockCallableStatement raw = new MockCallableStatement(null, null);
PoolableCallableStatement stmt = new PoolableCallableStatement(null, raw, null) {
protected SQLException checkException(Throwable error) throws SQLException {
if (error instanceof SQLException) {
return (SQLException) error;
return new SQLException(error);
Assert.assertEquals(0, raw.getParameters().size());
raw.registerOutParameter(1, Types.INTEGER);
Assert.assertEquals(1, raw.getParameters().size());
Assert.assertTrue(stmt.wasNull() == false);
stmt.getString(1);
Assert.assertTrue(stmt.wasNull());
stmt.getBoolean(1);
stmt.getByte(1);
stmt.getShort(1);
stmt.getInt(1);
stmt.getLong(1);
stmt.getFloat(1);
stmt.getDouble(1);
stmt.getBigDecimal(1);
stmt.getBigDecimal(1, 1);
stmt.getBytes(1);
stmt.getDate(1);
stmt.getTime(1);
stmt.getTimestamp(1);
stmt.getString("1");
stmt.getBoolean("1");
stmt.getByte("1");
stmt.getShort("1");
stmt.getInt("1");
stmt.getLong("1");
stmt.getFloat("1");
stmt.getDouble("1");
stmt.getBigDecimal("1");
stmt.getBytes("1");
stmt.getDate("1");
stmt.getTime("1");
stmt.getTimestamp("1");
SQLException error = null;
stmt.getString(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBoolean(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getByte(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getShort(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getInt(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getLong(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getFloat(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDouble(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBigDecimal(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBigDecimal(0, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBytes(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDate(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTime(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTimestamp(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBoolean("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getByte("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getShort("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getInt("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getLong("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getFloat("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDouble("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBigDecimal("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBytes("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDate("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTime("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTimestamp("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
private final List<Object> parameters = new ArrayList<Object>();
private boolean            wasNull    = false;
public List<Object> getParameters() {
return parameters;
parameters.add(null);
parameters.add(null);
return wasNull;
public String getString(int columnIndex) throws SQLException {
return (String) getObject(columnIndex);
public boolean getBoolean(int columnIndex) throws SQLException {
Object obj = getObject(columnIndex);
if (obj == null) {
return false;
return ((Boolean) obj).booleanValue();
public byte getByte(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.byteValue();
public short getShort(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.shortValue();
public int getInt(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.intValue();
public long getLong(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.longValue();
public float getFloat(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.floatValue();
public double getDouble(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.doubleValue();
public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
return (BigDecimal) getObject(columnIndex);
public byte[] getBytes(int columnIndex) throws SQLException {
return (byte[]) getObject(columnIndex);
public Date getDate(int columnIndex) throws SQLException {
return (Date) getObject(columnIndex);
public Time getTime(int columnIndex) throws SQLException {
return (Time) getObject(columnIndex);
public Timestamp getTimestamp(int columnIndex) throws SQLException {
return (Timestamp) getObject(columnIndex);
public String getString(String columnLabel) throws SQLException {
return getString(Integer.parseInt(columnLabel));
public boolean getBoolean(String columnLabel) throws SQLException {
return getBoolean(Integer.parseInt(columnLabel));
public byte getByte(String columnLabel) throws SQLException {
return getByte(Integer.parseInt(columnLabel));
public short getShort(String columnLabel) throws SQLException {
return getShort(Integer.parseInt(columnLabel));
public int getInt(String columnLabel) throws SQLException {
return getInt(Integer.parseInt(columnLabel));
public long getLong(String columnLabel) throws SQLException {
return getLong(Integer.parseInt(columnLabel));
public float getFloat(String columnLabel) throws SQLException {
return getFloat(Integer.parseInt(columnLabel));
public double getDouble(String columnLabel) throws SQLException {
return getDouble(Integer.parseInt(columnLabel));
public byte[] getBytes(String columnLabel) throws SQLException {
return getBytes(Integer.parseInt(columnLabel));
public Date getDate(String columnLabel) throws SQLException {
return getDate(Integer.parseInt(columnLabel));
public Time getTime(String columnLabel) throws SQLException {
return getTime(Integer.parseInt(columnLabel));
public Timestamp getTimestamp(String columnLabel) throws SQLException {
return getTimestamp(Integer.parseInt(columnLabel));
Object obj = parameters.get(parameterIndex - 1);
wasNull = (obj == null);
return obj;
return (BigDecimal) getObject(parameterIndex);
parameters.add(null);
parameters.add(null);
parameters.add(null);
parameters.add(null);
return getBigDecimal(Integer.parseInt(parameterName));
public static class PreparedStatementKey {
public class PrepareStatementTest extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_prepare() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_prepare2() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
public void test_prepareCall() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1");
stmt.close();
conn.close();
public void test_prepareCall1() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_prepareCall2() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
public class ConnectionStatementTest extends TestCase {
public void test_create() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.close();
conn.close();
public void test_create1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_create2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
public void test_prepare3() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new int[0]);
stmt.close();
conn.close();
public void test_prepare4() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new String[0]);
stmt.close();
conn.close();
public void test_prepare5() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", Statement.RETURN_GENERATED_KEYS);
stmt.close();
conn.close();
public class ConnectionStatementTest2 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_prepare() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_prepare2() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
public void test_prepare3() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new int[0]);
stmt.close();
conn.close();
public void test_prepare4() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new String[0]);
stmt.close();
conn.close();
public void test_prepare5() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", Statement.RETURN_GENERATED_KEYS);
stmt.close();
conn.close();
public void test_prepareCall() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1");
stmt.close();
conn.close();
public void test_prepareCall1() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_prepareCall2() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
public void test_create() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.close();
conn.close();
public void test_create1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY);
stmt.close();
conn.close();
public void test_create2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
stmt.close();
conn.close();
dataSource.resetStat();
Assert.assertEquals(0, dataSource.getCreateCount());
public class TestDataSourceBasic extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
dataSource.setRemoveAbandoned(true);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_prepare() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(1, dataSource.getActiveConnectionStackTrace().size());
Assert.assertEquals(1, dataSource.getActiveConnections().size());
conn.close();
Assert.assertEquals(0, dataSource.getActiveConnectionStackTrace().size());
Assert.assertEquals(0, dataSource.getActiveConnections().size());
Assert.assertEquals(true, dataSource.getCreateTimespanNano() > 0);
conn.setAutoCommit(false);
conn.setAutoCommit(false);
conn.commit();
Assert.assertEquals(1, dataSource.getStartTransactionCount());
Assert.assertEquals(1, dataSource.getCommitCount());
Assert.assertEquals(0, dataSource.getRollbackCount());
@SuppressWarnings("unchecked")
if (iface == PoolableConnection.class) {
return (T) this;
if (iface == PoolableConnection.class) {
return true;
PoolableConnection wrap = conn.unwrap(PoolableConnection.class);
Assert.assertTrue(wrap.isWrapperFor(PoolableConnection.class));
Assert.assertNotNull(wrap);
PoolableConnection wrap = conn.unwrap(PoolableConnection.class);
Assert.assertTrue(conn.isWrapperFor(PoolableConnection.class));
Assert.assertNotNull(wrap);
Statement wrap = conn.unwrap(Statement.class);
Assert.assertTrue(!conn.isWrapperFor(Statement.class));
Assert.assertNull(wrap);
public class TestCommit extends TestCase {
updateObject(columnIndex, null);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
Object[] row = rows.get(rowIndex);
row[columnIndex - 1] = x;
updateObject(columnLabel, null);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, x);
updateObject(columnLabel, reader);
updateObject(columnLabel, x);
updateObject(Integer.parseInt(columnLabel), x);
public class ResultSetTest extends TestCase {
private PoolableStatement stmt;
private MockResultSet     raw;
private PoolableResultSet resultSet;
protected void setUp() throws Exception {
stmt = new PoolableStatement(null, null) {
raw = new MockResultSet(null);
resultSet = new PoolableResultSet(stmt, raw);
@SuppressWarnings("deprecation")
public void test_get() throws Exception {
public void test_set() throws Exception {
long currentMillis = System.currentTimeMillis();
Assert.assertTrue(resultSet.next());
resultSet.updateNull(1);
Assert.assertNull(resultSet.getString(1));
resultSet.updateBoolean(1, true);
Assert.assertEquals(true, resultSet.getBoolean(1));
resultSet.updateByte(1, (byte) 12);
Assert.assertEquals(12, resultSet.getByte(1));
resultSet.updateShort(1, (short) 23);
Assert.assertEquals(23, resultSet.getShort(1));
resultSet.updateInt(1, 34);
Assert.assertEquals(34, resultSet.getInt(1));
resultSet.updateLong(1, 45);
Assert.assertEquals(45, resultSet.getLong(1));
resultSet.updateFloat(1, 1.0F);
Assert.assertEquals(true, 1.0F == resultSet.getFloat(1));
resultSet.updateDouble(1, 2.0D);
Assert.assertEquals(true, 2.0D == resultSet.getDouble(1));
resultSet.updateBigDecimal(1, new BigDecimal("33"));
Assert.assertEquals(new BigDecimal("33"), resultSet.getBigDecimal(1));
resultSet.updateString(1, "xxx");
Assert.assertEquals("xxx", resultSet.getString(1));
resultSet.updateBytes(1, new byte[0]);
Assert.assertEquals(0, resultSet.getBytes(1).length);
resultSet.updateDate(1, new java.sql.Date(currentMillis));
Assert.assertEquals(new java.sql.Date(currentMillis), resultSet.getDate(1));
resultSet.updateTime(1, new java.sql.Time(1000));
Assert.assertEquals(new java.sql.Time(1000), resultSet.getTime(1));
resultSet.updateTimestamp(1, new java.sql.Timestamp(currentMillis));
Assert.assertEquals(new java.sql.Timestamp(currentMillis), resultSet.getTimestamp(1));
public void test_get_error() throws Exception {
public void test_set_error() throws Exception {
long currentMillis = System.currentTimeMillis();
Assert.assertTrue(resultSet.next());
SQLException error = null;
resultSet.updateNull(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBoolean(0, true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateByte(0, (byte) 12);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateShort(0, (short) 23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateInt(0, 34);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateLong(0, 45);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateFloat(0, 1.0F);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateDouble(0, 2.0D);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBigDecimal(0, new BigDecimal("33"));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateString(0, "xxx");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBytes(0, new byte[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateDate(0, new java.sql.Date(currentMillis));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateTime(0, new java.sql.Time(1000));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateTimestamp(0, new java.sql.Timestamp(currentMillis));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setByName() throws Exception {
long currentMillis = System.currentTimeMillis();
Assert.assertTrue(resultSet.next());
resultSet.updateNull("1");
Assert.assertNull(resultSet.getString(1));
resultSet.updateBoolean("1", true);
Assert.assertEquals(true, resultSet.getBoolean("1"));
resultSet.updateByte("1", (byte) 12);
Assert.assertEquals(12, resultSet.getByte("1"));
resultSet.updateShort("1", (short) 23);
Assert.assertEquals(23, resultSet.getShort("1"));
resultSet.updateInt("1", 34);
Assert.assertEquals(34, resultSet.getInt("1"));
resultSet.updateLong("1", 45);
Assert.assertEquals(45, resultSet.getLong("1"));
resultSet.updateFloat("1", 1.0F);
Assert.assertEquals(true, 1.0F == resultSet.getFloat("1"));
resultSet.updateDouble("1", 2.0D);
Assert.assertEquals(true, 2.0D == resultSet.getDouble("1"));
resultSet.updateBigDecimal("1", new BigDecimal("33"));
Assert.assertEquals(new BigDecimal("33"), resultSet.getBigDecimal("1"));
resultSet.updateString("1", "xxx");
Assert.assertEquals("xxx", resultSet.getString("1"));
resultSet.updateBytes("1", new byte[0]);
Assert.assertEquals(0, resultSet.getBytes("1").length);
resultSet.updateDate("1", new java.sql.Date(currentMillis));
Assert.assertEquals(new java.sql.Date(currentMillis), resultSet.getDate("1"));
resultSet.updateTime("1", new java.sql.Time(1000));
Assert.assertEquals(new java.sql.Time(1000), resultSet.getTime("1"));
resultSet.updateTimestamp("1", new java.sql.Timestamp(currentMillis));
Assert.assertEquals(new java.sql.Timestamp(currentMillis), resultSet.getTimestamp("1"));
public void test_setByLabel_error() throws Exception {
long currentMillis = System.currentTimeMillis();
Assert.assertTrue(resultSet.next());
SQLException error = null;
resultSet.updateNull("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBoolean("0", true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateByte("0", (byte) 12);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateShort("0", (short) 23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateInt("0", 34);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateLong("0", 45);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateFloat("0", 1.0F);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateDouble("0", 2.0D);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBigDecimal("0", new BigDecimal("33"));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateString("0", "xxx");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBytes("0", new byte[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateDate("0", new java.sql.Date(currentMillis));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateTime("0", new java.sql.Time(1000));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateTimestamp("0", new java.sql.Timestamp(currentMillis));
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
public void updateBlob(int columnIndex, InputStream x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateClob(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnIndex, x);
updateObject(columnLabel, x);
public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void updateBlob(int columnIndex, InputStream x) throws SQLException {
updateObject(columnIndex, x);
public void updateBlob(String columnLabel, InputStream x) throws SQLException {
updateObject(columnLabel, x);
public void updateClob(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateClob(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void test_updateByLabel_error() throws Exception {
public void test_updateBinaryStream() throws Exception {
resultSet.next();
resultSet.updateBinaryStream(1, (InputStream) null);
resultSet.updateBinaryStream("1", (InputStream) null);
SQLException error = null;
resultSet.updateBinaryStream("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBinaryStream(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateCharacterStream() throws Exception {
resultSet.next();
resultSet.updateCharacterStream(1, (Reader) null);
resultSet.updateCharacterStream("1", (Reader) null);
SQLException error = null;
resultSet.updateCharacterStream("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateCharacterStream(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_update_blob() throws Exception {
resultSet.next();
resultSet.updateBlob(1, (InputStream) null);
resultSet.updateBlob("1", (InputStream) null);
SQLException error = null;
resultSet.updateBlob("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBlob(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_update_clob() throws Exception {
resultSet.next();
resultSet.updateClob(1, (Reader) null);
resultSet.updateClob("1", (Reader) null);
SQLException error = null;
resultSet.updateClob("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateClob(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_update_nclob() throws Exception {
resultSet.next();
resultSet.updateNClob(1, (Reader) null);
resultSet.updateNClob("1", (Reader) null);
SQLException error = null;
resultSet.updateNClob("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNClob(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
rs.next();
public void test_update_nclob_1() throws Exception {
resultSet.next();
resultSet.updateNClob(1, (Reader) null, 1);
resultSet.updateNClob("1", (Reader) null, 1);
SQLException error = null;
resultSet.updateNClob("0", (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNClob(0, (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_update_clob_1() throws Exception {
resultSet.next();
resultSet.updateClob(1, (Reader) null, 1);
resultSet.updateClob("1", (Reader) null, 1);
SQLException error = null;
resultSet.updateClob("0", (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateClob(0, (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_update_blob_1() throws Exception {
resultSet.next();
resultSet.updateBlob(1, (InputStream) null, 1);
resultSet.updateBlob("1", (InputStream) null, 1);
SQLException error = null;
resultSet.updateBlob("0", (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBlob(0, (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateCharacterStream_1() throws Exception {
resultSet.next();
resultSet.updateCharacterStream(1, (Reader) null, 1);
resultSet.updateCharacterStream("1", (Reader) null, 1);
SQLException error = null;
resultSet.updateCharacterStream("0", (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateCharacterStream(0, (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateAsciiStream_1() throws Exception {
resultSet.next();
resultSet.updateAsciiStream(1, (InputStream) null, 1);
resultSet.updateAsciiStream("1", (InputStream) null, 1);
SQLException error = null;
resultSet.updateAsciiStream("0", (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBlob(0, (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateBinaryStream_1() throws Exception {
resultSet.next();
resultSet.updateBinaryStream(1, (InputStream) null, 1);
resultSet.updateBinaryStream("1", (InputStream) null, 1);
SQLException error = null;
resultSet.updateBinaryStream("0", (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBinaryStream(0, (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateAsciiStream() throws Exception {
resultSet.next();
resultSet.updateAsciiStream(1, (InputStream) null);
resultSet.updateAsciiStream("1", (InputStream) null);
SQLException error = null;
resultSet.updateAsciiStream("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateAsciiStream(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateNCharacterStream() throws Exception {
resultSet.next();
resultSet.updateNCharacterStream(1, (Reader) null);
resultSet.updateNCharacterStream("1", (Reader) null);
SQLException error = null;
resultSet.updateNCharacterStream("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNCharacterStream(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void updateNString(int columnIndex, String x) throws SQLException {
updateObject(columnIndex, x);
public void updateNString(String columnLabel, String x) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(int columnIndex, NClob x) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(String columnLabel, NClob x) throws SQLException {
updateObject(columnLabel, x);
return (NClob) getObject(columnIndex);
return (NClob) getObject(columnLabel);
return (SQLXML) getObject(columnIndex);
return (SQLXML) getObject(columnLabel);
public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
updateObject(columnIndex, x);
public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
updateObject(columnLabel, x);
return (String) getObject(columnIndex);
return (String) getObject(columnLabel);
return (Reader) getNCharacterStream(columnIndex);
return (Reader) getNCharacterStream(columnLabel);
updateObject(columnLabel, x);
public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateBlob(String columnLabel, InputStream x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateClob(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
updateObject(columnLabel, x);
public void test_updateSQLXML() throws Exception {
resultSet.next();
resultSet.updateSQLXML(1, (SQLXML) null);
resultSet.updateSQLXML("1", (SQLXML) null);
SQLException error = null;
resultSet.updateSQLXML("0", (SQLXML) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateSQLXML(0, (SQLXML) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return getObject(parameterIndex);
return (Ref) getObject(parameterIndex);
return (Blob) getObject(parameterIndex);
return (Clob) getObject(parameterIndex);
return (Array) getObject(parameterIndex);
return (Date) getObject(parameterIndex);
return (Time) getObject(parameterIndex);
return (Timestamp) getObject(parameterIndex);
return getObject(Integer.parseInt(parameterName));
return getObject(parameterName);
return (Ref) getObject(parameterName);
return (Blob) getObject(parameterName);
return (Clob) getObject(parameterName);
return (Array) getObject(parameterName);
return (Date) getObject(parameterName);
return (Time) getObject(parameterName);
return (Timestamp) getObject(parameterName);
return (URL) getObject(parameterName);
return (RowId) getObject(parameterIndex);
return (RowId) getObject(parameterName);
protected MockCallableStatement     raw;
protected PoolableCallableStatement stmt;
protected void setUp() throws Exception {
raw = new MockCallableStatement(null, null);
stmt = new PoolableCallableStatement(null, raw, null) {
raw.registerOutParameter(2, Types.DECIMAL, 10);
Assert.assertEquals(2, raw.getParameters().size());
public void test_basic() throws Exception {
Assert.assertEquals(raw, stmt.getRawPreparedStatement());
public void test_callableStmt() throws Exception {
stmt.getObject(1);
stmt.getRef(1);
stmt.getBlob(1);
stmt.getObject("1");
stmt.getRef("1");
stmt.getBlob("1");
public void test_getByLabel_error() {
stmt.getTimestamp(0);
stmt.getString("0");
stmt.getBoolean("0");
stmt.getByte("0");
stmt.getShort("0");
stmt.getInt("0");
stmt.getLong("0");
stmt.getFloat("0");
stmt.getDouble("0");
stmt.getBigDecimal("0");
stmt.getBytes("0");
stmt.getDate("0");
stmt.getTime("0");
stmt.getTimestamp("0");
SQLException error = null;
stmt.getObject("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.getRef("0");
SQLException error = null;
stmt.getBlob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_get_error() {
stmt.getString(0);
stmt.getBoolean(0);
stmt.getByte(0);
stmt.getShort(0);
stmt.getInt(0);
stmt.getLong(0);
stmt.getFloat(0);
stmt.getDouble(0);
stmt.getBigDecimal(0);
stmt.getBigDecimal(0, 1);
stmt.getBytes(0);
stmt.getDate(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTime(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getObject(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getRef(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getBlob(0);
public class PoolablePreparedStatementTest extends TestCase {
protected MockPreparedStatement     raw;
protected PoolablePreparedStatement stmt;
protected void setUp() throws Exception {
raw = new MockPreparedStatement(null, null);
stmt = new PoolablePreparedStatement(null, raw, null) {
protected SQLException checkException(Throwable error) throws SQLException {
if (error instanceof SQLException) {
return (SQLException) error;
return new SQLException(error);
public void test_basic() throws Exception {
Assert.assertEquals(raw, stmt.getRawPreparedStatement());
public void test_setBoolean() throws Exception {
stmt.setBoolean(1, true);
Assert.assertEquals(Boolean.TRUE, raw.getParameters().get(0));
SQLException error = null;
stmt.setBoolean(0, true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNull() throws Exception {
stmt.setNull(1, Types.INTEGER);
Assert.assertEquals(null, raw.getParameters().get(0));
SQLException error = null;
stmt.setNull(0, Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setByte() throws Exception {
stmt.setByte(1, (byte) 23);
Assert.assertEquals(new Byte((byte) 23), raw.getParameters().get(0));
SQLException error = null;
stmt.setByte(0, Byte.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setShort() throws Exception {
stmt.setShort(1, Short.MAX_VALUE);
Assert.assertEquals(new Short(Short.MAX_VALUE), raw.getParameters().get(0));
SQLException error = null;
stmt.setShort(0, Short.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setInt() throws Exception {
stmt.setInt(1, Integer.MAX_VALUE);
Assert.assertEquals(new Integer(Integer.MAX_VALUE), raw.getParameters().get(0));
SQLException error = null;
stmt.setInt(0, Integer.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setLong() throws Exception {
stmt.setLong(1, Long.MAX_VALUE);
Assert.assertEquals(new Long(Long.MAX_VALUE), raw.getParameters().get(0));
SQLException error = null;
stmt.setLong(0, Long.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setFloat() throws Exception {
stmt.setFloat(1, Float.MAX_VALUE);
Assert.assertEquals(new Float(Float.MAX_VALUE), raw.getParameters().get(0));
SQLException error = null;
stmt.setFloat(0, Float.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setDouble() throws Exception {
stmt.setDouble(1, Double.MAX_VALUE);
Assert.assertEquals(new Double(Double.MAX_VALUE), raw.getParameters().get(0));
SQLException error = null;
stmt.setDouble(0, Double.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return getObject(findColumn(columnLabel));
return Integer.parseInt(columnLabel);
return (Reader) getObject(columnIndex);
return (Reader) getObject(columnLabel);
return (Reader) getObject(columnIndex);
return (Reader) getObject(columnLabel);
public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
Assert.assertEquals(raw, stmt.getCallableStatementRaw());
public void test_getSQLXML() throws Exception {
resultSet.next();
resultSet.getSQLXML(1);
resultSet.getSQLXML("1");
SQLException error = null;
resultSet.getSQLXML("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getSQLXML("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getNClob() throws Exception {
resultSet.next();
resultSet.getNClob(1);
resultSet.getNClob("1");
SQLException error = null;
resultSet.getNClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getNClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getNString() throws Exception {
resultSet.next();
resultSet.getNString(1);
resultSet.getNString("1");
SQLException error = null;
resultSet.getNString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getNString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getNCharacterStream() throws Exception {
resultSet.next();
resultSet.getNCharacterStream(1);
resultSet.getNCharacterStream("1");
SQLException error = null;
resultSet.getNCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getNCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getCharacterStream() throws Exception {
resultSet.next();
resultSet.getCharacterStream(1);
resultSet.getCharacterStream("1");
SQLException error = null;
resultSet.getCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
Assert.assertEquals(raw, stmt.getRawStatement());
public void test_setBigDecimal() throws Exception {
stmt.setBigDecimal(1, BigDecimal.TEN);
Assert.assertEquals(BigDecimal.TEN, raw.getParameters().get(0));
SQLException error = null;
stmt.setBigDecimal(0, BigDecimal.TEN);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setString() throws Exception {
stmt.setString(1, "");
Assert.assertEquals("", raw.getParameters().get(0));
SQLException error = null;
stmt.setString(0, "");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBytes() throws Exception {
byte[] bytes = "".getBytes();
stmt.setBytes(1, bytes);
Assert.assertEquals(true, Arrays.equals(bytes, (byte[]) raw.getParameters().get(0)));
SQLException error = null;
stmt.setBytes(0, bytes);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setDate() throws Exception {
Date value = new Date(System.currentTimeMillis());
stmt.setDate(1, value);
Assert.assertEquals(value, raw.getParameters().get(0));
SQLException error = null;
stmt.setDate(0, value);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setTimestamp() throws Exception {
Timestamp value = new Timestamp(System.currentTimeMillis());
stmt.setTimestamp(1, value);
Assert.assertEquals(value, raw.getParameters().get(0));
SQLException error = null;
stmt.setTimestamp(0, value);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setAsciiStream() throws Exception {
InputStream value = null;
stmt.setAsciiStream(1, value);
Assert.assertEquals(value, raw.getParameters().get(0));
SQLException error = null;
stmt.setAsciiStream(0, value);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
@SuppressWarnings("deprecation")
public void test_setUnicodeStream() throws Exception {
InputStream value = null;
stmt.setUnicodeStream(1, value, 0);
Assert.assertEquals(value, raw.getParameters().get(0));
SQLException error = null;
stmt.setUnicodeStream(0, value, 0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
@SuppressWarnings("deprecation")
public void test_setBinaryStream() throws Exception {
InputStream value = null;
stmt.setBinaryStream(1, value, 0);
Assert.assertEquals(value, raw.getParameters().get(0));
SQLException error = null;
stmt.setBinaryStream(0, value, 0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateAsciiStream_2() throws Exception {
resultSet.next();
resultSet.updateAsciiStream(1, (InputStream) null, 1L);
resultSet.updateAsciiStream("1", (InputStream) null, 1L);
SQLException error = null;
resultSet.updateAsciiStream("0", (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBlob(0, (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateNCharacterStream_1() throws Exception {
resultSet.next();
resultSet.updateNCharacterStream(1, (Reader) null, 1);
resultSet.updateNCharacterStream("1", (Reader) null, 1);
SQLException error = null;
resultSet.updateNCharacterStream("0", (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNCharacterStream(0, (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateCharacterStream_2() throws Exception {
resultSet.next();
resultSet.updateCharacterStream(1, (Reader) null, 1L);
resultSet.updateCharacterStream("1", (Reader) null, 1L);
SQLException error = null;
resultSet.updateCharacterStream("0", (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateCharacterStream(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return (URL) getObject(parameterIndex);
public void setURL(String parameterName, URL x) throws SQLException {
setObject(parameterName, x);
setObject(parameterName, null);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(Integer.parseInt(parameterName), x);
public void setCharacterStream(String parameterName, Reader x, int length) throws SQLException {
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, null);
return (NClob) getObject(parameterIndex);
return (NClob) getObject(parameterName);
return (SQLXML) getObject(parameterName);
return (String) getObject(parameterIndex);
return (String) getObject(parameterName);
return (Reader) getObject(parameterIndex);
return (Reader) getObject(parameterName);
return (Reader) getObject(parameterIndex);
return (Reader) getObject(parameterName);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
public void setCharacterStream(String parameterName, Reader x, long length) throws SQLException {
setObject(parameterName, x);
setObject(parameterName, x);
setObject(parameterName, x);
public void setCharacterStream(String parameterName, Reader x) throws SQLException {
setObject(parameterName, x);
public void setNCharacterStream(String parameterName, Reader x) throws SQLException {
setObject(parameterName, x);
public void setClob(String parameterName, Reader x) throws SQLException {
setObject(parameterName, x);
public void setBlob(String parameterName, InputStream x) throws SQLException {
setObject(parameterName, x);
public void setNClob(String parameterName, Reader x) throws SQLException {
setObject(parameterName, x);
stmt.registerOutParameter(1, Types.INTEGER);
stmt.registerOutParameter(2, Types.DECIMAL, 10);
public void test_getNClob() throws Exception {
stmt.getNClob(1);
stmt.getNClob("1");
SQLException error = null;
stmt.getNClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getNClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getNString() throws Exception {
stmt.getNString(1);
stmt.getNString("1");
SQLException error = null;
stmt.getNString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getNString("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getNCharacterStream() throws Exception {
stmt.getNCharacterStream(1);
stmt.getNCharacterStream("1");
SQLException error = null;
stmt.getNCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getNCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getCharacterStream() throws Exception {
stmt.getCharacterStream(1);
stmt.getCharacterStream("1");
SQLException error = null;
stmt.getCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getCharacterStream("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateCharacterStream_2() throws Exception {
stmt.setCharacterStream(1, (Reader) null, 1L);
stmt.setCharacterStream("1", (Reader) null, 1L);
SQLException error = null;
stmt.setCharacterStream("0", (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setCharacterStream(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
protected void tearDown() throws Exception {
stmt.clearParameters();
Assert.assertEquals(0, raw.getParameters().size());
public void test_updateCharacterStream_2() throws Exception {
stmt.setCharacterStream(1, (Reader) null, 1L);
SQLException error = null;
stmt.setCharacterStream(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return getObject(columnLabel);
return (Ref) getObject(columnLabel);
return (Blob) getObject(columnLabel);
return (Clob) getObject(columnLabel);
return (Array) getObject(columnLabel);
return (Date) getObject(columnIndex);
return (Date) getObject(columnLabel);
return (Time) getObject(columnIndex);
return (Time) getObject(columnLabel);
return (Timestamp) getObject(columnIndex);
return (Timestamp) getObject(columnLabel);
return (URL) getObject(columnIndex);
return (URL) getObject(columnLabel);
public void test_getURL() throws Exception {
resultSet.next();
resultSet.getURL(1);
resultSet.getURL("1");
SQLException error = null;
resultSet.getURL("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getURL("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTimestamp() throws Exception {
resultSet.next();
resultSet.getTimestamp(1, null);
resultSet.getTimestamp("1", null);
SQLException error = null;
resultSet.getTimestamp("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTimestamp("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTime() throws Exception {
resultSet.next();
resultSet.getTime(1, null);
resultSet.getTime("1", null);
SQLException error = null;
resultSet.getTime("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getTime("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getDate() throws Exception {
resultSet.next();
resultSet.getDate(1, null);
resultSet.getDate("1", null);
SQLException error = null;
resultSet.getDate("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getDate("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getArray() throws Exception {
resultSet.next();
resultSet.getArray(1);
resultSet.getArray("1");
SQLException error = null;
resultSet.getArray("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getArray("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getClob() throws Exception {
resultSet.next();
resultSet.getClob(1);
resultSet.getClob("1");
SQLException error = null;
resultSet.getClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getBlob() throws Exception {
resultSet.next();
resultSet.getBlob(1);
resultSet.getBlob("1");
SQLException error = null;
resultSet.getBlob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getBlob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getRef() throws Exception {
resultSet.next();
resultSet.getRef(1);
resultSet.getRef("1");
SQLException error = null;
resultSet.getRef("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getRef("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getObject() throws Exception {
resultSet.next();
resultSet.getObject(1, null);
resultSet.getObject("1", null);
SQLException error = null;
resultSet.getObject("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getObject("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
return getObject(columnIndex);
return (Array) getObject(columnIndex);
resultSet.getSQLXML(0);
resultSet.getNClob(0);
resultSet.getNString(0);
resultSet.getNCharacterStream(0);
resultSet.getCharacterStream(0);
resultSet.getURL(0);
resultSet.getTimestamp(0, null);
resultSet.getTime(0, null);
resultSet.getDate(0, null);
resultSet.getArray(0);
resultSet.getClob(0);
resultSet.getBlob(0);
resultSet.getRef(0);
resultSet.getObject(0, null);
stmt.getNClob(0);
stmt.getNString(0);
stmt.getNCharacterStream(0);
stmt.getCharacterStream(0);
public void test_updateBinaryStream_2() throws Exception {
resultSet.next();
resultSet.updateBinaryStream(1, (InputStream) null, 1L);
resultSet.updateBinaryStream("1", (InputStream) null, 1L);
SQLException error = null;
resultSet.updateBinaryStream("0", (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBinaryStream(0, (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
resultSet.updateAsciiStream(0, (InputStream) null, 1L);
public void test_updateNClob() throws Exception {
resultSet.next();
resultSet.updateNClob(1, (NClob) null);
resultSet.updateNClob("1", (NClob) null);
SQLException error = null;
resultSet.updateNClob(0, (NClob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNClob("0", (NClob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateNString() throws Exception {
resultSet.next();
resultSet.updateNString(1, null);
resultSet.updateNString("1", null);
SQLException error = null;
resultSet.updateNString(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateNString("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateRowId() throws Exception {
resultSet.next();
resultSet.updateRowId(1, null);
resultSet.updateRowId("1", null);
SQLException error = null;
resultSet.updateRowId(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateRowId("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateArray() throws Exception {
resultSet.next();
resultSet.updateArray(1, null);
resultSet.updateArray("1", null);
SQLException error = null;
resultSet.updateArray(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateArray("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateClob() throws Exception {
resultSet.next();
resultSet.updateClob(1, (Clob) null);
resultSet.updateClob("1", (Clob) null);
SQLException error = null;
resultSet.updateClob(0, (Clob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateClob("0", (Clob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateBlob() throws Exception {
resultSet.next();
resultSet.updateBlob(1, (Blob) null);
resultSet.updateBlob("1", (Blob) null);
SQLException error = null;
resultSet.updateBlob(0, (Blob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateBlob("0", (Blob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateRef() throws Exception {
resultSet.next();
resultSet.updateRef(1, (Ref) null);
resultSet.updateRef("1", (Ref) null);
SQLException error = null;
resultSet.updateRef(0, (Ref) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateRef("0", (Ref) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
pstmt.close();
private int                   rowIndex  = -1;
private List<Object[]>        rows      = new ArrayList<Object[]>();
private boolean               wasNull   = false;
private MockResultSetMetaData metaData  = new MockResultSetMetaData();
private boolean               closed    = false;
private int                   fetchSize = 0;
@SuppressWarnings("unchecked")
if (iface == MockResultSet.class || iface == ResultSet.class) {
return (T) this;
if (iface == MockResultSet.class || iface == ResultSet.class) {
return true;
this.closed = true;
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
this.fetchSize = rows;
if (closed) {
throw new SQLException();
return fetchSize;
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
resultSet.updateAsciiStream(0, (InputStream) null, 1);
public void test_updateObject() throws Exception {
resultSet.next();
resultSet.updateObject(1, null);
resultSet.updateObject("1", null);
SQLException error = null;
resultSet.updateObject(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateObject("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateObject_1() throws Exception {
resultSet.next();
resultSet.updateObject(1, null, 1);
resultSet.updateObject("1", null, 1);
SQLException error = null;
resultSet.updateObject(0, null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.updateObject("0", null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public class ResultSetTest2 extends TestCase {
private PoolableStatement stmt;
private MockResultSet     raw;
private PoolableResultSet resultSet;
protected void setUp() throws Exception {
stmt = new PoolableStatement(null, null) {
protected SQLException checkException(Throwable error) throws SQLException {
if (error instanceof SQLException) {
return (SQLException) error;
return new SQLException(error);
raw = new MockResultSet(null);
raw.getRows().add(new Object[] { null });
resultSet = new PoolableResultSet(stmt, raw);
public void test_rowDeleted() throws Exception {
resultSet.rowDeleted();
raw.close();
SQLException error = null;
resultSet.rowDeleted();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_rowInserted() throws Exception {
resultSet.rowInserted();
raw.close();
SQLException error = null;
resultSet.rowInserted();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_rowUpdated() throws Exception {
resultSet.rowInserted();
raw.close();
SQLException error = null;
resultSet.rowUpdated();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getConcurrency() throws Exception {
resultSet.getConcurrency();
raw.close();
SQLException error = null;
resultSet.getConcurrency();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getType() throws Exception {
resultSet.getType();
raw.close();
SQLException error = null;
resultSet.getType();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_FetchSize() throws Exception {
resultSet.setFetchSize(10);
Assert.assertEquals(10, resultSet.getFetchSize());
raw.close();
SQLException error = null;
resultSet.getFetchSize();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNClob() throws Exception {
stmt.setNClob(1, (Reader) null);
stmt.setNClob("1", (Reader) null);
SQLException error = null;
stmt.setNClob("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNClob(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setClob() throws Exception {
stmt.setClob(1, (Reader) null);
stmt.setClob("1", (Reader) null);
SQLException error = null;
stmt.setClob("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setClob(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNCharacterStream() throws Exception {
stmt.setNCharacterStream(1, (Reader) null);
stmt.setNCharacterStream("1", (Reader) null);
SQLException error = null;
stmt.setNCharacterStream("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNCharacterStream(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setCharacterStream() throws Exception {
stmt.setCharacterStream(1, (Reader) null);
stmt.setCharacterStream("1", (Reader) null);
SQLException error = null;
stmt.setCharacterStream("0", (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setCharacterStream(0, (Reader) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBinaryStream() throws Exception {
stmt.setBinaryStream(1, (InputStream) null);
stmt.setBinaryStream("1", (InputStream) null);
SQLException error = null;
stmt.setBinaryStream("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBinaryStream(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBinaryStream_1() throws Exception {
stmt.setBinaryStream(1, (InputStream) null, 1);
stmt.setBinaryStream("1", (InputStream) null, 1);
SQLException error = null;
stmt.setBinaryStream("0", (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBinaryStream(0, (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBinaryStream_2() throws Exception {
stmt.setBinaryStream(1, (InputStream) null, 1L);
stmt.setBinaryStream("1", (InputStream) null, 1L);
SQLException error = null;
stmt.setBinaryStream("0", (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBinaryStream(0, (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setAsciiStream() throws Exception {
stmt.setAsciiStream(1, (InputStream) null);
stmt.setAsciiStream("1", (InputStream) null);
SQLException error = null;
stmt.setAsciiStream("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setAsciiStream(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
if (closed) {
throw new SQLException("resultSet closed");
return (RowId) getObject(columnIndex);
return (RowId) getObject(columnLabel);
if (closed) {
throw new SQLException("resultSet closed");
return closed;
public Statement getStatement() {
return stmt;
public void test_getRowId() throws Exception {
resultSet.next();
resultSet.getRowId(1);
resultSet.getRowId("1");
SQLException error = null;
resultSet.getRowId(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getRowId("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.setFetchSize(10);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getHoldability() throws Exception {
resultSet.getHoldability();
raw.close();
SQLException error = null;
resultSet.getHoldability();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getStatement() throws Exception {
resultSet.getStatement();
raw.close();
SQLException error = null;
raw.getStatement();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_moveToCurrentRow() throws Exception {
resultSet.moveToCurrentRow();
raw.close();
SQLException error = null;
resultSet.moveToCurrentRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_moveToInsertRow() throws Exception {
resultSet.moveToInsertRow();
raw.close();
SQLException error = null;
resultSet.moveToInsertRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_cancelRowUpdates() throws Exception {
resultSet.cancelRowUpdates();
raw.close();
SQLException error = null;
resultSet.cancelRowUpdates();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_refreshRow() throws Exception {
resultSet.refreshRow();
raw.close();
SQLException error = null;
resultSet.refreshRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
private int                   rowIndex       = -1;
private List<Object[]>        rows           = new ArrayList<Object[]>();
private boolean               wasNull        = false;
private MockResultSetMetaData metaData       = new MockResultSetMetaData();
private boolean               closed         = false;
private int                   fetchSize      = 0;
private int                   fetchDirection = 0;
if (closed) {
throw new SQLException();
this.fetchDirection = direction;
return fetchDirection;
public void test_FetchDirection() throws Exception {
resultSet.setFetchDirection(ResultSet.FETCH_REVERSE);
Assert.assertEquals(ResultSet.FETCH_REVERSE, resultSet.getFetchDirection());
raw.close();
SQLException error = null;
resultSet.getFetchDirection();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.setFetchDirection(ResultSet.FETCH_REVERSE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_deleteRow() throws Exception {
resultSet.deleteRow();
raw.close();
SQLException error = null;
resultSet.deleteRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_updateRow() throws Exception {
resultSet.deleteRow();
raw.close();
SQLException error = null;
resultSet.updateRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_insertRow() throws Exception {
resultSet.deleteRow();
raw.close();
SQLException error = null;
resultSet.insertRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_previous() throws Exception {
resultSet.previous();
raw.close();
SQLException error = null;
resultSet.previous();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_relative() throws Exception {
resultSet.relative(1);
raw.close();
SQLException error = null;
resultSet.relative(1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_absolute() throws Exception {
resultSet.absolute(1);
raw.close();
SQLException error = null;
resultSet.absolute(1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
private SQLWarning            warning;
private String                cursorName;
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
return warning;
if (closed) {
throw new SQLException();
warning = null;
public void setWarning(SQLWarning warning) {
this.warning = warning;
if (closed) {
throw new SQLException();
return cursorName;
public void setCursorName(String cursorName) {
this.cursorName = cursorName;
public void test_next() throws Exception {
resultSet.next();
raw.close();
SQLException error = null;
resultSet.next();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_wasNull() throws Exception {
resultSet.wasNull();
raw.close();
SQLException error = null;
resultSet.wasNull();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
if (closed) {
throw new SQLException();
public void test_isBeforeFirst() throws Exception {
resultSet.isBeforeFirst();
raw.close();
SQLException error = null;
resultSet.isBeforeFirst();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_isAfterLast() throws Exception {
resultSet.isAfterLast();
raw.close();
SQLException error = null;
resultSet.isAfterLast();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_isFirst() throws Exception {
resultSet.isFirst();
raw.close();
SQLException error = null;
resultSet.isFirst();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_isLast() throws Exception {
resultSet.isLast();
raw.close();
SQLException error = null;
resultSet.isLast();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_beforeFirst() throws Exception {
resultSet.beforeFirst();
raw.close();
SQLException error = null;
resultSet.beforeFirst();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_first() throws Exception {
resultSet.first();
raw.close();
SQLException error = null;
resultSet.first();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_afterLast() throws Exception {
resultSet.afterLast();
raw.close();
SQLException error = null;
resultSet.afterLast();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_last() throws Exception {
resultSet.last();
raw.close();
SQLException error = null;
resultSet.last();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getRow() throws Exception {
resultSet.getRow();
raw.close();
SQLException error = null;
resultSet.getRow();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
resultSet.updateRow();
resultSet.insertRow();
if (closed) {
throw new SQLException("resultSet closed");
public void test_getObject_1() throws Exception {
resultSet.next();
resultSet.getObject(1);
resultSet.getObject("1");
SQLException error = null;
resultSet.getObject(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
resultSet.getObject("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getWarnings() throws Exception {
resultSet.getWarnings();
raw.close();
SQLException error = null;
resultSet.getWarnings();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_clearWarnings() throws Exception {
resultSet.clearWarnings();
raw.close();
SQLException error = null;
resultSet.clearWarnings();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getCursorName() throws Exception {
resultSet.getCursorName();
raw.close();
SQLException error = null;
resultSet.getCursorName();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getMetaData() throws Exception {
resultSet.getMetaData();
raw.close();
SQLException error = null;
resultSet.getMetaData();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
private int                maxFieldSize;
private int                maxRows;
private int                queryTimeout;
private boolean            escapeProcessing;
if (closed) {
throw new SQLException("stmt closed.");
return maxFieldSize;
if (closed) {
throw new SQLException("stmt closed.");
this.maxFieldSize = max;
if (closed) {
throw new SQLException("stmt closed.");
return maxRows;
if (closed) {
throw new SQLException("stmt closed.");
this.maxRows = max;
if (closed) {
throw new SQLException("stmt closed.");
this.escapeProcessing = enable;
public boolean isEscapeProcessing() {
return escapeProcessing;
if (closed) {
throw new SQLException("stmt closed.");
return queryTimeout;
if (closed) {
throw new SQLException("stmt closed.");
this.queryTimeout = seconds;
if (closed) {
throw new SQLException("stmt closed.");
public void test_setEscapeProcessing() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setEscapeProcessing(true);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.setEscapeProcessing(true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getMaxFieldSize() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setMaxFieldSize(23);
Assert.assertEquals(23, stmt.getMaxFieldSize());
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getMaxFieldSize();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setMaxFieldSize(23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_QueryTimeout() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setQueryTimeout(33);
Assert.assertEquals(33, stmt.getQueryTimeout());
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getQueryTimeout();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setQueryTimeout(23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_findColumn() throws Exception {
resultSet.findColumn("1");
raw.close();
SQLException error = null;
resultSet.findColumn("xxxx");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_closeError() throws Exception {
MockResultSet mock = new MockResultSet(null) {
public void close() throws SQLException {
throw new SQLException();
PoolableResultSet rs = new PoolableResultSet(stmt, mock);
SQLException error = null;
rs.close();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_toCompositeData() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
dataSource.getCompositeData();
if (sqlStat != null) {
sqlStat.addUpdateCount(updateCount);
private SQLWarning         warnings;
private String             cursorName;
private int                updateCount;
if (closed) {
throw new SQLException("stmt closed.");
return warnings;
if (closed) {
throw new SQLException("stmt closed.");
warnings = null;
public void setWarning(SQLWarning warning) {
this.warnings = warning;
if (closed) {
throw new SQLException("stmt closed.");
cursorName = name;
public String getCursorName() {
return cursorName;
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
return updateCount;
public void setUpdateCount(int updateCount) {
this.updateCount = updateCount;
public void test_MaxRows() throws Exception {
public void test_MaxRows() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setMaxRows(44);
Assert.assertEquals(44, stmt.getMaxRows());
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getMaxRows();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setMaxRows(23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_cancel() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.cancel();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.cancel();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getWarnings() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getWarnings();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getWarnings();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_clearWarnings() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.clearWarnings();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.clearWarnings();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_setCursorName() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setCursorName("c_name");
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.setCursorName("c_name");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getResultSet() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getResultSet();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getResultSet();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getUpdateCount() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getUpdateCount();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getUpdateCount();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
private int                fetchDirection;
private int                fetchSize;
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
this.fetchDirection = direction;
if (closed) {
throw new SQLException("stmt closed.");
return fetchDirection;
if (closed) {
throw new SQLException("stmt closed.");
this.fetchSize = rows;
if (closed) {
throw new SQLException("stmt closed.");
return fetchSize;
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
if (closed) {
throw new SQLException("stmt closed.");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.close();
stmt.close();
conn.close();
public void test_FetchDirection() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setFetchDirection(144);
Assert.assertEquals(144, stmt.getFetchDirection());
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getFetchDirection();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setFetchDirection(23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_FetchSize() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setFetchSize(144);
Assert.assertEquals(144, stmt.getFetchSize());
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getFetchSize();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setFetchSize(23);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
stmt.close();
conn.close();
public void test_getResultSet() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getResultSet();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getResultSet();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getUpdateCount() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getUpdateCount();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getUpdateCount();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getMoreResults() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getMoreResults();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getMoreResults();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getResultSetConcurrency() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getResultSetConcurrency();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getResultSetConcurrency();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getResultSetType() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getResultSetType();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getResultSetType();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_addBatch() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.addBatch("select 1");
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.addBatch("select 1");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_clearBatch() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.clearBatch();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.clearBatch();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeBatch() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeBatch();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeBatch();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getMoreResults_1() throws Exception {
stmt.getMoreResults(1);
stmt.getMoreResults(1);
public void test_getGeneratedKeys() throws Exception {
stmt.getGeneratedKeys();
stmt.getGeneratedKeys();
setObject(parameterName, x);
public void setNString(String parameterName, String x) throws SQLException {
setObject(parameterName, x);
public void setNCharacterStream(String parameterName, Reader x, long length) throws SQLException {
setObject(parameterName, x);
public void setNClob(String parameterName, NClob x) throws SQLException {
setObject(parameterName, x);
public void setClob(String parameterName, Reader x, long length) throws SQLException {
setObject(parameterName, x);
public void setBlob(String parameterName, InputStream x, long length) throws SQLException {
setObject(parameterName, x);
public void setNClob(String parameterName, Reader x, long length) throws SQLException {
public void setClob(int parameterIndex, Reader value, long length) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void test_setBlob() throws Exception {
stmt.setBlob(1, (InputStream) null);
stmt.setBlob("1", (InputStream) null);
SQLException error = null;
stmt.setBlob("0", (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBlob(0, (InputStream) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setClob_1() throws Exception {
stmt.setClob(1, (Clob) null);
stmt.setClob("1", (Clob) null);
SQLException error = null;
stmt.setClob("0", (Clob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setClob(0, (Clob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setClob_2() throws Exception {
stmt.setClob(1, (Reader) null, 1L);
stmt.setClob("1", (Reader) null, 1L);
SQLException error = null;
stmt.setClob("0", (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setClob(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setAsciiStream_1() throws Exception {
stmt.setAsciiStream(1, (InputStream) null, 1L);
stmt.setAsciiStream("1", (InputStream) null, 1L);
SQLException error = null;
stmt.setAsciiStream("0", (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setAsciiStream(0, (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
setObject(parameterName, x);
parameters.add(parameterIndex - 1, x);
public void test_setNull() throws Exception {
stmt.setNull(1, Types.INTEGER, "Int");
stmt.setNull("1", Types.INTEGER, "Int");
SQLException error = null;
stmt.setNull("0", Types.INTEGER, "Int");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNull(0, Types.INTEGER, "Int");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setTimestamp() throws Exception {
stmt.setTimestamp(1, (Timestamp) null, null);
stmt.setTimestamp("1", (Timestamp) null, null);
SQLException error = null;
stmt.setTimestamp("0", (Timestamp) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setTimestamp(0, (Timestamp) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setTime() throws Exception {
stmt.setTime(1, (Time) null, null);
stmt.setTime("1", (Time) null, null);
SQLException error = null;
stmt.setTime("0", (Time) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setTime(0, (Time) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setDate() throws Exception {
stmt.setDate(1, (Date) null, null);
stmt.setDate("1", (Date) null, null);
SQLException error = null;
stmt.setDate("0", (Date) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setDate(0, (Date) null, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.setTimestamp(1, (Timestamp) null);
stmt.setTimestamp("1", (Timestamp) null);
SQLException error = null;
stmt.setTimestamp("0", (Timestamp) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setTimestamp(0, (Timestamp) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setTimestamp_1() throws Exception {
stmt.setTime(1, (Time) null);
stmt.setTime("1", (Time) null);
SQLException error = null;
stmt.setTime("0", (Time) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setTime(0, (Time) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setTime_1() throws Exception {
stmt.setDate(1, (Date) null);
stmt.setDate("1", (Date) null);
SQLException error = null;
stmt.setDate("0", (Date) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setDate(0, (Date) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setDate_1() throws Exception {
public void test_setCharacterStream_1() throws Exception {
stmt.setCharacterStream(1, (Reader) null, 1);
stmt.setCharacterStream("1", (Reader) null, 1);
SQLException error = null;
stmt.setCharacterStream("0", (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setCharacterStream(0, (Reader) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setObject() throws Exception {
stmt.setObject(1, null);
stmt.setObject("1", null);
SQLException error = null;
stmt.setObject("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setObject(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setObject_1() throws Exception {
stmt.setObject(1, null, Types.INTEGER);
stmt.setObject("1", null, Types.INTEGER);
SQLException error = null;
stmt.setObject("0", null, Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setObject(0, null, Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setObject_2() throws Exception {
stmt.setObject(1, null, Types.INTEGER, 2);
stmt.setObject("1", null, Types.INTEGER, 2);
SQLException error = null;
stmt.setObject("0", null, Types.INTEGER, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setObject(0, null, Types.INTEGER, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setAsciiStream_2() throws Exception {
stmt.setAsciiStream(1, (InputStream) null, 1);
stmt.setAsciiStream("1", (InputStream) null, 1);
SQLException error = null;
stmt.setAsciiStream("0", (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setAsciiStream(0, (InputStream) null, 1);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBytes() throws Exception {
stmt.setBytes(1, null);
stmt.setBytes("1", null);
SQLException error = null;
stmt.setBytes("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBytes(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setString() throws Exception {
stmt.setString(1, null);
stmt.setString("1", null);
SQLException error = null;
stmt.setString("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setString(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBigDecimal() throws Exception {
stmt.setBigDecimal(1, null);
stmt.setBigDecimal("1", null);
SQLException error = null;
stmt.setBigDecimal("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBigDecimal(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setDouble() throws Exception {
stmt.setDouble(1, 1.0D);
stmt.setDouble("1", 1.0D);
SQLException error = null;
stmt.setDouble("0", 1.0D);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setDouble(0, 1.0D);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setFloat() throws Exception {
stmt.setFloat(1, 1.0F);
stmt.setFloat("1", 1.0F);
SQLException error = null;
stmt.setFloat("0", 1.0F);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setFloat(0, 1.0F);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setLong() throws Exception {
stmt.setLong(1, 2);
stmt.setLong("1", 2);
SQLException error = null;
stmt.setLong("0", 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setLong(0, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setInt() throws Exception {
stmt.setInt(1, 2);
stmt.setInt("1", 2);
SQLException error = null;
stmt.setInt("0", 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setInt(0, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setShort() throws Exception {
stmt.setShort(1, Short.MAX_VALUE);
stmt.setShort("1", Short.MAX_VALUE);
SQLException error = null;
stmt.setShort("0", Short.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setShort(0, Short.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setByte() throws Exception {
stmt.setByte(1, Byte.MAX_VALUE);
stmt.setByte("1", Byte.MAX_VALUE);
SQLException error = null;
stmt.setByte("0", Byte.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setByte(0, Byte.MAX_VALUE);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getClob() throws Exception {
stmt.getClob(1);
stmt.getClob("1");
SQLException error = null;
stmt.getClob(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getClob("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getArray() throws Exception {
stmt.getArray(1);
stmt.getArray("1");
SQLException error = null;
stmt.getArray(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getArray("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getDate() throws Exception {
stmt.getDate(1);
stmt.getDate("1");
SQLException error = null;
stmt.getDate(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDate("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getDate_1() throws Exception {
stmt.getDate(1, null);
stmt.getDate("1", null);
SQLException error = null;
stmt.getDate(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getDate("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTime() throws Exception {
stmt.getTime(1);
stmt.getTime("1");
SQLException error = null;
stmt.getTime(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTime("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTime_1() throws Exception {
stmt.getTime(1, null);
stmt.getTime("1", null);
SQLException error = null;
stmt.getTime(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTime("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTimestamp() throws Exception {
stmt.getTimestamp(1);
stmt.getTimestamp("1");
SQLException error = null;
stmt.getTimestamp(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTimestamp("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getTimestamp_1() throws Exception {
stmt.getTimestamp(1, null);
stmt.getTimestamp("1", null);
SQLException error = null;
stmt.getTimestamp(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getTimestamp("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getURL() throws Exception {
stmt.getURL(1);
stmt.getURL("1");
SQLException error = null;
stmt.getURL(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getURL("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getResultSetHoldability() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.getResultSetHoldability();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getResultSetHoldability();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_execute() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1", new String[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", new String[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_execute_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1", new int[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", new int[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_execute_2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1", Statement.NO_GENERATED_KEYS);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", Statement.NO_GENERATED_KEYS);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SELECT 1", new String[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", new String[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SELECT 1", new int[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", new int[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_3() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SELECT 1", Statement.NO_GENERATED_KEYS);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute("SELECT 1", Statement.NO_GENERATED_KEYS);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
setObject(parameterName, x);
public void setSQLXML(String parameterName, SQLXML x) throws SQLException {
setObject(parameterName, x);
return (SQLXML) getObject(parameterIndex);
public void test_setBlob_1() throws Exception {
stmt.setBlob(1, (Blob) null);
stmt.setBlob("1", (Blob) null);
SQLException error = null;
stmt.setBlob("0", (Blob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBlob(0, (Blob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setSQLXML() throws Exception {
stmt.setSQLXML(1, (SQLXML) null);
stmt.setSQLXML("1", (SQLXML) null);
SQLException error = null;
stmt.setSQLXML("0", (SQLXML) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setSQLXML(0, (SQLXML) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getSQLXML() throws Exception {
stmt.getSQLXML(1);
stmt.getSQLXML("1");
SQLException error = null;
stmt.getSQLXML(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getSQLXML("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBlob_2() throws Exception {
stmt.setBlob(1, (InputStream) null, 1L);
stmt.setBlob("1", (InputStream) null, 1L);
SQLException error = null;
stmt.setBlob("0", (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBlob(0, (InputStream) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNClob_1() throws Exception {
stmt.setNClob(1, (Reader) null, 1L);
stmt.setNClob("1", (Reader) null, 1L);
SQLException error = null;
stmt.setNClob("0", (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNClob(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNCharacterStream_1() throws Exception {
stmt.setNCharacterStream(1, (Reader) null, 1L);
stmt.setNCharacterStream("1", (Reader) null, 1L);
SQLException error = null;
stmt.setNCharacterStream("0", (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNCharacterStream(0, (Reader) null, 1L);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setRowId() throws Exception {
stmt.setRowId(1, (RowId) null);
stmt.setRowId("1", (RowId) null);
SQLException error = null;
stmt.setRowId("0", (RowId) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setRowId(0, (RowId) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getRowId() throws Exception {
stmt.getRowId(1);
stmt.getRowId("1");
SQLException error = null;
stmt.getRowId(0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getRowId("0");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNString() throws Exception {
stmt.setNString(1, (String) null);
stmt.setNString("1", (String) null);
SQLException error = null;
stmt.setNString("0", (String) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNString(0, (String) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getObject() throws Exception {
stmt.getObject(1, null);
stmt.getObject("1", null);
SQLException error = null;
stmt.getObject(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.getObject("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setBoolean() throws Exception {
stmt.setBoolean(1, true);
stmt.setBoolean("1", true);
SQLException error = null;
stmt.setBoolean("0", true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setBoolean(0, true);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setURL() throws Exception {
stmt.setURL(1, null);
stmt.setURL("1", null);
SQLException error = null;
stmt.setURL("0", null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setURL(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
if (parameterIndex < 1) {
throw new SQLException();
if (parameters.size() >= parameterIndex - 1) {
parameters.add(null);
throw new SQLException();
registerOutParameter(parameterIndex, sqlType);
registerOutParameter(parameterIndex, sqlType);
registerOutParameter(Integer.parseInt(parameterName), sqlType);
registerOutParameter(parameterName, sqlType);
registerOutParameter(parameterName, sqlType);
public void test_setNClob_2() throws Exception {
stmt.setNClob(1, (NClob) null);
stmt.setNClob("1", (NClob) null);
SQLException error = null;
stmt.setNClob("0", (NClob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNClob(0, (NClob) null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setNull_1() throws Exception {
stmt.setNull(1, Types.INTEGER);
stmt.setNull("1", Types.INTEGER);
SQLException error = null;
stmt.setNull("0", Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.setNull(0, Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_registerOutParameter() throws Exception {
stmt.registerOutParameter(1, Types.INTEGER, "Int");
stmt.registerOutParameter("1", Types.INTEGER, "Int");
SQLException error = null;
stmt.registerOutParameter("0", Types.INTEGER, "Int");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.registerOutParameter(0, Types.INTEGER, "Int");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_registerOutParameter_1() throws Exception {
stmt.registerOutParameter(1, Types.INTEGER, 2);
stmt.registerOutParameter("1", Types.INTEGER, 2);
SQLException error = null;
stmt.registerOutParameter("0", Types.INTEGER, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.registerOutParameter(0, Types.INTEGER, 2);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_registerOutParameter_2() throws Exception {
stmt.registerOutParameter(1, Types.INTEGER);
stmt.registerOutParameter("1", Types.INTEGER);
SQLException error = null;
stmt.registerOutParameter("0", Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
SQLException error = null;
stmt.registerOutParameter(0, Types.INTEGER);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
protected boolean            closed    = false;
public void test_getMeta() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.getMetaData();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getMetaData();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_getParameterMetaData() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.getParameterMetaData();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.getParameterMetaData();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
dataSource.setFilters("stat,trace");
JdbcStatContext context = new JdbcStatContext();
context.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(context);
JdbcStatManager.getInstance().setStatContext(null);
dataSource.setFilters("stat,trace");
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
rawStatement.clearParameters();
} catch (SQLException ex) {
LOG.error("clear parameter error", ex);
public void test_setRef() throws Exception {
stmt.setRef(1, null);
SQLException error = null;
stmt.setRef(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setArray() throws Exception {
stmt.setArray(1, null);
SQLException error = null;
stmt.setArray(0, null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_wasNull() throws Exception {
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall("SELELCT 1");
stmt.wasNull();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.wasNull();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeQuery() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.executeQuery();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeQuery();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_4() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.executeQuery();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeUpdate();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_execute_3() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.execute();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.execute();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_clearParameters() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.clearParameters();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.clearParameters();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_addBatch_1() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELELCT 1");
stmt.addBatch();
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.addBatch();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public class ConnectionTest3 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_basic() throws Exception {
PoolableConnection conn = (PoolableConnection) dataSource.getConnection();
conn.getStartTransactionTimeMillis();
conn.getMetaData();
conn.setReadOnly(true);
Assert.assertEquals(true, conn.isReadOnly());
conn.setCatalog("xxx");
Assert.assertEquals("xxx", conn.getCatalog());
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
Assert.assertEquals(Connection.TRANSACTION_READ_COMMITTED, conn.getTransactionIsolation());
conn.getWarnings();
conn.clearWarnings();
conn.getTypeMap();
conn.setTypeMap(null);
conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
conn.setSavepoint();
conn.setSavepoint("savepoint");
conn.rollback();
conn.rollback(null);
conn.releaseSavepoint(null);
conn.createBlob();
conn.createClob();
conn.createNClob();
conn.createSQLXML();
conn.isValid(200);
conn.setClientInfo(new Properties());
conn.setClientInfo("xx", "11");
conn.getClientInfo("xx");
conn.getClientInfo();
conn.createArrayOf("int", new Object[0]);
conn.createStruct("int", new Object[0]);
conn.addConnectionEventListener(null);
conn.removeConnectionEventListener(null);
conn.addStatementEventListener(null);
conn.removeStatementEventListener(null);
conn.close();
dataSource.setFilters("stat,trace");
if (savepoint != null) {
event.putContext("savepointId", savepoint.getSavepointId());
event.putContext("savepointName", savepoint.getSavepointName());
if (savepoint != null) {
event.putContext("savepointId", savepoint.getSavepointId());
event.putContext("savepointName", savepoint.getSavepointName());
if (savepoint != null) {
event.putContext("savepointId", savepoint.getSavepointId());
event.putContext("savepointName", savepoint.getSavepointName());
if (savepoint != null) {
event.putContext("savepointId", savepoint.getSavepointId());
event.putContext("savepointName", savepoint.getSavepointName());
if (savepoint != null) {
event.putContext("savepointId", savepoint.getSavepointId());
event.putContext("savepointName", savepoint.getSavepointName());
JdbcStatContext context = new JdbcStatContext();
context.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(context);
JdbcStatManager.getInstance().setStatContext(null);
if (poolable) {
throw new SQLException("not support");
public void test_executeUpdate_5() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SET 1", Statement.RETURN_GENERATED_KEYS);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeUpdate("SET 1", Statement.RETURN_GENERATED_KEYS);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_6() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SET 1", new String[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeUpdate("SET 1", new String[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_executeUpdate_7() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("SET 1", new int[0]);
((PoolableStatement) stmt).getStatement().close();
SQLException error = null;
stmt.executeUpdate("SET 1", new int[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public void test_setPoolable() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.setPoolable(true);
SQLException error = null;
stmt.setPoolable(false);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
stmt.close();
conn.close();
public Driver getDriver() {
return dataSource.getDriver();
public void setDriver(Driver driver) {
dataSource.setDriver(driver);
public void setFilters(String filters) throws SQLException {
dataSource.setFilters(filters);
public class DruidDataSourceC3P0AdapterTest extends TestCase {
private MockDriver      driver;
private DruidDataSourceC3P0Adapter dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSourceC3P0Adapter();
dataSource.setJdbcUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialPoolSize(1);
dataSource.setMaxPoolSize(2);
dataSource.setMinPoolSize(1);
dataSource.setMaxIdleTime(300); 
dataSource.setIdleConnectionTestPeriod(180); 
dataSource.setTestConnectionOnCheckout(false);
dataSource.setPreferredTestQuery("SELECT 1");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_basic() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
public List<Filter> getProxyFilters() {
return dataSource.getProxyFilters();
public void setProxyFilters(List<Filter> filters) {
dataSource.setProxyFilters(filters);
public abstract class DruidAbstractDataSource extends WrapperAdapter implements DruidAbstractDataSourceMBean, DataSource, DataSourceProxy, Serializable {
if (dataSource.getCreateCount() > 0) {
Assert.assertEquals(true, dataSource.getCreateTimespanNano() > 0);
public void test_wrap() throws Exception {
Assert.assertTrue(!dataSource.isWrapperFor(Date.class));
Assert.assertTrue(dataSource.isWrapperFor(DataSource.class));
protected void clearResultSet() {
public class PoolableStatementTest3 extends TestCase {
public void test_clearResultSetError() throws Exception {
final MockResultSet rs = new MockResultSet(null) {
public void close() throws SQLException {
throw new SQLException();
PoolableStatement stmt = new PoolableStatement(null, null) {
public void close() throws SQLException {
resultSetTrace.add(rs);
clearResultSet();
stmt.close();
public PreparedStatementKey(String sql, String catalog, MethodType methodType){
public class PreparedStatementKeyTest extends TestCase {
public void test_equals_0() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", "c1", MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x1", "c2", MethodType.M1);
PreparedStatementKey k3 = new PreparedStatementKey("x1", "c3", MethodType.M1);
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_2() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", "c1", MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x2", "c1", MethodType.M1);
PreparedStatementKey k3 = new PreparedStatementKey("x3", "c1", MethodType.M1);
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_3() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", "c1", MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x1", "c1", MethodType.M2);
PreparedStatementKey k3 = new PreparedStatementKey("x1", "c1", MethodType.M3);
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_4() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", "c1", MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x1", "c2", MethodType.M1);
PreparedStatementKey k3 = new PreparedStatementKey("x1", null, MethodType.M1);
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
private boolean    autoCommit           = false;
private boolean    closed               = false;
private boolean    readOnly             = false;
private String     catalog              = null;
private int        transactionIsolation;
private SQLWarning warning;
private int        holdability;
private MockDriver driver;
private Properties connectProperties;
private long       id;
private final long createdTimeMillis    = System.currentTimeMillis();
private long       lastActiveTimeMillis = System.currentTimeMillis();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (iface == null) {
if (iface.isInstance(this)) {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
public class ConnectionTest4 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat,trace");
dataSource.setPoolPreparedStatements(true);
JdbcStatContext context = new JdbcStatContext();
context.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(context);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
JdbcStatManager.getInstance().setStatContext(null);
public void test_basic() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
Assert.assertEquals(null, conn.unwrap(Date.class));
Assert.assertEquals(conn, conn.unwrap(Connection.class));
Assert.assertEquals(true, conn.isWrapperFor(PoolableConnection.class));
Assert.assertEquals(true, conn.isWrapperFor(Connection.class));
conn.close();
public void test_prepareStatement_error() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error3() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
if (closed) {
throw new SQLException();
public void checkOpen() throws SQLException {
public PreparedStatementKey(String sql, String catalog, MethodType methodType) throws SQLException{
throw new SQLException("sql is null");
Assert.assertEquals(null, conn.unwrap(null));
Assert.assertEquals(false, conn.isWrapperFor(null));
Assert.assertEquals("SELECT 1", conn.nativeSQL("SELECT 1"));
conn.toString();
conn.toString();
public void test_prepareStatement_error4() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
SQLException error = null;
conn.prepareStatement(null, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error5() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
SQLException error = null;
conn.prepareStatement(null, new int[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error6() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1", new int[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error7() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1", new String[0]);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement_error8() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareStatement("SELECT 1", 0);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepareStatement() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_prepareStatement_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_prepareStatement_2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new int[0]);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new int[0]);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_prepareStatement_3() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new String[0]);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", new String[0]);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_prepareStatement_4() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareStatement("SELECT 1", 0);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT 1", 0);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_preCall_error() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_preCall_error_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_preCall_error_2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.prepareCall("SELECT 1");
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_prepCall() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_prepCall_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
MockPreparedStatement raw = null;
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY);
raw = stmt.unwrap(MockPreparedStatement.class);
stmt.close();
PreparedStatement stmt = conn.prepareCall("SELECT 1", ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY);
Assert.assertEquals(raw, stmt.unwrap(MockPreparedStatement.class));
stmt.close();
conn.close();
public void test_create() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.createStatement();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_create_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
ResultSet.HOLD_CURSORS_OVER_COMMIT);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_create_2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_setAutoCommit() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getAutoCommit();
conn.setAutoCommit(true);
conn.getConnection().close();
SQLException error = null;
conn.setAutoCommit(false);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_commit() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.commit();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_rollback() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.rollback();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_rollback_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.rollback(null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_releaseSavepoint_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
SQLException error = null;
conn.releaseSavepoint(null);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
public void test_addListenerError() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
conn.addConnectionEventListener(null);
} catch (IllegalStateException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_addListenerError2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
conn.addStatementEventListener(null);
} catch (IllegalStateException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_removeConnectionEventListener() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
conn.removeConnectionEventListener(null);
} catch (IllegalStateException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_removeStatementEventListener() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
conn.removeStatementEventListener(null);
} catch (IllegalStateException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_checkOpen_error() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
conn.checkOpen();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_equals_5() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", null, MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x1", null, MethodType.M2);
PreparedStatementKey k3 = new PreparedStatementKey("x1", null, MethodType.M3);
k1.hashCode();
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_6() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", null, MethodType.M1);
PreparedStatementKey k2 = new PreparedStatementKey("x2", null, MethodType.M1);
PreparedStatementKey k3 = new PreparedStatementKey("x3", null, MethodType.M1);
k1.hashCode();
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public final class ConnectionHolder {
conn.getConnectionHolder().toString();
conn.getConnectionHolder().setLastActiveTimeMillis(0);
conn.getConnectionHolder().toString();
conn.getConnectionHolder().getUseCount();
conn.getConnectionHolder().getTimeMillis();
public class ConnectionTest5 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat,trace");
JdbcStatContext context = new JdbcStatContext();
context.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(context);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
JdbcStatManager.getInstance().setStatContext(null);
public void test_basic() throws Exception {
PoolableConnection conn = (PoolableConnection) dataSource.getConnection();
conn.close();
Assert.assertEquals(true, dataSource.isResetStatEnable());
dataSource.setResetStatEnable(false);
Assert.assertEquals(false, dataSource.isResetStatEnable());
Assert.assertEquals(1, dataSource.getConnectCount());
dataSource.resetStat();
Assert.assertEquals(1, dataSource.getConnectCount());
dataSource.setResetStatEnable(true);
dataSource.resetStat();
Assert.assertEquals(0, dataSource.getConnectCount());
ValidConnectionChecker validConnectionChecker = null;
if (clazz != null) {
validConnectionChecker = (ValidConnectionChecker) clazz.newInstance();
public void setPasswordCallbackClassName(String passwordCallbackClassName) throws Exception {
Class<?> clazz = DruidLoaderUtils.loadClass(passwordCallbackClassName);
if (clazz != null) {
this.passwordCallback = (PasswordCallback) clazz.newInstance();
this.passwordCallback = null;
public class TestDataSourceBasic2 extends TestCase {
public void test_0() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setBreakAfterAcquireFailure(true);
Assert.assertEquals(true, dataSource.isBreakAfterAcquireFailure());
dataSource.setConnectionErrorRetryAttempts(234);
Assert.assertEquals(234, dataSource.getConnectionErrorRetryAttempts());
dataSource.setMaxPoolPreparedStatementPerConnectionSize(234);
Assert.assertEquals(234, dataSource.getMaxPoolPreparedStatementPerConnectionSize());
dataSource.incrementDupCloseCount();
Assert.assertEquals(1, dataSource.getDupCloseCount());
dataSource.setValidConnectionChecker(null);
dataSource.setValidConnectionCheckerClassName(null);
Assert.assertEquals(null, dataSource.getValidConnectionChecker());
dataSource.addConnectionProperty("user", "ljw");
Assert.assertEquals(1, dataSource.getConnectProperties().size());
Assert.assertEquals(0, dataSource.getConnectionInitSqls().size());
dataSource.setConnectionInitSqls(Arrays.<Object>asList("SELECT 1", null, ""));
Assert.assertEquals(1, dataSource.getConnectionInitSqls().size());
Assert.assertEquals(30 * 1000, dataSource.getTimeBetweenConnectErrorMillis());
Assert.assertEquals(-1, dataSource.getMaxOpenPreparedStatements());
Assert.assertEquals(300, dataSource.getRemoveAbandonedTimeout());
dataSource.setRemoveAbandonedTimeout(400);
Assert.assertEquals(400, dataSource.getRemoveAbandonedTimeout());
Assert.assertEquals(400 * 1000, dataSource.getRemoveAbandonedTimeoutMillis());
Assert.assertEquals(3, dataSource.getNumTestsPerEvictionRun());
dataSource.setNumTestsPerEvictionRun(4);
Assert.assertEquals(4, dataSource.getNumTestsPerEvictionRun());
dataSource.setMaxWaitThreadCount(4);
Assert.assertEquals(4, dataSource.getMaxWaitThreadCount());
dataSource.setValidationQueryTimeout(4);
Assert.assertEquals(4, dataSource.getValidationQueryTimeout());
dataSource.setAccessToUnderlyingConnectionAllowed(true);
Assert.assertEquals(true, dataSource.isAccessToUnderlyingConnectionAllowed());
dataSource.setDefaultReadOnly(true);
Assert.assertEquals(Boolean.TRUE, dataSource.getDefaultReadOnly());
dataSource.setDefaultTransactionIsolation(10);
Assert.assertEquals(Integer.valueOf(10), dataSource.getDefaultTransactionIsolation());
dataSource.setDefaultCatalog("xxx");
Assert.assertEquals("xxx", dataSource.getDefaultCatalog());
dataSource.setPasswordCallbackClassName(null);
dataSource.setUserCallback(null);
Assert.assertEquals(0, dataSource.getQueryTimeout());
dataSource.setQueryTimeout(10001);
Assert.assertEquals(10001, dataSource.getQueryTimeout());
Assert.assertEquals(-1, dataSource.getMaxWait());
dataSource.setMaxWait(10001);
Assert.assertEquals(10001, dataSource.getMaxWait());
Assert.assertEquals(8, dataSource.getMaxIdle());
dataSource.setMaxIdle(3);
Assert.assertEquals(3, dataSource.getMaxIdle());
Assert.assertEquals(0, dataSource.getLoginTimeout());
dataSource.setLoginTimeout(30);
Assert.assertEquals(30, dataSource.getLoginTimeout());
Assert.assertEquals(null, dataSource.getUsername());
dataSource.setUsername("ljw");
Assert.assertEquals("ljw", dataSource.getUsername());
Assert.assertEquals(null, dataSource.getPassword());
dataSource.setPassword("xxx");
Assert.assertEquals("xxx", dataSource.getPassword());
dataSource.setConnectProperties(new Properties());
Assert.assertEquals(0, dataSource.getConnectProperties().size());
dataSource.setConnectionProperties("a=1;b=2;c");
Assert.assertEquals(3, dataSource.getConnectProperties().size());
dataSource.setExceptionSoter((ExceptionSorter) null);
dataSource.close();
protected void tearDown() throws Exception {
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
dataSource.close();
private final Wrapper wrapper;
this.wrapper = wraaper;
return wrapper.isWrapperFor(iface);
return wrapper.unwrap(iface);
public class PoolableWrapperTest extends TestCase {
public void test_isWrapper() throws Exception {
PoolableWrapper wrapper = new PoolableWrapper(new MockConnection());
Assert.assertEquals(false, wrapper.isWrapperFor(null));
Assert.assertEquals(true, wrapper.isWrapperFor(PoolableWrapper.class));
Assert.assertEquals(true, wrapper.isWrapperFor(MockConnection.class));
public void test_handleException_5() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.addConnectionEventListener(new ConnectionEventListener() {
public void connectionClosed(ConnectionEvent event) {
public void connectionErrorOccurred(ConnectionEvent event) {
conn.getConnection().close();
SQLException error = null;
conn.handleException(new RuntimeException());
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
conn.close();
@SuppressWarnings("unchecked")
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
dataSource.handleConnectionException(this, t);
conn.close();
dataSource.setTestOnBorrow(true);
dataSource.setTestOnReturn(true);
public void test_unwrap() throws Exception {
PoolableWrapper wrapper = new PoolableWrapper(new MockConnection());
Assert.assertEquals(null, wrapper.unwrap(null));
Assert.assertEquals(true, wrapper.unwrap(PoolableWrapper.class) != null);
Assert.assertEquals(true, wrapper.unwrap(MockConnection.class) != null);
public class DataSourceTest3 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(true);
dataSource.setTestOnReturn(true);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat,trace");
JdbcStatContext context = new JdbcStatContext();
context.setTraceEnable(true);
JdbcStatManager.getInstance().setStatContext(context);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
JdbcStatManager.getInstance().setStatContext(null);
public void test_prepareStatement_error() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setUsername("xxx");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setPoolPreparedStatements(false);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setMaxWait(1);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_3() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setMinIdle(1);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_4() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setMaxIdle(1);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_5() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setInitialSize(1);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_6() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setMaxActive(1);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_7() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setPassword("xx");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_8() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setConnectProperties(new Properties());
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_9() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setConnectionProperties("x=12");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_getValidConnectionCheckerClassName() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
dataSource.getValidConnectionCheckerClassName();
public void test_setConnectionInitSqls() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
dataSource.setConnectionInitSqls(null);
public void test_setConnectionProperties() throws Exception {
dataSource.setConnectionProperties(null);
dataSource.setLogWriter(null);
dataSource.getLogWriter();
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
public void test_error_10() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.addConnectionProperty("x", "11");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_11() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
dataSource.getUrl();
Exception error = null;
dataSource.setUrl("x");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public class DruidDataSourceFactoryTest extends TestCase {
@SuppressWarnings("serial")
public void test_factory() throws Exception {
DruidDataSourceFactory factory = new DruidDataSourceFactory();
Assert.assertNull(factory.getObjectInstance(null, null, null, null));
Assert.assertNull(factory.getObjectInstance(new Reference("javax.sql.Date"), null, null, null));
Reference ref = new Reference("javax.sql.DataSource");
ref.add(new RefAddr("user") {
public Object getContent() {
return null;
ref.add(new RefAddr("defaultReadOnly") {
public Object getContent() {
return Boolean.TRUE;
factory.getObjectInstance(ref, null, null, new Hashtable<Object, Object>());
this.setExceptionSorter(exceptionSorter);
public void setExceptionSorter(String exceptionSorter) throws Exception {
dataSource.setExceptionSorter(value);
dataSource.setExceptionSorter(value);
dataSource.setConnectionProperties("x=12;;");
public void test_setConnectionInitSqls_2() throws Exception {
dataSource.setConnectionInitSqls(Collections.emptyList());
dataSource.setConnectionInitSqls(Collections.singleton(null));
public void test_ValidConnectionChecker() throws Exception {
dataSource.getValidConnectionCheckerClassName();
dataSource.setValidConnectionChecker(new MySqlValidConnectionChecker());
Assert.assertEquals(MySqlValidConnectionChecker.class.getName(),
dataSource.getValidConnectionCheckerClassName());
public void test_setConnectionInitSqls_1() throws Exception {
dataSource.setConnectionInitSqls(Collections.emptyList());
dataSource.setConnectionInitSqls(Collections.singleton(null));
public static class MyPasswordCallbackClassName extends PasswordCallback {
public MyPasswordCallbackClassName(){
super("password", false);
private static final long serialVersionUID = 1L;
public void test_setPasswordCallbackClassName() throws Exception {
dataSource.setPasswordCallbackClassName(MyPasswordCallbackClassName.class.getName());
public void test_error_12() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.setDriverClassName("");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_setExceptionSorter() throws Exception {
dataSource.setExceptionSorter(NullExceptionSorter.class.getName());
public void test_setProxyFilters() throws Exception {
dataSource.setProxyFilters(null);
dataSource.setFilters(null);
dataSource.setFilters("");
dataSource.setExceptionSorter(MySqlExceptionSorter.class.getName());
dataSource.setExceptionSorter(OracleExceptionSorter.class.getName());
public void validateConnection(Connection conn) throws SQLException {
ResultSet rs = null;
rs = stmt.executeQuery(query);
if (!rs.next()) {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
public void test_error_validateConnection() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.close();
Exception error = null;
dataSource.validateConnection(conn);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_validateConnection_2() throws Exception {
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
conn.getConnection().close();
Exception error = null;
dataSource.validateConnection(conn);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_validateConnection_3() throws Exception {
dataSource.setValidationQuery(null);
dataSource.setValidConnectionChecker(new MySqlValidConnectionChecker());
PoolableConnection conn = dataSource.getConnection().unwrap(PoolableConnection.class);
dataSource.validateConnection(conn);
Exception error = null;
dataSource.validateConnection(conn);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
public class DruidDataSourceC3P0AdapterTest2 extends TestCase {
public void test_0() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
DruidDataSourceC3P0Adapter dataSource = new DruidDataSourceC3P0Adapter();
dataSource.setJdbcUrl("jdbc:mock:xxx");
dataSource.setLogWriter(dataSource.getLogWriter());
dataSource.setLoginTimeout(dataSource.getLoginTimeout());
Assert.assertTrue(dataSource.isWrapperFor(DruidDataSourceC3P0Adapter.class));
Assert.assertTrue(dataSource.isWrapperFor(DruidDataSource.class));
Assert.assertTrue(dataSource.isWrapperFor(DataSource.class));
Assert.assertFalse(dataSource.isWrapperFor(null));
dataSource.close();
protected void tearDown() throws Exception {
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
dataSource.close();
Assert.assertNotNull(dataSource.unwrap(DruidDataSourceC3P0Adapter.class));
Assert.assertNotNull(dataSource.unwrap(DruidDataSource.class));
Assert.assertNotNull(dataSource.unwrap(DataSource.class));
Assert.assertNull(dataSource.unwrap(null));
dataSource.setProperties(dataSource.getProperties());
dataSource.setUser(dataSource.getUser());
dataSource.setPassword(dataSource.getPassword());
dataSource.setCheckoutTimeout(dataSource.getCheckoutTimeout());
dataSource.setAutoCommitOnClose(dataSource.isAutoCommitOnClose());
dataSource.setIdleConnectionTestPeriod(dataSource.getIdleConnectionTestPeriod());
dataSource.setInitialPoolSize(dataSource.getInitialPoolSize());
dataSource.setMaxIdleTime(dataSource.getMaxIdleTime());
dataSource.setMaxPoolSize(dataSource.getMaxPoolSize());
dataSource.setMinPoolSize(dataSource.getMinPoolSize());
dataSource.setTestConnectionOnCheckout(dataSource.isTestConnectionOnCheckout());
dataSource.setTestConnectionOnCheckin(dataSource.isTestConnectionOnCheckin());
dataSource.setPreferredTestQuery(dataSource.getPreferredTestQuery());
dataSource.setProxyFilters(dataSource.getProxyFilters());
dataSource.getDataSourceName();
dataSource.getNumConnections();
dataSource.getNumIdleConnections();
dataSource.getNumBusyConnections();
dataSource.getNumUnclosedOrphanedConnections();
dataSource.getNumConnectionsDefaultUser();
dataSource.getNumIdleConnectionsDefaultUser();
dataSource.getNumBusyConnectionsDefaultUser();
dataSource.getMaxStatementsPerConnection();
dataSource.getMaxStatements();
dataSource.setUnreturnedConnectionTimeout(dataSource.getUnreturnedConnectionTimeout());
dataSource.isDebugUnreturnedConnectionStackTraces();
dataSource.setAcquireRetryAttempts(dataSource.getAcquireRetryAttempts());
dataSource.setAcquireRetryDelay(dataSource.getAcquireRetryDelay());
dataSource.setBreakAfterAcquireFailure(dataSource.isBreakAfterAcquireFailure());
dataSource.isEnable();
dataSource.shrink();
dataSource.getWaitThreadCount();
dataSource.getLockQueueLength();
public void test_createDataSource() throws Exception {
Properties properties = new Properties();
properties.setProperty("defaultAutoCommit", "true");
properties.setProperty("defaultReadOnly", "true");
properties.setProperty("defaultTransactionIsolation", "NONE");
properties.setProperty("defaultCatalog", "cn");
properties.setProperty("driverClassName", "com.alibaba.druid.mock.MockDriver");
properties.setProperty("maxActive", "8");
properties.setProperty("maxIdle", "8");
properties.setProperty("minIdle", "3");
properties.setProperty("initialSize", "1");
properties.setProperty("maxWait", "-1");
properties.setProperty("testOnBorrow", "true");
properties.setProperty("testOnReturn", "true");
properties.setProperty("timeBetweenEvictionRunsMillis", "3000");
properties.setProperty("numTestsPerEvictionRun", "1");
properties.setProperty("minEvictableIdleTimeMillis", "10000");
properties.setProperty("testWhileIdle", "true");
properties.setProperty("password", "xxx");
properties.setProperty("url", "jdbc:mock:xxx");
properties.setProperty("username", "user");
properties.setProperty("validationQuery", "select 1");
properties.setProperty("validationQueryTimeout", "30");
DruidDataSourceFactory.createDataSource(properties);
properties.setProperty("initConnectionSqls", "select 1");
properties.setProperty("accessToUnderlyingConnectionAllowed", "true");
properties.setProperty("removeAbandoned", "true");
properties.setProperty("removeAbandonedTimeout", "30");
properties.setProperty("logAbandoned", "true");
properties.setProperty("poolPreparedStatements", "true");
properties.setProperty("maxOpenPreparedStatements", "200");
properties.setProperty("connectionProperties", "x=1;y=2;;");
properties.setProperty("filters", "stat;trace");
properties.setProperty("exceptionSorter", "com.alibaba.druid.pool.vendor.NullExceptionSorter");
properties.setProperty("exception-sorter-class-name", "com.alibaba.druid.pool.vendor.NullExceptionSorter");
return chain.connection_createStatement(connection, resultSetType, resultSetConcurrency);
return chain.connection_createStatement(connection, resultSetType, resultSetConcurrency, resultSetHoldability);
dataSource.setExceptionSorter((ExceptionSorter) null);
StatementProxy statement = super.connection_createStatement(chain, connection, resultSetType, resultSetConcurrency);
StatementProxy statement = super.connection_createStatement(chain, connection, resultSetType, resultSetConcurrency,
MockStatement stmt = new MockStatement(this);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
return stmt;
protected boolean          closed    = false;
private int                resultSetType;
private int                resultSetConcurrency;
public int getResultSetType() throws SQLException {
if (closed) {
throw new SQLException("stmt closed.");
return resultSetType;
public void setResultSetType(int resultType) {
this.resultSetType = resultType;
public void setResultSetConcurrency(int resultSetConcurrency) {
this.resultSetConcurrency = resultSetConcurrency;
return resultSetConcurrency;
return createChain().connection_createStatement(this, resultSetType, resultSetConcurrency);
return createChain().connection_createStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
public class Bug_for_happyday517 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_for_happyday517() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
stmt.close();
conn.close();
MockPreparedStatement stmt = new MockPreparedStatement(this, sql);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
return stmt;
MockCallableStatement stmt = new MockCallableStatement(this, sql);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
return stmt;
MockStatement stmt = new MockStatement(this);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
stmt.setResultSetHoldability(resultSetHoldability);
return stmt;
MockPreparedStatement stmt = new MockPreparedStatement(this, sql);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
stmt.setResultSetHoldability(resultSetHoldability);
return stmt;
MockCallableStatement stmt = new MockCallableStatement(this, sql);
stmt.setResultSetType(resultSetType);
stmt.setResultSetConcurrency(resultSetConcurrency);
stmt.setResultSetHoldability(resultSetHoldability);
return stmt;
private int                resultSetHoldability;
return resultSetHoldability;
public void setResultSetHoldability(int resultSetHoldability) {
this.resultSetHoldability = resultSetHoldability;
dataSource.setFilters("stat,trace,log");
public void test_for_happyday517_0() throws Exception {
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
stmt.close();
conn.close();
public void test_for_happyday517_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
stmt.close();
conn.close();
public void test_for_happyday517_2() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
stmt.close();
conn.close();
public void test_for_happyday517_3() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
Statement stmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
stmt.close();
conn.close();
public void test_for_happyday517_4() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
conn.close();
public void test_for_happyday517_5() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
Statement stmt = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_SENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
stmt.close();
dataSource.setFilters("stat,trace,log,encoding");
public long[] getTransactionHistogramValues() {
return transactionHistogram.toArray();
long[] getTransactionHistogramValues();
public PoolableCallableStatement(PoolableConnection conn, CallableStatement stmt, PreparedStatementKey key, String sql){
super(conn, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
CallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
CallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
CallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
private final String               sql;
public PoolablePreparedStatement(PoolableConnection conn, PreparedStatement stmt, PreparedStatementKey key,
String sql){
this.sql = sql;
public String getSql() {
return sql;
transactionRecord(sql);
transactionRecord(sql);
transactionRecord(sql);
public int[] executeBatch() throws SQLException {
transactionRecord(sql);
return super.executeBatch();
transactionRecord(sql);
protected void transactionRecord(String sql) {
if (conn.getTransactionInfo() != null) {
conn.getTransactionInfo().getSqlList().add(sql);
transactionRecord(sql);
transactionRecord(sql);
public int[] executeBatch() throws SQLException {
transactionRecord(sql);
transactionRecord(sql);
transactionRecord(sql);
transactionRecord(sql);
transactionRecord(sql);
transactionRecord(sql);
stmt = new PoolableCallableStatement(null, raw, null, null) {
stmt = new PoolablePreparedStatement(null, raw, null, null) {
pool.put(new PoolablePreparedStatement(null, null, k1, null));
dataSource.setFilters("stat,trace,log4j,encoding");
dataSource.logTransaction( transactionInfo);
if (transactionInfo == null) {
protected void transactionRecord(String sql) throws SQLException {
if (transactionInfo == null && (!conn.getAutoCommit())) {
DruidAbstractDataSource dataSource = holder.getDataSource();
dataSource.incrementStartTransactionCount();
transactionInfo = new TransactionInfo(dataSource.createTransactionId());
if (transactionInfo != null) {
transactionInfo.getSqlList().add(sql);
protected void transactionRecord(String sql) throws SQLException {
conn.transactionRecord(sql);
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1");
stmt.close();
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1");
stmt.close();
public boolean visit(OracleConstraintState x) {
printlnAndAccept(x.getStates(), " ");
return false;
public void test_close_error() throws Exception {
public void test_close_error_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
MockConnection conn = new MockConnection() {
public void close() throws SQLException {
throw new RuntimeException();
Exception error = null;
filter.connection_close(chain, new ConnectionProxyImpl(dataSource, conn, new Properties(), 0));
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public class OracleDbLinkExpr extends SQLExprImpl implements SQLName {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLName) {
String ident = ((SQLName) expr).toString();
if (tableSource.getExpr() instanceof SQLName) {
String ident = ((SQLName) tableSource.getExpr()).toString();
String sql = "SELECT MAX(salary) from emp where F1 = Date '2011-10-01'";
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("emp", "F1")));
Assert.assertEquals("SELECT MAX(salary)nFROM empnWHERE F1 = DATE '2011-10-01';n", buf.toString());
public class OracleOutputVisitorTest_dblink extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT salary from master@emp";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("master@emp"));
Assert.assertEquals(1, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("master@emp", "salary")));
StringBuilder buf = new StringBuilder();
OracleOutputVisitor outputVisitor = new OracleOutputVisitor(buf);
stmt.accept(outputVisitor);
Assert.assertEquals("SELECT salarynFROM master@emp;n", buf.toString());
void setTransactionThresholdMillis(long transactionThresholdMillis);
long getTransactionThresholdMillis();
public long[] getTransactionHistogramRanges() {
return transactionHistogram.getRanges();
public long[] getRanges() {
return ranges;
public class OracleOutputVisitorTest_delete extends TestCase {
public void test_0() throws Exception {
String sql = "DELETE FROM employee where id = 3";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("employee"));
Assert.assertEquals(1, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "id")));
StringBuilder buf = new StringBuilder();
OracleOutputVisitor outputVisitor = new OracleOutputVisitor(buf);
stmt.accept(outputVisitor);
Assert.assertEquals("DELETE FROM employee WHERE id = 3;n", buf.toString());
public class OracleOutputVisitorTest_forupdate extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT salary from employee for update";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("employee"));
Assert.assertEquals(1, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "salary")));
StringBuilder buf = new StringBuilder();
OracleOutputVisitor outputVisitor = new OracleOutputVisitor(buf);
stmt.accept(outputVisitor);
Assert.assertEquals("SELECT salarynFROM employeenFOR UPDATE;n", buf.toString());
public class OracleOutputVisitorTest_orderBy extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT salary from employee order by name";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("employee"));
Assert.assertEquals(2, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "salary")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "name")));
StringBuilder buf = new StringBuilder();
OracleOutputVisitor outputVisitor = new OracleOutputVisitor(buf);
stmt.accept(outputVisitor);
Assert.assertEquals("SELECT salarynFROM employeenORDER BY name;n", buf.toString());
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
Assert.assertEquals("DELETE FROM employeenWHERE id = 3;n", buf.toString());
public class OracleOutputVisitorTest_selectJoin extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT e.salary from employee e join department d where e.depId = d.id";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("employee"));
Assert.assertEquals(true, visitor.containsTable("department"));
Assert.assertEquals(3, visitor.getFields().size());
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "salary")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("employee", "depId")));
Assert.assertEquals(true, visitor.getFields().contains(new Column("department", "id")));
StringBuilder buf = new StringBuilder();
OracleOutputVisitor outputVisitor = new OracleOutputVisitor(buf);
stmt.accept(outputVisitor);
Assert.assertEquals("SELECT e.salarynFROM employee e JOIN department dnWHERE e.depId = d.id;n", buf.toString());
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
if (stmt != null) {
return stmt.unwrap(iface);
return null;
private HADataSource    dataSourceHA;
public void test_0() throws Exception {
conn.close();
public void test_1() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.close();
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, stmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, stmt.getResultSetConcurrency());
stmt.close();
conn.close();
public void test_2() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.close();
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, stmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, stmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, stmt.getResultSetHoldability());
stmt.close();
return statementIdSeed.incrementAndGet();
public void test_createStatement_0() throws Exception {
stmt.setMaxFieldSize(100);
stmt.setMaxRows(201);
stmt.setEscapeProcessing(true);
stmt.setQueryTimeout(101);
stmt.setCursorName("cName");
stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
stmt.setFetchSize(202);
MultiDataSourceStatement dsStmt = stmt.unwrap(MultiDataSourceStatement.class);
Assert.assertTrue(dsStmt.getId() > 0);
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(100, mockStmt.getMaxFieldSize());
Assert.assertEquals(201, mockStmt.getMaxRows());
Assert.assertEquals(true, mockStmt.isEscapeProcessing());
Assert.assertEquals(101, mockStmt.getQueryTimeout());
Assert.assertEquals("cName", mockStmt.getCursorName());
Assert.assertEquals(ResultSet.FETCH_REVERSE, mockStmt.getFetchDirection());
Assert.assertEquals(202, mockStmt.getFetchSize());
public void test_createStatement_1() throws Exception {
stmt.close();
conn.close();
public void test_createStatement_2() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.close();
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, stmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, stmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, stmt.getResultSetHoldability());
public void test_createStatement_3() throws Exception {
public Boolean isEscapeProcessing() {
return escapeProcessing;
public String getCursorName() {
return cursorName;
Assert.assertEquals(100, stmt.getMaxFieldSize());
Assert.assertEquals(201, stmt.getMaxRows());
Assert.assertEquals(true, dsStmt.isEscapeProcessing().booleanValue());
Assert.assertEquals(101, stmt.getQueryTimeout());
Assert.assertEquals("cName", dsStmt.getCursorName());
Assert.assertEquals(ResultSet.FETCH_REVERSE, stmt.getFetchDirection());
Assert.assertEquals(202, stmt.getFetchSize());
MultiDataSourceStatement dsStmt = stmt.unwrap(MultiDataSourceStatement.class);
Assert.assertTrue(dsStmt.getId() > 0);
Assert.assertEquals(100, stmt.getMaxFieldSize());
Assert.assertEquals(201, stmt.getMaxRows());
Assert.assertEquals(true, dsStmt.isEscapeProcessing().booleanValue());
Assert.assertEquals(101, stmt.getQueryTimeout());
Assert.assertEquals("cName", dsStmt.getCursorName());
Assert.assertEquals(ResultSet.FETCH_REVERSE, stmt.getFetchDirection());
Assert.assertEquals(202, stmt.getFetchSize());
dataSourceA.setFilters("trace");
dataSourceB.setFilters("stat");
public void test_createStatement_4() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
stmt.executeUpdate("SET @user = 'xxx'");
MockStatement mockStmt = stmt.unwrap(MockStatement.class);
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, mockStmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, mockStmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, mockStmt.getResultSetHoldability());
Assert.assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, stmt.getResultSetType());
Assert.assertEquals(ResultSet.CONCUR_UPDATABLE, stmt.getResultSetConcurrency());
Assert.assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, stmt.getResultSetHoldability());
stmt.close();
conn.close();
public void test_close() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE,
ResultSet.CLOSE_CURSORS_AT_COMMIT);
stmt.getMaxFieldSize();
stmt.getMaxRows();
stmt.cancel();
stmt.getWarnings();
stmt.clearWarnings();
stmt.getResultSet();
stmt.getUpdateCount();
stmt.getMoreResults();
stmt.getMoreResults(1);
stmt.getResultSetConcurrency();
stmt.getResultSetHoldability();
stmt.getResultSetType();
stmt.getConnection();
stmt.getGeneratedKeys();
stmt.isClosed();
stmt.close();
conn.close();
public void test_set() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT ?");
stmt.setInt(1, 123);
stmt.setArray(1, null);
stmt.setAsciiStream(1, null);
stmt.setAsciiStream(1, null, 0);
stmt.setAsciiStream(1, null, 0L);
stmt.setBigDecimal(1, null);
stmt.setBinaryStream(1, null);
stmt.setBinaryStream(1, null, 0);
stmt.setBinaryStream(1, null, 0L);
stmt.setBlob(1, (Blob) null);
stmt.setBlob(1, (InputStream) null);
stmt.setBlob(1, (InputStream) null, 0);
stmt.setBoolean(1, true);
stmt.setByte(1, (byte) 12);
stmt.setBytes(1, null);
stmt.setCharacterStream(1, null);
stmt.setCharacterStream(1, null, 0);
stmt.setCharacterStream(1, null, 0L);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
stmt.setClob(1, (Clob) null);
stmt.setClob(1, (Reader) null);
stmt.setClob(1, (Reader) null, 1);
stmt.setDate(1, null);
stmt.setDate(1, null, null);
stmt.setDouble(1, 1D);
stmt.setFloat(1, 1F);
stmt.setLong(1, 1L);
stmt.setNCharacterStream(1, null);
stmt.setNCharacterStream(1, null, 0);
stmt.setNClob(1, (NClob) null);
stmt.setNClob(1, (Reader) null);
stmt.setNClob(1, (Reader) null, 1);
stmt.setNull(1, Types.INTEGER);
stmt.setNull(1, Types.INTEGER, "int");
stmt.setObject(1, null);
stmt.setObject(1, null, Types.INTEGER);
stmt.setObject(1, null, Types.INTEGER, 2);
stmt.setRef(1, null);
stmt.setRowId(1, null);
stmt.setShort(1, (short) 1);
stmt.setSQLXML(1, null);
stmt.setString(1, null);
stmt.setTime(1, null);
stmt.setTime(1, null, null);
stmt.setTimestamp(1, null);
stmt.setTimestamp(1, null, null);
stmt.setUnicodeStream(1, null, 0);
stmt.setURL(1, null);
rs.previous();
rs.next();
Assert.assertTrue(meta.unwrap(null) == null);
Assert.assertTrue(meta.unwrap(java.sql.ResultSetMetaData.class) != null);
Assert.assertTrue(meta.unwrap(Object.class) != null);
Assert.assertTrue(meta.unwrap(Date.class) == null);
ColumnMetaData column = new ColumnMetaData();
meta.getColumns().add(column);
meta.isAutoIncrement(1);
meta.isCaseSensitive(1);
meta.isSearchable(1);
meta.isCurrency(1);
meta.isNullable(1);
meta.isSigned(1);
meta.getColumnDisplaySize(1);
meta.getColumnLabel(1);
meta.getSchemaName(1);
meta.getPrecision(1);
meta.getScale(1);
meta.getTableName(1);
meta.getCatalogName(1);
meta.getColumnTypeName(1);
meta.isReadOnly(1);
meta.isWritable(1);
meta.isDefinitelyWritable(1);
meta.getColumnClassName(1);
if (iface == null) {
return null;
if (iface.isAssignableFrom(MockResultSetMetaData.class)) {
if (iface == null) {
return false;
for (;;) {
if (lexer.token() == Token.AND || lexer.token() == Token.AMPAMP) {
lexer.nextToken();
SQLExpr rightExp = relational();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanAnd, rightExp);
for (;;) {
if (lexer.token() == Token.OR) {
lexer.nextToken();
SQLExpr rightExp = and();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp);
} else if (lexer.token() == Token.XOR) {
lexer.nextToken();
SQLExpr rightExp = and();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp);
public class LargeOrTest extends TestCase {
public void test_largeOr() throws Exception {
StringBuffer buf = new StringBuffer();
buf.append("SELECT 1 FROM T WHERE ID = ?");
for (int i = 0; i < 10000; ++i) {
buf.append(" OR ID = ?");
String sql = buf.toString();
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
SQLSelectQueryBlock select = (SQLSelectQueryBlock) stmt.getSelect().getQuery();
SQLBinaryOpExpr where = (SQLBinaryOpExpr) select.getWhere();
SQLBinaryOpExpr last = (SQLBinaryOpExpr) where.getRight();
Assert.assertEquals(SQLBinaryOperator.Equality, last.getOperator());
public void test_largeAnd() throws Exception {
StringBuffer buf = new StringBuffer();
buf.append("SELECT 1 FROM T WHERE ID = ?");
for (int i = 0; i < 10000; ++i) {
buf.append(" AND ID = ?");
String sql = buf.toString();
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
SQLSelectQueryBlock select = (SQLSelectQueryBlock) stmt.getSelect().getQuery();
SQLBinaryOpExpr where = (SQLBinaryOpExpr) select.getWhere();
SQLBinaryOpExpr last = (SQLBinaryOpExpr) where.getRight();
Assert.assertEquals(SQLBinaryOperator.Equality, last.getOperator());
private final Histogram  histogram             = new Histogram(new long[] { 
4, 15, 60, 250, 
1000, 4 * 1000, 15 * 1000, 60 * 1000, 250 * 1000
histogram.reset();
long millis = nanoSpan / (1000 * 1000);
histogram.recode(millis);
, new ArrayType<Long>(1, SimpleType.LONG)
, "ExecuteCountHistogram"};
map.put("ExecuteCountHistogram", this.histogram.toArray());
public class TestHistogram extends TestCase {
public void test_histogram() throws Exception {
int val = 4;
for (int i = 0; i < 10; ++i) {
System.out.println(val);
public final static int RevisionVersion = 11;
SQLExpr rightExp = bitXor();
SQLExpr rightExp = bitXor();
SQLExpr rightExp = bitXor();
SQLExpr expr = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
rightExp = bitOr();
SQLExpr rightExp = equality();
map.put("ConnectionHistogram", stat.getConnectionHistogramValues());
map.put("StatementHistogram", stat.getStatementStat().getHistogramValues());
map.put("ConnectionHistogram", new long[0]);
map.put("StatementHistogram", new long[0]);
private DruidDataSource               masterDataSource;
map.put("ConnectionHistogram", stat.getConnectionHistogramValues());
map.put("StatementHistogram", stat.getStatementStat().getHistogramValues());
map.put("ConnectionHistogram", new long[0]);
map.put("StatementHistogram", new long[0]);
private final AtomicInteger activeCount           = new AtomicInteger();
private final AtomicInteger activeCountMax        = new AtomicInteger();
private final AtomicInteger connectingCount       = new AtomicInteger();
private final AtomicInteger connectingMax         = new AtomicInteger();
private final AtomicLong    connectCount          = new AtomicLong();
private final AtomicLong    connectErrorCount     = new AtomicLong();
private final AtomicLong    connectNanoTotal      = new AtomicLong(0);                       
private final AtomicLong    connectNanoMax        = new AtomicLong(0);                       
private final AtomicLong    errorCount            = new AtomicLong();
private final AtomicLong    aliveNanoTotal        = new AtomicLong();
private long                connectLastTime       = 0;
private final AtomicLong    closeCount            = new AtomicLong(0);                       
private final AtomicLong    transactionStartCount = new AtomicLong(0);
private final AtomicLong    commitCount           = new AtomicLong(0);                       
private final AtomicLong    rollbackCount         = new AtomicLong(0);                       
private final AtomicLong    aliveNanoMin          = new AtomicLong();
private final AtomicLong    aliveNanoMax          = new AtomicLong();
private final Histogram     histogram             = new Histogram(TimeUnit.SECONDS, new long[] { 
1, 5, 15, 60, 300, 1800 });
histogram.reset();
long aliveMillis = aliveNano / (1000 * 1000);
histogram.recode(aliveMillis);
public long[] getHistorgramValues() {
return this.histogram.toArray();
public long[] getHistogramRanges() {
return this.histogram.getRanges();
public long[] getConnectionHistogramRanges() {
return connectionStat.getHistogramRanges();
public long[] getConnectionHistogramValues() {
return connectionStat.getHistorgramValues();
long[] getConnectionHistogramValues();
long[] getConnectionHistogramRanges();
, new ArrayType<Long>(SimpleType.LONG, true), new ArrayType<Long>(SimpleType.LONG, true)
"ResultSetErrorCount", "ResultSetOpenningMillisTotal", "ResultSetLastErrorTime",
"ResultSetLastErrorMessage", "ResultSetLastErrorStackTrace", "ConnectionConnectCount",
"ConnectionErrorLastMessage", "ConnectionErrorLastStackTrace",
, "ConnectionConnectMillisMax", "ConnectionErrorLastTime", "ConnectionAliveMillisMax",
, "ConnectionHistogram", "StatementHistogram",
private final AtomicLong    createCount      = new AtomicLong(0);                                     
private final AtomicLong    prepareCount     = new AtomicLong(0);                                     
private final AtomicLong    prepareCallCount = new AtomicLong(0);                                     
private final AtomicLong    closeCount       = new AtomicLong(0);                                     
private final AtomicInteger runningCount     = new AtomicInteger();
private final AtomicInteger concurrentMax    = new AtomicInteger();
private final AtomicLong    count            = new AtomicLong();
private final AtomicLong    errorCount       = new AtomicLong();
private final AtomicLong    nanoTotal        = new AtomicLong();
private long                lastSampleTime   = 0;
private final Histogram     histogram        = new Histogram(new long[] { 10, 100, 1000, 1000 * 10 });
public long[] getHistogramRanges() {
return histogram.getRanges();
public long[] getHistogramValues() {
return histogram.toArray();
histogram.reset();
long millis = nanoSpan / (1000 * 1000);
histogram.recode(millis);
map.put("ErrorCount", dataSource.getErrorCount());
SimpleType.LONG, SimpleType.LONG, SimpleType.LONG,
"NotEmptyWaitCount", "NotEmptyWaitNanos", "ErrorCount"
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void addTrace(PoolableStatement stmt) {
public void removeTrace(PoolableStatement stmt) {
public PoolableCallableStatement(PoolableConnection conn, CallableStatement stmt, PreparedStatementKey key,
String sql) throws SQLException{
PreparedStatement stmt = null;
if (holder.isPoolPreparedStatements()) {
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement stmt = null;
if (holder.isPoolPreparedStatements()) {
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement stmt = null;
if (holder.isPoolPreparedStatements()) {
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement stmt = null;
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql, columnIndexes);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement stmt = null;
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql, columnNames);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
PreparedStatement stmt = null;
stmt = holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareStatement(sql, autoGeneratedKeys);
} catch (SQLException ex) {
handleException(ex);
PoolablePreparedStatement rtnVal = new PoolablePreparedStatement(this, stmt, key, sql);
CallableStatement stmt = null;
if (holder.isPoolPreparedStatements()) {
stmt = (CallableStatement) holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareCall(sql);
} catch (SQLException ex) {
handleException(ex);
PoolableCallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
CallableStatement stmt = null;
stmt = (CallableStatement) holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
} catch (SQLException ex) {
handleException(ex);
PoolableCallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
CallableStatement stmt = null;
stmt = (CallableStatement) holder.getStatementPool().get(key);
if (stmt == null) {
stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency);
} catch (SQLException ex) {
handleException(ex);
PoolableCallableStatement rtnVal = new PoolableCallableStatement(this, stmt, key, sql);
dataSource.logTransaction(transactionInfo);
private int                        defaultMaxFieldSize;
private int                        defaultMaxRows;
private int                        defaultQueryTimeout;
private int                        defaultFetchDirection;
private int                        defaultFetchSize;
private int                        currentMaxFieldSize;
private int                        currentMaxRows;
private int                        currentQueryTimeout;
private int                        currentFetchDirection;
private int                        currentFetchSize;
String sql) throws SQLException{
defaultMaxFieldSize = stmt.getMaxFieldSize();
defaultMaxRows = stmt.getMaxRows();
defaultQueryTimeout = stmt.getQueryTimeout();
defaultFetchDirection = stmt.getFetchDirection();
defaultFetchSize = stmt.getFetchSize();
currentMaxFieldSize = defaultMaxFieldSize;
currentMaxRows = defaultMaxRows;
currentQueryTimeout = defaultQueryTimeout;
currentFetchDirection = defaultFetchDirection;
currentFetchSize = defaultFetchSize;
public void setFetchSize(int rows) throws SQLException {
currentFetchSize = rows;
super.setFetchSize(rows);
public void setFetchDirection(int direction) throws SQLException {
currentFetchDirection = direction;
super.setFetchDirection(direction);
public void setMaxFieldSize(int max) throws SQLException {
currentMaxFieldSize = max;
super.setMaxFieldSize(max);
public void setMaxRows(int max) throws SQLException {
currentMaxRows = max;
super.setMaxRows(max);
public void setQueryTimeout(int seconds) throws SQLException {
currentQueryTimeout = seconds;
super.setQueryTimeout(seconds);
if (defaultMaxFieldSize != currentMaxFieldSize) {
stmt.setMaxFieldSize(defaultMaxFieldSize);
currentMaxFieldSize = defaultMaxFieldSize;
if (defaultMaxRows != currentMaxRows) {
stmt.setMaxRows(defaultMaxRows);
currentMaxRows = defaultMaxRows;
if (defaultQueryTimeout != currentQueryTimeout) {
stmt.setQueryTimeout(defaultQueryTimeout);
currentQueryTimeout = defaultQueryTimeout;
if (defaultFetchDirection != currentFetchDirection) {
stmt.setFetchDirection(defaultFetchDirection);
currentFetchDirection = defaultFetchDirection;
if (defaultFetchSize != currentFetchSize) {
stmt.setFetchSize(defaultFetchSize);
currentFetchSize = defaultFetchSize;
public int getMaxFieldSize() throws SQLException {
public void setMaxFieldSize(int max) throws SQLException {
public void setMaxRows(int max) throws SQLException {
public void setQueryTimeout(int seconds) throws SQLException {
public void setFetchDirection(int direction) throws SQLException {
public void setFetchSize(int rows) throws SQLException {
private HashMap<PreparedStatementKey, PreparedStatement> map = new HashMap<PreparedStatementKey, PreparedStatement>();
public PreparedStatement get(PreparedStatementKey key) {
return map.remove(key);
map.put(key, poolableStatement.getRawPreparedStatement());
public HashMap<PreparedStatementKey, PreparedStatement> getMap() {
SQLExpr expr = primary();
SQLExpr expr = shift();
rightExp = shift();
rightExp = shift();
, new ArrayType<Long>(SimpleType.LONG, true)
, "Histogram"};
map.put("Histogram", this.histogram.toArray());
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(stmt.unwrap(MockStatement.class), stmt2.unwrap(MockStatement.class));
Assert.assertEquals(true, stmt.isClosed());
Assert.assertEquals(stmt.unwrap(MockStatement.class), stmt2.unwrap(MockStatement.class));
pool.put(new PoolablePreparedStatement(null, new MockPreparedStatement(null, null), k1, null));
long[] histogram = (long[]) row.get("Histogram");
Assert.assertEquals(0L, histogram[histogram.length - 1]);
protected final AtomicLong                                                               reusePreparedStatement                    = new AtomicLong();
public void incrementPreparedStatementCount() {
reusePreparedStatement.incrementAndGet();
public long getReusePreparedStatement() {
return reusePreparedStatement.get();
long getReusePreparedStatement();
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-09-28 22:44";
void setPoolPreparedStatements(boolean poolPreparedStatements);
void closePoolableStatement() {
PreparedStatementPool statmentPool = holder.getStatementPool();
if (statmentPool != null) {
for (PreparedStatement stmt : statmentPool.getMap().values()) {
JdbcUtils.close(stmt);
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
holder.getDataSource().incrementPreparedStatementCount();
public <T> T getObject(int parameterIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String parameterName, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setSchema(String schema) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String getSchema() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void abort(Executor executor) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
throw new SQLFeatureNotSupportedException();
public int getNetworkTimeout() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void closeOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isCloseOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(int parameterIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String parameterName, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setSchema(String schema) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String getSchema() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void abort(Executor executor) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
throw new SQLFeatureNotSupportedException();
public int getNetworkTimeout() throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void closeOnCompletion() throws SQLException {
public boolean isCloseOnCompletion() throws SQLException {
return false;
public void setSchema(String schema) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String getSchema() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void abort(Executor executor) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
throw new SQLFeatureNotSupportedException();
public int getNetworkTimeout() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void closeOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isCloseOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(int parameterIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String parameterName, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setSchema(String schema) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String getSchema() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void abort(Executor executor) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
throw new SQLFeatureNotSupportedException();
public int getNetworkTimeout() throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void closeOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isCloseOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
stmt.getObject(1, (java.util.Map) null);
stmt.getObject("1", (java.util.Map) null);
stmt.getObject(0, (java.util.Map) null);
stmt.getObject("0", (java.util.Map) null);
resultSet.getObject(1, (java.util.Map) null);
resultSet.getObject("1", (java.util.Map) null);
resultSet.getObject(0, (java.util.Map) null);
resultSet.getObject("0", (java.util.Map) null);
statementPool = new PreparedStatementPool(dataSource.getMaxPoolPreparedStatementPerConnectionSize());
protected int                                                                            maxPoolPreparedStatementPerConnectionSize = 10;
private final LRUCache<PreparedStatementKey, PreparedStatement> map;
public PreparedStatementPool(int maxSize){
map = new LRUCache<PreparedStatementKey, PreparedStatement>(maxSize);
public LRUCache<PreparedStatementKey, PreparedStatement> getMap() {
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
private static final long serialVersionUID = 1L;
protected int             maxElements;
public LRUCache(int maxSize){
super(maxSize);
this.maxElements = maxSize;
protected boolean removeEldestEntry(Entry<K, V> eldest) {
return (size() > this.maxElements);
public long getReusePreparedStatementCount() {
long getReusePreparedStatementCount();
map.put("ReusePreparedStatementCount", dataSource.getReusePreparedStatementCount());
"NotEmptyWaitCount", "NotEmptyWaitNanos", "ErrorCount", "ReusePreparedStatementCount"
map.put("StartTransactionCount", dataSource.getStartTransactionCount());
map.put("CommitCount", dataSource.getCommitCount());
map.put("RollbackCount", dataSource.getRollbackCount());
SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG
, SimpleType.LONG, SimpleType.LONG
"NotEmptyWaitCount", "NotEmptyWaitNanos", "ErrorCount", "ReusePreparedStatementCount", "StartTransactionCount", 
"CommitCount", "RollbackCount"
public class TransactionTimeoutException extends SQLException {
if (holder == null) {
if (holder == null) {
if (holder.getReusedCount() == 0) {
dataSource.incrementCachedPreparedStatementCount();
public class TestPoolStatement extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:oracle:thin:@10.20.36.18:1521:testconn");
dataSource.setInitialSize(1);
dataSource.setMaxActive(14);
dataSource.setMaxIdle(14);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(false);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
dataSource.setUsername("alibaba");
dataSource.setPassword("alibaba");
public void test_0() throws Exception {
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 5; ++i) {
long millis = System.currentTimeMillis() - startMillis;
System.out.println();
System.out.println("millis : " + millis);
private void stat() throws SQLException {
Connection conn = dataSource.getConnection();
String sql = "SELECT sysdate,name,value FROM V$SYSSTAT WHERE NAME IN ('parse count (total)', 'execute count')";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
private void exec() throws SQLException {
Connection conn = dataSource.getConnection();
String sql = "select * from ALIBABA.ORDER_MAIN WHERE ID = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setLong(1, new Random().nextInt(1000 * 100));
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
public class OracleSelectGroupingTest extends TestCase {
public void test_select() throws Exception {
String sql = "SELECT COUNT(*) FROM employees e, departments d WHERE d.department_id = e.department_id GROUP BY ROLLUP (department_name, job_id);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
output(statementList);
private void output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
visitor.println();
System.out.println(out.toString());
public void test_select() throws Exception {
public class Bug_for_happyday517_2 extends TestCase {
private DruidDataSource dataSource;
private MockDriver      driver;
final DataTruncation    exception = new java.sql.DataTruncation(0, true, true, 0, 0);
protected void setUp() throws Exception {
final MockPreparedStatement mockStatement = new MockPreparedStatement(null, null) {
public boolean execute() throws SQLException {
throw exception;
driver = new MockDriver() {
public Connection connect(String url, Properties info) throws SQLException {
super.connect(url, info);
return new MockConnection(driver, info) {
public PreparedStatement prepareStatement(String sql) throws SQLException {
return mockStatement;
dataSource = new DruidDataSource();
dataSource.setDriver(driver);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat,trace,log4j,encoding");
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_bug() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("insert into message.dbo.TempSMS(sms) values ('333')");
Exception error = null;
stmt.execute();
} catch (SQLException ex) {
error = ex;
Assert.assertTrue(exception == error);
stmt.close();
conn.close();
public class Bug_for_happyday517_3 extends TestCase {
private DruidDataSource dataSource;
private MockDriver      driver;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setDriver(driver);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat,trace,log4j,encoding");
dataSource.setDefaultAutoCommit(false);
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_bug() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(false, conn.getAutoCommit());
conn.close();
public class OracleCursorExpr extends SQLExprImpl {
private static final long serialVersionUID = 1L;
private SQLSelect         query;
public OracleCursorExpr(){
public OracleCursorExpr(SQLSelect query){
this.query = query;
public SQLSelect getQuery() {
return query;
public void setQuery(SQLSelect query) {
this.query = query;
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
protected void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, query);
case CURSO
lexer.nextToken();
accept(Token.LPAREN);
OracleSelect select = createSelectParser().select();
OracleCursorExpr cursorExpr = new OracleCursorExpr(select);
accept(Token.RPAREN);
sqlExpr = cursorExpr;
return  primaryRest(sqlExpr);
map.put("CURSOR", Token.CURSOR);
public boolean visit(OracleCursorExpr x) {
return true;
public void endVisit(OracleCursorExpr x) {
boolean visit(OracleCursorExpr x);
void endVisit(OracleCursorExpr x);
public boolean visit(OracleCursorExpr x) {
print("CURSOR(");
x.getQuery().accept(this);
print(")");
return false;
public void endVisit(OracleCursorExpr x) {
CURSOR("CURSOR"),
public class CursorTest extends TestCase {
public void test_cursor() throws Exception {
String sql = "SELECT department_name, CURSOR(SELECT salary, commission_pct FROM employees e WHERE e.department_id = d.department_id) "
+ "FROM departments d;";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals("SELECT department_name, CURSOR(SELECT salary, commission_pctn"
+ "tFROM employees en" + "tWHERE e.department_id = d.department_id)n"
+ "FROM departments d;n", text);
System.out.println(text);
String text = TestUtils.output(statementList);
public class TestUtils {
public static String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor = new OracleOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public static String output(SQLStatement... stmtList) {
return output(Arrays.asList(stmtList));
public class OracleHint extends OracleSQLObjectImpl {
public interface OracleSQLObject extends SQLObject {
public abstract class OracleSQLObjectImpl extends SQLObjectImpl implements OracleSQLObject {
private static final long serialVersionUID = 1L;
public OracleSQLObjectImpl(){
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
protected abstract void accept0(OracleASTVisitor visitor);
public class CycleClause extends OracleSQLObjectImpl {
public abstract class FlashbackQueryClause extends OracleSQLObjectImpl {
public class PartitionExtensionClause extends OracleSQLObjectImpl {
public class SampleClause extends OracleSQLObjectImpl {
public class SearchClause extends OracleSQLObjectImpl {
public class SubqueryFactoringClause extends OracleSQLObjectImpl {
public static class Entry extends OracleSQLObjectImpl {
public class OracleAggregateExpr extends SQLAggregateExpr implements Serializable, OracleExpr {
public class OracleAnalytic extends SQLObjectImpl implements OracleExpr {
public class OracleAnalyticWindowing extends SQLObjectImpl implements OracleExpr {
public class OracleArrayAccessExpr extends SQLExprImpl implements OracleExpr {
public class OracleBinaryDoubleExpr extends SQLNumericLiteralExpr implements OracleExpr {
public class OracleBinaryFloatExpr extends SQLNumericLiteralExpr implements OracleExpr {
public class OracleCursorExpr extends SQLExprImpl implements OracleExpr {
public class OracleDateExpr extends SQLLiteralExpr implements OracleExpr {
public abstract class OracleDatetimeLiteralExpr extends SQLLiteralExpr implements OracleExpr {
public class OracleDbLinkExpr extends SQLExprImpl implements SQLName, OracleExpr {
public interface OracleExpr extends SQLExpr, OracleSQLObject {
public class OracleExtractExpr extends SQLExprImpl implements OracleExpr {
public class OracleGroupComparisonCondition extends SQLExprImpl implements OracleExpr {
public class OracleGroupingSetsExpr extends SQLExprImpl implements OracleExpr {
public class OracleIntervalExpr extends SQLLiteralExpr implements OracleExpr {
public class OracleIsSetExpr extends SQLExprImpl implements OracleExpr {
private static final long serialVersionUID = 1L;
protected void accept0(SQLASTVisitor visitor) {
public class OracleOuterExpr extends SQLExprImpl implements OracleExpr {
public class OraclePriorExpr extends SQLExprImpl implements OracleExpr {
public class OracleTableCollectionExpr extends SQLExprImpl implements OracleExpr {
public class OracleTimestampExpr extends SQLLiteralExpr implements OracleExpr {
public abstract class OracleConstraint extends OracleSQLObjectImpl {
public class OracleSelectForUpdate extends OracleSQLObjectImpl {
public class OracleSelectHierachicalQueryClause extends OracleSQLObjectImpl {
public static class Item extends OracleSQLObjectImpl {
public abstract class OracleSelectPivotBase extends OracleSQLObjectImpl {
public abstract class OracleSelectRestriction extends OracleSQLObjectImpl {
public abstract class OracleUpdateSetClause extends OracleSQLObjectImpl {
public abstract class OracleUpdateSetListItem extends OracleSQLObjectImpl {
public class OracleIsASetTest extends TestCase {
public void test_is_a_set() throws Exception {
String sql = "SELECT customer_id, cust_address_ntab FROM customers_demo WHERE cust_address_ntab IS A SET;";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals("SELECT customer_id, cust_address_ntabn" + "FROM customers_demon"
+ "WHERE cust_address_ntab IS A SET;n", text);
System.out.println(text);
public void accept0(OracleASTVisitor visitor) {
void accept0(OracleASTVisitor visitor);
public abstract void accept0(OracleASTVisitor visitor);
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
private SQLExpr           nestedTable;
public OracleIsSetExpr(){
public OracleIsSetExpr(SQLExpr nestedTable){
this.nestedTable = nestedTable;
public SQLExpr getNestedTable() {
return nestedTable;
public void setNestedTable(SQLExpr nestedTable) {
this.nestedTable = nestedTable;
this.accept0((OracleASTVisitor) visitor);
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, nestedTable);
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public void accept0(OracleASTVisitor visitor) {
public SQLExpr relationalRest(SQLExpr expr) throws ParserException {
if (lexer.token() == Token.IS) {
lexer.nextToken();
if (lexer.token() == Token.NOT) {
lexer.nextToken();
SQLExpr rightExpr = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.IsNot, rightExpr);
} else if (identifierEquals("A")) {
lexer.nextToken();
accept(Token.SET);
expr = new OracleIsSetExpr(expr);
SQLExpr rightExpr = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Is, rightExpr);
return expr;
return super.relationalRest(expr);
public boolean visit(OracleIsSetExpr x) {
return true;
public void endVisit(OracleIsSetExpr x) {
boolean visit(OracleIsSetExpr x);
void endVisit(OracleIsSetExpr x);
public boolean visit(OracleIsSetExpr x) {
x.getNestedTable().accept(this);
print(" IS A SET");
return false;
public void endVisit(OracleIsSetExpr x) {
incrementIndent();
decrementIndent();
+ "tPARTITION BY (country)n" + "tDIMENSION BY (prod, YEAR)n" + "tMEASURES (sale s)n"
+ "tIGNORE NAVn" + "tUNIQUE DIMENSIONn" + "tRULES UPSERT SEQUENTIAL ORDER (s[ANY, 2000] = 0)n"
public class OracleIsEmptyTest extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT product_id, TO_CHAR(ad_finaltext) FROM print_media WHERE ad_textdocs_ntab IS NOT EMPTY;";
String expect = "SELECT product_id, TO_CHAR(ad_finaltext)n" + "FROM print_median"
+ "WHERE ad_textdocs_ntab IS NOT EMPTY;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
super(new OracleLexer(text));
this.lexer.nextToken();
public class SqlServerExprParser extends SQLExprParser {
public SqlServerExprParser(Lexer lexer){
super(lexer);
public SqlServerExprParser(String sql) throws ParserException{
super(sql);
public class SqlServerLexer extends Lexer {
public final static Keywords DEFAULT_SQL_SERVER_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
DEFAULT_SQL_SERVER_KEYWORDS = new Keywords(map);
public SqlServerLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public SqlServerLexer(String input){
super(input);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public class SqlServerLexer extends Lexer {
public final static Keywords DEFAULT_SQL_SERVER_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
DEFAULT_SQL_SERVER_KEYWORDS = new Keywords(map);
public SqlServerLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public SqlServerLexer(String input){
super(input);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public interface SqlServerObject extends SQLObject {
public class OracleEXTRACTTest extends TestCase {
public void test_Extract() throws Exception {
String sql = "SELECT EXTRACT(YEAR FROM DATE '1998-03-07') FROM DUAL;";
String expect = "SELECT EXTRACT(YEAR FROM DATE '1998-03-07')n"
+ "FROM DUAL;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser
.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class OracleFlashbackQueryTest extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT salary FROM employees AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '1' DAY) WHERE last_name = 'Chung';";
String expect = "SELECT salaryn" + "FROM employeesn"
+ "AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '1' DAY)n"
+ "WHERE last_name = 'Chung';n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser
.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class OracleFlashbackQueryTest2 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT salary FROM employeesn"
+ "VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP - INTERVAL '10' MINUTE AND SYSTIMESTAMP - INTERVAL '1' MINUTEn"
+ "WHERE last_name = 'Chung';";
String expect = "SELECT salaryn"
+ "FROM employeesn"
+ "VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP - INTERVAL '10' MINUTE AND SYSTIMESTAMP - INTERVAL '1' MINUTEn"
+ "WHERE last_name = 'Chung';n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
OracleIntervalType type = OracleIntervalType.valueOf(lexer.token().name);
interval.setType(type);
lexer.nextToken();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
if (lexer.token() != Token.LITERAL_INT) {
throw new ParserException("syntax error");
interval.setPrecision(lexer.integerValue().intValue());
if (lexer.token() == Token.COMMA) {
interval.setFactionalSecondsPrecision(lexer.integerValue().intValue());
accept(Token.RPAREN);
if (lexer.token() == Token.TO) {
accept(Token.TO);
if (lexer.token() == Token.SECOND) {
lexer.nextToken();
interval.setToType(OracleIntervalType.SECOND);
if (lexer.token() == Token.LPAREN) {
interval.setToFactionalSecondsPrecision(lexer.integerValue().intValue());
accept(Token.RPAREN);
interval.setToType(OracleIntervalType.MONTH);
lexer.nextToken();
return interval;
map.put("MINUTE", Token.MINUTE);
MINUTE("MINUTE"),
public class OracleTest2 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT NAME FROM V$ARCHIVED_LOG;";
String expect = "SELECT NAMEnFROM V$ARCHIVED_LOG;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class OracleFlashbackQueryTest3 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT DECODE(GROUPING(department_name), 1, 'All Departments', department_name) AS department,"
+ "DECODE(GROUPING(job_id), 1, 'All Jobs', job_id) AS job, COUNT(*) AS "Total Empl", AVG(salary) * 12 AS "Average Sal" "
+ "FROM employees e, departments dn" + "WHERE d.department_id = e.department_idn"
+ "GROUP BY ROLLUP (department_name, job_id);n";
String expect = "SELECT DECODE(GROUPING(department_name), 1, 'All Departments', department_name) AS department, "
+ "DECODE(GROUPING(job_id), 1, 'All Jobs', job_id) AS job, COUNT(*) AS "Total Empl", AVG(salary) * 12 AS "Average Sal"n"
+ "FROM employees e, departments dn" + "WHERE d.department_id = e.department_idn"
+ "GROUP BY ROLLUP(department_name, job_id);n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.output(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
if (identifierEquals("SIBLINGS")) {
if (x.getStartWith() != null) {
print("START WITH ");
x.getStartWith().accept(this);
println();
public class OracleLiteralTest extends TestCase {
public class OraclePriorTest extends TestCase {
public void test_oracle() throws Exception {
String sql = "SELECT employee_id, last_name, manager_id FROM employees CONNECT BY PRIOR employee_id = manager_id;";
String expect = "SELECT employee_id, last_name, manager_idn" + "FROM employeesn"
+ "CONNECT BY PRIOR employee_id = manager_id;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public void test_oracle_2() throws Exception {
String sql = "SELECT last_name, employee_id, manager_id, LEVELn" + "FROM employeesn"
+ "START WITH employee_id = 100n" + "CONNECT BY PRIOR employee_id = manager_idn"
+ "ORDER SIBLINGS BY last_name;";
String expect = "SELECT last_name, employee_id, manager_id, LEVELn" + "FROM employeesn"
+ "START WITH employee_id = 100n" + "CONNECT BY PRIOR employee_id = manager_idn"
+ "ORDER SIBLINGS BY last_name;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
SQLExpr restExpr = super.primaryRest(expr);
if (restExpr != expr && restExpr instanceof SQLMethodInvokeExpr) {
SQLMethodInvokeExpr methodInvoke = (SQLMethodInvokeExpr) restExpr;
if (methodInvoke.getParameters().size() == 1) {
SQLExpr paramExpr = methodInvoke.getParameters().get(0);
if (paramExpr instanceof SQLIdentifierExpr && "+".equals(((SQLIdentifierExpr) paramExpr).getName())) {
OracleOuterExpr outerExpr = new OracleOuterExpr();
if (methodInvoke.getOwner() == null) {
outerExpr.setExpr(new SQLIdentifierExpr(methodInvoke.getMethodName()));
outerExpr.setExpr(new SQLPropertyExpr(methodInvoke.getOwner(), methodInvoke.getMethodName()));
return outerExpr;
return restExpr;
methodInvokeExpr.setOwner(expr);
public class OracleOuterTest extends TestCase {
public void test_oracle() throws Exception {
String sql = "SELECT employee_id, manager_idn" + "FROM employeesn"
+ "WHERE employees.manager_id(+) = employees.employee_id;";
String expect = "SELECT employee_id, manager_idn" + "FROM employeesn"
+ "WHERE employees.manager_id(+) = employees.employee_id;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public void test_date() throws Exception {
String sql = "SELECT DATE '1998-12-25' FROM DUAL;";
String expect = "SELECT DATE '1998-12-25'n" + "FROM DUAL;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class OracleGroupingSetsExpr extends SQLExprImpl implements OracleExpr {
private static final long   serialVersionUID = 1L;
private final List<SQLExpr> items            = new ArrayList<SQLExpr>();
public OracleGroupingSetsExpr(){
public List<SQLExpr> getItems() {
return this.items;
public void output(StringBuffer buf) {
buf.append("GROUPING SETS (");
int i = 0;
for (int size = this.items.size(); i < size; ++i) {
if (i != 0) {
buf.append(", ");
((SQLExpr) this.items.get(i)).output(buf);
buf.append(")");
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.items);
visitor.endVisit(this);
public void endVisit(OracleGroupingSetsExpr x) {
public boolean visit(OracleGroupingSetsExpr x) {
return true;
void endVisit(OracleGroupingSetsExpr x);
boolean visit(OracleGroupingSetsExpr x);
public void endVisit(OracleGroupingSetsExpr x) {
public class OracleGroupingSetTest extends TestCase {
public void test_interval() throws Exception {
String sql = "SELECT channel_desc, calendar_month_desc, co.country_id, "
+ "TO_CHAR(sum(amount_sold) , '9,999,999,999') AS SALES$n"
+ "FROM sales, customers, times, channels, countries con"
+ "WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id "
+ "AND customers.country_id = co.country_id AND channels.channel_desc IN ('Direct Sales', 'Internet') "
+ "AND times.calendar_month_desc IN ('2000-09', '2000-10') "
+ "AND co.country_id IN ('UK', 'US')n"
+ "GROUP BY GROUPING SETS((channel_desc, calendar_month_desc, co.country_id), (channel_desc, co.country_id), "
+ "( calendar_month_desc, co.country_id) );n";
String expected = "SELECT channel_desc, calendar_month_desc, co.country_id, "
+ "TO_CHAR(sum(amount_sold), '9,999,999,999') AS SALES$n"
+ "FROM sales, customers, times, channels, countries con"
+ "WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id "
+ "AND customers.country_id = co.country_id AND channels.channel_desc IN ('Direct Sales', 'Internet') "
+ "AND times.calendar_month_desc IN ('2000-09', '2000-10') "
+ "AND co.country_id IN ('UK', 'US')n"
+ "GROUP BY GROUPING SETS ((channel_desc, calendar_month_desc, co.country_id), (channel_desc, co.country_id), "
+ "(calendar_month_desc, co.country_id));n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expected, text);
System.out.println(text);
boolean space = false;
space = true;
if (space) {
print(" ");
space = true;
if (space) {
print(" ");
public class OracleAnalyticTest extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT last_name, salary, STDDEV(salary) OVER (ORDER BY hire_date) "StdDev" "
"FROM employees "
"WHERE department_id = 30;";
String expect = "SELECT last_name, salary, STDDEV(salary) OVER (ORDER BY hire_date) AS "StdDev"n"
"FROM employeesn"
"WHERE department_id = 30;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser
.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
throw new ParserException("syntax error");
over.setWindowing(windowing);
print("PARTITION BY ");
public void test_0() throws Exception {
public void test_1() throws Exception {
String sql = "SELECT submit_date, num_votes, TRUNC(AVG(num_votes) OVER(PARTITION BY submit_date ORDER BY submit_date ROWS UNBOUNDED PRECEDING)) AVG_VOTE_PER_DAYn"
"FROM vote_countn"
"ORDER BY submit_date;n";
String expect = "SELECT submit_date, num_votes, TRUNC(AVG(num_votes) OVER (PARTITION BY submit_date ORDER BY submit_date ROWS UNBOUNDED PRECEDING)) AS AVG_VOTE_PER_DAYn"
"FROM vote_countn"
"ORDER BY submit_date;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser
.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class OracleSubqueryFactoringTest extends TestCase {
public void test_interval() throws Exception {
String sql = "WITH dept_costs AS (n"
"SELECT department_name, SUM(salary) dept_totaln"
"FROM employees e, departments dn"
"WHERE e.department_id = d.department_idn"
"GROUP BY department_name), "
"avg_cost AS (SELECT SUM(dept_total)/COUNT(*) avg FROM dept_costs)n"
"SELECT * FROM dept_costs WHERE dept_total > (SELECT avg FROM avg_cost) ORDER BY department_name;";
String expected = "WITHn"
"tdept_costsn"
"ttSELECT department_name, SUM(salary) AS dept_totaln"
"ttFROM employees e, departments dn"
"ttWHERE e.department_id = d.department_idn"
"ttGROUP BY department_namen"
"tavg_costn"
"ttSELECT SUM(dept_total) / COUNT(*) AS avgn"
"ttFROM dept_costsn"
"SELECT *n"
"FROM dept_costsn"
"WHERE dept_total > (n"
"tSELECT avgn"
"tFROM avg_costn"
"ORDER BY department_name;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expected, text);
System.out.println(text);
accept(Token.TO);
public class OracleSubqueryFactoringTest2 extends TestCase {
public void test_interval() throws Exception {
String sql = "WITH org_chart (eid, emp_last, mgr_id, reportLevel, salary, job_id) ASn"
"SELECT employee_id, last_name, manager_id, 0 reportLevel, salary, job_idn"
"FROM employeesn"
"WHERE manager_id is nulln"
"UNION ALLn"
"SELECT e.employee_id, e.last_name, e.manager_id, r.reportLevel+1 reportLevel, e.salary, e.job_idn"
"FROM org_chart r, employees en"
"WHERE r.eid = e.manager_idn"
"SEARCH DEPTH FIRST BY emp_last SET order1n"
"CYCLE hire_date SET is_cycle TO 'Y' DEFAULT 'N'"
"SELECT lpad(' ',2*reportLevel)||emp_last emp_name, eid, mgr_id, salary, job_idn"
"FROM org_chartn"
"ORDER BY order1;n";
String expected = "WITHn"
"torg_chart (eid, emp_last, mgr_id, reportLevel, salary, job_id)n"
"ttSELECT employee_id, last_name, manager_id, 0 AS reportLevel, salaryn"
"ttt, job_idn"
"ttFROM employeesn"
"ttWHERE manager_id IS NULLn"
"ttUNION ALLn"
"ttSELECT e.employee_id, e.last_name, e.manager_id, r.reportLevel + 1 AS reportLevel, e.salaryn"
"ttt, e.job_idn"
"ttFROM org_chart r, employees en"
"ttWHERE r.eid = e.manager_idn"
"tSEARCH DEPTH FIRST BY emp_last SET order1n"
"tCYCLE hire_date SET is_cycle TO 'Y' DEFAULT 'N'n"
"SELECT lpad(' ', 2 * reportLevel) || emp_last AS emp_name, eid, mgr_id, salary, job_idn"
"FROM org_chartn"
"ORDER BY order1;n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expected, text);
System.out.println(text);
println();
public class OracleSampleClauseTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT COUNT(*) * 10 FROM orders SAMPLE (10);";
String expected = "SELECT COUNT(*) * 10n" + "FROM ordersn" + "SAMPLE (10);n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expected, text);
System.out.println(text);
public void test_1() throws Exception {
String sql = "SELECT COUNT(*) * 10 FROM orders SAMPLE (10) SEED (1);";
String expected = "SELECT COUNT(*) * 10n" + "FROM ordersn" + "SAMPLE (10) SEED (1);n";
OracleStatementParser parser = new OracleStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals(expected, text);
System.out.println(text);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((left == null) ? 0 : left.hashCode());
result = prime * result + ((operator == null) ? 0 : operator.hashCode());
result = prime * result + ((right == null) ? 0 : right.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof SQLBinaryOpExpr)) {
return false;
SQLBinaryOpExpr other = (SQLBinaryOpExpr) obj;
if (left == null) {
if (other.left != null) {
return false;
} else if (!left.equals(other.left)) {
return false;
if (operator != other.operator) {
return false;
if (right == null) {
if (other.right != null) {
return false;
} else if (!right.equals(other.right)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((name == null) ? 0 : name.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof SQLIdentifierExpr)) {
return false;
SQLIdentifierExpr other = (SQLIdentifierExpr) obj;
if (name == null) {
if (other.name != null) {
return false;
} else if (!name.equals(other.name)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((name == null) ? 0 : name.hashCode());
result = prime * result + ((owner == null) ? 0 : owner.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof SQLPropertyExpr)) {
return false;
SQLPropertyExpr other = (SQLPropertyExpr) obj;
if (name == null) {
if (other.name != null) {
return false;
} else if (!name.equals(other.name)) {
return false;
if (owner == null) {
if (other.owner != null) {
return false;
} else if (!owner.equals(other.owner)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((name == null) ? 0 : name.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof SQLVariantRefExpr)) {
return false;
SQLVariantRefExpr other = (SQLVariantRefExpr) obj;
if (name == null) {
if (other.name != null) {
return false;
} else if (!name.equals(other.name)) {
return false;
return true;
for (;;) {
if (x.getRight() instanceof SQLBinaryOpExpr) {
if (x.getLeft() instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr leftBinaryExpr = (SQLBinaryOpExpr) x.getLeft();
if (leftBinaryExpr.getRight().equals(x.getRight())) {
x = leftBinaryExpr;
x = new SQLBinaryOpExpr(x.getLeft(), x.getOperator(), merge((SQLBinaryOpExpr) x.getRight()));
for (;;) {
if (x.getRight() instanceof SQLBinaryOpExpr) {
if (x.getLeft() instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr leftBinaryExpr = (SQLBinaryOpExpr) x.getLeft();
if (leftBinaryExpr.getRight().equals(x.getRight())) {
x = leftBinaryExpr;
x = new SQLBinaryOpExpr(x.getLeft(), x.getOperator(), merge((SQLBinaryOpExpr) x.getRight()));
PreparedStatementHolder holder = map.get(key);
super(maxSize, 0.75f, true);
public abstract boolean equals(Object o);
public abstract int hashCode();
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((arguments == null) ? 0 : arguments.hashCode());
result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());
result = prime * result + option;
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLAggregateExpr other = (SQLAggregateExpr) obj;
if (arguments == null) {
if (other.arguments != null) {
return false;
} else if (!arguments.equals(other.arguments)) {
return false;
if (methodName == null) {
if (other.methodName != null) {
return false;
} else if (!methodName.equals(other.methodName)) {
return false;
if (option != other.option) {
return false;
return true;
public int hashCode() {
public boolean equals(Object o) {
return o instanceof SQLAllColumnExpr;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLAllExpr other = (SQLAllExpr) obj;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLAnyExpr other = (SQLAnyExpr) obj;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((beginExpr == null) ? 0 : beginExpr.hashCode());
result = prime * result + ((endExpr == null) ? 0 : endExpr.hashCode());
result = prime * result + (not ? 1231 : 1237);
result = prime * result + ((testExpr == null) ? 0 : testExpr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLBetweenExpr other = (SQLBetweenExpr) obj;
if (beginExpr == null) {
if (other.beginExpr != null) {
return false;
} else if (!beginExpr.equals(other.beginExpr)) {
return false;
if (endExpr == null) {
if (other.endExpr != null) {
return false;
} else if (!endExpr.equals(other.endExpr)) {
return false;
if (not != other.not) {
return false;
if (testExpr == null) {
if (other.testExpr != null) {
return false;
} else if (!testExpr.equals(other.testExpr)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLBitStringLiteralExpr other = (SQLBitStringLiteralExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((elseExpr == null) ? 0 : elseExpr.hashCode());
result = prime * result + ((items == null) ? 0 : items.hashCode());
result = prime * result + ((valueExpr == null) ? 0 : valueExpr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLCaseExpr other = (SQLCaseExpr) obj;
if (elseExpr == null) {
if (other.elseExpr != null) {
return false;
} else if (!elseExpr.equals(other.elseExpr)) {
return false;
if (items == null) {
if (other.items != null) {
return false;
} else if (!items.equals(other.items)) {
return false;
if (valueExpr == null) {
if (other.valueExpr != null) {
return false;
} else if (!valueExpr.equals(other.valueExpr)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((dataType == null) ? 0 : dataType.hashCode());
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLCastExpr other = (SQLCastExpr) obj;
if (dataType == null) {
if (other.dataType != null) {
return false;
} else if (!dataType.equals(other.dataType)) {
return false;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((cursorName == null) ? 0 : cursorName.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLCurrentOfCursorExpr other = (SQLCurrentOfCursorExpr) obj;
if (cursorName == null) {
if (other.cursorName != null) {
return false;
} else if (!cursorName.equals(other.cursorName)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLDateLiteralExpr other = (SQLDateLiteralExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + (not ? 1231 : 1237);
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLExistsExpr other = (SQLExistsExpr) obj;
if (not != other.not) {
return false;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((hex == null) ? 0 : hex.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLHexExpr other = (SQLHexExpr) obj;
if (hex == null) {
if (other.hex != null) {
return false;
} else if (!hex.equals(other.hex)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLHexStringLiteralExpr other = (SQLHexStringLiteralExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
result = prime * result + (not ? 1231 : 1237);
result = prime * result + ((targetList == null) ? 0 : targetList.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLInListExpr other = (SQLInListExpr) obj;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
if (not != other.not) {
return false;
if (targetList == null) {
if (other.targetList != null) {
return false;
} else if (!targetList.equals(other.targetList)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
result = prime * result + (not ? 1231 : 1237);
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLInSubQueryExpr other = (SQLInSubQueryExpr) obj;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
if (not != other.not) {
return false;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((number == null) ? 0 : number.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLIntegerExpr other = (SQLIntegerExpr) obj;
if (number == null) {
if (other.number != null) {
return false;
} else if (!number.equals(other.number)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((sign == null) ? 0 : sign.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLIntervalLiteralExpr other = (SQLIntervalLiteralExpr) obj;
if (sign == null) {
if (other.sign != null) {
return false;
} else if (!sign.equals(other.sign)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((items == null) ? 0 : items.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLListExpr other = (SQLListExpr) obj;
if (items == null) {
if (other.items != null) {
return false;
} else if (!items.equals(other.items)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());
result = prime * result + ((owner == null) ? 0 : owner.hashCode());
result = prime * result + ((parameters == null) ? 0 : parameters.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLMethodInvokeExpr other = (SQLMethodInvokeExpr) obj;
if (methodName == null) {
if (other.methodName != null) {
return false;
} else if (!methodName.equals(other.methodName)) {
return false;
if (owner == null) {
if (other.owner != null) {
return false;
} else if (!owner.equals(other.owner)) {
return false;
if (parameters == null) {
if (other.parameters != null) {
return false;
} else if (!parameters.equals(other.parameters)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLNotExpr other = (SQLNotExpr) obj;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
return true;
public int hashCode() {
public boolean equals(Object o) {
return o instanceof SQLNullExpr;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((number == null) ? 0 : number.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLNumberExpr other = (SQLNumberExpr) obj;
if (number == null) {
if (other.number != null) {
return false;
} else if (!number.equals(other.number)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((objType == null) ? 0 : objType.hashCode());
result = prime * result + ((paramList == null) ? 0 : paramList.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLObjectCreateExpr other = (SQLObjectCreateExpr) obj;
if (objType == null) {
if (other.objType != null) {
return false;
} else if (!objType.equals(other.objType)) {
return false;
if (paramList == null) {
if (other.paramList != null) {
return false;
} else if (!paramList.equals(other.paramList)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLQueryExpr other = (SQLQueryExpr) obj;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((subQuery == null) ? 0 : subQuery.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLSomeExpr other = (SQLSomeExpr) obj;
if (subQuery == null) {
if (other.subQuery != null) {
return false;
} else if (!subQuery.equals(other.subQuery)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((text == null) ? 0 : text.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLTextLiteralExpr other = (SQLTextLiteralExpr) obj;
if (text == null) {
if (other.text != null) {
return false;
} else if (!text.equals(other.text)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
result = prime * result + ((operator == null) ? 0 : operator.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLUnaryExpr other = (SQLUnaryExpr) obj;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
if (operator != other.operator) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
MySqlBinaryExpr other = (MySqlBinaryExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + (value ? 1231 : 1237);
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
MySqlBooleanExpr other = (MySqlBooleanExpr) obj;
if (value != other.value) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((unit == null) ? 0 : unit.hashCode());
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof MySqlExtractExpr)) {
return false;
MySqlExtractExpr other = (MySqlExtractExpr) obj;
if (unit != other.unit) {
return false;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((unit == null) ? 0 : unit.hashCode());
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
MySqlIntervalExpr other = (MySqlIntervalExpr) obj;
if (unit != other.unit) {
return false;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((against == null) ? 0 : against.hashCode());
result = prime * result + ((columns == null) ? 0 : columns.hashCode());
result = prime * result + ((searchModifier == null) ? 0 : searchModifier.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
MySqlMatchAgainstExpr other = (MySqlMatchAgainstExpr) obj;
if (against == null) {
if (other.against != null) {
return false;
} else if (!against.equals(other.against)) {
return false;
if (columns == null) {
if (other.columns != null) {
return false;
} else if (!columns.equals(other.columns)) {
return false;
if (searchModifier != other.searchModifier) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((parameters == null) ? 0 : parameters.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (!(obj instanceof GroupingSetExpr)) {
return false;
GroupingSetExpr other = (GroupingSetExpr) obj;
if (parameters == null) {
if (other.parameters != null) {
return false;
} else if (!parameters.equals(other.parameters)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleBinaryDoubleExpr other = (OracleBinaryDoubleExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleBinaryFloatExpr other = (OracleBinaryFloatExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((query == null) ? 0 : query.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleCursorExpr other = (OracleCursorExpr) obj;
if (query == null) {
if (other.query != null) {
return false;
} else if (!query.equals(other.query)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((literal == null) ? 0 : literal.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleDateExpr other = (OracleDateExpr) obj;
if (literal == null) {
if (other.literal != null) {
return false;
} else if (!literal.equals(other.literal)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((dbLink == null) ? 0 : dbLink.hashCode());
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleDbLinkExpr other = (OracleDbLinkExpr) obj;
if (dbLink == null) {
if (other.dbLink != null) {
return false;
} else if (!dbLink.equals(other.dbLink)) {
return false;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((from == null) ? 0 : from.hashCode());
result = prime * result + ((unit == null) ? 0 : unit.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleExtractExpr other = (OracleExtractExpr) obj;
if (from == null) {
if (other.from != null) {
return false;
} else if (!from.equals(other.from)) {
return false;
if (unit != other.unit) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((factionalSecondsPrecision == null) ? 0 : factionalSecondsPrecision.hashCode());
result = prime * result + ((precision == null) ? 0 : precision.hashCode());
result = prime * result + ((toFactionalSecondsPrecision == null) ? 0 : toFactionalSecondsPrecision.hashCode());
result = prime * result + ((toType == null) ? 0 : toType.hashCode());
result = prime * result + ((type == null) ? 0 : type.hashCode());
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleIntervalExpr other = (OracleIntervalExpr) obj;
if (factionalSecondsPrecision == null) {
if (other.factionalSecondsPrecision != null) {
return false;
} else if (!factionalSecondsPrecision.equals(other.factionalSecondsPrecision)) {
return false;
if (precision == null) {
if (other.precision != null) {
return false;
} else if (!precision.equals(other.precision)) {
return false;
if (toFactionalSecondsPrecision == null) {
if (other.toFactionalSecondsPrecision != null) {
return false;
} else if (!toFactionalSecondsPrecision.equals(other.toFactionalSecondsPrecision)) {
return false;
if (toType != other.toType) {
return false;
if (type != other.type) {
return false;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((nestedTable == null) ? 0 : nestedTable.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleIsSetExpr other = (OracleIsSetExpr) obj;
if (nestedTable == null) {
if (other.nestedTable != null) {
return false;
} else if (!nestedTable.equals(other.nestedTable)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleOuterExpr other = (OracleOuterExpr) obj;
if (expr == null) {
if (other.expr != null) {
return false;
} else if (!expr.equals(other.expr)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((literal == null) ? 0 : literal.hashCode());
result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleTimestampExpr other = (OracleTimestampExpr) obj;
if (literal == null) {
if (other.literal != null) {
return false;
} else if (!literal.equals(other.literal)) {
return false;
if (timeZone == null) {
if (other.timeZone != null) {
return false;
} else if (!timeZone.equals(other.timeZone)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((dbLink == null) ? 0 : dbLink.hashCode());
result = prime * result + ((partition == null) ? 0 : partition.hashCode());
result = prime * result + ((partitionFor == null) ? 0 : partitionFor.hashCode());
result = prime * result + ((subPartition == null) ? 0 : subPartition.hashCode());
result = prime * result + ((subPartitionFor == null) ? 0 : subPartitionFor.hashCode());
result = prime * result + ((table == null) ? 0 : table.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
OracleTableExpr other = (OracleTableExpr) obj;
if (dbLink == null) {
if (other.dbLink != null) {
return false;
} else if (!dbLink.equals(other.dbLink)) {
return false;
if (partition == null) {
if (other.partition != null) {
return false;
} else if (!partition.equals(other.partition)) {
return false;
if (partitionFor == null) {
if (other.partitionFor != null) {
return false;
} else if (!partitionFor.equals(other.partitionFor)) {
return false;
if (subPartition == null) {
if (other.subPartition != null) {
return false;
} else if (!subPartition.equals(other.subPartition)) {
return false;
if (subPartitionFor == null) {
if (other.subPartitionFor != null) {
return false;
} else if (!subPartitionFor.equals(other.subPartitionFor)) {
return false;
if (table == null) {
if (other.table != null) {
return false;
} else if (!table.equals(other.table)) {
return false;
return true;
public class MySqlParameterizedOutputVisitorTest2 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT * FROM T WHERE ID = ?";
for (int i = 0; i < 10000; ++i) {
sql += " OR ID = ?";
validate(sql, "SELECT * FROM T WHERE ID = ?");
validateOracle(sql, "SELECT * FROM T WHERE ID = ?; ");
void validate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
Assert.assertEquals(expect, out.toString());
void validateOracle(String sql, String expect) {
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out);
statemen.accept(visitor);
Assert.assertEquals(expect, out.toString());
public class TestLRU extends TestCase {
public void test_lru() throws Exception {
LinkedHashMap<Integer, Object> cache = new LinkedHashMap<Integer, Object>(100, 0.75f, true);
cache.put(2, "22");
cache.put(3, "33");
System.out.println(cache);
cache.put(2, "22");
System.out.println(cache);
Assert.assertTrue(pool.get(k1) != null);
public class TestMySqlPing extends TestCase {
public void test_ping() throws Exception {
String url = "jdbc:mysql:
String user = "dragoon_admin";
String password = "dragoon_root";
Class.forName("com.mysql.jdbc.Driver");
com.mysql.jdbc.Connection conn = (com.mysql.jdbc.Connection) DriverManager.getConnection(url, user, password);
ping(conn);
conn.close();
public void ping(com.mysql.jdbc.Connection conn) throws Exception {
System.out.println(conn.getClass());
conn.ping();
public interface SqlServerObject extends TransactSQLObject {
public interface TransactSQLObject extends SQLObject {
public final static int RevisionVersion = 13;
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-11-11 14:06";
public interface SQLServerObject extends TransactSQLObject {
public class SQLServerSelect {
public abstract class TransactSQLObjectImpl extends SQLObjectImpl implements TransactSQLObject {
private static final long serialVersionUID = 1L;
public TransactSQLObjectImpl(){
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public abstract void accept0(OracleASTVisitor visitor);
public class TransactSQLSelect {
public class SQLServerSelect extends SQLSelect {
private static final long serialVersionUID = 1L;
public class SQLServerLexer extends Lexer {
public final static Keywords DEFAULT_SQL_SERVER_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("WITH", Token.WITH);
map.put("CURSOR", Token.CURSOR);
DEFAULT_SQL_SERVER_KEYWORDS = new Keywords(map);
public SQLServerLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public SQLServerLexer(String input){
super(input);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public class SQLServerStatementParser extends SQLStatementParser {
public SQLServerStatementParser(String sql){
super(new SQLServerLexer(sql));
this.lexer.nextToken();
public SQLServerStatementParser(Lexer lexer){
super(lexer);
public void parseStatementList(List<SQLStatement> statementList) throws ParserException {
for (;;) {
if (lexer.token() == Token.EOF) {
if (lexer.token() == (Token.SEMI)) {
lexer.nextToken();
if (lexer.token() == (Token.SELECT)) {
statementList.add(new SQLSelectStatement(new SQLSelectParser(this.lexer).select()));
if (lexer.token() == (Token.UPDATE)) {
statementList.add(parseUpdateStatement());
if (lexer.token() == (Token.CREATE)) {
lexer.nextToken();
throw new ParserException("TODO");
if (lexer.token() == Token.INSERT) {
statementList.add(new OracleInsertParser(this.lexer).parseInsert());
if (lexer.token() == (Token.DELETE)) {
statementList.add(new OracleDeleteParser(this.lexer).parseDelete());
if (lexer.token() == (Token.SLASH)) {
lexer.nextToken();
statementList.add(new OraclePLSQLCommitStatement());
if (lexer.token() == Token.ALTER) {
throw new ParserException("TODO");
if (lexer.token() == Token.WITH) {
statementList.add(new SQLSelectStatement(new OracleSelectParser(this.lexer).select()));
if (identifierEquals("CALL")) {
statementList.add(this.parseCall());
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
this(new OracleLexer(sql));
this.lexer.nextToken();
this(new OracleLexer(sql));
this.lexer.nextToken();
public abstract class SQLServerObjectImpl extends SQLObjectImpl implements SQLServerObject {
private static final long serialVersionUID = 1L;
public SQLServerObjectImpl(){
protected void accept0(SQLASTVisitor visitor) {
this.accept0((SQLServerASTVisitor) visitor);
public abstract void accept0(SQLServerASTVisitor visitor);
public class SQLServerSelectQueryBlock extends SQLSelectQueryBlock {
private static final long serialVersionUID = 1L;
private Top               top;
public Top getTop() {
return top;
public void setTop(Top top) {
this.top = top;
protected void accept0(SQLASTVisitor visitor) {
accept0((SQLServerASTVisitor) visitor);
protected void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.top);
acceptChild(visitor, this.selectList);
acceptChild(visitor, this.from);
acceptChild(visitor, this.where);
acceptChild(visitor, this.groupBy);
visitor.endVisit(this);
public class Top extends SQLServerObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr expr;
private boolean percent;
private boolean withTies;
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
this.expr = expr;
public boolean isPercent() {
return percent;
public void setPercent(boolean percent) {
this.percent = percent;
public boolean isWithTies() {
return withTies;
public void setWithTies(boolean withTies) {
this.withTies = withTies;
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
map.put("TOP", Token.TOP);
public class SQLServerSelectParser extends SQLSelectParser {
public SQLServerSelectParser(String sql){
super(new SQLServerLexer(sql));
this.lexer.nextToken();
public SQLServerSelectParser(Lexer lexer){
super(lexer);
public SQLSelect select() throws ParserException {
SQLServerSelect select = new SQLServerSelect();
select.setQuery(query());
select.setOrderBy(parseOrderBy());
if (select.getOrderBy() == null) {
select.setOrderBy(parseOrderBy());
return select;
protected SQLSelectQuery query() throws ParserException {
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLSelectQuery select = query();
accept(Token.RPAREN);
return queryRest(select);
accept(Token.SELECT);
SQLServerSelectQueryBlock queryBlock = new SQLServerSelectQueryBlock();
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
if (lexer.token() == Token.TOP) {
Top top = new Top();
lexer.nextToken();
top.setExpr(createExprParser().primary());
queryBlock.setTop(top);
parseSelectList(queryBlock);
parseFrom(queryBlock);
parseWhere(queryBlock);
parseGroupBy(queryBlock);
return queryRest(queryBlock);
statementList.add(new SQLSelectStatement(new SQLServerSelectParser(this.lexer).select()));
public interface SQLServerASTVisitor extends SQLASTVisitor {
boolean visit(SQLServerSelectQueryBlock x);
void endVisit(SQLServerSelectQueryBlock x);
boolean visit(Top x);
void endVisit(Top x);
public class SqlServerOutputVisitor extends SQLASTOutputVisitor implements SQLServerASTVisitor {
public SqlServerOutputVisitor(Appendable appender){
super(appender);
public boolean visit(SQLServerSelectQueryBlock select) {
print("SELECT ");
if (SQLSetQuantifier.ALL == select.getDistionOption()) {
print("ALL ");
} else if (SQLSetQuantifier.DISTINCT == select.getDistionOption()) {
print("DISTINCT ");
} else if (SQLSetQuantifier.UNIQUE == select.getDistionOption()) {
print("UNIQUE ");
if (select.getTop() != null) {
select.getTop().accept(this);
printSelectList(select.getSelectList());
if (select.getFrom() != null) {
println();
print("FROM ");
select.getFrom().accept(this);
if (select.getWhere() != null) {
println();
print("WHERE ");
select.getWhere().accept(this);
if (select.getGroupBy() != null) {
print(" ");
select.getGroupBy().accept(this);
return false;
public void endVisit(SQLServerSelectQueryBlock x) {
public boolean visit(Top x) {
print("TOP ");
x.getExpr().accept(this);
print(" ");
return false;
public void endVisit(Top x) {
TOP("TOP"),
public class SQLServerTopTest extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT TOP 10 * FROM T";
String expect = "SELECT TOP 10 *nFROM T";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public static String outputSqlServer(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
SqlServerOutputVisitor visitor = new SqlServerOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public static String outputSqlServer(SQLStatement... stmtList) {
return outputSqlServer(Arrays.asList(stmtList));
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-11-15 09:48";
private final boolean                       defaultReadOnly;
private final int                           defaultHoldability;
private final int                           defaultTransactionIsolation;
MockConnection conn = new MockConnection();
PreparedStatementPool pool = new PreparedStatementPool(new ConnectionHolder(dataSource, conn));
private final static Log           LOG                        = LogFactory.getLog(StatFilter.class);
if (sqlStat != null) {
sqlStat.addExecuteBatchCount(batchSize);
if (sqlStat != null) {
sqlStat.setExecuteLastStartTime(System.currentTimeMillis());
sqlStat.incrementRunningCount();
if (sqlStat != null) {
sqlStat.incrementExecuteSuccessCount();
for (int updateCount : updateCountArray) {
sqlStat.addUpdateCount(updateCount);
sqlStat.decrementExecutingCount();
sqlStat.addExecuteTime(nanoSpan);
if (sqlStat != null) {
sqlStat.error(error);
sqlStat.addExecuteTime(nanoSpan);
if (sqlStat == null) {
LOG.error("stat is null");
stmt.execute();
stmt.execute();
for (int i = 0; i < 1000 * 100 * 1; ++i) {
stmt.execute();
Connection conn = dataSource.getConnection();
PoolableConnection poolableConn = conn.unwrap(PoolableConnection.class);
Assert.assertNotNull(poolableConn);
Assert.assertEquals(dataSource.getMaxPoolPreparedStatementPerConnectionSize(),
poolableConn.getConnectionHolder().getStatementPool().getMap().size());
conn.close();
protected int                      maxSqlStatCount            = 1000 * 100;
public final static int RevisionVersion = 14;
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-11-16 09:48";
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
if (holder.isPoolPreparedStatements()) {
holder.getStatementPool().put(stmtHolder);
public void put(PreparedStatementHolder holder) throws SQLException {
PreparedStatement stmt = holder.getStatement();
if (stmt.isClosed()) {
dataSource.setPoolPreparedStatements(false);
for (int j = 0; j < 10; ++j) {
for (int i = 0; i < 10; ++i) {
Connection conn = dataSource.getConnection();
String sql = "SELECT" + i;
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.execute();
stmt.close();
conn.close();
dataSource.setPoolPreparedStatements(true);
for (int j = 0; j < 10; ++j) {
for (int i = 0; i < 10; ++i) {
Connection conn = dataSource.getConnection();
String sql = "SELECT" + i;
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.execute();
stmt.close();
conn.close();
public int getMaxSqlStatCount() {
return maxSqlStatCount;
public void setMaxSqlStatCount(int maxSqlStatCount) {
this.maxSqlStatCount = maxSqlStatCount;
((StatFilter) dataSource.getProxyFilters().get(0)).setMaxSqlStatCount(100);
((StatFilter) dataSource.getProxyFilters().get(0)).setMaxSqlStatCount(100);
for (int i = 0; i < 1000 * 1; ++i) {
if (stmt == null) {
public final static int RevisionVersion = 15;
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-11-23 13:39";
private boolean                                                                          dupCloseLogEnable                         = true;
public boolean isDupCloseLogEnable() {
return dupCloseLogEnable;
public void setDupCloseLogEnable(boolean dupCloseLogEnable) {
this.dupCloseLogEnable = dupCloseLogEnable;
private final boolean      dupCloseLogEnable;
dupCloseLogEnable = holder.getDataSource().isDupCloseLogEnable();
if (holder == null && dupCloseLogEnable) {
private int      initialSize     = 1;
PreparedStatement stmt = conn.prepareStatement("SELECT 1 FROM DUAL");
ResultSet rs = stmt.executeQuery();
if (conn.isReadOnly() != dataSource.getDefaultReadOnly()) {
conn.setReadOnly(dataSource.getDefaultReadOnly());
if (conn.getTransactionIsolation() != dataSource.getDefaultTransactionIsolation().intValue()) {
conn.setTransactionIsolation(dataSource.getDefaultTransactionIsolation());
public final static int RevisionVersion = 17;
protected ScheduledExecutorService getScheduler() {
return scheduler;
if (this.mockConnection != null && this.mockConnection.isClosed()) {
throw new SQLException("No operations allowed after connection closed.");
void setTestOnBorrow(boolean testOnBorrow);
boolean isTestWhileIdle();
void setTestWhileIdle(boolean testWhileIdle);
void setLogAbandoned(boolean logAbandoned);
super.close();
protected void close() {
scheduler.shutdownNow();
Object[] items = this.getDataSources().toArray();
for (Object item : items) {
JdbcUtils.close((DruidDataSource) item);
System.out.println("unclosed datasource : " + dataSource.getObjectName() + ", url : " + dataSource.getUrl());
dataSourceA.setUrl("jdbc:mock:ha1");
dataSourceB.setUrl("jdbc:mock:ha2");
public void resetStat() {
masterConnectCount.set(0);
slaveConnectCount.set(0);
void resetStat();
private String     url;
this(null, null, null);
public MockConnection(MockDriver driver, String url, Properties connectProperties){
this.driver = driver;
this.connectProperties = connectProperties;
this.url = url;
if (driver != null) {
this.id = driver.generateConnectionId();
public String getUrl() {
return url;
public void setUrl(String url) {
this.url = url;
MockConnection conn = new MockConnection(this, url, info);
return new MockConnection(driver, url, info) {
public class HADataSourceTest2 extends TestCase {
private DruidDataSource dataSourceA;
private DruidDataSource dataSourceB;
private HADataSource    dataSourceHA;
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
dataSourceA = new DruidDataSource();
dataSourceA.setUrl("jdbc:mock:ha1");
dataSourceA.setFilters("trace");
dataSourceB = new DruidDataSource();
dataSourceB.setUrl("jdbc:mock:ha2");
dataSourceB.setFilters("stat");
dataSourceHA = new HADataSource();
dataSourceHA.setMaster(dataSourceA);
dataSourceHA.setSlave(dataSourceB);
protected void tearDown() throws Exception {
dataSourceHA.close();
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_switch() throws Exception {
Connection conn = dataSourceHA.getConnection();
MockConnection mockConn = conn.unwrap(MockConnection.class);
conn.close();
if (conn == null && slave.isEnable()) {
public boolean isWrapperFor(Class<?> iface) throws SQLException {
boolean result = super.isWrapperFor(iface);
if (result == false && conn != null) {
result = conn.isWrapperFor(iface);
return result;
public <T> T unwrap(Class<T> iface) throws SQLException {
T object = super.unwrap(iface);
if (object == null && conn != null) {
object = conn.unwrap(iface);
return object;
private DruidDataSource dataSourceA;
private DruidDataSource dataSourceB;
private HADataSource dataSourceHA;
private String MASTER_URL = "jdbc:mock:master";
private String SLAVE_URL = "jdbc:mock:slave";
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance()
.getDataSourceList().size());
dataSourceA = new DruidDataSource();
dataSourceA.setUrl(MASTER_URL);
dataSourceA.setFilters("trace");
dataSourceB = new DruidDataSource();
dataSourceB.setUrl(SLAVE_URL);
dataSourceB.setFilters("stat");
dataSourceHA = new HADataSource();
dataSourceHA.setMaster(dataSourceA);
dataSourceHA.setSlave(dataSourceB);
protected void tearDown() throws Exception {
dataSourceHA.close();
for (DruidDataSource dataSource : DruidDataSourceStatManager
.getDruidDataSourceInstances()) {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance()
.getDataSourceList().size());
public void test_switch() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(dataSourceA.getUrl(), mockConn.getUrl());
conn.close();
dataSourceHA.setMasterEnable(false);
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(dataSourceB.getUrl(), mockConn.getUrl());
conn.close();
public void switchMasterSlave() {
DruidDataSource tmp = this.getMaster();
this.setMaster(this.getSlave());
this.setSlave(tmp);
long getMasterConnectCount();
long getSlaveConnectCount();
boolean isMasterEnable();
void setMasterEnable(boolean value);
boolean isSlaveEnable();
void setSlaveEnable(boolean value);
void switchMasterSlave();
void resetStat();
private boolean                             underlyingReadOnly;
private int                                 underlyingHoldability;
private int                                 underlyingTransactionIsolation;
private boolean                             underlyingAutoCommit;
this.underlyingAutoCommit = defaultAutoCommit;
this.underlyingHoldability = defaultHoldability;
this.underlyingTransactionIsolation = defaultTransactionIsolation;
this.underlyingTransactionIsolation = defaultTransactionIsolation;
public boolean isUnderlyingReadOnly() {
return underlyingReadOnly;
public void setUnderlyingReadOnly(boolean underlyingReadOnly) {
this.underlyingReadOnly = underlyingReadOnly;
public int getUnderlyingHoldability() {
return underlyingHoldability;
public void setUnderlyingHoldability(int underlyingHoldability) {
this.underlyingHoldability = underlyingHoldability;
public int getUnderlyingTransactionIsolation() {
return underlyingTransactionIsolation;
public void setUnderlyingTransactionIsolation(int underlyingTransactionIsolation) {
this.underlyingTransactionIsolation = underlyingTransactionIsolation;
public boolean isUnderlyingAutoCommit() {
return underlyingAutoCommit;
public void setUnderlyingAutoCommit(boolean underlyingAutoCommit) {
this.underlyingAutoCommit = underlyingAutoCommit;
if (underlyingReadOnly != defaultReadOnly) {
if (underlyingHoldability != defaultHoldability) {
if (underlyingTransactionIsolation != defaultTransactionIsolation) {
if (underlyingAutoCommit != defaultAutoCommit) {
public class DruidDataSource extends DruidAbstractDataSource implements
DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable {
private final static Log LOG = LogFactory.getLog(DruidDataSource.class);
private static final long serialVersionUID = 1L;
private final ReentrantLock lock = new ReentrantLock();
private final Condition notEmpty = lock.newCondition();
private final Condition empty = lock.newCondition();
private long connectCount = 0L;
private long closeCount = 0L;
private long connectErrorCount = 0L;
private long recycleCount = 0L;
private long createConnectionCount = 0L;
private long destroyCount = 0L;
private long removeAbandonedCount = 0L;
private long notEmptyWaitCount = 0L;
private long notEmptySignalCount = 0L;
private long notEmptyWaitNanos = 0L;
private int activePeak = 0;
private long activePeakTime = 0;
private int poolingPeak = 0;
private long poolingPeakTime = 0;
private ConnectionHolder[] connections;
private int poolingCount = 0;
private int activeCount = 0;
private int notEmptyWaitThreadCount = 0;
private CreateConnectionThread createConnectionThread;
private DestroyConnectionThread destoryConnectionThread;
private final CountDownLatch initedLatch = new CountDownLatch(2);
private boolean enable = true;
private boolean resetStatEnable = true;
private String initStackTrace;
public DruidDataSource() {
public String getInitStackTrace() {
return initStackTrace;
public boolean isResetStatEnable() {
return resetStatEnable;
public void setResetStatEnable(boolean resetStatEnable) {
this.resetStatEnable = resetStatEnable;
public void resetStat() {
if (!resetStatEnable) {
lock.lock();
connectCount = 0;
closeCount = 0;
connectErrorCount = 0;
recycleCount = 0;
createConnectionCount = 0;
destroyCount = 0;
removeAbandonedCount = 0;
notEmptyWaitCount = 0;
notEmptySignalCount = 0L;
notEmptyWaitNanos = 0;
activePeak = 0;
activePeakTime = 0;
poolingPeak = 0;
createTimespan = 0;
} finally {
lock.unlock();
errorCount.set(0);
commitCount.set(0);
rollbackCount.set(0);
startTransactionCount.set(0);
reusePreparedStatement.set(0);
closedPreparedStatementCount.set(0);
preparedStatementCount.set(0);
transactionHistogram.reset();
public boolean isEnable() {
return enable;
public void setEnable(boolean enable) {
lock.lock();
this.enable = enable;
if (!enable) {
notEmpty.signalAll();
notEmptySignalCount++;
} finally {
lock.unlock();
public void setPoolPreparedStatements(boolean value) {
lock.lock();
if (this.poolPreparedStatements && (!value)) {
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder connection = connections[i];
for (PreparedStatementHolder holder : connection
.getStatementPool().getMap().values()) {
closePreapredStatement(holder);
decrementCachedPreparedStatementCount();
connection.getStatementPool().getMap().clear();
super.setPoolPreparedStatements(value);
} finally {
lock.unlock();
public boolean isInited() {
return this.inited;
private void init() throws SQLException {
if (inited) {
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
if (inited) {
initStackTrace = JdbcUtils.toString(Thread.currentThread()
.getStackTrace());
this.id = DruidDriver.createDataSourceId();
if (maxActive <= 0) {
throw new IllegalArgumentException("illegal maxActive "
+ maxActive);
if (maxActive < minIdle) {
throw new IllegalArgumentException("illegal maxActive "
+ maxActive);
if (maxIdle <= 0 || maxIdle < minIdle) {
throw new IllegalArgumentException("illegal maxPoolSize");
if (getInitialSize() > maxActive) {
throw new IllegalArgumentException("illegal initialSize");
if (this.driverClass != null) {
this.driverClass = driverClass.trim();
if (this.jdbcUrl != null) {
this.jdbcUrl = this.jdbcUrl.trim();
if (jdbcUrl.startsWith(DruidDriver.DEFAULT_PREFIX)) {
DataSourceProxyConfig config = DruidDriver.parseConfig(
jdbcUrl, null);
this.driverClass = config.getRawDriverClassName();
this.jdbcUrl = config.getRawUrl();
if (this.name == null) {
this.name = config.getName();
this.filters.addAll(config.getFilters());
if (this.driver == null) {
if (this.driverClass == null || this.driverClass.isEmpty()) {
this.driverClass = JdbcUtils
.getDriverClassName(this.jdbcUrl);
driver = JdbcUtils.createDriver(driverClass);
if (this.driverClass == null) {
this.driverClass = driver.getClass().getName();
this.dbType = JdbcUtils.getDbType(jdbcUrl, driverClass.getClass()
.getName());
String realDriverClassName = driver.getClass().getName();
if (realDriverClassName.equals("com.mysql.jdbc.Driver")) {
this.validConnectionChecker = new MySqlValidConnectionChecker();
this.exceptionSorter = new MySqlExceptionSorter();
} else if (realDriverClassName
.equals("oracle.jdbc.driver.OracleDriver")) {
this.validConnectionChecker = new OracleValidConnectionChecker();
this.exceptionSorter = new OracleExceptionSorter();
} else if (realDriverClassName
.equals("com.microsoft.jdbc.sqlserver.SQLServerDriver")) {
this.validConnectionChecker = new MSSQLValidConnectionChecker();
} else if (realDriverClassName
.equals("com.informix.jdbc.IfxDriver")) {
this.exceptionSorter = new InformixExceptionSorter();
} else if (realDriverClassName
.equals("com.sybase.jdbc2.jdbc.SybDriver")) {
this.exceptionSorter = new SybaseExceptionSorter();
} else if (realDriverClassName
.equals("com.alibaba.druid.mock.MockDriver")) {
this.exceptionSorter = new MockExceptionSorter();
for (Filter filter : filters) {
filter.init(this);
initConnectionFactory();
connections = new ConnectionHolder[maxActive];
SQLException connectError = null;
for (int i = 0, size = getInitialSize(); i < size; ++i) {
Connection conn = connectionFactory.createConnection();
conn.setAutoCommit(true);
connections[poolingCount++] = new ConnectionHolder(this,
} catch (SQLException ex) {
LOG.error("init datasource error", ex);
connectError = ex;
createConnectionThread = new CreateConnectionThread(
"Druid-ConnectionPool-Create");
createConnectionThread.setDaemon(true);
destoryConnectionThread = new DestroyConnectionThread(
"Druid-ConnectionPool-Destory");
destoryConnectionThread.setDaemon(true);
createConnectionThread.start();
destoryConnectionThread.start();
initedLatch.await();
createdTime = new Date();
DruidDataSourceStatManager.add(this);
if (connectError != null && poolingCount == 0) {
throw connectError;
} catch (InterruptedException e) {
throw new SQLException(e.getMessage(), e);
} finally {
inited = true;
lock.unlock();
public Connection getConnection() throws SQLException {
return getConnection(maxWait);
public Connection getConnection(long maxWaitMillis) throws SQLException {
final int maxWaitThreadCount = getMaxWaitThreadCount();
if (maxWaitThreadCount > 0) {
if (notEmptyWaitThreadCount > maxWaitThreadCount) {
lock.lock();
connectErrorCount++;
} finally {
lock.unlock();
throw new SQLException("maxWaitThreadCount "
+ maxWaitThreadCount + ", current wait Thread count "
+ lock.getQueueLength());
for (;;) {
PoolableConnection poolalbeConnection = getConnectionInternal(maxWaitMillis);
if (isTestOnBorrow()) {
boolean validate = testConnectionInternal(poolalbeConnection
.getConnection());
if (!validate) {
if (LOG.isDebugEnabled()) {
LOG.debug("skip not validate connection.");
Connection realConnection = poolalbeConnection
.getConnection();
discardConnection(realConnection);
Connection realConnection = poolalbeConnection.getConnection();
if (realConnection.isClosed()) {
discardConnection(null); 
if (isTestWhileIdle()) {
long idleMillis = System.currentTimeMillis()
- poolalbeConnection.getConnectionHolder()
.getLastActiveTimeMillis();
if (idleMillis >= this.getTimeBetweenEvictionRunsMillis()) {
boolean validate = testConnectionInternal(poolalbeConnection
.getConnection());
if (!validate) {
if (LOG.isDebugEnabled()) {
LOG.debug("skip not validate connection.");
discardConnection(realConnection);
if (isRemoveAbandoned()) {
StackTraceElement[] stackTrace = Thread.currentThread()
.getStackTrace();
activeConnections.put(poolalbeConnection,
new ActiveConnectionTraceInfo(poolalbeConnection,
System.currentTimeMillis(), stackTrace));
poolalbeConnection.setTraceEnable(true);
if (!this.isDefaultAutoCommit()) {
poolalbeConnection.setAutoCommit(false);
return poolalbeConnection;
private void discardConnection(Connection realConnection)
throws SQLException {
JdbcUtils.close(realConnection);
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
activeCount--;
} finally {
lock.unlock();
private PoolableConnection getConnectionInternal(long maxWait)
throws SQLException {
PoolableConnection poolalbeConnection;
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
connectCount++;
ConnectionHolder holder;
if (maxWait > 0) {
holder = pollLast(maxWait, TimeUnit.MILLISECONDS);
holder = takeLast();
if (holder == null) {
throw new SQLException("can not get connection");
holder.incrementUseCount();
activeCount++;
if (activeCount > activePeak) {
activePeak = activeCount;
activePeakTime = System.currentTimeMillis();
poolalbeConnection = new PoolableConnection(holder);
} catch (InterruptedException e) {
connectErrorCount++;
throw new SQLException(e.getMessage(), e);
} catch (SQLException e) {
connectErrorCount++;
} finally {
lock.unlock();
return poolalbeConnection;
public void handleConnectionException(PoolableConnection pooledConnection,
Throwable t) throws SQLException {
final ConnectionHolder holder = pooledConnection.getConnectionHolder();
errorCount.incrementAndGet();
if (t instanceof SQLException) {
SQLException sqlEx = (SQLException) t;
ConnectionEvent event = new ConnectionEvent(pooledConnection, sqlEx);
for (ConnectionEventListener eventListener : holder
.getConnectionEventListeners()) {
eventListener.connectionErrorOccurred(event);
if (exceptionSorter != null
&& exceptionSorter.isExceptionFatal(sqlEx)) {
if (pooledConnection.isTraceEnable()) {
activeConnections.remove(pooledConnection);
this.discardConnection(holder.getConnection());
pooledConnection.disable();
throw sqlEx;
throw new SQLException("Error", t);
protected void recycle(PoolableConnection pooledConnection)
throws SQLException {
final Connection conn = pooledConnection.getConnection();
final ConnectionHolder holder = pooledConnection.getConnectionHolder();
assert holder != null;
if (pooledConnection.isTraceEnable()) {
ActiveConnectionTraceInfo oldInfo = activeConnections
.remove(pooledConnection);
if (oldInfo == null) {
LOG.warn("remove abandonded failed. activeConnections.size "
+ activeConnections.size());
if (conn == null) {
lock.lockInterruptibly();
activeCount--;
closeCount++;
} finally {
lock.unlock();
final boolean isAutoCommit = holder.isUnderlyingAutoCommit();
final boolean isReadOnly = holder.isUnderlyingReadOnly();
if ((!isAutoCommit) && (!isReadOnly)) {
pooledConnection.rollback();
holder.reset();
if (isTestOnReturn()) {
boolean validate = testConnectionInternal(conn);
if (!validate) {
JdbcUtils.close(conn);
lock.lockInterruptibly();
destroyCount++;
activeCount--;
closeCount++;
} finally {
lock.unlock();
lock.lockInterruptibly();
activeCount--;
closeCount++;
putLast(holder);
recycleCount++;
} finally {
lock.unlock();
} catch (Throwable e) {
JdbcUtils.close(conn);
lock.lockInterruptibly();
} catch (InterruptedException interruptEx) {
throw new SQLException("interrupt", interruptEx);
activeCount--;
closeCount++;
} finally {
lock.unlock();
throw new SQLException("recyle error", e);
public void close() {
lock.lock();
if (!this.inited) {
if (createConnectionThread != null) {
createConnectionThread.interrupt();
if (destoryConnectionThread != null) {
destoryConnectionThread.interrupt();
for (int i = 0; i < poolingCount; ++i) {
JdbcUtils.close(connections[i].getConnection());
connections[i] = null;
destroyCount++;
} catch (Exception ex) {
LOG.warn("close connection error", ex);
poolingCount = 0;
DruidDataSourceStatManager.remove(this);
enable = false;
notEmpty.signalAll();
notEmptySignalCount++;
} finally {
lock.unlock();
void incrementCreateCount() {
createConnectionCount++;
void putLast(ConnectionHolder e) throws SQLException {
if (!enable) {
discardConnection(e.getConnection());
e.setLastActiveTimeMillis(System.currentTimeMillis());
connections[poolingCount++] = e;
notEmpty.signal();
notEmptySignalCount++;
ConnectionHolder takeLast() throws InterruptedException, SQLException {
while (poolingCount == 0) {
empty.signal(); 
notEmptyWaitThreadCount++;
notEmpty.await(); 
} finally {
notEmptyWaitThreadCount--;
notEmptyWaitCount++;
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
} catch (InterruptedException ie) {
notEmpty.signal(); 
notEmptySignalCount++;
poolingCount--;
ConnectionHolder last = connections[poolingCount];
connections[poolingCount] = null;
return last;
ConnectionHolder pollLast(long timeout, TimeUnit unit)
throws InterruptedException, SQLException {
long estimate = unit.toNanos(timeout);
for (;;) {
if (poolingCount == 0) {
empty.signal(); 
if (estimate <= 0) {
throw new GetConnectionTimeoutException();
notEmptyWaitThreadCount++;
long startEstimate = estimate;
estimate = notEmpty.awaitNanos(estimate); 
notEmptyWaitCount++;
notEmptyWaitNanos += (startEstimate - estimate);
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
} catch (InterruptedException ie) {
notEmpty.signal(); 
notEmptySignalCount++;
} finally {
notEmptyWaitThreadCount--;
if (poolingCount == 0) {
if (estimate > 0) {
throw new GetConnectionTimeoutException();
poolingCount--;
ConnectionHolder last = connections[poolingCount];
connections[poolingCount] = null;
return last;
public Connection getConnection(String username, String password)
throws SQLException {
throw new UnsupportedOperationException(
"Not supported by DruidDataSource");
public long getCreateCount() {
return createConnectionCount;
public long getDestroyCount() {
return destroyCount;
public long getConnectCount() {
return connectCount;
public long getCloseCount() {
return closeCount;
public long getConnectErrorCount() {
return connectErrorCount;
public int getPoolingCount() {
lock.lock();
return poolingCount;
} finally {
lock.unlock();
public int getPoolingPeak() {
return poolingPeak;
public Date getPoolingPeakTime() {
if (poolingPeakTime <= 0) {
return null;
return new Date(poolingPeakTime);
public long getRecycleCount() {
return recycleCount;
public int getActiveCount() {
lock.lock();
return activeCount;
} finally {
lock.unlock();
public long getRemoveAbandonedCount() {
return removeAbandonedCount;
public class CreateConnectionThread extends Thread {
public CreateConnectionThread(String name) {
super(name);
public void run() {
initedLatch.countDown();
int errorCount = 0;
for (;;) {
lock.lockInterruptibly();
} catch (InterruptedException e2) {
if (poolingCount >= notEmptyWaitThreadCount) {
empty.await();
if (activeCount + poolingCount >= maxActive) {
empty.await();
} catch (InterruptedException e) {
} catch (RuntimeException e) {
LOG.error("create connection error", e);
} catch (Error e) {
LOG.error("create connection error", e);
} finally {
lock.unlock();
Connection connection = null;
connection = connectionFactory.createConnection();
} catch (SQLException e) {
LOG.error("create connection error", e);
errorCount++;
if (errorCount > connectionErrorRetryAttempts
&& timeBetweenConnectErrorMillis > 0) {
if (breakAfterAcquireFailure) {
Thread.sleep(timeBetweenConnectErrorMillis);
} catch (InterruptedException interruptEx) {
} catch (RuntimeException e) {
LOG.error("create connection error", e);
} catch (Error e) {
LOG.error("create connection error", e);
if (connection == null) {
lock.lock();
connections[poolingCount++] = new ConnectionHolder(
DruidDataSource.this, connection);
if (poolingCount > poolingPeak) {
poolingPeak = poolingCount;
poolingPeakTime = System.currentTimeMillis();
errorCount = 0; 
notEmpty.signal();
notEmptySignalCount++;
} catch (SQLException ex) {
LOG.error("create connection holder error", ex);
} finally {
lock.unlock();
public class DestroyConnectionThread extends Thread {
public DestroyConnectionThread(String name) {
super(name);
public void run() {
initedLatch.countDown();
for (;;) {
if (timeBetweenEvictionRunsMillis > 0) {
Thread.sleep(timeBetweenEvictionRunsMillis);
Thread.sleep(1000); 
if (Thread.interrupted()) {
shrink(true);
if (isRemoveAbandoned()) {
removeAbandoned();
} catch (InterruptedException e) {
public int removeAbandoned() {
int removeCount = 0;
Iterator<Map.Entry<PoolableConnection, ActiveConnectionTraceInfo>> iter = activeConnections
.entrySet().iterator();
long currentMillis = System.currentTimeMillis();
List<PoolableConnection> abondonedList = new ArrayList<PoolableConnection>();
for (; iter.hasNext();) {
Map.Entry<PoolableConnection, ActiveConnectionTraceInfo> entry = iter
ActiveConnectionTraceInfo activeInfo = entry.getValue();
long timeMillis = currentMillis - activeInfo.getConnectTime();
if (timeMillis >= removeAbandonedTimeoutMillis) {
PoolableConnection pooledConnection = entry.getKey();
JdbcUtils.close(pooledConnection);
removeAbandonedCount++;
removeCount++;
abondonedList.add(pooledConnection);
if (isLogAbandoned()) {
StringBuilder buf = new StringBuilder();
buf.append("abandon connection, open stackTracen");
StackTraceElement[] trace = activeInfo.getStackTrace();
for (int i = 0; i < trace.length; i++) {
buf.append("tat ");
buf.append(trace[i].toString());
buf.append("n");
LOG.error(buf.toString());
for (PoolableConnection conn : abondonedList) {
activeConnections.remove(conn);
return removeCount;
public DataSourceProxyConfig getConfig() {
return null;
protected String instanceKey = null;
public Reference getReference() throws NamingException {
final String className = getClass().getName();
final String factoryName = className + "Factory"; 
Reference ref = new Reference(className, factoryName, null);
ref.add(new StringRefAddr("instanceKey", instanceKey));
return ref;
static class ActiveConnectionTraceInfo {
private final PoolableConnection connection;
private final long connectTime;
private final StackTraceElement[] stackTrace;
public ActiveConnectionTraceInfo(PoolableConnection connection,
long connectTime, StackTraceElement[] stackTrace) {
this.connection = connection;
this.connectTime = connectTime;
this.stackTrace = stackTrace;
public PoolableConnection getConnection() {
return connection;
public long getConnectTime() {
return connectTime;
public StackTraceElement[] getStackTrace() {
return stackTrace;
public List<String> getFilterClassNames() {
List<String> names = new ArrayList<String>();
for (Filter filter : filters) {
names.add(filter.getClass().getName());
return names;
public int getRawDriverMajorVersion() {
int version = -1;
if (this.driver != null) {
version = driver.getMajorVersion();
return version;
public int getRawDriverMinorVersion() {
int version = -1;
if (this.driver != null) {
version = driver.getMinorVersion();
return version;
public String getProperties() {
if (this.connectionProperties == null) {
return null;
Properties properties = new Properties(this.connectionProperties);
if (properties.contains("password")) {
properties.put("password", "******");
return properties.toString();
public void shrink() {
shrink(false);
public void shrink(boolean checkTime) {
final List<ConnectionHolder> evictList = new ArrayList<ConnectionHolder>();
lock.lockInterruptibly();
} catch (InterruptedException e) {
final int checkCount = poolingCount - minIdle;
for (int i = 0; i < checkCount; ++i) {
ConnectionHolder connection = connections[i];
if (checkTime) {
long idleMillis = System.currentTimeMillis()
- connection.getLastActiveTimeMillis();
if (idleMillis >= minEvictableIdleTimeMillis) {
evictList.add(connection);
evictList.add(connection);
int removeCount = evictList.size();
if (removeCount > 0) {
System.arraycopy(connections, removeCount, connections, 0,
poolingCount - removeCount);
Arrays.fill(connections, poolingCount - removeCount,
poolingCount, null);
poolingCount -= removeCount;
} finally {
lock.unlock();
for (ConnectionHolder item : evictList) {
Connection connection = item.getConnection();
JdbcUtils.close(connection);
destroyCount++;
public int getWaitThreadCount() {
lock.lock();
return lock.getWaitQueueLength(notEmpty);
} finally {
lock.unlock();
public long getNotEmptyWaitCount() {
return notEmptyWaitCount;
public int getNotEmptyWaitThreadCount() {
return notEmptyWaitThreadCount;
public long getNotEmptySignalCount() {
return notEmptySignalCount;
public long getNotEmptyWaitMillis() {
return notEmptyWaitNanos / (1000 * 1000);
public long getNotEmptyWaitNanos() {
return notEmptyWaitNanos;
public int getLockQueueLength() {
return lock.getQueueLength();
public int getActivePeak() {
return activePeak;
public Date getActivePeakTime() {
if (activePeakTime <= 0) {
return null;
return new Date(activePeakTime);
public String dump() {
lock.lock();
return this.toString();
} finally {
lock.unlock();
public long getErrorCount() {
return this.errorCount.get();
public String toString() {
StringBuilder buf = new StringBuilder();
buf.append("{");
buf.append("ntCreateTime:"");
buf.append(JdbcUtils.toString(getCreatedTime()));
buf.append(""");
buf.append(",ntActiveCount:");
buf.append(getActiveCount());
buf.append(",ntPoolingCount:");
buf.append(getPoolingCount());
buf.append(",ntCreateCount:");
buf.append(getCreateCount());
buf.append(",ntDestroyCount:");
buf.append(getDestroyCount());
buf.append(",ntCloseCount:");
buf.append(getCloseCount());
buf.append(",ntConnectCount:");
buf.append(getConnectCount());
buf.append(",ntConnections:[");
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder conn = connections[i];
if (conn != null) {
if (i != 0) {
buf.append(",");
buf.append("ntt");
buf.append(conn.toString());
buf.append("nt]");
buf.append("n}");
if (this.isPoolPreparedStatements()) {
buf.append("nn[");
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder conn = connections[i];
if (conn != null) {
if (i != 0) {
buf.append(",");
buf.append("nt{ntID:");
buf.append(System.identityHashCode(conn.getConnection()));
PreparedStatementPool pool = conn.getStatementPool();
if (pool != null) {
buf.append(", ntpoolStatements:[");
int entryIndex = 0;
for (Map.Entry<PreparedStatementKey, PreparedStatementHolder> entry : pool
.getMap().entrySet()) {
if (entryIndex++ != 0) {
buf.append(",");
buf.append("ntt{reuseCount:");
buf.append(entry.getValue().getReusedCount());
buf.append(",sql:"");
buf.append(entry.getKey().getSql());
buf.append(""");
buf.append("t}");
buf.append("ntt]");
buf.append("nt}");
buf.append("n]");
return buf.toString();
public void logTransaction(TransactionInfo info) {
long transactionMillis = info.getEndTimeMillis()
- info.getStartTimeMillis();
if (transactionThresholdMillis > 0
&& transactionMillis > transactionThresholdMillis) {
StringBuilder buf = new StringBuilder();
buf.append("long time transaction, take ");
buf.append(transactionMillis);
buf.append(" ms : ");
for (String sql : info.getSqlList()) {
buf.append(sql);
buf.append(";");
LOG.error(buf.toString(), new TransactionTimeoutException());
public String getVersion() {
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "."
+ VERSION.RevisionVersion + "-2011-12-01 12:13";
if (this.holder == null) {
holder.setUnderlyingAutoCommit(autoCommit);
holder.setUnderlyingReadOnly(readOnly);
holder.setUnderlyingTransactionIsolation(level);
holder.setUnderlyingHoldability(holdability);
ObjectName getObjectName();
void setObjectName(ObjectName objectName);
public class HADataSource extends MultiDataSource implements HADataSourceMBean, ManagedDataSource, DataSource {
super.resetStat();
public String getMasterUrl() {
if (master == null) {
return null;
return master.getUrl();
public String getSlaveUrl() {
if (slave == null) {
return null;
return slave.getUrl();
public interface HADataSourceMBean extends MultiDataSourceMBean {
String getMasterUrl();
String getSlaveUrl();
public abstract class MultiDataSource extends DataSourceAdapter implements MultiDataSourceMBean, DataSourceProxy {
private Properties                             properties                       = new Properties();
private final AtomicLong                       connectionIdSeed                 = new AtomicLong();
private final AtomicLong                       statementIdSeed                  = new AtomicLong();
private final AtomicLong                       resultSetIdSeed                  = new AtomicLong();
private final AtomicLong                       transactionIdSeed             = new AtomicLong();
private ValidDataSourceChecker                 validDataSourceChecker           = new DefaultValidDataSourceChecker();
private long                                   validDataSourceCheckPeriodMillis = 3000;
private int                                    schedulerThreadCount             = 3;
private ScheduledExecutorService               scheduler;
private boolean                                inited                           = false;
private final Lock                             lock                             = new ReentrantLock();
private ConcurrentMap<String, DruidDataSource> dataSources                      = new ConcurrentHashMap<String, DruidDataSource>();
private ObjectName                             objectName;
private List<Filter>                           filters                          = new ArrayList<Filter>();
private boolean                                enable;
private String                                 name;
public String getName() {
if (name == null) {
return "HADataSource-" + System.identityHashCode(this);
return name;
public String getNameInternal() {
return this.name;
public void setName(String name) {
this.name = name;
public boolean isEnable() {
return enable;
public void setEnable(boolean enable) {
this.enable = enable;
public ObjectName getObjectName() {
return objectName;
public void setObjectName(ObjectName objectName) {
this.objectName = objectName;
scheduler.scheduleAtFixedRate(new FailureDetectTask(), validDataSourceCheckPeriodMillis,
MultiDataSourceStatManager.add(this);
public void resetStat() {
MultiDataSourceStatManager.remove(this);
public void failureDetect() {
for (DruidDataSource dataSource : getDataSources().values()) {
boolean isValid = validDataSourceChecker.isValid(dataSource);
if (isValid) {
handleNotAwailableDatasource(dataSource);
public long createConnectionId() {
public long createStatementId() {
public String getDbType() {
return null;
public Driver getRawDriver() {
return null;
public String getUrl() {
return null;
public String getRawJdbcUrl() {
return null;
public List<Filter> getProxyFilters() {
return filters;
public long createResultSetId() {
return resultSetIdSeed.incrementAndGet();
public long createTransactionId() {
return transactionIdSeed.incrementAndGet();
class FailureDetectTask implements Runnable {
failureDetect();
private final long             id;
public MultiDataSourceConnection(MultiDataSource haDataSource, long id){
return haDataSource;
public interface MultiDataSourceMBean {
public class MultiDataSourceStatManager implements MultiDataSourceStatManagerMBean {
private final static Log                                                    LOG         = LogFactory.getLog(MultiDataSourceStatManager.class);
private final static MultiDataSourceStatManager                             instance    = new MultiDataSourceStatManager();
private final AtomicLong                                                    resetCount  = new AtomicLong();
private static final ConcurrentIdentityHashMap<MultiDataSource, ObjectName> dataSources = new ConcurrentIdentityHashMap<MultiDataSource, ObjectName>();
private final static String                                                 MBEAN_NAME  = "com.alibaba.druid.ha:type=HADruidDataSourceStat";
public static MultiDataSourceStatManager getInstance() {
return instance;
public synchronized static void add(MultiDataSource dataSource) {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
if (dataSources.size() == 0) {
mbeanServer.registerMBean(instance, new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("register mbean error", ex);
ObjectName objectName = null;
if (dataSource.getNameInternal() != null) {
objectName = new ObjectName("com.alibaba.druid.ha:type=DruidDataSource,id=" + dataSource.getNameInternal());
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
if (objectName == null) {
int id = System.identityHashCode(dataSource);
objectName = new ObjectName("com.alibaba.druid.ha:type=DruidDataSource,id=" + id);
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
dataSources.put(dataSource, objectName);
dataSource.setObjectName(objectName);
public synchronized static void remove(MultiDataSource dataSource) {
ObjectName objectName = dataSources.remove(dataSource);
if (objectName == null) {
objectName = dataSource.getObjectName();
if (objectName == null) {
LOG.error("unregister mbean failed. ");
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
if (objectName != null) {
mbeanServer.unregisterMBean(objectName);
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
if (dataSources.size() == 0) {
mbeanServer.unregisterMBean(new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
public static Set<MultiDataSource> getDruidDataSourceInstances() {
return dataSources.keySet();
public void reset() {
final Set<MultiDataSource> dataSources = getDruidDataSourceInstances();
for (MultiDataSource dataSource : dataSources) {
dataSource.resetStat();
resetCount.incrementAndGet();
public long getResetCount() {
return resetCount.get();
public interface MultiDataSourceStatManagerMBean {
int getFilterSize();
public int getFilterSize() {
return filterSize;
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
return new MultiDataSourcePreparedStatement(this, stmt, sql, stmtId);
public class MultiDataSourcePreparedStatement extends PreparedStatementProxyImpl {
private MultiDataSourceConnection multiConnection;
public MultiDataSourcePreparedStatement(MultiDataSourceConnection connection, PreparedStatement statement, String sql, long id){
super(connection, statement, sql, id);
multiConnection = connection;
public MultiDataSourceConnection getConnection() {
return multiConnection;
public boolean execute() throws SQLException {
FilterChain chain = createChain();
if (chain.getFilterSize() == 0) {
return this.statement.execute();
return chain.preparedStatement_execute(this);
public ResultSet executeQuery() throws SQLException {
FilterChain chain = createChain();
if (chain.getFilterSize() == 0) {
return this.statement.executeQuery();
return chain.preparedStatement_executeQuery(this);
public int executeUpdate() throws SQLException {
FilterChain chain = createChain();
if (chain.getFilterSize() == 0) {
return this.statement.executeUpdate();
return chain.preparedStatement_executeUpdate(this);
protected final PreparedStatement statement;
protected final String            sql;
private final AtomicLong                       transactionIdSeed                = new AtomicLong();
protected DataSourceFailureDetecter               validDataSourceChecker           = new DefaultDataSourceFailureDetecter();
if (!isValid) {
public DataSourceFailureDetecter getValidDataSourceChecker() {
public void setValidDataSourceChecker(DataSourceFailureDetecter validDataSourceChecker) {
public void handleNotAwailableDatasource(DruidDataSource dataSource) {
dataSource.setEnable(false);
void failureDetect();
public interface DataSourceFailureDetecter {
public class DefaultDataSourceFailureDetecter implements DataSourceFailureDetecter {
private final static Log LOG           = LogFactory.getLog(DefaultDataSourceFailureDetecter.class);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M2, resultSetType,
resultSetConcurrency);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M3, resultSetType,
resultSetConcurrency, resultSetHoldability);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M4, columnIndexes);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M5, columnNames);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M6, autoGeneratedKeys);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.Precall_2, resultSetType,
resultSetConcurrency, resultSetHoldability);
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.Precall_3, resultSetType,
resultSetConcurrency);
private final int          resultSetType;
private final int          resultSetConcurrency;
private final int          resultSetHoldability;
private final int          autoGeneratedKeys;
private final int[]        columnIndexes;
private final String[]     columnNames;
this(sql, catalog, methodType, 0, 0, 0, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency) throws SQLException{
this(sql, catalog, methodType, resultSetType, resultSetConcurrency, 0, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency, int resultSetHoldability) throws SQLException{
this(sql, catalog, methodType, resultSetType, resultSetConcurrency, resultSetHoldability, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int autoGeneratedKeys) throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, autoGeneratedKeys, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int[] columnIndexes) throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, 0, columnIndexes, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, String[] columnNames) throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, 0, null, columnNames);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency, int resultSetHoldability, int autoGeneratedKeys,
int[] columnIndexes, String[] columnNames) throws SQLException{
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
this.resultSetHoldability = resultSetHoldability;
this.autoGeneratedKeys = autoGeneratedKeys;
this.columnIndexes = columnIndexes;
this.columnNames = columnNames;
public int getResultSetType() {
return resultSetType;
public int getResultSetConcurrency() {
return resultSetConcurrency;
public int getResultSetHoldability() {
return resultSetHoldability;
if (this.resultSetType != that.resultSetType) {
return false;
if (this.resultSetConcurrency != that.resultSetConcurrency) {
return false;
if (this.resultSetHoldability != that.resultSetHoldability) {
return false;
if (this.autoGeneratedKeys != that.autoGeneratedKeys) {
return false;
if (!Arrays.equals(columnIndexes, that.columnIndexes)) {
return false;
if (!Arrays.equals(columnNames, that.columnNames)) {
return false;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((sql == null) ? 0 : sql.hashCode());
result = prime * result + ((catalog == null) ? 0 : catalog.hashCode());
result = prime * result + ((methodType == null) ? 0 : methodType.hashCode());
result = prime * result + resultSetConcurrency;
result = prime * result + resultSetHoldability;
result = prime * result + resultSetType;
result = prime * result + autoGeneratedKeys;
result = prime * result + Arrays.hashCode(columnIndexes);
result = prime * result + Arrays.hashCode(columnNames);
return result;
new PreparedStatementHolder(new PreparedStatementKey("", null, null, 0, 0, 0), raw)) {
new PreparedStatementHolder(new PreparedStatementKey("", null, null, 0, 0, 0), raw)) {
public void test_equals_7() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", null, MethodType.M1, 0, 0);
PreparedStatementKey k2 = new PreparedStatementKey("x1", null, MethodType.M1, 1, 0);
PreparedStatementKey k3 = new PreparedStatementKey("x2", null, MethodType.M1, 0, 1);
k1.hashCode();
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_8() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", null, MethodType.M1, 0, 0, 0);
PreparedStatementKey k2 = new PreparedStatementKey("x1", null, MethodType.M1, 0, 0, 1);
PreparedStatementKey k3 = new PreparedStatementKey("x2", null, MethodType.M1, 0, 1, 0);
k1.hashCode();
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
public void test_equals_9() throws Exception {
PreparedStatementKey k1 = new PreparedStatementKey("x1", null, MethodType.M1, 2);
PreparedStatementKey k2 = new PreparedStatementKey("x1", null, MethodType.M1, new int[] {});
PreparedStatementKey k3 = new PreparedStatementKey("x2", null, MethodType.M1, new String[] {});
k1.hashCode();
Assert.assertFalse(k1.equals(k2));
Assert.assertFalse(k1.equals(k3));
Assert.assertFalse(k2.equals(k1));
Assert.assertFalse(k2.equals(k3));
Assert.assertFalse(k3.equals(k2));
Assert.assertFalse(k3.equals(k1));
dataSource.setMaxIdle(maxPoolSize);
public class DataSourceHolder {
private DruidDataSource  dataSource;
private boolean          enable;
private final AtomicLong connectCount = new AtomicLong();
public DataSourceHolder(DruidDataSource dataSource){
this.dataSource = dataSource;
public void resetStat() {
connectCount.set(0);
public boolean isEnable() {
return enable;
public void setEnable(boolean enable) {
this.enable = enable;
public DruidDataSource getDataSource() {
return dataSource;
public void setDataSource(DruidDataSource dataSource) {
this.dataSource = dataSource;
public long getConnectCount() {
return connectCount.get();
public void incrementConnectCount() {
connectCount.incrementAndGet();
public String getUrl() {
if (dataSource == null) {
return null;
return dataSource.getUrl();
public Connection getConnection() throws SQLException {
connectCount.incrementAndGet();
return dataSource.getConnection();
private final static Log   LOG = LogFactory.getLog(HADataSource.class);
protected DataSourceHolder master;
protected DataSourceHolder slave;
master.resetStat();
slave.resetStat();
return master.getConnectCount();
return slave.getConnectCount();
public DataSourceHolder getMaster() {
this.setMaster(new DataSourceHolder(master));
public void setMaster(DataSourceHolder master) {
public DataSourceHolder getSlave() {
this.setSlave(new DataSourceHolder(slave));
public void setSlave(DataSourceHolder slave) {
DataSourceHolder tmp = this.getMaster();
this.setMaster(this.getSlave());
this.setSlave(tmp);
private ConcurrentMap<String, DataSourceHolder> dataSources                      = new ConcurrentHashMap<String, DataSourceHolder>();
for (DataSourceHolder dataSourceHolder : getDataSources().values()) {
boolean isValid = validDataSourceChecker.isValid(dataSourceHolder.getDataSource());
handleNotAwailableDatasource(dataSourceHolder);
public Map<String, DataSourceHolder> getDataSources() {
public void handleNotAwailableDatasource(DataSourceHolder dataSourceHolder) {
dataSourceHolder.setEnable(false);
DataSourceHolder dataSource = null;
List<DataSourceHolder> dataSources = new ArrayList<DataSourceHolder>(multiDataSource.getDataSources().values());
if (!dataSource.isEnable()) {
private final AtomicLong connectCount      = new AtomicLong();
private final AtomicLong connectErrorCount = new AtomicLong();
return dataSource.getConnection();
} catch (SQLException ex) {
connectErrorCount.incrementAndGet();
} catch (RuntimeException ex) {
connectErrorCount.incrementAndGet();
public MultiConnectionHolder getConnectionInternal(MultiDataSourceConnection connection, String sql) throws SQLException {
DataSourceHolder dataSource = null;
dataSource = master;
dataSource = slave;
return new MultiConnectionHolder(dataSource, conn);
public class MultiConnectionHolder {
private final Connection       connection;
private final DataSourceHolder dataSourceHolder;
public MultiConnectionHolder(DataSourceHolder dataSourceHolder, Connection connection){
this.dataSourceHolder = dataSourceHolder;
this.connection = connection;
public Connection getConnection() {
return connection;
public DataSourceHolder getDataSourceHolder() {
return dataSourceHolder;
public abstract MultiConnectionHolder getConnectionInternal(MultiDataSourceConnection conn, String sql) throws SQLException;
private DataSourceHolder      dataSourceHolder;
private final long            id;
public DataSourceHolder getDataSourceHolder() {
return dataSourceHolder;
MultiConnectionHolder connHolder = haDataSource.getConnectionInternal(this, sql);
conn = connHolder.getConnection();
this.dataSourceHolder = connHolder.getDataSourceHolder();
boolean result = super.isWrapperFor(iface);
if (result == false && conn != null) {
result = conn.isWrapperFor(iface);
return result;
T object = super.unwrap(iface);
if (object == null && conn != null) {
object = conn.unwrap(iface);
return object;
public class DataSourceHolder implements Closeable {
private final DruidDataSource  dataSource;
private boolean          enable            = true;
if (dataSource == null) {
throw new IllegalArgumentException("dataSource is null");
public void close() {
dataSource.close();
JdbcUtils.close((DataSourceHolder) item);
public void restart() {
this.close();
this.inited = false;
public void resetState() {
public void restart() {
dataSource.resetStat();
master.resetState();
slave.resetState();
public String[] getDataSourceNames() {
return this.dataSources.keySet().toArray(new String[this.dataSources.size()]);
public boolean restartDataSource(String name) {
DataSourceHolder holder = this.getDataSources().get(name);
if (holder != null) {
holder.restart();
return true;
return false;
String[] getDataSourceNames();
boolean restartDataSource(String name);
public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable {
private final static Log        LOG                     = LogFactory.getLog(DruidDataSource.class);
private static final long       serialVersionUID        = 1L;
private final ReentrantLock     lock                    = new ReentrantLock();
private final Condition         notEmpty                = lock.newCondition();
private final Condition         empty                   = lock.newCondition();
private long                    connectCount            = 0L;
private long                    closeCount              = 0L;
private long                    connectErrorCount       = 0L;
private long                    recycleCount            = 0L;
private long                    createConnectionCount   = 0L;
private long                    destroyCount            = 0L;
private long                    removeAbandonedCount    = 0L;
private long                    notEmptyWaitCount       = 0L;
private long                    notEmptySignalCount     = 0L;
private long                    notEmptyWaitNanos       = 0L;
private int                     activePeak              = 0;
private long                    activePeakTime          = 0;
private int                     poolingPeak             = 0;
private long                    poolingPeakTime         = 0;
private ConnectionHolder[]      connections;
private int                     poolingCount            = 0;
private int                     activeCount             = 0;
private int                     notEmptyWaitThreadCount = 0;
private CreateConnectionThread  createConnectionThread;
private DestroyConnectionThread destoryConnectionThread;
private final CountDownLatch    initedLatch             = new CountDownLatch(2);
private boolean                 enable                  = true;
private boolean                 resetStatEnable         = true;
private String                  initStackTrace;
public DruidDataSource(){
public String getInitStackTrace() {
return initStackTrace;
public boolean isResetStatEnable() {
return resetStatEnable;
public void setResetStatEnable(boolean resetStatEnable) {
this.resetStatEnable = resetStatEnable;
public void restart() {
lock.lock();
this.close();
this.resetStat();
this.inited = false;
} finally {
lock.unlock();
public void resetStat() {
if (!resetStatEnable) {
lock.lock();
connectCount = 0;
closeCount = 0;
connectErrorCount = 0;
recycleCount = 0;
createConnectionCount = 0;
destroyCount = 0;
removeAbandonedCount = 0;
notEmptyWaitCount = 0;
notEmptySignalCount = 0L;
notEmptyWaitNanos = 0;
activePeak = 0;
activePeakTime = 0;
poolingPeak = 0;
createTimespan = 0;
} finally {
lock.unlock();
errorCount.set(0);
commitCount.set(0);
rollbackCount.set(0);
startTransactionCount.set(0);
reusePreparedStatement.set(0);
closedPreparedStatementCount.set(0);
preparedStatementCount.set(0);
transactionHistogram.reset();
public boolean isEnable() {
return enable;
public void setEnable(boolean enable) {
lock.lock();
this.enable = enable;
if (!enable) {
notEmpty.signalAll();
notEmptySignalCount++;
} finally {
lock.unlock();
public void setPoolPreparedStatements(boolean value) {
lock.lock();
if (this.poolPreparedStatements && (!value)) {
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder connection = connections[i];
for (PreparedStatementHolder holder : connection.getStatementPool().getMap().values()) {
closePreapredStatement(holder);
decrementCachedPreparedStatementCount();
connection.getStatementPool().getMap().clear();
super.setPoolPreparedStatements(value);
} finally {
lock.unlock();
public boolean isInited() {
return this.inited;
private void init() throws SQLException {
if (inited) {
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
if (inited) {
initStackTrace = JdbcUtils.toString(Thread.currentThread().getStackTrace());
this.id = DruidDriver.createDataSourceId();
if (maxActive <= 0) {
throw new IllegalArgumentException("illegal maxActive " + maxActive);
if (maxActive < minIdle) {
throw new IllegalArgumentException("illegal maxActive " + maxActive);
if (maxIdle <= 0 || maxIdle < minIdle) {
throw new IllegalArgumentException("illegal maxPoolSize");
if (getInitialSize() > maxActive) {
throw new IllegalArgumentException("illegal initialSize");
if (this.driverClass != null) {
this.driverClass = driverClass.trim();
if (this.jdbcUrl != null) {
this.jdbcUrl = this.jdbcUrl.trim();
if (jdbcUrl.startsWith(DruidDriver.DEFAULT_PREFIX)) {
DataSourceProxyConfig config = DruidDriver.parseConfig(jdbcUrl, null);
this.driverClass = config.getRawDriverClassName();
this.jdbcUrl = config.getRawUrl();
if (this.name == null) {
this.name = config.getName();
this.filters.addAll(config.getFilters());
if (this.driver == null) {
if (this.driverClass == null || this.driverClass.isEmpty()) {
this.driverClass = JdbcUtils.getDriverClassName(this.jdbcUrl);
driver = JdbcUtils.createDriver(driverClass);
if (this.driverClass == null) {
this.driverClass = driver.getClass().getName();
this.dbType = JdbcUtils.getDbType(jdbcUrl, driverClass.getClass().getName());
String realDriverClassName = driver.getClass().getName();
if (realDriverClassName.equals("com.mysql.jdbc.Driver")) {
this.validConnectionChecker = new MySqlValidConnectionChecker();
this.exceptionSorter = new MySqlExceptionSorter();
} else if (realDriverClassName.equals("oracle.jdbc.driver.OracleDriver")) {
this.validConnectionChecker = new OracleValidConnectionChecker();
this.exceptionSorter = new OracleExceptionSorter();
} else if (realDriverClassName.equals("com.microsoft.jdbc.sqlserver.SQLServerDriver")) {
this.validConnectionChecker = new MSSQLValidConnectionChecker();
} else if (realDriverClassName.equals("com.informix.jdbc.IfxDriver")) {
this.exceptionSorter = new InformixExceptionSorter();
} else if (realDriverClassName.equals("com.sybase.jdbc2.jdbc.SybDriver")) {
this.exceptionSorter = new SybaseExceptionSorter();
} else if (realDriverClassName.equals("com.alibaba.druid.mock.MockDriver")) {
this.exceptionSorter = new MockExceptionSorter();
for (Filter filter : filters) {
filter.init(this);
initConnectionFactory();
connections = new ConnectionHolder[maxActive];
SQLException connectError = null;
for (int i = 0, size = getInitialSize(); i < size; ++i) {
Connection conn = connectionFactory.createConnection();
conn.setAutoCommit(true);
connections[poolingCount++] = new ConnectionHolder(this, conn);
} catch (SQLException ex) {
LOG.error("init datasource error", ex);
connectError = ex;
createConnectionThread = new CreateConnectionThread("Druid-ConnectionPool-Create");
createConnectionThread.setDaemon(true);
destoryConnectionThread = new DestroyConnectionThread("Druid-ConnectionPool-Destory");
destoryConnectionThread.setDaemon(true);
createConnectionThread.start();
destoryConnectionThread.start();
initedLatch.await();
createdTime = new Date();
DruidDataSourceStatManager.add(this);
if (connectError != null && poolingCount == 0) {
throw connectError;
} catch (InterruptedException e) {
throw new SQLException(e.getMessage(), e);
} finally {
inited = true;
lock.unlock();
public Connection getConnection() throws SQLException {
return getConnection(maxWait);
public Connection getConnection(long maxWaitMillis) throws SQLException {
final int maxWaitThreadCount = getMaxWaitThreadCount();
if (maxWaitThreadCount > 0) {
if (notEmptyWaitThreadCount > maxWaitThreadCount) {
lock.lock();
connectErrorCount++;
} finally {
lock.unlock();
throw new SQLException("maxWaitThreadCount " + maxWaitThreadCount + ", current wait Thread count "
+ lock.getQueueLength());
for (;;) {
PoolableConnection poolalbeConnection = getConnectionInternal(maxWaitMillis);
if (isTestOnBorrow()) {
boolean validate = testConnectionInternal(poolalbeConnection.getConnection());
if (!validate) {
if (LOG.isDebugEnabled()) {
LOG.debug("skip not validate connection.");
Connection realConnection = poolalbeConnection.getConnection();
discardConnection(realConnection);
Connection realConnection = poolalbeConnection.getConnection();
if (realConnection.isClosed()) {
discardConnection(null); 
if (isTestWhileIdle()) {
long idleMillis = System.currentTimeMillis()
- poolalbeConnection.getConnectionHolder().getLastActiveTimeMillis();
if (idleMillis >= this.getTimeBetweenEvictionRunsMillis()) {
boolean validate = testConnectionInternal(poolalbeConnection.getConnection());
if (!validate) {
if (LOG.isDebugEnabled()) {
LOG.debug("skip not validate connection.");
discardConnection(realConnection);
if (isRemoveAbandoned()) {
StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
activeConnections.put(poolalbeConnection,
new ActiveConnectionTraceInfo(poolalbeConnection, System.currentTimeMillis(),
stackTrace));
poolalbeConnection.setTraceEnable(true);
if (!this.isDefaultAutoCommit()) {
poolalbeConnection.setAutoCommit(false);
return poolalbeConnection;
private void discardConnection(Connection realConnection) throws SQLException {
JdbcUtils.close(realConnection);
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
activeCount--;
} finally {
lock.unlock();
private PoolableConnection getConnectionInternal(long maxWait) throws SQLException {
PoolableConnection poolalbeConnection;
lock.lockInterruptibly();
} catch (InterruptedException e) {
throw new SQLException("interrupt", e);
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
connectCount++;
ConnectionHolder holder;
if (maxWait > 0) {
holder = pollLast(maxWait, TimeUnit.MILLISECONDS);
holder = takeLast();
if (holder == null) {
throw new SQLException("can not get connection");
holder.incrementUseCount();
activeCount++;
if (activeCount > activePeak) {
activePeak = activeCount;
activePeakTime = System.currentTimeMillis();
poolalbeConnection = new PoolableConnection(holder);
} catch (InterruptedException e) {
connectErrorCount++;
throw new SQLException(e.getMessage(), e);
} catch (SQLException e) {
connectErrorCount++;
} finally {
lock.unlock();
return poolalbeConnection;
public void handleConnectionException(PoolableConnection pooledConnection, Throwable t) throws SQLException {
final ConnectionHolder holder = pooledConnection.getConnectionHolder();
errorCount.incrementAndGet();
if (t instanceof SQLException) {
SQLException sqlEx = (SQLException) t;
ConnectionEvent event = new ConnectionEvent(pooledConnection, sqlEx);
for (ConnectionEventListener eventListener : holder.getConnectionEventListeners()) {
eventListener.connectionErrorOccurred(event);
if (exceptionSorter != null && exceptionSorter.isExceptionFatal(sqlEx)) {
if (pooledConnection.isTraceEnable()) {
activeConnections.remove(pooledConnection);
this.discardConnection(holder.getConnection());
pooledConnection.disable();
throw sqlEx;
throw new SQLException("Error", t);
protected void recycle(PoolableConnection pooledConnection) throws SQLException {
final Connection conn = pooledConnection.getConnection();
final ConnectionHolder holder = pooledConnection.getConnectionHolder();
assert holder != null;
if (pooledConnection.isTraceEnable()) {
ActiveConnectionTraceInfo oldInfo = activeConnections.remove(pooledConnection);
if (oldInfo == null) {
LOG.warn("remove abandonded failed. activeConnections.size " + activeConnections.size());
if (conn == null) {
lock.lockInterruptibly();
activeCount--;
closeCount++;
} finally {
lock.unlock();
final boolean isAutoCommit = holder.isUnderlyingAutoCommit();
final boolean isReadOnly = holder.isUnderlyingReadOnly();
if ((!isAutoCommit) && (!isReadOnly)) {
pooledConnection.rollback();
holder.reset();
if (isTestOnReturn()) {
boolean validate = testConnectionInternal(conn);
if (!validate) {
JdbcUtils.close(conn);
lock.lockInterruptibly();
destroyCount++;
activeCount--;
closeCount++;
} finally {
lock.unlock();
lock.lockInterruptibly();
activeCount--;
closeCount++;
putLast(holder);
recycleCount++;
} finally {
lock.unlock();
} catch (Throwable e) {
JdbcUtils.close(conn);
lock.lockInterruptibly();
} catch (InterruptedException interruptEx) {
throw new SQLException("interrupt", interruptEx);
activeCount--;
closeCount++;
} finally {
lock.unlock();
throw new SQLException("recyle error", e);
public void close() {
lock.lock();
if (!this.inited) {
if (createConnectionThread != null) {
createConnectionThread.interrupt();
if (destoryConnectionThread != null) {
destoryConnectionThread.interrupt();
for (int i = 0; i < poolingCount; ++i) {
JdbcUtils.close(connections[i].getConnection());
connections[i] = null;
destroyCount++;
} catch (Exception ex) {
LOG.warn("close connection error", ex);
poolingCount = 0;
DruidDataSourceStatManager.remove(this);
enable = false;
notEmpty.signalAll();
notEmptySignalCount++;
} finally {
lock.unlock();
void incrementCreateCount() {
createConnectionCount++;
void putLast(ConnectionHolder e) throws SQLException {
if (!enable) {
discardConnection(e.getConnection());
e.setLastActiveTimeMillis(System.currentTimeMillis());
connections[poolingCount++] = e;
notEmpty.signal();
notEmptySignalCount++;
ConnectionHolder takeLast() throws InterruptedException, SQLException {
while (poolingCount == 0) {
empty.signal(); 
notEmptyWaitThreadCount++;
notEmpty.await(); 
} finally {
notEmptyWaitThreadCount--;
notEmptyWaitCount++;
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
} catch (InterruptedException ie) {
notEmpty.signal(); 
notEmptySignalCount++;
poolingCount--;
ConnectionHolder last = connections[poolingCount];
connections[poolingCount] = null;
return last;
ConnectionHolder pollLast(long timeout, TimeUnit unit) throws InterruptedException, SQLException {
long estimate = unit.toNanos(timeout);
for (;;) {
if (poolingCount == 0) {
empty.signal(); 
if (estimate <= 0) {
throw new GetConnectionTimeoutException();
notEmptyWaitThreadCount++;
long startEstimate = estimate;
estimate = notEmpty.awaitNanos(estimate); 
notEmptyWaitCount++;
notEmptyWaitNanos += (startEstimate - estimate);
if (!enable) {
connectErrorCount++;
throw new DataSourceDisableException();
} catch (InterruptedException ie) {
notEmpty.signal(); 
notEmptySignalCount++;
} finally {
notEmptyWaitThreadCount--;
if (poolingCount == 0) {
if (estimate > 0) {
throw new GetConnectionTimeoutException();
poolingCount--;
ConnectionHolder last = connections[poolingCount];
connections[poolingCount] = null;
return last;
public Connection getConnection(String username, String password) throws SQLException {
throw new UnsupportedOperationException("Not supported by DruidDataSource");
public long getCreateCount() {
return createConnectionCount;
public long getDestroyCount() {
return destroyCount;
public long getConnectCount() {
return connectCount;
public long getCloseCount() {
return closeCount;
public long getConnectErrorCount() {
return connectErrorCount;
public int getPoolingCount() {
lock.lock();
return poolingCount;
} finally {
lock.unlock();
public int getPoolingPeak() {
return poolingPeak;
public Date getPoolingPeakTime() {
if (poolingPeakTime <= 0) {
return null;
return new Date(poolingPeakTime);
public long getRecycleCount() {
return recycleCount;
public int getActiveCount() {
lock.lock();
return activeCount;
} finally {
lock.unlock();
public long getRemoveAbandonedCount() {
return removeAbandonedCount;
public class CreateConnectionThread extends Thread {
public CreateConnectionThread(String name){
super(name);
public void run() {
initedLatch.countDown();
int errorCount = 0;
for (;;) {
lock.lockInterruptibly();
} catch (InterruptedException e2) {
if (poolingCount >= notEmptyWaitThreadCount) {
empty.await();
if (activeCount + poolingCount >= maxActive) {
empty.await();
} catch (InterruptedException e) {
} catch (RuntimeException e) {
LOG.error("create connection error", e);
} catch (Error e) {
LOG.error("create connection error", e);
} finally {
lock.unlock();
Connection connection = null;
connection = connectionFactory.createConnection();
} catch (SQLException e) {
LOG.error("create connection error", e);
errorCount++;
if (errorCount > connectionErrorRetryAttempts && timeBetweenConnectErrorMillis > 0) {
if (breakAfterAcquireFailure) {
Thread.sleep(timeBetweenConnectErrorMillis);
} catch (InterruptedException interruptEx) {
} catch (RuntimeException e) {
LOG.error("create connection error", e);
} catch (Error e) {
LOG.error("create connection error", e);
if (connection == null) {
lock.lock();
connections[poolingCount++] = new ConnectionHolder(DruidDataSource.this, connection);
if (poolingCount > poolingPeak) {
poolingPeak = poolingCount;
poolingPeakTime = System.currentTimeMillis();
errorCount = 0; 
notEmpty.signal();
notEmptySignalCount++;
} catch (SQLException ex) {
LOG.error("create connection holder error", ex);
} finally {
lock.unlock();
public class DestroyConnectionThread extends Thread {
public DestroyConnectionThread(String name){
super(name);
public void run() {
initedLatch.countDown();
for (;;) {
if (timeBetweenEvictionRunsMillis > 0) {
Thread.sleep(timeBetweenEvictionRunsMillis);
Thread.sleep(1000); 
if (Thread.interrupted()) {
shrink(true);
if (isRemoveAbandoned()) {
removeAbandoned();
} catch (InterruptedException e) {
public int removeAbandoned() {
int removeCount = 0;
Iterator<Map.Entry<PoolableConnection, ActiveConnectionTraceInfo>> iter = activeConnections.entrySet().iterator();
long currentMillis = System.currentTimeMillis();
List<PoolableConnection> abondonedList = new ArrayList<PoolableConnection>();
for (; iter.hasNext();) {
Map.Entry<PoolableConnection, ActiveConnectionTraceInfo> entry = iter.next();
ActiveConnectionTraceInfo activeInfo = entry.getValue();
long timeMillis = currentMillis - activeInfo.getConnectTime();
if (timeMillis >= removeAbandonedTimeoutMillis) {
PoolableConnection pooledConnection = entry.getKey();
JdbcUtils.close(pooledConnection);
removeAbandonedCount++;
removeCount++;
abondonedList.add(pooledConnection);
if (isLogAbandoned()) {
StringBuilder buf = new StringBuilder();
buf.append("abandon connection, open stackTracen");
StackTraceElement[] trace = activeInfo.getStackTrace();
for (int i = 0; i < trace.length; i++) {
buf.append("tat ");
buf.append(trace[i].toString());
buf.append("n");
LOG.error(buf.toString());
for (PoolableConnection conn : abondonedList) {
activeConnections.remove(conn);
return removeCount;
public DataSourceProxyConfig getConfig() {
return null;
protected String instanceKey = null;
public Reference getReference() throws NamingException {
final String className = getClass().getName();
final String factoryName = className + "Factory"; 
Reference ref = new Reference(className, factoryName, null);
ref.add(new StringRefAddr("instanceKey", instanceKey));
return ref;
static class ActiveConnectionTraceInfo {
private final PoolableConnection  connection;
private final long                connectTime;
private final StackTraceElement[] stackTrace;
public ActiveConnectionTraceInfo(PoolableConnection connection, long connectTime, StackTraceElement[] stackTrace){
this.connection = connection;
this.connectTime = connectTime;
this.stackTrace = stackTrace;
public PoolableConnection getConnection() {
return connection;
public long getConnectTime() {
return connectTime;
public StackTraceElement[] getStackTrace() {
return stackTrace;
public List<String> getFilterClassNames() {
List<String> names = new ArrayList<String>();
for (Filter filter : filters) {
names.add(filter.getClass().getName());
return names;
public int getRawDriverMajorVersion() {
int version = -1;
if (this.driver != null) {
version = driver.getMajorVersion();
return version;
public int getRawDriverMinorVersion() {
int version = -1;
if (this.driver != null) {
version = driver.getMinorVersion();
return version;
public String getProperties() {
if (this.connectionProperties == null) {
return null;
Properties properties = new Properties(this.connectionProperties);
if (properties.contains("password")) {
properties.put("password", "******");
return properties.toString();
public void shrink() {
shrink(false);
public void shrink(boolean checkTime) {
final List<ConnectionHolder> evictList = new ArrayList<ConnectionHolder>();
lock.lockInterruptibly();
} catch (InterruptedException e) {
final int checkCount = poolingCount - minIdle;
for (int i = 0; i < checkCount; ++i) {
ConnectionHolder connection = connections[i];
if (checkTime) {
long idleMillis = System.currentTimeMillis() - connection.getLastActiveTimeMillis();
if (idleMillis >= minEvictableIdleTimeMillis) {
evictList.add(connection);
evictList.add(connection);
int removeCount = evictList.size();
if (removeCount > 0) {
System.arraycopy(connections, removeCount, connections, 0, poolingCount - removeCount);
Arrays.fill(connections, poolingCount - removeCount, poolingCount, null);
poolingCount -= removeCount;
} finally {
lock.unlock();
for (ConnectionHolder item : evictList) {
Connection connection = item.getConnection();
JdbcUtils.close(connection);
destroyCount++;
public int getWaitThreadCount() {
lock.lock();
return lock.getWaitQueueLength(notEmpty);
} finally {
lock.unlock();
public long getNotEmptyWaitCount() {
return notEmptyWaitCount;
public int getNotEmptyWaitThreadCount() {
return notEmptyWaitThreadCount;
public long getNotEmptySignalCount() {
return notEmptySignalCount;
public long getNotEmptyWaitMillis() {
return notEmptyWaitNanos / (1000 * 1000);
public long getNotEmptyWaitNanos() {
return notEmptyWaitNanos;
public int getLockQueueLength() {
return lock.getQueueLength();
public int getActivePeak() {
return activePeak;
public Date getActivePeakTime() {
if (activePeakTime <= 0) {
return null;
return new Date(activePeakTime);
public String dump() {
lock.lock();
return this.toString();
} finally {
lock.unlock();
public long getErrorCount() {
return this.errorCount.get();
public String toString() {
StringBuilder buf = new StringBuilder();
buf.append("{");
buf.append("ntCreateTime:"");
buf.append(JdbcUtils.toString(getCreatedTime()));
buf.append(""");
buf.append(",ntActiveCount:");
buf.append(getActiveCount());
buf.append(",ntPoolingCount:");
buf.append(getPoolingCount());
buf.append(",ntCreateCount:");
buf.append(getCreateCount());
buf.append(",ntDestroyCount:");
buf.append(getDestroyCount());
buf.append(",ntCloseCount:");
buf.append(getCloseCount());
buf.append(",ntConnectCount:");
buf.append(getConnectCount());
buf.append(",ntConnections:[");
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder conn = connections[i];
if (conn != null) {
if (i != 0) {
buf.append(",");
buf.append("ntt");
buf.append(conn.toString());
buf.append("nt]");
buf.append("n}");
if (this.isPoolPreparedStatements()) {
buf.append("nn[");
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder conn = connections[i];
if (conn != null) {
if (i != 0) {
buf.append(",");
buf.append("nt{ntID:");
buf.append(System.identityHashCode(conn.getConnection()));
PreparedStatementPool pool = conn.getStatementPool();
if (pool != null) {
buf.append(", ntpoolStatements:[");
int entryIndex = 0;
for (Map.Entry<PreparedStatementKey, PreparedStatementHolder> entry : pool.getMap().entrySet()) {
if (entryIndex++ != 0) {
buf.append(",");
buf.append("ntt{reuseCount:");
buf.append(entry.getValue().getReusedCount());
buf.append(",sql:"");
buf.append(entry.getKey().getSql());
buf.append(""");
buf.append("t}");
buf.append("ntt]");
buf.append("nt}");
buf.append("n]");
return buf.toString();
public void logTransaction(TransactionInfo info) {
long transactionMillis = info.getEndTimeMillis() - info.getStartTimeMillis();
if (transactionThresholdMillis > 0 && transactionMillis > transactionThresholdMillis) {
StringBuilder buf = new StringBuilder();
buf.append("long time transaction, take ");
buf.append(transactionMillis);
buf.append(" ms : ");
for (String sql : info.getSqlList()) {
buf.append(sql);
buf.append(";");
LOG.error(buf.toString(), new TransactionTimeoutException());
public String getVersion() {
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-12-01 12:13";
public void resetState() {
public void restart() {
dataSource.restart();
master.resetState();
slave.resetState();
public void restartMaster() {
this.restartDataSource("master");
public void restartSlave() {
this.restartDataSource("slave");
void restartMaster();
void restartSlave();
public String[] getDataSourceNames() {
return this.dataSources.keySet().toArray(new String[this.dataSources.size()]);
public boolean restartDataSource(String name) {
DataSourceHolder holder = this.getDataSources().get(name);
if (holder != null) {
holder.restart();
return true;
return false;
String[] getDataSourceNames();
boolean restartDataSource(String name);
this.enable = true;
dataSourceHolder.setEnable(false);
dataSourceHolder.setEnable(true);
private final DruidDataSource dataSource;
private boolean               enable            = true;
private final AtomicLong      connectCount      = new AtomicLong();
private final AtomicLong      connectErrorCount = new AtomicLong();
private boolean               fail              = false;
return enable && (!fail);
public boolean isFail() {
return fail;
public void setFail(boolean fail) {
this.fail = fail;
public boolean isMasterFail() {
if (master == null) {
return false;
return master.isFail();
public boolean isSlaveFail() {
if (slave == null) {
return false;
return slave.isFail();
boolean isMasterFail();
boolean isSlaveFail();
dataSourceHolder.setFail(true);
dataSourceHolder.setFail(false);
if (connection != null) {
JdbcConnectionStat.Entry statEntry = getConnectionInfo(connection);
dataSourceStat.getConnections().put(connection.getId(), statEntry);
statEntry.setConnectTime(new Date(startTime));
statEntry.setConnectTimespanNano(nanoSpan);
statEntry.setEstablishNano(System.nanoTime());
statEntry.setEstablishTime(nowTime);
statEntry.setConnectStackTrace(new Exception());
connectStat.setActiveCount(dataSourceStat.getConnections().size());
dataSourceStat.getConnectionStat().setActiveCount(dataSourceStat.getConnections().size());
private int                   weight            = 1;
public int getWeight() {
return weight;
public void setWeight(int weight) {
this.weight = weight;
private Properties                              properties                       = new Properties();
private final AtomicLong                        connectionIdSeed                 = new AtomicLong();
private final AtomicLong                        statementIdSeed                  = new AtomicLong();
private final AtomicLong                        resultSetIdSeed                  = new AtomicLong();
private final AtomicLong                        transactionIdSeed                = new AtomicLong();
protected DataSourceFailureDetecter             validDataSourceChecker           = new DefaultDataSourceFailureDetecter();
private long                                    validDataSourceCheckPeriodMillis = 3000;
private int                                     schedulerThreadCount             = 3;
private ScheduledExecutorService                scheduler;
private boolean                                 inited                           = false;
protected final Lock                            lock                             = new ReentrantLock();
private ObjectName                              objectName;
private List<Filter>                            filters                          = new ArrayList<Filter>();
private boolean                                 enable;
private String                                  name;
private long                                    totalWeight                      = 0;
private ConfigLoader                            configLoader;
public ConfigLoader getConfigLoader() {
return configLoader;
public void setConfigLoader(ConfigLoader configLoader) {
this.configLoader = configLoader;
public boolean isIntited() {
return this.inited;
public void init() throws SQLException {
initInternal();
protected void initInternal() throws SQLException {
public DataSourceHolder getDataSourceHolder(String name) {
return dataSources.get(name);
public void addDataSource(String name, DataSourceHolder dataSourceHolder) {
dataSources.put(name, dataSourceHolder);
this.totalWeight += dataSourceHolder.getWeight();
public void computeTotalWeight() {
int totalWeight = 0;
for (DataSourceHolder holder : this.dataSources.values()) {
totalWeight += holder.getWeight();
this.totalWeight = totalWeight;
public abstract MultiConnectionHolder getConnectionInternal(MultiDataSourceConnection conn, String sql)
throws SQLException;
public class CobarConfigLoader extends URLConnectionConfigLoader implements ConfigLoader {
private final CobarDataSource dataSource;
public CobarConfigLoader(CobarDataSource cobarDataSource) throws SQLException{
super(createURL(cobarDataSource.getUrl()));
this.dataSource = cobarDataSource;
public CobarDataSource getDataSource() {
return dataSource;
public static URL createURL(String jdbcUrl) throws SQLException {
if (!CobarDataSource.isCobar(jdbcUrl)) {
throw new SQLException("illegal cobar url");
String rest = jdbcUrl.substring("jdbc:cobar:
String[] items = rest.split("/");
String loginServerIp = items[0];
String schemaName = items[1];
int port = 80;
int pos = loginServerIp.indexOf(':');
if (pos != -1) {
loginServerIp = loginServerIp.substring(0, pos);
port = Integer.parseInt(loginServerIp.substring(pos + 1));
String url = "http:
if (port != 80) {
url += ":" + port;
url += "cobarStatusQuery?sid=" + schemaName;
return new URL(url);
} catch (MalformedURLException e) {
throw new SQLException(e.getMessage(), e);
protected void handleResponseMessage(String response) throws SQLException {
JSONObject json = JSON.parseObject(response);
String errorMessage = json.getString("error");
if (errorMessage != null) {
throw new SQLException("load config error, message : " + errorMessage);
JSONArray array = json.getJSONArray("cobarList");
Set<String> keys = new HashSet<String>();
for (int i = 0; i < array.size(); ++i) {
JSONObject item = array.getJSONObject(i);
String ip = item.getString("ip");
int port = item.getIntValue("port");
String schema = item.getString("schema");
int weight = item.getIntValue("weight");
String key = ip + ":" + port + "/" + schema;
keys.add(key);
DataSourceHolder holder = dataSource.getDataSourceHolder(key);
if (holder == null) {
String jdbcUrl = "jdbc:mysql:
holder = dataSource.createDataSourceHolder(jdbcUrl, weight);
dataSource.addDataSource(key, holder);
if (holder.getWeight() != weight) {
holder.setWeight(weight);
dataSource.computeTotalWeight();
int removeCount = 0;
Iterator<Map.Entry<String, DataSourceHolder>> iter = dataSource.getDataSources().entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, DataSourceHolder> entry = iter.next();
if (!keys.contains(entry.getKey())) {
iter.remove();
dataSource.handleDataSourceDiscard(entry.getValue());
removeCount++;
if (removeCount != 0) {
dataSource.computeTotalWeight();
public class CobarDataSource extends MultiDataSource {
private final static Log LOG          = LogFactory.getLog(CobarDataSource.class);
private String           url;
private String           username;
private String           password;
private List<Filter>     proxyFilters = new ArrayList<Filter>();
private String           filters;
public CobarDataSource(){
public String getUrl() {
return url;
public void setUrl(String url) {
this.url = url;
public String getUsername() {
return username;
public void setUsername(String username) {
this.username = username;
public String getPassword() {
return password;
public void setPassword(String password) {
this.password = password;
public List<Filter> getProxyFilters() {
return proxyFilters;
public void setProxyFilters(List<Filter> proxyFilters) {
this.proxyFilters = proxyFilters;
public String getFilters() {
return filters;
public void setFilters(String filters) {
this.filters = filters;
protected void initInternal() throws SQLException {
if (url == null || url.isEmpty()) {
throw new SQLException("");
if (isCobar(url)) {
this.setConfigLoader(new CobarConfigLoader(this));
DataSourceHolder holder = createDataSourceHolder(this.url, 1);
this.addDataSource("master", holder);
protected DataSourceHolder createDataSourceHolder(String url, int weight) throws SQLException {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl(url);
dataSource.setUsername(username);
dataSource.setPassword(password);
if (filters != null && !filters.isEmpty()) {
dataSource.setFilters(filters);
dataSource.setProxyFilters(proxyFilters);
DataSourceHolder holder = new DataSourceHolder(dataSource);
holder.setWeight(weight);
return holder;
protected void handleDataSourceDiscard(DataSourceHolder holder) {
LOG.debug("dataSource close");
JdbcUtils.close(holder);
public static boolean isCobar(String url) {
return url.startsWith("jdbc:cobar:
public MultiConnectionHolder getConnectionInternal(MultiDataSourceConnection conn, String sql) throws SQLException {
return null;
void load() throws SQLException;
public abstract class URLConnectionConfigLoader implements ConfigLoader {
public void load() throws SQLException {
handleResponseMessage(responseMessage);
throw new SQLException("load config error, url : " + url.toString());
protected abstract void handleResponseMessage(String response) throws SQLException;
private transient int         weightRegionBegin;
private transient int         weightReginEnd;
public int getWeightRegionBegin() {
return weightRegionBegin;
public void setWeightRegionBegin(int weightRegionBegin) {
this.weightRegionBegin = weightRegionBegin;
public int getWeightReginEnd() {
return weightReginEnd;
public void setWeightReginEnd(int weightReginEnd) {
this.weightReginEnd = weightReginEnd;
public MultiConnectionHolder getConnection() throws SQLException {
Connection conn = dataSource.getConnection();
return new MultiConnectionHolder(this, conn);
if (dataSource == null && slave.isEnable()) {
if (dataSource == null) {
return dataSource.getConnection();
private int                                    totalWeight                      = 0;
private Random                                  random;
public int getTotalWeight() {
return totalWeight;
random = new Random();
holder.setWeightRegionBegin(totalWeight);
holder.setWeightReginEnd(totalWeight);
public MultiConnectionHolder getConnectionInternal(MultiDataSourceConnection multiConn, String sql)
throws SQLException {
int randomNumber = random.nextInt(totalWeight);
DataSourceHolder dataSource = null;
DataSourceHolder first = null;
for (DataSourceHolder item : this.dataSources.values()) {
if (first == null) {
first = item;
if (randomNumber >= item.getWeightRegionBegin() && randomNumber < item.getWeightReginEnd()) {
dataSource = item;
if (dataSource == null) {
dataSource = first;
return dataSource.getConnection();
MultiConnectionHolder getConnection(MultiDataSourceConnection connectionProxy, String sql) throws SQLException;
public MultiConnectionHolder getConnection(MultiDataSourceConnection connectionProxy, String sql) throws SQLException {
MultiConnectionHolder conn = null;
public static boolean isCobar(String url) {
return url.startsWith("jdbc:cobar:
if (!isCobar(jdbcUrl)) {
if (CobarConfigLoader.isCobar(url)) {
private final static Log                        LOG                       = LogFactory.getLog(MultiDataSource.class);
private Properties                              properties                = new Properties();
private final AtomicLong                        connectionIdSeed          = new AtomicLong();
private final AtomicLong                        statementIdSeed           = new AtomicLong();
private final AtomicLong                        resultSetIdSeed           = new AtomicLong();
private final AtomicLong                        transactionIdSeed         = new AtomicLong();
private final AtomicLong                        configLoadCount           = new AtomicLong();
private final AtomicLong                        failureDetectCount        = new AtomicLong();
protected DataSourceFailureDetecter             validDataSourceChecker    = new DefaultDataSourceFailureDetecter();
private long                                    failureDetectPeriodMillis = 3000;
private long                                    configLoadPeriodMillis    = 1000 * 60;
private int                                     schedulerThreadCount      = 3;
private ScheduledFuture<?>                      failureDetectFuture;
private ScheduledFuture<?>                      configLoadFuture;
private boolean                                 inited                    = false;
protected final Lock                            lock                      = new ReentrantLock();
private ConcurrentMap<String, DataSourceHolder> dataSources               = new ConcurrentHashMap<String, DataSourceHolder>();
private List<Filter>                            filters                   = new ArrayList<Filter>();
private int                                     totalWeight               = 0;
startFailureDetectScheduleTask();
public boolean startConfigLoadScheduleTask() {
if (configLoadFuture != null) {
configLoadFuture = scheduler.scheduleAtFixedRate(new ConfigLoadTask(), configLoadPeriodMillis,
configLoadPeriodMillis, TimeUnit.MILLISECONDS);
return true;
return false;
public boolean stopConfigLoadScheduleTask() {
if (configLoadFuture != null) {
configLoadFuture.cancel(true);
configLoadFuture = null;
return true;
return false;
public boolean startFailureDetectScheduleTask() {
if (failureDetectFuture != null) {
failureDetectFuture = scheduler.scheduleAtFixedRate(new FailureDetectTask(), failureDetectPeriodMillis,
failureDetectPeriodMillis, TimeUnit.MILLISECONDS);
return true;
return false;
public boolean stopFailureDetectScheduleTask() {
if (failureDetectFuture != null) {
failureDetectFuture.cancel(true);
failureDetectFuture = null;
return true;
return false;
return failureDetectPeriodMillis;
this.failureDetectPeriodMillis = validDataSourceCheckPeriodMillis;
throws SQLException {
public long getConfigLoadCount() {
return configLoadCount.get();
public long getFailureDetectCount() {
return failureDetectCount.get();
class ConfigLoadTask implements Runnable {
public void run() {
if (configLoader != null) {
configLoadCount.incrementAndGet();
configLoader.load();
} catch (SQLException e) {
LOG.error("config load error", e);
failureDetectCount.incrementAndGet();
boolean startFailureDetectScheduleTask();
boolean stopFailureDetectScheduleTask();
boolean startConfigLoadScheduleTask();
boolean stopConfigLoadScheduleTask();
long getConfigLoadCount();
long getFailureDetectCount();
this.addDataSource("master", master);
this.addDataSource("slave", slave);
this.computeTotalWeight();
public boolean isBusy() {
lock.lock();
return this.inited && this.activeCount == maxActive && this.poolingCount == 0;
} finally {
lock.unlock();
private transient int         weightRegionEnd;
public int getWeightRegionEnd() {
return weightRegionEnd;
public void setWeightRegionEnd(int weightReginEnd) {
this.weightRegionEnd = weightReginEnd;
public int getMasterWeight() {
return master.getWeight();
public int getSlaveWeight() {
return slave.getWeight();
public int getMasterWeightRegionBegin() {
return master.getWeightRegionBegin();
public int getMasterWeightRegionEnd() {
return master.getWeightRegionEnd();
public int getSlaveWeightRegionBegin() {
return slave.getWeightRegionBegin();
public int getSlaveWeightRegionEnd() {
return slave.getWeightRegionEnd();
int getMasterWeight();
int getSlaveWeight();
int getMasterWeightRegionBegin();
int getMasterWeightRegionEnd();
int getSlaveWeightRegionBegin();
int getSlaveWeightRegionEnd();
private final AtomicLong                        busySkipCount             = new AtomicLong();
private final AtomicLong                        retryGetConnectionCount   = new AtomicLong();
int changeCount = 0;
boolean isFail = !validDataSourceChecker.isValid(dataSourceHolder.getDataSource());
if (isFail != dataSourceHolder.isFail()) {
dataSourceHolder.setFail(isFail);
changeCount++;
if (changeCount != 0) {
computeTotalWeight();
if (!holder.isEnable()) {
holder.setWeightRegionBegin(-1);
holder.setWeightRegionEnd(-1);
holder.setWeightRegionEnd(totalWeight);
final int MAX_RETRY = 10;
for (int i = 0; i < MAX_RETRY; ++i) {
int randomNumber = random.nextInt(totalWeight);
DataSourceHolder first = null;
boolean needRetry = false;
for (DataSourceHolder item : this.dataSources.values()) {
if (first == null) {
first = item;
if (randomNumber >= item.getWeightRegionBegin() && randomNumber < item.getWeightRegionEnd()) {
if (!item.isEnable()) {
needRetry = true;
if (item.getDataSource().isBusy()) {
busySkipCount.incrementAndGet();
needRetry = true;
dataSource = item;
if (needRetry) {
retryGetConnectionCount.incrementAndGet();
if (dataSource == null) {
dataSource = first;
public long getRetryGetConnectionCount() {
return retryGetConnectionCount.get();
public long getBusySkipCount() {
return busySkipCount.get();
long getRetryGetConnectionCount();
long getBusySkipCount();
this.getConfigLoader().load();
this.computeTotalWeight();
this.computeTotalWeight();
if (failureDetectFuture == null) {
failureDetectCount.incrementAndGet();
public long getFailureDetectPeriodMillis() {
return failureDetectPeriodMillis;
public long getConfigLoadPeriodMillis() {
return configLoadPeriodMillis;
} catch (Exception e) {
failureDetect();
} catch (Exception ex) {
LOG.error("failure detect error", ex);
int getTotalWeight();
long getFailureDetectPeriodMillis();
long getConfigLoadPeriodMillis();
protected DataSourceFailureDetecter             failureDetector    = new DefaultDataSourceFailureDetecter();
boolean isFail = !failureDetector.isValid(dataSourceHolder.getDataSource());
return failureDetector;
this.failureDetector = validDataSourceChecker;
String ip = items[0];
String sid = items[1];
int pos = ip.indexOf(':');
ip = ip.substring(0, pos);
port = Integer.parseInt(ip.substring(pos + 1));
String url = "http:
final int RETRY_COUNT = 3;
for (int i = 0; i < RETRY_COUNT; ++i) {
this.getConfigLoader().load();
} catch (Exception ex) {
LOG.error("load config error", ex);
Thread.sleep(1000);
} catch (InterruptedException e) {
public class CobarFailureDetecter extends DefaultDataSourceFailureDetecter {
private final static Log LOG                 = LogFactory.getLog(CobarFailureDetecter.class);
private int              queryTimeoutSeconds = 30;
public CobarFailureDetecter(){
this.setValidateSql("SHOW COBAR_STATUS");
public int getQueryTimeoutSeconds() {
return queryTimeoutSeconds;
public void setQueryTimeoutSeconds(int queryTimeoutSeconds) {
this.queryTimeoutSeconds = queryTimeoutSeconds;
public boolean isValidConnection(DruidDataSource dataSource, Connection conn) {
Statement stmt = null;
ResultSet rs = null;
stmt = conn.createStatement();
stmt.setQueryTimeout(queryTimeoutSeconds);
rs = stmt.executeQuery(getValidateSql());
if (!rs.next()) {
return false;
String status = rs.getString(1);
if ("on".equalsIgnoreCase(status)) {
return true;
return false;
} catch (Exception ex) {
LOG.error("check datasource valid errror", ex);
return false;
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
stmt.execute(getValidateSql());
protected DataSourceFailureDetecter             failureDetector           = new DefaultDataSourceFailureDetecter();
public DataSourceFailureDetecter getFailureDetector() {
public void setFailureDetector(DataSourceFailureDetecter failureDetector) {
this.failureDetector = failureDetector;
this.setFailureDetector(new CobarFailureDetecter());
public void setFailureDetectPeriodMillis(long failureDetectPeriodMillis) {
this.failureDetectPeriodMillis = failureDetectPeriodMillis;
public void setConfigLoadPeriodMillis(long configLoadPeriodMillis) {
this.configLoadPeriodMillis = configLoadPeriodMillis;
private final static Log LOG                                   = LogFactory.getLog(CobarDataSource.class);
public static long       DEFAULT_FAILURE_DETECT_PERRIOD_MILLIS = 1000 * 3;                                
public static long       DEFAULT_CONFIG_LOAD_PERRIOD_MILLIS    = 1000 * 60 * 3;                           
private List<Filter>     proxyFilters                          = new ArrayList<Filter>();
private int              maxPoolSize;
this.setFailureDetectPeriodMillis(DEFAULT_FAILURE_DETECT_PERRIOD_MILLIS);
this.setConfigLoadPeriodMillis(DEFAULT_CONFIG_LOAD_PERRIOD_MILLIS);
public int getMaxPoolSize() {
return maxPoolSize;
public void setMaxPoolSize(int maxPoolSize) throws SQLException {
if (this.isIntited()) {
throw new SQLException("dataSource inited");
this.maxPoolSize = maxPoolSize;
protected final Condition                       notFull                   = lock.newCondition();
private int                                     maxPoolSize;
private long                                    activeCount               = 0;
public int getMaxPoolSize() {
return maxPoolSize;
public void setMaxPoolSize(int maxPoolSize) throws SQLException {
if (this.isIntited()) {
throw new SQLException("dataSource inited");
this.maxPoolSize = maxPoolSize;
public long getActiveCount() {
return activeCount;
lock.lock();
if (activeCount >= maxPoolSize) {
notFull.await();
MultiDataSourceConnection conn = new MultiDataSourceConnection(this, createConnectionId());
activeCount++;
return conn;
} catch (InterruptedException e) {
throw new SQLException("thread interrupted", e);
} finally {
lock.unlock();
protected void afterConnectionClosed(MultiDataSourceConnection conn) {
lock.lock();
activeCount--;
notFull.signal();
} finally {
lock.unlock();
private boolean               closed           = false;
this.closed = true;
return closed;
private long             minEvictableIdleTimeMillis            = 1000 * 60 * 3;                           
public long getMinEvictableIdleTimeMillis() {
return minEvictableIdleTimeMillis;
public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
dataSource.setMaxActive(getMaxPoolSize());
dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); 
private boolean          testWhileIdle                         = true;
public boolean isTestWhileIdle() {
return testWhileIdle;
public void setTestWhileIdle(boolean testWhileIdle) {
this.testWhileIdle = testWhileIdle;
dataSource.setTestWhileIdle(testWhileIdle);
public class MultiDataSource extends DataSourceAdapter implements MultiDataSourceMBean, DataSourceProxy {
private int                                     maxPoolSize               = 50;
public int produceRandomNumber() {
return random.nextInt(totalWeight);
int randomNumber = produceRandomNumber();
haDataSource.afterConnectionClosed(this);
long getActiveCount();
int getMaxPoolSize();
int produceRandomNumber();
public class MultiDataSourceTest extends TestCase {
public void test_0 () throws Exception {
MultiDataSource multiDataSource = new MultiDataSource();
public class MultiDataSource extends DataSourceAdapter implements MultiDataSourceMBean, DataSourceProxy {
private int                                     maxPoolSize               = 50;
public int produceRandomNumber() {
return random.nextInt(totalWeight);
int randomNumber = produceRandomNumber();
if (closed) {
haDataSource.afterConnectionClosed(this);
long getActiveCount();
int getMaxPoolSize();
int produceRandomNumber();
public class MultiDataSourceTest extends TestCase {
public void test_0 () throws Exception {
MultiDataSource multiDataSource = new MultiDataSource();
if (stmt instanceof CobarShowStatus) {
return showStatus(statement);
public ResultSet showStatus(MockStatement statement) throws SQLException {
MockResultSet rs = new MockResultSet(statement);
MockResultSetMetaData metaData = rs.getMockMetaData();
Object[] row = new Object[] { "on" };
ColumnMetaData column = new ColumnMetaData();
column.setColumnType(Types.NVARCHAR);
metaData.getColumns().add(column);
rs.getRows().add(row);
return rs;
protected Exception                                                                      createError                               = null;
public Exception getCreateError() {
return createError;
dataSource.createError = null;
dataSource.createError = ex;
dataSource.createError = ex;
if (createError != null) {
throw new GetConnectionTimeoutException(createError);
throw new GetConnectionTimeoutException();
protected final Condition                       notFail                   = lock.newCondition();
private long                                    maxWaitMillis             = 0;
public long getMaxWaitMillis() {
return maxWaitMillis;
public void setMaxWaitMillis(long maxWaitMillis) {
this.maxWaitMillis = maxWaitMillis;
public void setMaxWait(long seconds) {
this.setMaxWaitMillis(1000 * seconds);
public long getMaxWait() {
return this.getMaxWaitMillis() / 1000;
startConfigLoadScheduleTask();
if (configLoadFuture == null) {
lock.lock();
notFail.signalAll();
} finally {
lock.unlock();
if (totalWeight == 0) {
public MultiConnectionHolder getRealConnection(MultiDataSourceConnection multiConn, String sql) throws SQLException {
long startNano = -1;
if (maxWaitMillis > 0) {
startNano = System.nanoTime();
if (dataSource == null && i != MAX_RETRY - 1) {
lock.lock();
if (getEnabledDataSourceCount() == 0) {
if (maxWaitMillis > 0) {
long nano = System.nanoTime() - startNano;
long restNano = maxWaitMillis * 1000 * 1000 - nano;
if (restNano > 0) {
notFail.awaitNanos(restNano);
notFail.await();
} catch (InterruptedException e) {
throw new SQLException("interrupted", e);
} finally {
lock.unlock();
if (dataSource == null) {
throw new SQLException("cannot get connection. enabledDataSourceCount " + getEnabledDataSourceCount());
public int getEnabledDataSourceCount() {
int count = 0;
for (DataSourceHolder item : this.dataSources.values()) {
if (item.isEnable()) {
return count;
MultiConnectionHolder connHolder = haDataSource.getRealConnection(this, sql);
ip = ip.substring(0, pos);
protected void handleResponseMessage() throws SQLException {
String responseMessage = this.getResponseMessage();
JSONObject json = JSON.parseObject(responseMessage);
String jdbcUrl = createJdbcUrl(ip, port, schema);
protected String createJdbcUrl(String ip, int port, String schema) {
return "jdbc:mysql:
if (this.getConfigLoader() == null) {
this.setConfigLoader(new CobarConfigLoader(this));
private URL    url;
private int    connectTimeout = 1000 * 3;
private int    readTimeout;
protected String responseMessage;
public String getResponseMessage() {
return responseMessage;
handleResponseMessage();
throw new SQLException("load config error, url : " + url.toString(), e);
protected abstract void handleResponseMessage() throws SQLException;
public class CobarShowStatus extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
protected void accept0(MySqlASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
if (identifierEquals("COBAR_STATUS")) {
lexer.nextToken();
return new CobarShowStatus();
void endVisit(CobarShowStatus x);
boolean visit(CobarShowStatus x);
public void endVisit(CobarShowStatus x) {
public boolean visit(CobarShowStatus x) {
return true;
public void endVisit(CobarShowStatus x) {
public boolean visit(CobarShowStatus x) {
print("SHOW COBAR_STATUS");
return false;
if (date == null) {
return null;
public class DruidTest extends TestCase {
public void test_0() throws Exception {
DruidDataSource ds = new DruidDataSource();
ds.setMaxWait(30);
ds.setInitialSize(0);
ds.setUrl("jdbc:mysql:xxx");
ds.getConnection();
} catch (Exception ex) {
ex.printStackTrace();
public class CobarDataSourceTest extends TestCase {
public void test_cobarDataSource() throws Exception {
String url = "jdbc:cobar:
final JSONObject config = new JSONObject();
JSONArray cobarList = new JSONArray();
JSONObject cobarA = new JSONObject();
cobarA.put("ip", "mock");
cobarA.put("port", 80);
cobarA.put("schema", "cobarA");
cobarA.put("weight", 1);
cobarList.add(cobarA);
JSONObject cobarB = new JSONObject();
cobarB.put("ip", "mock");
cobarB.put("port", 81);
cobarB.put("schema", "cobarB");
cobarB.put("weight", 1);
cobarList.add(cobarB);
String mockUrlA = "jdbc:mock:
String mockUrlB = "jdbc:mock:
config.put("cobarList", cobarList);
final CobarDataSource dataSource = new CobarDataSource();
dataSource.setUrl(url);
dataSource.setUsername("test");
dataSource.setPassword("");
dataSource.setMaxWait(1);
dataSource.setConfigLoadPeriodMillis(3);
CobarConfigLoader configLoader = new CobarConfigLoader(dataSource) {
public void load() throws SQLException {
responseMessage = config.toJSONString();
handleResponseMessage();
protected String createJdbcUrl(String ip, int port, String schema) {
return "jdbc:mock:
dataSource.setConfigLoader(configLoader);
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
rs.next();
rs.close();
stmt.close();
conn.close();
cobarList.remove(cobarB);
Assert.assertEquals(1, cobarList.size());
Thread.sleep(dataSource.getConfigLoadPeriodMillis() * 2);
for (int i = 0; i < 100; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(mockUrlA, mockConn.getUrl());
rs.next();
rs.close();
stmt.close();
conn.close();
cobarList.add(cobarB);
Assert.assertEquals(2, cobarList.size());
cobarList.remove(cobarA);
Assert.assertEquals(1, cobarList.size());
Thread.sleep(dataSource.getConfigLoadPeriodMillis() * 2);
for (int i = 0; i < 100; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(mockUrlB, mockConn.getUrl());
rs.next();
rs.close();
stmt.close();
conn.close();
public class CobarDataSourceTest extends TestCase {
public void test_cobar() throws Exception {
String url = "jdbc:cobar:
final CobarDataSource dataSource = new CobarDataSource();
dataSource.setUrl(url);
dataSource.setUsername("test");
dataSource.setPassword("");
final int COUNT = 10;
final CountDownLatch latch = new CountDownLatch(COUNT);
Runnable task = new Runnable() {
public void run() {
for (int i = 0; i < 1000 * 1000; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("select 1");
stmt.close();
conn.close();
} catch (Exception ex) {
ex.printStackTrace();
} finally {
latch.countDown();
for (int i = 0; i < 10; ++i) {
Thread thread = new Thread(task);
thread.setName("thread-" + i);
thread.start();
latch.await();
private int                     notEmptyWaitThreadPeak  = 0;
if (notEmptyWaitThreadCount > notEmptyWaitThreadPeak) {
notEmptyWaitThreadPeak = notEmptyWaitThreadCount;
if (notEmptyWaitThreadCount > notEmptyWaitThreadPeak) {
notEmptyWaitThreadPeak = notEmptyWaitThreadCount;
public int getNotEmptyWaitThreadPeak() {
lock.lock();
return notEmptyWaitThreadPeak;
} finally {
lock.unlock();
map.put("ActiveCount", dataSource.getActivePeak());
map.put("WaitThreadCount", dataSource.getNotEmptyWaitThreadPeak());
private boolean               writable          = true;
public boolean isWritable() {
return writable;
public void setWritable(boolean writable) {
this.writable = writable;
public boolean isMasterWritable() {
return master != null && master.isWritable();
public boolean isSlaveWritable() {
return slave != null && slave.isWritable();
public DataSourceHolder setMaster(DruidDataSource master) {
DataSourceHolder holder = new DataSourceHolder(master);
this.setMaster(holder);
return holder;
public DataSourceHolder setSlave(DruidDataSource slave) {
DataSourceHolder holder = new DataSourceHolder(slave);
this.setSlave(holder);
return holder;
public class HAConfigLoader extends URLConnectionConfigLoader {
public HAConfigLoader(URL configServerURL){
super(configServerURL);
protected void handleResponseMessage() throws SQLException {
JSONObject json = JSON.parseObject(this.getResponseMessage());
json.get("serverList");
final String mockUrlA = "jdbc:mock:
final String mockUrlB = "jdbc:mock:
final AtomicBoolean statusA = new AtomicBoolean(true);
final AtomicBoolean statusB = new AtomicBoolean(true);
dataSource.setConfigLoadPeriodMillis(10);
dataSource.setFailureDetectPeriodMillis(1);
CobarFailureDetecter failureDetector = new CobarFailureDetecter() {
public boolean isValidConnection(DruidDataSource dataSource, Connection conn) {
MockConnection mockConn;
mockConn = conn.unwrap(MockConnection.class);
} catch (SQLException e) {
e.printStackTrace();
return false;
if (mockConn.getUrl().equals(mockUrlA)) {
return statusA.get();
return statusB.get();
dataSource.setFailureDetector(failureDetector);
cobarList.add(cobarA);
Assert.assertEquals(2, cobarList.size());
Thread.sleep(dataSource.getConfigLoadPeriodMillis() * 2);
for (int i = 0; i < 100; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
rs.next();
rs.close();
stmt.close();
conn.close();
statusA.set(false);
Thread.sleep(dataSource.getFailureDetectPeriodMillis() * 2);
for (int i = 0; i < 100; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(mockUrlB, mockConn.getUrl());
rs.next();
rs.close();
stmt.close();
conn.close();
statusA.set(true);
statusB.set(false);
Thread.sleep(dataSource.getFailureDetectPeriodMillis() * 2);
for (int i = 0; i < 100; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
Assert.assertEquals(mockUrlA, mockConn.getUrl());
rs.next();
rs.close();
stmt.close();
conn.close();
public MultiConnectionHolder getConnection(MultiDataSourceConnection connectionProxy, String sql)
throws SQLException {
DataSourceHolder first = null;
int itemIndex = 0;
for (DataSourceHolder item : multiDataSource.getDataSources().values()) {
if (!item.isEnable()) {
if (first == null) {
first = item;
if (itemIndex == index) {
dataSource = item;
itemIndex++;
if (dataSource == null) {
dataSource = first;
if (dataSource == null) {
throw new SQLException("can not get real connection.");
public class WeightBalancer {
public void incrementRetryGetConnectionCount() {
retryGetConnectionCount.incrementAndGet();
public Lock getLock() {
return lock;
public Condition getNotFail() {
return notFail;
public void incrementBusySkipCount() {
busySkipCount.incrementAndGet();
public class WeightBalancer implements Balancer {
public MultiConnectionHolder getConnection(MultiDataSourceConnection connectionProxy, String sql)
throws SQLException {
MultiDataSource haDataSource = connectionProxy.getHaDataSource();
long maxWaitMillis = haDataSource.getMaxWaitMillis();
long startNano = -1;
if (maxWaitMillis > 0) {
startNano = System.nanoTime();
DataSourceHolder dataSource = null;
final int MAX_RETRY = 10;
for (int i = 0; i < MAX_RETRY; ++i) {
int randomNumber = haDataSource.produceRandomNumber();
DataSourceHolder first = null;
boolean needRetry = false;
for (DataSourceHolder item : haDataSource.getDataSources().values()) {
if (first == null) {
first = item;
if (randomNumber >= item.getWeightRegionBegin() && randomNumber < item.getWeightRegionEnd()) {
if (!item.isEnable()) {
needRetry = true;
if (item.getDataSource().isBusy()) {
haDataSource.incrementBusySkipCount();
needRetry = true;
dataSource = item;
if (needRetry) {
haDataSource.incrementRetryGetConnectionCount();
if (dataSource == null) {
dataSource = first;
if (dataSource == null && i != MAX_RETRY - 1) {
Lock lock = haDataSource.getLock();
Condition notFail = haDataSource.getNotFail();
lock.lock();
if (haDataSource.getEnabledDataSourceCount() == 0) {
if (maxWaitMillis > 0) {
long nano = System.nanoTime() - startNano;
long restNano = maxWaitMillis * 1000 * 1000 - nano;
if (restNano > 0) {
notFail.awaitNanos(restNano);
notFail.await();
} catch (InterruptedException e) {
throw new SQLException("interrupted", e);
} finally {
lock.unlock();
if (dataSource == null) {
throw new SQLException("cannot get connection. enabledDataSourceCount " + haDataSource.getEnabledDataSourceCount());
return dataSource.getConnection();
private Balancer                                balancer                  = new WeightBalancer();
return balancer.getConnection(multiConn, sql);
private final MultiDataSource multiDataSource;
public MultiDataSourceConnection(MultiDataSource multiDataSource, long id){
this.multiDataSource = multiDataSource;
MultiConnectionHolder connHolder = multiDataSource.getRealConnection(this, sql);
public MultiDataSource getMultiDataSource() {
return multiDataSource;
multiDataSource.afterConnectionClosed(this);
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
long stmtId = multiDataSource.createStatementId();
return multiDataSource.getProperties();
return multiDataSource;
MultiDataSource multiDataSource = connectionProxy.getMultiDataSource();
MultiDataSource multiDataSource = connectionProxy.getMultiDataSource();
long maxWaitMillis = multiDataSource.getMaxWaitMillis();
int randomNumber = multiDataSource.produceRandomNumber();
for (DataSourceHolder item : multiDataSource.getDataSources().values()) {
multiDataSource.incrementBusySkipCount();
multiDataSource.incrementRetryGetConnectionCount();
Lock lock = multiDataSource.getLock();
Condition notFail = multiDataSource.getNotFail();
if (multiDataSource.getEnabledDataSourceCount() == 0) {
throw new SQLException("cannot get connection. enabledDataSourceCount " + multiDataSource.getEnabledDataSourceCount());
return ThreadLocalRandom.current().nextInt(totalWeight);
throw new SQLException("cannot get connection. enabledDataSourceCount "
+ multiDataSource.getEnabledDataSourceCount());
public class ThreadLocalRandom extends Random {
private static final long multiplier = 0x5DEECE66DL;
private static final long addend = 0xBL;
private static final long mask = (1L << 48) - 1;
private long rnd;
boolean initialized;
private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
private static final ThreadLocal<ThreadLocalRandom> localRandom =
new ThreadLocal<ThreadLocalRandom>() {
protected ThreadLocalRandom initialValue() {
return new ThreadLocalRandom();
ThreadLocalRandom() {
initialized = true;
public static ThreadLocalRandom current() {
return localRandom.get();
public void setSeed(long seed) {
if (initialized)
throw new UnsupportedOperationException();
rnd = (seed ^ multiplier) & mask;
protected int next(int bits) {
rnd = (rnd * multiplier + addend) & mask;
return (int) (rnd >>> (48-bits));
public int nextInt(int least, int bound) {
if (least >= bound)
throw new IllegalArgumentException();
return nextInt(bound - least) + least;
public long nextLong(long n) {
if (n <= 0)
throw new IllegalArgumentException("n must be positive");
long offset = 0;
while (n >= Integer.MAX_VALUE) {
int bits = next(2);
long half = n >>> 1;
long nextn = ((bits & 2) == 0) ? half : n - half;
if ((bits & 1) == 0)
offset += n - nextn;
n = nextn;
return offset + nextInt((int) n);
public long nextLong(long least, long bound) {
if (least >= bound)
throw new IllegalArgumentException();
return nextLong(bound - least) + least;
public double nextDouble(double n) {
if (n <= 0)
throw new IllegalArgumentException("n must be positive");
return nextDouble() * n;
public double nextDouble(double least, double bound) {
if (least >= bound)
throw new IllegalArgumentException();
return nextDouble() * (bound - least) + least;
private static final long serialVersionUID = -5851777807851030925L;
public class DataSourceChangedEvent {
private final DruidDataSource dataSource;
public DataSourceChangedEvent(DruidDataSource dataSource){
this.dataSource = dataSource;
public DruidDataSource getDataSource() {
return dataSource;
private final MultiDataSource multiDataSource;
public DataSourceHolder(MultiDataSource multiDataSource, DruidDataSource dataSource){
this.multiDataSource = multiDataSource;
if (this.enable != enable) {
this.enable = enable;
multiDataSource.afterDataSourceChanged(null);
if (this.fail != fail) {
this.fail = fail;
multiDataSource.afterDataSourceChanged(null);
DataSourceHolder holder = new DataSourceHolder(this, master);
DataSourceHolder holder = new DataSourceHolder(this, slave);
this.balancer.init(this);
afterDataSourceChanged(null);
afterDataSourceChanged(null);
public void notFailSignal() {
public void afterDataSourceChanged(Object event) {
this.balancer.afterDataSourceChanged(null);
void init(MultiDataSource dataSource);
void afterDataSourceChanged(Object event);
private MultiDataSource     multiDataSource;
public void afterDataSourceChanged(Object event) {
public void init(MultiDataSource multiDataSource) {
this.multiDataSource = multiDataSource;
public MultiDataSource getMultiDataSource() {
return multiDataSource;
private MultiDataSource multiDataSource;
private int             totalWeight = 0;
public void init(MultiDataSource multiDataSource) {
this.multiDataSource = multiDataSource;
public void afterDataSourceChanged(Object event) {
computeTotalWeight();
public int produceRandomNumber() {
if (totalWeight == 0) {
return ThreadLocalRandom.current().nextInt(totalWeight);
public void computeTotalWeight() {
int totalWeight = 0;
for (DataSourceHolder holder : multiDataSource.getDataSources().values()) {
if (!holder.isEnable()) {
holder.setWeightRegionBegin(-1);
holder.setWeightRegionEnd(-1);
holder.setWeightRegionBegin(totalWeight);
totalWeight += holder.getWeight();
holder.setWeightRegionEnd(totalWeight);
this.totalWeight = totalWeight;
multiDataSource.notFailSignal();
int randomNumber = produceRandomNumber();
dataSource.afterDataSourceChanged(null);
dataSource.afterDataSourceChanged(null);
DataSourceHolder holder = new DataSourceHolder(this, dataSource);
public abstract class AbstractBalancer implements Balancer {
private MultiDataSource multiDataSource;
public void init(MultiDataSource multiDataSource) {
this.multiDataSource = multiDataSource;
public MultiDataSource getMultiDataSource() {
return multiDataSource;
void afterDataSourceChanged(DataSourceChangedEvent event);
public class LeastConnectionBalancer extends AbstractBalancer {
public void afterDataSourceChanged(DataSourceChangedEvent event) {
public MultiConnectionHolder getConnection(MultiDataSourceConnection connectionProxy, String sql)
throws SQLException {
return null;
public void afterDataSourceChanged(DataSourceChangedEvent event) {
public void afterDataSourceChanged(DataSourceChangedEvent event) {
private Throwable               lastError;
private Throwable               lastCreateError;
public Throwable getLastCreateError() {
return lastCreateError;
public Throwable getLastError() {
return this.lastError;
lastError = t;
lastCreateError = e;
lastCreateError = e;
lastCreateError = e;
public void close() {
if (!this.balancer.isInited()) {
this.balancer.init(this);
private boolean         inited = false;
public synchronized void init(MultiDataSource multiDataSource) {
if (this.inited) {
if (multiDataSource == null) {
throw new IllegalStateException();
inited = true;
public boolean isInited() {
return inited;
boolean isInited();
public class RoundRobinBlancer extends AbstractBalancer {
public void afterDataSourceChanged(DataSourceChangedEvent event) {
public class WeightBalancer extends AbstractBalancer {
for (DataSourceHolder holder : getMultiDataSource().getDataSources().values()) {
getMultiDataSource().notFailSignal();
map.put("LastError", JMXUtils.getErrorCompositeData(dataSource.getLastError()));
map.put("LastCreateError", JMXUtils.getErrorCompositeData(dataSource.getCreateError()));
, SimpleType.LONG, SimpleType.LONG, JMXUtils.getThrowableCompositeType(), JMXUtils.getThrowableCompositeType()
"CommitCount", "RollbackCount", "LastError", "LastCreateError"
@SuppressWarnings("unused")
dataSource.close();
private DruidDataSource dataSourceA;
private DruidDataSource dataSourceB;
private HADataSource    dataSourceHA;
private String          MASTER_URL = "jdbc:mock:master";
private String          SLAVE_URL  = "jdbc:mock:slave";
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
dataSourceA = new DruidDataSource();
dataSourceA.setUrl(MASTER_URL);
dataSourceA.setFilters("trace");
dataSourceB = new DruidDataSource();
dataSourceB.setUrl(SLAVE_URL);
dataSourceB.setFilters("stat");
dataSourceHA = new HADataSource();
dataSourceHA.setMaster(dataSourceA);
dataSourceHA.setSlave(dataSourceB);
protected void tearDown() throws Exception {
dataSourceHA.close();
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_switch() throws Exception {
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
conn.close();
dataSourceHA.setMasterEnable(false);
Connection conn = dataSourceHA.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("select 1");
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
conn.close();
private final AtomicLong                                                                 executeCount                              = new AtomicLong();
public long getExecuteCount() {
return executeCount.get();
public void incrementExecuteCount() {
this.executeCount.incrementAndGet();
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion + "-2011-12-27 14:45";
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
checkOpen();
incrementExecuteCount();
return super.executeBatch();
} catch (Throwable t) {
throw checkException(t);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int autoGeneratedKeys)
throws SQLException{
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int[] columnIndexes)
throws SQLException{
public PreparedStatementKey(String sql, String catalog, MethodType methodType, String[] columnNames)
throws SQLException{
public void incrementExecuteCount() {
this.getPoolableConnection().getConnectionHolder().getDataSource().incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
incrementExecuteCount();
public MultiConnectionHolder getConnection(MultiDataSourceConnection conn, String sql) throws SQLException {
MultiDataSource multiDataSource = conn.getMultiDataSource();
DataSourceHolder dataSource = null;
int leastCount = -1;
for (DataSourceHolder item : multiDataSource.getDataSources().values()) {
if (!item.isEnable()) {
int activeCount = item.getDataSource().getActiveCount();
if (dataSource == null) {
leastCount = activeCount;
dataSource = item;
if (leastCount > item.getDataSource().getActiveCount()) {
dataSource = item;
leastCount = activeCount;
if (dataSource == null) {
throw new SQLException("can not get real connection, enableDataSourceCount "
+ multiDataSource.getEnabledDataSourceCount());
return dataSource.getConnection();
public MultiConnectionHolder getConnection(MultiDataSourceConnection conn, String sql) throws SQLException {
MultiDataSource multiDataSource = conn.getMultiDataSource();
int size = multiDataSource.getDataSources().size();
long connectionId = (int) conn.getId();
if (size == 0) {
throw new SQLException("can not get connection, no availabe datasources");
int index = (int) (connectionId % size);
DataSourceHolder first = null;
DataSourceHolder dataSource = null;
int itemIndex = 0;
for (DataSourceHolder item : multiDataSource.getDataSources().values()) {
if (!item.isEnable()) {
if (first == null) {
first = item;
if (itemIndex == index) {
dataSource = item;
itemIndex++;
dataSource = first;
} catch (Exception ex) {
indexErrorCount.incrementAndGet();
if (LOG.isDebugEnabled()) {
LOG.debug("getDataSource error, index : " + index, ex);
if (dataSource == null) {
throw new SQLException("can not get real connection.");
MultiConnectionHolder holder = null;
return holder;
private int totalWeight = 0;
public MultiConnectionHolder getConnection(MultiDataSourceConnection conn, String sql) throws SQLException {
MultiDataSource multiDataSource = conn.getMultiDataSource();
int randomNumber = produceRandomNumber();
DataSourceHolder first = null;
for (DataSourceHolder item : multiDataSource.getDataSources().values()) {
if (!item.isEnable()) {
if (first == null) {
first = item;
if (randomNumber >= item.getWeightRegionBegin() && randomNumber < item.getWeightRegionEnd()) {
if (!item.isEnable()) {
if (item.getDataSource().isBusy()) {
multiDataSource.incrementBusySkipCount();
dataSource = item;
if (dataSource == null) {
dataSource = first;
public class DruidJdbcExtractor implements NativeJdbcExtractor {
public boolean isNativeConnectionNecessaryForNativeStatements() {
return true;
public boolean isNativeConnectionNecessaryForNativePreparedStatements() {
return true;
public boolean isNativeConnectionNecessaryForNativeCallableStatements() {
return true;
public Connection getNativeConnection(Connection conn) throws SQLException {
if (conn instanceof PoolableConnection) {
conn = ((PoolableConnection) conn).getConnection();
if (conn instanceof ConnectionProxy) {
conn = ((ConnectionProxy) conn).getConnectionRaw();
return conn;
public Connection getNativeConnectionFromStatement(Statement stmt) throws SQLException {
return getNativeConnection(stmt.getConnection());
public Statement getNativeStatement(Statement stmt) throws SQLException {
if (stmt instanceof PoolableStatement) {
stmt = ((PoolableStatement) stmt).getStatement();
if (stmt instanceof StatementProxy) {
stmt = ((StatementProxy) stmt).getStatementRaw();
return stmt;
public PreparedStatement getNativePreparedStatement(PreparedStatement stmt) throws SQLException {
if (stmt instanceof PoolablePreparedStatement) {
stmt = ((PoolablePreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof PreparedStatementProxy) {
stmt = ((PreparedStatementProxy) stmt).getRawPreparedStatement();
return stmt;
public CallableStatement getNativeCallableStatement(CallableStatement stmt) throws SQLException {
if (stmt instanceof PoolableCallableStatement) {
stmt = ((PoolableCallableStatement) stmt).getCallableStatementRaw();
if (stmt instanceof CallableStatementProxy) {
stmt = ((CallableStatementProxy) stmt).getRawCallableStatement();
return stmt;
public ResultSet getNativeResultSet(ResultSet rs) throws SQLException {
if (rs instanceof PoolableResultSet) {
rs = ((PoolableResultSet) rs).getRawResultSet();
if (rs instanceof ResultSetProxy) {
rs = ((ResultSetProxy) rs).getResultSetRaw();
return rs;
protected int                                                                            transactionQueryTimeout;
public int getTransactionQueryTimeout() {
if (transactionQueryTimeout <= 0) {
return queryTimeout;
return transactionQueryTimeout;
public void setTransactionQueryTimeout(int transactionQueryTimeout) {
this.transactionQueryTimeout = transactionQueryTimeout;
void initStatement(PoolableConnection conn, Statement stmt) throws SQLException {
boolean transaction = !conn.getConnectionHolder().isUnderlyingAutoCommit();
int queryTimeout = transaction ? getTransactionQueryTimeout() : getQueryTimeout();
int getTransactionQueryTimeout();
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
holder.getDataSource().initStatement(this, stmt);
holder.getDataSource().initStatement(this, stmt);
holder.getDataSource().initStatement(this, stmt);
boolean poolPreparedStatements = dataSource.isPoolPreparedStatements();
if (poolPreparedStatements) {
boolean transaction = !isUnderlyingAutoCommit();
if (transaction && !dataSource.isSharePreparedStatements()) {
poolPreparedStatements = false;
return poolPreparedStatements;
protected boolean                                                                        sharePreparedStatements                   = false;
if (maxPoolPreparedStatementPerConnectionSize > 0) {
this.poolPreparedStatements = true;
public boolean isSharePreparedStatements() {
return sharePreparedStatements;
public void setSharePreparedStatements(boolean sharePreparedStatements) {
this.sharePreparedStatements = sharePreparedStatements;
this.setMaxPoolPreparedStatementPerConnectionSize(maxOpenPreparedStatements);
boolean isSharePreparedStatements();
PreparedStatementHolder stmtHolder = null;
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementHolder stmtHolder = null;
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementHolder stmtHolder = null;
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M4, columnIndexes);
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M5, columnNames);
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementKey key = new PreparedStatementKey(sql, getCatalog(), MethodType.M6, autoGeneratedKeys);
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
PreparedStatementHolder stmtHolder = null;
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
boolean poolPreparedStatements = holder.isPoolPreparedStatements();
if (poolPreparedStatements) {
if (poolPreparedStatements) {
public class TestSharePreparedStatements extends TestCase {
protected void setUp() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_sharePreparedStatements() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxPoolPreparedStatementPerConnectionSize(30);
String sql = "SELECT 1";
MockPreparedStatement mockStmt = null;
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
mockStmt = stmt.unwrap(MockPreparedStatement.class);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
Assert.assertEquals(mockStmt, stmt.unwrap(MockPreparedStatement.class));
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);
PreparedStatement stmt = conn.prepareStatement(sql);
Assert.assertEquals(true, mockStmt != stmt.unwrap(MockPreparedStatement.class));
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);
PreparedStatement stmt = conn.prepareStatement(sql);
Assert.assertEquals(true, mockStmt != stmt.unwrap(MockPreparedStatement.class));
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
dataSource.close();
perfOracle("SELECT a.ID, a.GMT_CREATE, a.GMT_MODIFIED, a.COMPANY_NAME, a.BIZ_TYPE , b.SERVICE_TYPE, b.SERVICE_LEVEL, b.BUSINESS_ROLE, a.STATUS, a.RECOMMENDED , a.COUNTRY, a.PROVINCE, a.CITY, a.ADDRESS, a.ZIP , a.LOGO_FILE, a.EMAIL, a.BRIEF_PROFILE, a.DOMAIN_ID, a.IS_PASS_AV , a.KEYWORDS, a.PROVIDE_PRODUCTS, a.PURCHASE_PRODUCTS, a.BRAND_NAME, a.PROMOTION_VALUE , a.OWNER_MEMBER_ID, a.OWNER_SEQ, a.EMPLOYEES_COUNT, a.ANNUAL_REVENUE, a.HOMEPAGE_URL , a.REG_ADDRESS, a.TRADE_REGION, a.TRADE_REGION_USER, a.REG_CAPITAL, a.OWNERSHIP_TYPE , a.ESTABLISHED_YEAR, a.PRINCIPAL, a.ANNUAL_PURCHASE, a.CERTIFICATION, a.CERTIFICATION_2 , a.CONTACT_MANUFACTURING, a.YEARS_OEM, b.STAGE, a.VIDEO_PATH, a.ABOUTUS_IMAGE_PATH , a.ABOUTUS_IMAGE_TITLE, a.CHINESE_NAME, a.IMAGE_VERSION FROM COMPANY a, VACCOUNT b WHERE a.ID = b.ID AND a.id IN (?)");
perfMySql("SELECT a.ID, a.GMT_CREATE, a.GMT_MODIFIED, a.COMPANY_NAME, a.BIZ_TYPE , b.SERVICE_TYPE, b.SERVICE_LEVEL, b.BUSINESS_ROLE, a.STATUS, a.RECOMMENDED , a.COUNTRY, a.PROVINCE, a.CITY, a.ADDRESS, a.ZIP , a.LOGO_FILE, a.EMAIL, a.BRIEF_PROFILE, a.DOMAIN_ID, a.IS_PASS_AV , a.KEYWORDS, a.PROVIDE_PRODUCTS, a.PURCHASE_PRODUCTS, a.BRAND_NAME, a.PROMOTION_VALUE , a.OWNER_MEMBER_ID, a.OWNER_SEQ, a.EMPLOYEES_COUNT, a.ANNUAL_REVENUE, a.HOMEPAGE_URL , a.REG_ADDRESS, a.TRADE_REGION, a.TRADE_REGION_USER, a.REG_CAPITAL, a.OWNERSHIP_TYPE , a.ESTABLISHED_YEAR, a.PRINCIPAL, a.ANNUAL_PURCHASE, a.CERTIFICATION, a.CERTIFICATION_2 , a.CONTACT_MANUFACTURING, a.YEARS_OEM, b.STAGE, a.VIDEO_PATH, a.ABOUTUS_IMAGE_PATH , a.ABOUTUS_IMAGE_TITLE, a.CHINESE_NAME, a.IMAGE_VERSION FROM COMPANY a, VACCOUNT b WHERE a.ID = b.ID AND a.id IN (?)");
protected final AtomicLong                                                               cachedPreparedStatementDeleteCount              = new AtomicLong();
public void incrementCachedPreparedStatementDeleteCount() {
cachedPreparedStatementDeleteCount.incrementAndGet();
public long getCachedPreparedStatementDeleteCount() {
return cachedPreparedStatementDeleteCount.get();
long getCachedPreparedStatementDeleteCount();
cachedPreparedStatementDeleteCount.set(0);
public class XAPoolableConnection extends PoolableConnection implements XAResource {
private final static Log     LOG       = LogFactory.getLog(XAPoolableConnection.class);
protected final XAConnection xaConnection;
protected final XAResource   xaResource;
protected Xid                currentXid;
private Lock                 stateLock = new ReentrantLock();
public XAPoolableConnection(ConnectionHolder holder, XAConnection xaConnection) throws SQLException{
super(holder);
this.xaConnection = xaConnection;
this.xaResource = xaConnection.getXAResource();
public void commit(Xid xid, boolean onePhase) throws XAException {
xaResource.commit(xid, onePhase);
public void end(Xid xid, int arg1) throws XAException {
public void forget(Xid xid) throws XAException {
xaResource.forget(xid);
public int getTransactionTimeout() throws XAException {
return xaResource.getTransactionTimeout();
public boolean isSameRM(XAResource other) throws XAException {
return xaResource.isSameRM(other);
public int prepare(Xid xid) throws XAException {
return xaResource.prepare(xid);
public Xid[] recover(int flag) throws XAException {
return xaResource.recover(flag);
public void rollback(Xid xid) throws XAException {
xaResource.rollback(xid);
public boolean setTransactionTimeout(int seconds) throws XAException {
return xaResource.setTransactionTimeout(seconds);
public void start(Xid xid, int flags) throws XAException {
if (holder == null) {
throw new XAException("connection is closed");
xaResource.start(xid, flags);
} catch (XAException e) {
if (isFailedXA(e.errorCode)) {
LOG.error("Start transaction failed for " + this);
stateLock.lock();
currentXid = xid;
} finally {
stateLock.unlock();
private boolean isFailedXA(int errorCode) {
return (errorCode == XAException.XAER_RMERR || errorCode == XAException.XAER_RMFAIL);
map.put("PreparedStatementCacheDeleteCount", dataSource.getCachedPreparedStatementDeleteCount());
map.put("Version", dataSource.getVersion());
, SimpleType.LONG, SimpleType.LONG, JMXUtils.getThrowableCompositeType(), JMXUtils.getThrowableCompositeType(), SimpleType.LONG 
, SimpleType.STRING
"CommitCount", "RollbackCount", "LastError", "LastCreateError", "PreparedStatementCacheDeleteCount" 
, "Version"
protected final AtomicLong                                                               cachedPreparedStatementDeleteCount        = new AtomicLong();
protected final AtomicLong                                                               cachedPreparedStatementMissCount          = new AtomicLong();
public void incrementCachedPreparedStatementMissCount() {
cachedPreparedStatementMissCount.incrementAndGet();
public long getCachedPreparedStatementMissCount() {
return cachedPreparedStatementMissCount.get();
dataSource.incrementCachedPreparedStatementMissCount();
dataSource.incrementCachedPreparedStatementDeleteCount();
map.put("PreparedStatementCacheMissCount", dataSource.getCachedPreparedStatementMissCount());
, SimpleType.LONG, SimpleType.STRING
, "CachedPreparedStatementMissCount", "Version"
map.put("PreparedStatementCacheHitCount", dataSource.getReusePreparedStatementCount());
map.put("PreparedStatementCacheCurrentCount", dataSource.getCachedPreparedStatementCount());
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.STRING
, "PreparedStatementCacheMissCount", "PreparedStatementCacheHitCount", "PreparedStatementCacheCurrentCount", "Version"
protected final AtomicLong                                                               cachedPreparedStatementHitCount                    = new AtomicLong();
protected Throwable                                                                      createError;
protected Throwable                                                                      lastError;
protected long                                                                           lastErrorTimeMillis;
protected Throwable                                                                      lastCreateError;
protected long                                                                           lastCreateErrorTimeMillis;
public Throwable getLastCreateError() {
return lastCreateError;
public Throwable getLastError() {
return this.lastError;
public long getLastErrorTimeMillis() {
return lastErrorTimeMillis;
public Date getLastErrorTime() {
if (lastErrorTimeMillis <= 0) {
return null;
return new Date(lastErrorTimeMillis);
public long getLastCreateErrorTimeMillis() {
return lastCreateErrorTimeMillis;
public Date getLastCreateErrorTime() {
if (lastErrorTimeMillis <= 0) {
return null;
return new Date(lastCreateErrorTimeMillis);
public long getCachedPreparedStatementAccessCount() {
return cachedPreparedStatementMissCount.get() + cachedPreparedStatementHitCount.get();
public void incrementCachedPreparedStatementHitCount() {
cachedPreparedStatementHitCount.incrementAndGet();
public long getCachedPreparedStatementHitCount() {
return cachedPreparedStatementHitCount.get();
dataSource.lastCreateError = ex;
dataSource.lastCreateErrorTimeMillis = System.currentTimeMillis();
dataSource.lastCreateError = ex;
dataSource.lastCreateErrorTimeMillis = System.currentTimeMillis();
long getCachedPreparedStatementAccessCount();
long getCachedPreparedStatementMissCount();
long getCachedPreparedStatementHitCount();
lastError = null;
lastErrorTimeMillis = 0;
lastCreateError = null;
lastCreateErrorTimeMillis = 0;
cachedPreparedStatementHitCount.set(0);
lastErrorTimeMillis = System.currentTimeMillis();
lastErrorTimeMillis = System.currentTimeMillis();
dataSource.incrementCachedPreparedStatementHitCount();
map.put("ReusePreparedStatementCount", dataSource.getCachedPreparedStatementHitCount());
map.put("LastCreateError", JMXUtils.getErrorCompositeData(dataSource.getLastCreateError()));
map.put("PreparedStatementCacheAccessCount", dataSource.getCachedPreparedStatementAccessCount());
map.put("PreparedStatementCacheHitCount", dataSource.getCachedPreparedStatementHitCount());
map.put("LastErrorTime", dataSource.getLastErrorTime());
map.put("LastCreateErrorTime", dataSource.getLastCreateErrorTime());
, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.LONG, SimpleType.STRING 
, SimpleType.DATE , SimpleType.D
, "PreparedStatementCacheAccessCount", "PreparedStatementCacheMissCount", "PreparedStatementCacheHitCount", "PreparedStatementCacheCurrentCount", "Version" 
, "LastErrorTime", "LastCreateErrorTime"
public void clearStatementCache() {
lock.lock();
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder conn = connections[i];
conn.getStatementPool().clear();
} finally {
lock.unlock();
void clearStatementCache();
private boolean            closed      = false;
private final Thread       ownerThread;
ownerThread = Thread.currentThread();
public Thread getOwnerThread() {
return ownerThread;
closed = true;
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
checkState();
public void checkState() throws SQLException {
if (holder == null || closed || diable) {
public void clear() {
Iterator<Entry<PreparedStatementKey, PreparedStatementHolder>> iter = map.entrySet().iterator();
while (iter.hasNext()) {
Entry<PreparedStatementKey, PreparedStatementHolder> entry = iter.next();
dataSource.closePreapredStatement(entry.getValue());
dataSource.decrementCachedPreparedStatementCount();
dataSource.incrementCachedPreparedStatementDeleteCount();
iter.remove();
conn.checkState();
buf.append("ntt{hitCount:");
buf.append(entry.getValue().getHitCount());
public class OracleUtils {
public static void clearDefines(PoolablePreparedStatement stmt) throws SQLException {
PreparedStatement raw = stmt.getRawPreparedStatement();
if (raw instanceof OracleStatement) {
OracleStatement oracleStmt = (OracleStatement) raw;
oracleStmt.clearDefines();
private boolean isOracle() {
return "oracle".equals(holder.getDataSource().getDbType());
if (stmt.getHitCount() == 0 && isOracle()) {
OracleUtils.clearDefines(stmt);
public int getHitCount() {
return holder.getHitCount();
private int                        hitCount = 0;
public void incrementHitCount() {
hitCount++;
public int getHitCount() {
return hitCount;
holder.incrementHitCount();
if (holder.getHitCount() == 0) {
public class TestOraclePreparedStatement extends TestCase {
private String jdbcUrl;
private String user;
private String password;
public void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.85:1521:ocnauto";
user = "alibaba";
password = "ccbuauto";
public void test_0() throws Exception {
Class.forName(JdbcUtils.getDriverClassName(jdbcUrl));
Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
OraclePreparedStatement oracleStmt = null;
PreparedStatement stmt = conn.prepareStatement("SELECT ? FROM DUAL");
oracleStmt = (OraclePreparedStatement) stmt;
stmt.setString(1, "aaa");
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
oracleStmt.clearDefines();
stmt.setString(1, "bbb");
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
dataSource.setInitialSize(1);
resultSet.setConstructNano(System.nanoTime());
long nanoSpan = System.nanoTime() - resultSet.getConstructNano();
int fetchCount = resultSet.getFetchRowCount();
resultSetStat.afterClose(nanoSpan);
dataSourceStat.getResultSetStat().afterClose(nanoSpan);
resultSetStat.addFetchRowCount(fetchCount);
dataSourceStat.getResultSetStat().addFetchRowCount(fetchCount);
resultSetStat.incrementCloseCounter();
dataSourceStat.getResultSetStat().incrementCloseCounter();
String sql = resultSet.getSql();
if (sql != null) {
JdbcSqlStat sqlStat = dataSourceStat.getSqlStatMap().get(sql);
if (sqlStat != null) {
sqlStat.addFetchRowCount(fetchCount);
stmt.getPreparedStatementHolder().setFetchRowPeak(stmt.getFetchRowPeak());
private boolean                 closed        = false;
protected int                   cursorIndex   = 0;
protected int                   fetchRowCount = 0;
boolean moreRows = rs.next();
if (moreRows) {
cursorIndex++;
if (cursorIndex > fetchRowCount) {
fetchRowCount = cursorIndex;
return moreRows;
stmt.recordFetchRowCount(fetchRowCount);
boolean moreRows = rs.previous();
if (moreRows) {
cursorIndex--;
return moreRows;
protected int                   fetchRowPeak   = -1;
protected void recordFetchRowCount(int fetchRowCount) {
if (fetchRowPeak < fetchRowCount) {
fetchRowPeak = fetchRowCount;
public int getFetchRowPeak() {
return fetchRowPeak;
private int                        hitCount     = 0;
private int                        fetchRowPeak = -1;
public int getFetchRowPeak() {
return fetchRowPeak;
public void setFetchRowPeak(int fetchRowPeak) {
if (fetchRowPeak > this.fetchRowPeak) {
this.fetchRowPeak = fetchRowPeak;
int getCursorIndex();
int getFetchRowCount();
long getConstructNano();
void setConstructNano(long constructNano);
protected int                cursorIndex   = 0;
protected int                fetchRowCount = 0;
protected long               constructNano;
public long getConstructNano() {
return constructNano;
public void setConstructNano(long constructNano) {
this.constructNano = constructNano;
public int getCursorIndex() {
return cursorIndex;
public int getFetchRowCount() {
return fetchRowCount;
boolean moreRows = createChain().resultSet_next(this);
if (moreRows) {
cursorIndex++;
if (cursorIndex > fetchRowCount) {
fetchRowCount = cursorIndex;
return moreRows;
boolean moreRows = createChain().resultSet_previous(this);
if (moreRows) {
cursorIndex--;
return moreRows;
String sql = "SELECT * FROM WS_OFFER WHERE ROWNUM <= ?";
PreparedStatement stmt = conn.prepareStatement(sql);
oracleStmt.setRowPrefetch(1);
stmt.setInt(1, 1);
while (rs.next()) {
oracleStmt.setRowPrefetch(1000);
stmt.setInt(1, 11);
public abstract boolean isOracle();
private boolean                 isOracle                = false;
if ("oracle".equals(this.dbType)) {
isOracle = true;
public boolean isOracle() {
return isOracle;
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
oracleStmt.clearDefines();
public static int getRowPrefetch(PreparedStatement stmt) throws SQLException {
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
return oracleStmt.getRowPrefetch();
public static void setRowPrefetch(PreparedStatement stmt, int value) throws SQLException {
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
oracleStmt.setRowPrefetch(value);
public static void setDefaultRowPrefetch(Connection conn, int value) throws SQLException {
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
oracleConn.setDefaultRowPrefetch(value);
public static int getDefaultRowPrefetch(Connection conn, int value) throws SQLException {
if (conn instanceof OracleConnection) {
OracleConnection oracleConn = (OracleConnection) conn;
return oracleConn.getDefaultRowPrefetch();
return -1;
public boolean isOracle() {
return holder.getDataSource().isOracle();
oracleSetRowPrefetch();
oracleSetRowPrefetch();
private void oracleSetRowPrefetch() throws SQLException {
if (!conn.isOracle()) {
if (holder.getHitCount() == 0) {
int fetchRowPeak = holder.getFetchRowPeak();
if (fetchRowPeak < 0) {
if (holder.getDefaultRowPretch() == -1) {
int defaultRowPretch = OracleUtils.getRowPrefetch(this);
holder.setDefaultRowPretch(defaultRowPretch);
holder.setRowPrefetch(defaultRowPretch);
int rowPrefetch;
if (fetchRowPeak <= 1) {
rowPrefetch = 1;
} else if (fetchRowPeak > holder.getDefaultRowPretch()) {
rowPrefetch = holder.getDefaultRowPretch();
rowPrefetch = fetchRowPeak;
if (rowPrefetch != holder.getRowPrefetch()) {
OracleUtils.setRowPrefetch(this, rowPrefetch);
holder.setRowPrefetch(rowPrefetch);
if (iface.isInstance(wrapper)) {
return true;
if (iface.isInstance(wrapper)) {
return (T) wrapper;
private int                        hitCount         = 0;
private int                        fetchRowPeak     = -1;
private int                        defaultRowPretch = -1;
private int                        rowPrefetch      = -1;
public int getDefaultRowPretch() {
return defaultRowPretch;
public void setDefaultRowPretch(int defaultRowPretch) {
this.defaultRowPretch = defaultRowPretch;
public int getRowPrefetch() {
return rowPrefetch;
public void setRowPrefetch(int rowPrefetch) {
this.rowPrefetch = rowPrefetch;
public class TestDruidOraclePreparedStatement extends TestCase {
private String          jdbcUrl;
private String          user;
private String          password;
private DruidDataSource dataSource;
public void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.85:1521:ocnauto";
user = "alibaba";
password = "ccbuauto";
dataSource = new DruidDataSource();
dataSource.setPoolPreparedStatements(true);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_0() throws Exception {
Class.forName(JdbcUtils.getDriverClassName(jdbcUrl));
for (int i = 0; i < 3; ++i) {
Connection conn = dataSource.getConnection();
String sql = "SELECT * FROM WS_OFFER WHERE ROWNUM <= ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setInt(1, 1);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
String sql = "SELECT * FROM WS_OFFER WHERE ROWNUM <= ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setInt(1, 11);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
OracleConnection oracleConn = (OracleConnection) conn;
int fetchRowSize = oracleConn.getDefaultRowPrefetch();
if (driver.getMajorVersion() < 10) {
throw new SQLException("not support oracle driver " + driver.getMajorVersion() + "." + driver.getMinorVersion());
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
return oracleConn.getDefaultRowPrefetch();
public static void cancel(Connection conn) throws SQLException {
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
oracleConn.cancel();
public static void pingDatabase(Connection conn) throws SQLException {
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
oracleConn.pingDatabase();
protected void oracleSetRowPrefetch() throws SQLException {
Connection conn = dataSource.getConnection();
ResultSet metaRs = conn.getMetaData().getTables(null, "ALIBABA", null, new String[] { "TABLE" });
JdbcUtils.printResultSet(metaRs);
metaRs.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM WP_ORDERS");
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
String sql = "SELECT * FROM WP_ORDERS WHERE ID <= ?";
oracleStmt.setRowPrefetch(10);
stmt.setInt(1, 327);
public class Oracle_Case4 extends TestCase {
private String  jdbcUrl;
private String  user;
private String  password;
private String  driverClass;
private int     maxIdle                = 40;
private int     maxActive              = 50;
private int     maxWait                = 5000;
private String  validationQuery        = "SELECT 1 FROM DUAL";
private int     threadCount            = 1;
private int     loopCount              = 3;
final int       LOOP_COUNT             = 1000 * 10;
private boolean testOnBorrow           = false;
private boolean preparedStatementCache = true;
private final String SQL = "SELECT MEMBER_ID FROM WP_ORDERS WHERE ID = ?";
protected void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.85:1521:ocnauto";
user = "alibaba";
password = "ccbuauto";
driverClass = "oracle.jdbc.driver.OracleDriver";
public void xtest_0() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setMaxActive(maxActive);
dataSource.setMaxIdle(maxIdle);
dataSource.setMaxWait(maxWait);
dataSource.setPoolPreparedStatements(preparedStatementCache);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setValidationQuery(validationQuery);
dataSource.setTestOnBorrow(testOnBorrow);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "druid", threadCount);
System.out.println();
public void test_1() throws Exception {
final BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxActive(maxActive);
dataSource.setMaxIdle(maxIdle);
dataSource.setMaxWait(maxWait);
dataSource.setPoolPreparedStatements(preparedStatementCache);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setValidationQuery(validationQuery);
dataSource.setTestOnBorrow(testOnBorrow);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "dbcp", threadCount);
System.out.println();
private void printWP_ORDERS(DruidDataSource dataSource) throws SQLException {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM WP_ORDERS");
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
protected void printTables(DruidDataSource dataSource) throws SQLException {
Connection conn = dataSource.getConnection();
ResultSet rs = conn.getMetaData().getTables(null, "ALIBABA", null, new String[] { "TABLE" });
JdbcUtils.printResultSet(rs);
rs.close();
conn.close();
private void p0(final DataSource dataSource, String name, int threadCount) throws Exception {
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
for (int i = 0; i < threadCount; ++i) {
Thread thread = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < LOOP_COUNT; ++i) {
Connection conn = dataSource.getConnection();
String sql = SQL; 
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setInt(1, 337);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
stmt.close();
Assert.isTrue(stmt.isClosed());
conn.close();
} catch (Exception ex) {
ex.printStackTrace();
endLatch.countDown();
thread.start();
long startMillis = System.currentTimeMillis();
long startYGC = TestUtil.getYoungGC();
long startFullGC = TestUtil.getFullGC();
startLatch.countDown();
endLatch.await();
long millis = System.currentTimeMillis() - startMillis;
long ygc = TestUtil.getYoungGC() - startYGC;
long fullGC = TestUtil.getFullGC() - startFullGC;
System.out.println("thread " + threadCount + " " + name + " millis : "
+ NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC);
private static final long serialVersionUID = -2227528634302168877L;
private static final Log  LOG              = LogFactory.getLog(OracleValidConnectionChecker.class);
int status = OracleUtils.pingDatabase(conn);
if (status < 0) {
return true;
public static int pingDatabase(Connection conn) throws SQLException {
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
return oracleConn.pingDatabase();
public static void openProxySession(Connection conn, int type, java.util.Properties prop) throws SQLException {
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
oracleConn.openProxySession(type, prop);
public static int getDefaultExecuteBatch(Connection conn) throws SQLException {
return oracleConn.getDefaultExecuteBatch();
if (stmt.getHitCount() < 2 && isOracle()) {
private static final long serialVersionUID = -2227528634302168877L;
private static final Log  LOG              = LogFactory.getLog(OracleValidConnectionChecker.class);
int status = OracleUtils.pingDatabase(conn);
if (status < 0) {
return true;
public class OracleUtils {
public static void clearDefines(PoolablePreparedStatement stmt) throws SQLException {
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
oracleStmt.clearDefines();
public static int getRowPrefetch(PreparedStatement stmt) throws SQLException {
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
return oracleStmt.getRowPrefetch();
public static void setRowPrefetch(PreparedStatement stmt, int value) throws SQLException {
OracleStatement oracleStmt = stmt.unwrap(OracleStatement.class);
oracleStmt.setRowPrefetch(value);
public static void setDefaultRowPrefetch(Connection conn, int value) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
oracleConn.setDefaultRowPrefetch(value);
public static int getDefaultRowPrefetch(Connection conn, int value) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
return oracleConn.getDefaultRowPrefetch();
public static void cancel(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
oracleConn.cancel();
public static int pingDatabase(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
return oracleConn.pingDatabase();
public static void openProxySession(Connection conn, int type, java.util.Properties prop) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
oracleConn.openProxySession(type, prop);
public static int getDefaultExecuteBatch(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
return oracleConn.getDefaultExecuteBatch();
public static OracleConnection unwrap(Connection conn) throws SQLException {
if (conn instanceof OracleConnection) {
return (OracleConnection) conn;
return conn.unwrap(OracleConnection.class);
public static ROWID getROWID(ResultSet rs, int columnIndex) throws SQLException {
OracleResultSet oracleResultSet = rs.unwrap(OracleResultSet.class);
return oracleResultSet.getROWID(columnIndex);
public class OracleUtilsTest extends TestCase {
public void test_oracle() throws Exception {
InvocationHandler handler = new InvocationHandler() {
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
if (method.getName().equals("pingDatabase")) {
return null;
OracleConnection conn = (OracleConnection) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] {OracleConnection.class}, handler);
Assert.assertNotNull(OracleUtils.unwrap(conn));
Assert.assertEquals(1, OracleUtils.pingDatabase(conn));
private String       jdbcUrl;
private String       user;
private String       password;
private String       driverClass;
private int          maxIdle                = 40;
private int          maxActive              = 50;
private int          maxWait                = 5000;
private String       validationQuery        = "SELECT 1 FROM DUAL";
private int          threadCount            = 1;
private int          loopCount              = 3;
final int            LOOP_COUNT             = 1000 * 1;
private boolean      testOnBorrow           = false;
private boolean      preparedStatementCache = true;
private final String SQL                    = "SELECT MEMBER_ID FROM WP_ORDERS WHERE ID = ?";
public void test_0() throws Exception {
dataSource.setMaxOpenPreparedStatements(10);
dataSource.setMaxOpenPreparedStatements(10);
if (stmt.getHitCount() < 1 && isOracle()) {
private static final long serialVersionUID = 1L;
private static final Log  LOG              = LogFactory.getLog(MySqlValidConnectionChecker.class);
MySqlUtils.ping(conn);
public class MySqlUtils {
public static com.mysql.jdbc.Connection unwrap(Connection conn) throws SQLException {
if (conn instanceof com.mysql.jdbc.Connection) {
return (com.mysql.jdbc.Connection) conn;
return conn.unwrap(com.mysql.jdbc.Connection.class);
public static void ping(Connection conn) throws SQLException {
com.mysql.jdbc.Connection mysqlConn = unwrap(conn);
mysqlConn.ping();
protected final AtomicLong                                                               cachedPreparedStatementHitCount           = new AtomicLong();
protected boolean                                                                        isOracle                                  = false;
public boolean isOracle() {
return isOracle;
throw new SQLException("not support oracle driver " + driver.getMajorVersion() + "."
+ driver.getMinorVersion());
public void clearStatementCache() throws SQLException {
void clearStatementCache() throws SQLException;
holder.getStatementPool().put(stmt.getPreparedStatementHolder());
oracleSetRowPrefetch();
rowPrefetch = 2;
rowPrefetch = fetchRowPeak + 1;
private final static Log                                         LOG = LogFactory.getLog(PreparedStatementPool.class);
public PreparedStatementHolder get(PreparedStatementKey key) throws SQLException {
OracleUtils.exitImplicitCacheToActive(holder.getStatement());
if (dataSource.isOracle()) {
OracleUtils.enterImplicitCache(stmt);
if (oldHolder != null && oldHolder != holder) {
public void clear() throws SQLException {
closeStatement(entry.getValue());
private void closeStatement(PreparedStatementHolder holder) throws SQLException {
if (dataSource.isOracle()) {
OracleUtils.exitImplicitCacheToClose(holder.getStatement());
dataSource.closePreapredStatement(holder);
dataSource.decrementCachedPreparedStatementCount();
dataSource.incrementCachedPreparedStatementDeleteCount();
closeStatement(eldest.getValue());
} catch (SQLException e) {
LOG.error("closeStatement error", e);
public static void enterImplicitCache(PreparedStatement stmt) throws SQLException {
oracle.jdbc.internal.OraclePreparedStatement oracleStmt = unwrapInternal(stmt);
oracleStmt.enterImplicitCache();
public static void exitImplicitCacheToClose(PreparedStatement stmt) throws SQLException {
oracle.jdbc.internal.OraclePreparedStatement oracleStmt = unwrapInternal(stmt);
oracleStmt.exitImplicitCacheToClose();
public static void exitImplicitCacheToActive(PreparedStatement stmt) throws SQLException {
oracle.jdbc.internal.OraclePreparedStatement oracleStmt = unwrapInternal(stmt);
oracleStmt.exitImplicitCacheToActive();
public static OraclePreparedStatement unwrapInternal(PreparedStatement stmt) throws SQLException {
if (stmt instanceof OraclePreparedStatement) {
return (OraclePreparedStatement) stmt;
return stmt.unwrap(OraclePreparedStatement.class);
public static boolean getImplicitCachingEnabled(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
return oracleConn.getImplicitCachingEnabled();
public static int getStatementCacheSize(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
return oracleConn.getStatementCacheSize();
public static void purgeImplicitCache(Connection conn) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
oracleConn.purgeImplicitCache();
public static void setImplicitCachingEnabled(Connection conn, boolean cache) throws SQLException {
OracleConnection oracleConn = unwrap(conn);
oracleConn.setImplicitCachingEnabled(cache);
public static void setStatementCacheSize(Connection conn, int size) throws SQLException {
oracleConn.setStatementCacheSize(size);
return oracleConn.pingDatabase(1000);
public class OracleConnectionPoolDataSourceTest extends TestCase {
public void test_oraclePool() throws Exception {
OracleConnectionPoolDataSource pool = new OracleConnectionPoolDataSource();
private String SQL;
jdbcUrl = "jdbc:oracle:thin:@10.20.149.81:1521:ointest3";
user = "alibaba";
password = "deYcR7facWSJtCuDpm2r";
SQL = "SELECT * FROM AV_INFO WHERE ID = ?";
Class.forName(JdbcUtils.getDriverClassName(jdbcUrl));
public void createTable() throws Exception {
Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE T");
stmt.execute("CREATE TABLE T (FID INT, FNAME VARCHAR2(4000), FDESC CLOB)");
stmt.close();
conn.close();
PreparedStatement stmt = conn.prepareStatement(SQL);
for (int i = 0; i < 10; ++i){
OracleUtils.enterImplicitCache(oracleStmt);
OracleUtils.exitImplicitCacheToActive(oracleStmt);
stmt.setInt(1, 327);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
private String  jdbcUrl;
private String  user;
private String  password;
private String  driverClass;
private int     maxIdle                    = 40;
private int     maxActive                  = 50;
private int     maxWait                    = 5000;
private String  validationQuery            = "SELECT 1 FROM DUAL";
private int     threadCount                = 1;
private int     loopCount                  = 3;
final int       LOOP_COUNT                 = 1000 * 10;
private boolean testOnBorrow               = false;
private boolean preparedStatementCache     = true;
private int     preparedStatementCacheSize = 50;
private String  properties = "defaultRowPrefetch=50";
private String  SQL;
jdbcUrl = "jdbc:oracle:thin:@10.20.149.81:1521:ointest3";
password = "deYcR7facWSJtCuDpm2r";
SQL = "SELECT * FROM AV_INFO WHERE ID = ?";
public void test_druid() throws Exception {
dataSource.setMaxOpenPreparedStatements(preparedStatementCacheSize);
dataSource.setConnectionProperties(properties);
public void test_dbcp() throws Exception {
dataSource.setMaxOpenPreparedStatements(preparedStatementCacheSize);
dataSource.setConnectionProperties(properties);
private void printAV_INFO(DataSource dataSource) throws SQLException {
String sql = "SELECT DISTINCT ID FROM AV_INFO WHERE ROWNUM <= 10";
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
int mod = i % 500;
String sql = SQL;
stmt.setInt(1, 61);
int rowCount = 0;
rowCount++;
Assert.isTrue(conn.isClosed());
public void addTrace(DruidPooledStatement stmt) {
public void removeTrace(DruidPooledStatement stmt) {
protected final ConcurrentIdentityHashMap<DruidPooledConnection, ActiveConnectionTraceInfo> activeConnections                         = new ConcurrentIdentityHashMap<DruidPooledConnection, ActiveConnectionTraceInfo>();
protected boolean                                                                        useOracleImplicitCache                    = false;
public boolean isUseOracleImplicitCache() {
return useOracleImplicitCache;
public void setUseOracleImplicitCache(boolean useOracleImplicitCache) {
this.useOracleImplicitCache = useOracleImplicitCache;
public Set<DruidPooledConnection> getActiveConnections() {
void removeActiveConnection(DruidPooledConnection conn) {
void initStatement(DruidPooledConnection conn, Statement stmt) throws SQLException {
public abstract void handleConnectionException(DruidPooledConnection pooledConnection, Throwable t)
protected abstract void recycle(DruidPooledConnection pooledConnection) throws SQLException;
DruidPooledConnection poolalbeConnection = getConnectionInternal(maxWaitMillis);
private DruidPooledConnection getConnectionInternal(long maxWait) throws SQLException {
DruidPooledConnection poolalbeConnection;
poolalbeConnection = new DruidPooledConnection(holder);
public void handleConnectionException(DruidPooledConnection pooledConnection, Throwable t) throws SQLException {
protected void recycle(DruidPooledConnection pooledConnection) throws SQLException {
Iterator<Map.Entry<DruidPooledConnection, ActiveConnectionTraceInfo>> iter = activeConnections.entrySet().iterator();
List<DruidPooledConnection> abondonedList = new ArrayList<DruidPooledConnection>();
Map.Entry<DruidPooledConnection, ActiveConnectionTraceInfo> entry = iter.next();
DruidPooledConnection pooledConnection = entry.getKey();
for (DruidPooledConnection conn : abondonedList) {
private final DruidPooledConnection  connection;
public ActiveConnectionTraceInfo(DruidPooledConnection connection, long connectTime, StackTraceElement[] stackTrace){
public DruidPooledConnection getConnection() {
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {
public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
public class DruidPooledConnection implements javax.sql.PooledConnection, Connection {
private final static Log   LOG         = LogFactory.getLog(DruidPooledConnection.class);
public DruidPooledConnection(ConnectionHolder holder){
void closePoolableStatement(DruidPooledPreparedStatement stmt) throws SQLException {
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
public class DruidPooledPreparedStatement extends DruidPooledStatement implements PreparedStatement {
public DruidPooledPreparedStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
public final class DruidPooledResultSet extends PoolableWrapper implements ResultSet {
private final DruidPooledStatement stmt;
public DruidPooledResultSet(DruidPooledStatement stmt, ResultSet rs){
public DruidPooledStatement getPoolableStatement() {
public class DruidPooledStatement extends PoolableWrapper implements Statement {
private final static Log        LOG            = LogFactory.getLog(DruidPooledStatement.class);
protected DruidPooledConnection    conn;
public DruidPooledStatement(DruidPooledConnection conn, Statement stmt){
public DruidPooledConnection getPoolableConnection() {
public void setPoolableConnection(DruidPooledConnection conn) {
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
private final static Log              LOG = LogFactory.getLog(PreparedStatementPool.class);
private final LRUCache                map;
private final DruidAbstractDataSource dataSource;
if (dataSource.isOracle() && dataSource.isUseOracleImplicitCache()) {
OracleUtils.exitImplicitCacheToActive(holder.getStatement());
if (dataSource.isOracle() && dataSource.isUseOracleImplicitCache()) {
if (dataSource.isOracle() && dataSource.isUseOracleImplicitCache()) {
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
public class XAPoolableConnection extends DruidPooledConnection implements XAResource {
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
if (stmt instanceof DruidPooledStatement) {
stmt = ((DruidPooledStatement) stmt).getStatement();
if (stmt instanceof DruidPooledPreparedStatement) {
stmt = ((DruidPooledPreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof DruidPooledCallableStatement) {
stmt = ((DruidPooledCallableStatement) stmt).getCallableStatementRaw();
if (rs instanceof DruidPooledResultSet) {
rs = ((DruidPooledResultSet) rs).getRawResultSet();
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
if (stmt instanceof DruidPooledStatement) {
stmt = ((DruidPooledStatement) stmt).getStatement();
if (stmt instanceof DruidPooledPreparedStatement) {
stmt = ((DruidPooledPreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof DruidPooledCallableStatement) {
stmt = ((DruidPooledCallableStatement) stmt).getCallableStatementRaw();
if (rs instanceof DruidPooledResultSet) {
rs = ((DruidPooledResultSet) rs).getRawResultSet();
public static void clearDefines(DruidPooledPreparedStatement stmt) throws SQLException {
Assert.assertTrue(conn instanceof DruidPooledConnection);
DruidPooledConnection poolableConn = conn.unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
Assert.assertEquals(true, conn.isWrapperFor(DruidPooledConnection.class));
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
protected DruidPooledCallableStatement stmt;
stmt = new DruidPooledCallableStatement(null,
protected DruidPooledPreparedStatement stmt;
stmt = new DruidPooledPreparedStatement(null,
protected DruidPooledStatement stmt;
stmt = new DruidPooledStatement(null, raw) {
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
DruidPooledStatement stmt = new DruidPooledStatement(null, null) {
private DruidPooledStatement stmt;
private DruidPooledResultSet resultSet;
stmt = new DruidPooledStatement(null, null) {
resultSet = new DruidPooledResultSet(stmt, raw);
private DruidPooledStatement stmt;
private DruidPooledResultSet resultSet;
stmt = new DruidPooledStatement(null, null) {
resultSet = new DruidPooledResultSet(stmt, raw);
DruidPooledResultSet rs = new DruidPooledResultSet(stmt, mock);
DruidPooledConnection wrap = conn.unwrap(DruidPooledConnection.class);
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
DruidPooledConnection wrap = conn.unwrap(DruidPooledConnection.class);
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
String sql = SQL + " AND ROWNUM <= " + (mod + 1);
public void addTrace(DruidPooledStatement stmt) {
public void removeTrace(DruidPooledStatement stmt) {
protected final ConcurrentIdentityHashMap<DruidPooledConnection, ActiveConnectionTraceInfo> activeConnections                         = new ConcurrentIdentityHashMap<DruidPooledConnection, ActiveConnectionTraceInfo>();
protected boolean                                                                        useOracleImplicitCache                    = false;
public boolean isUseOracleImplicitCache() {
return useOracleImplicitCache;
public void setUseOracleImplicitCache(boolean useOracleImplicitCache) {
this.useOracleImplicitCache = useOracleImplicitCache;
public Set<DruidPooledConnection> getActiveConnections() {
void removeActiveConnection(DruidPooledConnection conn) {
void initStatement(DruidPooledConnection conn, Statement stmt) throws SQLException {
public abstract void handleConnectionException(DruidPooledConnection pooledConnection, Throwable t)
protected abstract void recycle(DruidPooledConnection pooledConnection) throws SQLException;
boolean isUseOracleImplicitCache();
void setUseOracleImplicitCache(boolean useOracleImplicitCache);
DruidPooledConnection poolalbeConnection = getConnectionInternal(maxWaitMillis);
private DruidPooledConnection getConnectionInternal(long maxWait) throws SQLException {
DruidPooledConnection poolalbeConnection;
poolalbeConnection = new DruidPooledConnection(holder);
public void handleConnectionException(DruidPooledConnection pooledConnection, Throwable t) throws SQLException {
protected void recycle(DruidPooledConnection pooledConnection) throws SQLException {
Iterator<Map.Entry<DruidPooledConnection, ActiveConnectionTraceInfo>> iter = activeConnections.entrySet().iterator();
List<DruidPooledConnection> abondonedList = new ArrayList<DruidPooledConnection>();
Map.Entry<DruidPooledConnection, ActiveConnectionTraceInfo> entry = iter.next();
DruidPooledConnection pooledConnection = entry.getKey();
for (DruidPooledConnection conn : abondonedList) {
private final DruidPooledConnection  connection;
public ActiveConnectionTraceInfo(DruidPooledConnection connection, long connectTime, StackTraceElement[] stackTrace){
public DruidPooledConnection getConnection() {
public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {
public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
public class DruidPooledConnection implements javax.sql.PooledConnection, Connection {
private final static Log   LOG         = LogFactory.getLog(DruidPooledConnection.class);
public DruidPooledConnection(ConnectionHolder holder){
void closePoolableStatement(DruidPooledPreparedStatement stmt) throws SQLException {
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledPreparedStatement rtnVal = new DruidPooledPreparedStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledCallableStatement rtnVal = new DruidPooledCallableStatement(this, stmtHolder);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
public class DruidPooledPreparedStatement extends DruidPooledStatement implements PreparedStatement {
public DruidPooledPreparedStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
public final class DruidPooledResultSet extends PoolableWrapper implements ResultSet {
private final DruidPooledStatement stmt;
public DruidPooledResultSet(DruidPooledStatement stmt, ResultSet rs){
public DruidPooledStatement getPoolableStatement() {
public class DruidPooledStatement extends PoolableWrapper implements Statement {
private final static Log        LOG            = LogFactory.getLog(DruidPooledStatement.class);
protected DruidPooledConnection    conn;
public DruidPooledStatement(DruidPooledConnection conn, Statement stmt){
public DruidPooledConnection getPoolableConnection() {
public void setPoolableConnection(DruidPooledConnection conn) {
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
private int                        hitCount                 = 0;
private int                        fetchRowPeak             = -1;
private int                        defaultRowPretch         = -1;
private int                        rowPrefetch              = -1;
private boolean                    enterOracleImplicitCache = false;
public boolean isEnterOracleImplicitCache() {
return enterOracleImplicitCache;
public void setEnterOracleImplicitCache(boolean enterOracleImplicitCache) {
this.enterOracleImplicitCache = enterOracleImplicitCache;
private final static Log              LOG = LogFactory.getLog(PreparedStatementPool.class);
private final LRUCache                map;
private final DruidAbstractDataSource dataSource;
if (holder.isEnterOracleImplicitCache()) {
OracleUtils.exitImplicitCacheToActive(holder.getStatement());
if (dataSource.isOracle() && dataSource.isUseOracleImplicitCache()) {
holder.setEnterOracleImplicitCache(true);
holder.setEnterOracleImplicitCache(false);
if (holder.isEnterOracleImplicitCache()) {
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
public class XAPoolableConnection extends DruidPooledConnection implements XAResource {
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
if (stmt instanceof DruidPooledStatement) {
stmt = ((DruidPooledStatement) stmt).getStatement();
if (stmt instanceof DruidPooledPreparedStatement) {
stmt = ((DruidPooledPreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof DruidPooledCallableStatement) {
stmt = ((DruidPooledCallableStatement) stmt).getCallableStatementRaw();
if (rs instanceof DruidPooledResultSet) {
rs = ((DruidPooledResultSet) rs).getRawResultSet();
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
if (stmt instanceof DruidPooledStatement) {
stmt = ((DruidPooledStatement) stmt).getStatement();
if (stmt instanceof DruidPooledPreparedStatement) {
stmt = ((DruidPooledPreparedStatement) stmt).getRawPreparedStatement();
if (stmt instanceof DruidPooledCallableStatement) {
stmt = ((DruidPooledCallableStatement) stmt).getCallableStatementRaw();
if (rs instanceof DruidPooledResultSet) {
rs = ((DruidPooledResultSet) rs).getRawResultSet();
public static void clearDefines(DruidPooledPreparedStatement stmt) throws SQLException {
Assert.assertTrue(conn instanceof DruidPooledConnection);
DruidPooledConnection poolableConn = conn.unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
Assert.assertEquals(true, conn.isWrapperFor(DruidPooledConnection.class));
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
protected DruidPooledCallableStatement stmt;
stmt = new DruidPooledCallableStatement(null,
protected DruidPooledPreparedStatement stmt;
stmt = new DruidPooledPreparedStatement(null,
protected DruidPooledStatement stmt;
stmt = new DruidPooledStatement(null, raw) {
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
((DruidPooledStatement) stmt).getStatement().close();
DruidPooledStatement stmt = new DruidPooledStatement(null, null) {
private DruidPooledStatement stmt;
private DruidPooledResultSet resultSet;
stmt = new DruidPooledStatement(null, null) {
resultSet = new DruidPooledResultSet(stmt, raw);
private DruidPooledStatement stmt;
private DruidPooledResultSet resultSet;
stmt = new DruidPooledStatement(null, null) {
resultSet = new DruidPooledResultSet(stmt, raw);
DruidPooledResultSet rs = new DruidPooledResultSet(stmt, mock);
DruidPooledConnection wrap = conn.unwrap(DruidPooledConnection.class);
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
DruidPooledConnection wrap = conn.unwrap(DruidPooledConnection.class);
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
final int       LOOP_COUNT                 = 1000 * 1000;
dataSource.setUseOracleImplicitCache(false);
String sql = SQL; 
} catch (SQLException ex) {
} catch (SQLException ex) {
Assert.assertEquals(8, dataSource.getRawDriverMinorVersion());
public class DruidJdbcExtractorTest extends TestCase {
public void test_spring() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
DruidJdbcExtractor extractor = new DruidJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
preStmt.close();
conn.close();
} finally {
dataSource.close();
public void test_spring_filter() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
DruidJdbcExtractor extractor = new DruidJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
dataSource.setFilters("stat");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
preStmt.close();
conn.close();
} finally {
dataSource.close();
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == CallableStatement.class) {
if (stmt instanceof CallableStatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
if (iface == Connection.class) {
if (conn instanceof ConnectionProxy) {
return conn.unwrap(iface);
return (T) conn;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
if (stmt instanceof PreparedStatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == ResultSet.class) {
if (rs instanceof ResultSetProxy) {
return rs.unwrap(iface);
return (T) rs;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Statement.class) {
if (stmt instanceof StatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
return (T) statement;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Connection.class) {
return (T) connection;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
return (T) statement;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == ResultSet.class) {
return (T) resultSet;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Statement.class) {
return (T) statement;
return super.unwrap(iface);
public class DruidJdbcExtractor extends Jdbc4NativeJdbcExtractor {
@SuppressWarnings("deprecation")
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
Jdbc4NativeJdbcExtractor extractor = new Jdbc4NativeJdbcExtractor();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
public class Jdbc4ExtractorTest extends TestCase {
public void test_spring() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
Jdbc4NativeJdbcExtractor extractor = new Jdbc4NativeJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
ResultSet rs = preStmt.executeQuery();
Assert.assertEquals(true, extractor.getNativeResultSet(rs) instanceof MockResultSet);
rs.close();
preStmt.close();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
conn.close();
} finally {
dataSource.close();
public void test_spring_filter() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
DruidJdbcExtractor extractor = new DruidJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
dataSource.setFilters("stat");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
ResultSet rs = preStmt.executeQuery();
Assert.assertEquals(true, extractor.getNativeResultSet(rs) instanceof MockResultSet);
rs.close();
preStmt.close();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
conn.close();
} finally {
dataSource.close();
connection.getRawObject().clearWarnings();
connection.getRawObject().close();
connection.getRawObject().commit();
return connection.getRawObject().createArrayOf(typeName, elements);
return connection.getRawObject().createBlob();
Clob clob = connection.getRawObject().createClob();
NClob nclob = connection.getRawObject().createNClob();
return connection.getRawObject().createSQLXML();
Statement statement = connection.getRawObject().createStatement();
Statement statement = connection.getRawObject().createStatement(resultSetType, resultSetConcurrency);
Statement statement = connection.getRawObject().createStatement(resultSetType, resultSetConcurrency,
return connection.getRawObject().createStruct(typeName, attributes);
return connection.getRawObject().getAutoCommit();
return connection.getRawObject().getCatalog();
return connection.getRawObject().getClientInfo();
return connection.getRawObject().getClientInfo(name);
return connection.getRawObject().getHoldability();
DatabaseMetaData rawDatabaseMetaData = connection.getRawObject().getMetaData();
return connection.getRawObject().getTransactionIsolation();
return connection.getRawObject().getTypeMap();
return connection.getRawObject().getWarnings();
return connection.getRawObject().isClosed();
return connection.getRawObject().isReadOnly();
return connection.getRawObject().isValid(timeout);
return connection.getRawObject().nativeSQL(sql);
CallableStatement statement = connection.getRawObject().prepareCall(sql);
CallableStatement statement = connection.getRawObject().prepareCall(sql, resultSetType,
CallableStatement statement = connection.getRawObject().prepareCall(sql, resultSetType,
PreparedStatement statement = connection.getRawObject().prepareStatement(sql);
PreparedStatement statement = connection.getRawObject().prepareStatement(sql, autoGeneratedKeys);
PreparedStatement statement = connection.getRawObject().prepareStatement(sql, resultSetType,
PreparedStatement statement = connection.getRawObject().prepareStatement(sql, resultSetType,
PreparedStatement statement = connection.getRawObject().prepareStatement(sql, columnIndexes);
PreparedStatement statement = connection.getRawObject().prepareStatement(sql, columnNames);
connection.getRawObject().releaseSavepoint(savepoint);
connection.getRawObject().rollback();
connection.getRawObject().rollback(savepoint);
connection.getRawObject().setAutoCommit(autoCommit);
connection.getRawObject().setCatalog(catalog);
connection.getRawObject().setClientInfo(properties);
connection.getRawObject().setClientInfo(name, value);
connection.getRawObject().setHoldability(holdability);
connection.getRawObject().setReadOnly(readOnly);
return connection.getRawObject().setSavepoint();
return connection.getRawObject().setSavepoint(name);
connection.getRawObject().setTransactionIsolation(level);
connection.getRawObject().setTypeMap(map);
ResultSet resultSet = statement.getRawObject().executeQuery(sql);
return statement.getRawObject().executeUpdate(sql);
statement.getRawObject().close();
return statement.getRawObject().getMaxFieldSize();
statement.getRawObject().setMaxFieldSize(max);
return statement.getRawObject().getMaxRows();
statement.getRawObject().setMaxRows(max);
statement.getRawObject().setEscapeProcessing(enable);
return statement.getRawObject().getQueryTimeout();
statement.getRawObject().setQueryTimeout(seconds);
statement.getRawObject().cancel();
return statement.getRawObject().getWarnings();
statement.getRawObject().clearWarnings();
statement.getRawObject().setCursorName(name);
return statement.getRawObject().execute(sql);
ResultSet resultSet = statement.getRawObject().getResultSet();
return statement.getRawObject().getUpdateCount();
return statement.getRawObject().getMoreResults();
statement.getRawObject().setFetchDirection(direction);
return statement.getRawObject().getFetchDirection();
statement.getRawObject().setFetchSize(rows);
return statement.getRawObject().getFetchSize();
return statement.getRawObject().getResultSetConcurrency();
return statement.getRawObject().getResultSetType();
statement.getRawObject().addBatch(sql);
statement.getRawObject().clearBatch();
return statement.getRawObject().executeBatch();
return statement.getRawObject().getConnection();
return statement.getRawObject().getMoreResults(current);
ResultSet resultSet = statement.getRawObject().getGeneratedKeys();
return statement.getRawObject().executeUpdate(sql, autoGeneratedKeys);
return statement.getRawObject().executeUpdate(sql, columnIndexes);
return statement.getRawObject().executeUpdate(sql, columnNames);
return statement.getRawObject().execute(sql, autoGeneratedKeys);
return statement.getRawObject().execute(sql, columnIndexes);
return statement.getRawObject().execute(sql, columnNames);
return statement.getRawObject().getResultSetHoldability();
return statement.getRawObject().isClosed();
statement.getRawObject().setPoolable(poolable);
return statement.getRawObject().isPoolable();
ResultSet resultSet = statement.getRawObject().executeQuery();
return statement.getRawObject().executeUpdate();
statement.getRawObject().setNull(parameterIndex, sqlType);
statement.getRawObject().setBoolean(parameterIndex, x);
statement.getRawObject().setByte(parameterIndex, x);
statement.getRawObject().setShort(parameterIndex, x);
statement.getRawObject().setInt(parameterIndex, x);
statement.getRawObject().setLong(parameterIndex, x);
statement.getRawObject().setFloat(parameterIndex, x);
statement.getRawObject().setDouble(parameterIndex, x);
statement.getRawObject().setBigDecimal(parameterIndex, x);
statement.getRawObject().setString(parameterIndex, x);
statement.getRawObject().setBytes(parameterIndex, x);
statement.getRawObject().setDate(parameterIndex, x);
statement.getRawObject().setTime(parameterIndex, x);
statement.getRawObject().setTimestamp(parameterIndex, x);
statement.getRawObject().setAsciiStream(parameterIndex, x, length);
statement.getRawObject().setUnicodeStream(parameterIndex, x, length);
statement.getRawObject().setBinaryStream(parameterIndex, x, length);
statement.getRawObject().clearParameters();
statement.getRawObject().setObject(parameterIndex, x, targetSqlType);
statement.getRawObject().setObject(parameterIndex, x);
return statement.getRawObject().execute();
statement.getRawObject().addBatch();
statement.getRawObject().setCharacterStream(parameterIndex, reader, length);
statement.getRawObject().setRef(parameterIndex, x);
statement.getRawObject().setBlob(parameterIndex, x);
statement.getRawObject().setClob(parameterIndex, x);
statement.getRawObject().setArray(parameterIndex, x);
return statement.getRawObject().getMetaData();
statement.getRawObject().setDate(parameterIndex, x, cal);
statement.getRawObject().setTime(parameterIndex, x, cal);
statement.getRawObject().setTimestamp(parameterIndex, x, cal);
statement.getRawObject().setNull(parameterIndex, sqlType, typeName);
statement.getRawObject().setURL(parameterIndex, x);
return statement.getRawObject().getParameterMetaData();
statement.getRawObject().setRowId(parameterIndex, x);
statement.getRawObject().setNString(parameterIndex, value);
statement.getRawObject().setNCharacterStream(parameterIndex, value, length);
statement.getRawObject().setNClob(parameterIndex, value);
statement.getRawObject().setClob(parameterIndex, reader, length);
statement.getRawObject().setBlob(parameterIndex, inputStream, length);
statement.getRawObject().setNClob(parameterIndex, reader, length);
statement.getRawObject().setSQLXML(parameterIndex, xmlObject);
statement.getRawObject().setObject(parameterIndex, x, targetSqlType, scaleOrLength);
statement.getRawObject().setAsciiStream(parameterIndex, x, length);
statement.getRawObject().setBinaryStream(parameterIndex, x, length);
statement.getRawObject().setCharacterStream(parameterIndex, reader, length);
statement.getRawObject().setAsciiStream(parameterIndex, x);
statement.getRawObject().setBinaryStream(parameterIndex, x);
statement.getRawObject().setCharacterStream(parameterIndex, reader);
statement.getRawObject().setNCharacterStream(parameterIndex, value);
statement.getRawObject().setClob(parameterIndex, reader);
statement.getRawObject().setBlob(parameterIndex, inputStream);
statement.getRawObject().setNClob(parameterIndex, reader);
statement.getRawObject().registerOutParameter(parameterIndex, sqlType);
statement.getRawObject().registerOutParameter(parameterIndex, sqlType, scale);
return statement.getRawObject().wasNull();
return statement.getRawObject().getString(parameterIndex);
return statement.getRawObject().getBoolean(parameterIndex);
return statement.getRawObject().getByte(parameterIndex);
return statement.getRawObject().getShort(parameterIndex);
return statement.getRawObject().getInt(parameterIndex);
return statement.getRawObject().getLong(parameterIndex);
return statement.getRawObject().getFloat(parameterIndex);
return statement.getRawObject().getDouble(parameterIndex);
return statement.getRawObject().getBigDecimal(parameterIndex, scale);
return statement.getRawObject().getBytes(parameterIndex);
return statement.getRawObject().getDate(parameterIndex);
return statement.getRawObject().getTime(parameterIndex);
return statement.getRawObject().getTimestamp(parameterIndex);
return statement.getRawObject().getObject(parameterIndex);
return statement.getRawObject().getBigDecimal(parameterIndex);
return statement.getRawObject().getObject(parameterIndex, map);
return statement.getRawObject().getRef(parameterIndex);
return statement.getRawObject().getBlob(parameterIndex);
Clob clob = statement.getRawObject().getClob(parameterIndex);
return statement.getRawObject().getArray(parameterIndex);
return statement.getRawObject().getDate(parameterIndex, cal);
return statement.getRawObject().getTime(parameterIndex, cal);
return statement.getRawObject().getTimestamp(parameterIndex, cal);
statement.getRawObject().registerOutParameter(parameterIndex, sqlType, typeName);
statement.getRawObject().registerOutParameter(parameterName, sqlType);
statement.getRawObject().registerOutParameter(parameterName, sqlType, scale);
statement.getRawObject().registerOutParameter(parameterName, sqlType, typeName);
return statement.getRawObject().getURL(parameterIndex);
statement.getRawObject().setURL(parameterName, val);
statement.getRawObject().setNull(parameterName, sqlType);
statement.getRawObject().setBoolean(parameterName, x);
statement.getRawObject().setByte(parameterName, x);
statement.getRawObject().setShort(parameterName, x);
statement.getRawObject().setInt(parameterName, x);
statement.getRawObject().setLong(parameterName, x);
statement.getRawObject().setFloat(parameterName, x);
statement.getRawObject().setDouble(parameterName, x);
statement.getRawObject().setBigDecimal(parameterName, x);
statement.getRawObject().setString(parameterName, x);
statement.getRawObject().setBytes(parameterName, x);
statement.getRawObject().setDate(parameterName, x);
statement.getRawObject().setTime(parameterName, x);
statement.getRawObject().setTimestamp(parameterName, x);
statement.getRawObject().setAsciiStream(parameterName, x, length);
statement.getRawObject().setBinaryStream(parameterName, x, length);
statement.getRawObject().setObject(parameterName, x, targetSqlType, scale);
statement.getRawObject().setObject(parameterName, x, targetSqlType);
statement.getRawObject().setObject(parameterName, x);
statement.getRawObject().setCharacterStream(parameterName, reader, length);
statement.getRawObject().setDate(parameterName, x, cal);
statement.getRawObject().setTime(parameterName, x, cal);
statement.getRawObject().setTimestamp(parameterName, x, cal);
statement.getRawObject().setNull(parameterName, sqlType, typeName);
return statement.getRawObject().getString(parameterName);
return statement.getRawObject().getBoolean(parameterName);
return statement.getRawObject().getByte(parameterName);
return statement.getRawObject().getShort(parameterName);
return statement.getRawObject().getInt(parameterName);
return statement.getRawObject().getLong(parameterName);
return statement.getRawObject().getFloat(parameterName);
return statement.getRawObject().getDouble(parameterName);
return statement.getRawObject().getBytes(parameterName);
return statement.getRawObject().getDate(parameterName);
return statement.getRawObject().getTime(parameterName);
return statement.getRawObject().getTimestamp(parameterName);
return statement.getRawObject().getObject(parameterName);
return statement.getRawObject().getBigDecimal(parameterName);
return statement.getRawObject().getObject(parameterName, map);
return statement.getRawObject().getRef(parameterName);
return statement.getRawObject().getBlob(parameterName);
Clob clob = statement.getRawObject().getClob(parameterName);
return statement.getRawObject().getArray(parameterName);
return statement.getRawObject().getDate(parameterName, cal);
return statement.getRawObject().getTime(parameterName, cal);
return statement.getRawObject().getTimestamp(parameterName, cal);
return statement.getRawObject().getURL(parameterName);
return statement.getRawObject().getRowId(parameterIndex);
return statement.getRawObject().getRowId(parameterName);
statement.getRawObject().setRowId(parameterName, x);
statement.getRawObject().setNString(parameterName, value);
statement.getRawObject().setNCharacterStream(parameterName, value, length);
statement.getRawObject().setNClob(parameterName, value);
statement.getRawObject().setClob(parameterName, reader, length);
statement.getRawObject().setBlob(parameterName, inputStream, length);
statement.getRawObject().setNClob(parameterName, reader, length);
NClob nclob = statement.getRawObject().getNClob(parameterIndex);
NClob nclob = statement.getRawObject().getNClob(parameterName);
statement.getRawObject().setSQLXML(parameterName, xmlObject);
return statement.getRawObject().getSQLXML(parameterIndex);
return statement.getRawObject().getSQLXML(parameterName);
return statement.getRawObject().getNString(parameterIndex);
return statement.getRawObject().getNString(parameterName);
return statement.getRawObject().getNCharacterStream(parameterIndex);
return statement.getRawObject().getNCharacterStream(parameterName);
return statement.getRawObject().getCharacterStream(parameterIndex);
return statement.getRawObject().getCharacterStream(parameterName);
statement.getRawObject().setBlob(parameterName, x);
statement.getRawObject().setClob(parameterName, x);
statement.getRawObject().setAsciiStream(parameterName, x, length);
statement.getRawObject().setBinaryStream(parameterName, x, length);
statement.getRawObject().setCharacterStream(parameterName, reader, length);
statement.getRawObject().setAsciiStream(parameterName, x);
statement.getRawObject().setBinaryStream(parameterName, x);
statement.getRawObject().setCharacterStream(parameterName, reader);
statement.getRawObject().setNCharacterStream(parameterName, value);
statement.getRawObject().setClob(parameterName, reader);
statement.getRawObject().setBlob(parameterName, inputStream);
statement.getRawObject().setNClob(parameterName, reader);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == CallableStatement.class) {
if (stmt instanceof CallableStatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
if (iface == Connection.class) {
if (conn instanceof ConnectionProxy) {
return conn.unwrap(iface);
return (T) conn;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
if (stmt instanceof PreparedStatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == ResultSet.class) {
if (rs instanceof ResultSetProxy) {
return rs.unwrap(iface);
return (T) rs;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Statement.class) {
if (stmt instanceof StatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
return super.unwrap(iface);
public Connection getRawObject() {
stmt = conn.getRawObject().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
stmt = conn.getRawObject().createStatement(resultSetType, resultSetConcurrency);
stmt = conn.getRawObject().createStatement();
conn = ((ConnectionProxy) conn).getRawObject();
CallableStatement getRawObject();
public CallableStatement getRawObject() {
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
return (T) statement;
return super.unwrap(iface);
Connection getRawObject();
public Connection getRawObject() {
return connection;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Connection.class) {
return (T) connection;
return super.unwrap(iface);
PreparedStatement getRawObject();
public PreparedStatement getRawObject() {
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
return (T) statement;
return super.unwrap(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == ResultSet.class) {
return (T) resultSet;
return super.unwrap(iface);
Statement getRawObject();
public Statement getRawObject() {
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Statement.class) {
return (T) statement;
return super.unwrap(iface);
public class DruidJdbcExtractor extends Jdbc4NativeJdbcExtractor {
conn = ((ConnectionProxy) conn).getRawObject();
stmt = ((StatementProxy) stmt).getRawObject();
stmt = ((PreparedStatementProxy) stmt).getRawObject();
stmt = ((CallableStatementProxy) stmt).getRawObject();
@SuppressWarnings("deprecation")
Assert.assertEquals(((ConnectionProxy) conn.getConnection()).getRawObject(), conn.unwrap(Connection.class));
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
Jdbc4NativeJdbcExtractor extractor = new Jdbc4NativeJdbcExtractor();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
public class Jdbc4ExtractorTest extends TestCase {
public void test_spring() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
Jdbc4NativeJdbcExtractor extractor = new Jdbc4NativeJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
ResultSet rs = preStmt.executeQuery();
Assert.assertEquals(true, extractor.getNativeResultSet(rs) instanceof MockResultSet);
rs.close();
preStmt.close();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
conn.close();
} finally {
dataSource.close();
public void test_spring_filter() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
DruidJdbcExtractor extractor = new DruidJdbcExtractor();
dataSource.setUrl("jdbc:mock:xx1");
dataSource.setFilters("stat");
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, extractor.getNativeConnection(conn) instanceof MockConnection);
Statement stmt = conn.createStatement();
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(stmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(stmt) instanceof MockStatement);
stmt.close();
PreparedStatement preStmt = conn.prepareStatement("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(preStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(preStmt) instanceof MockPreparedStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(preStmt) instanceof MockPreparedStatement);
ResultSet rs = preStmt.executeQuery();
Assert.assertEquals(true, extractor.getNativeResultSet(rs) instanceof MockResultSet);
rs.close();
preStmt.close();
PreparedStatement callStmt = conn.prepareCall("select 1");
Assert.assertEquals(true, extractor.getNativeConnectionFromStatement(callStmt) instanceof MockConnection);
Assert.assertEquals(true, extractor.getNativeStatement(callStmt) instanceof MockCallableStatement);
Assert.assertEquals(true, extractor.getNativePreparedStatement(callStmt) instanceof MockCallableStatement);
callStmt.close();
conn.close();
} finally {
dataSource.close();
private static final long                                                                   serialVersionUID                          = 1L;
public final static int                                                                     DEFAULT_INITIAL_SIZE                      = 0;
public final static int                                                                     DEFAULT_MAX_ACTIVE_SIZE                   = 8;
public final static int                                                                     DEFAULT_MAX_IDLE                          = 8;
public final static int                                                                     DEFAULT_MIN_IDLE                          = 0;
public final static int                                                                     DEFAULT_MAX_WAIT                          = -1;
public final static String                                                                  DEFAULT_VALIDATION_QUERY                  = null;                                                                             
public final static boolean                                                                 DEFAULT_TEST_ON_BORROW                    = true;
public final static boolean                                                                 DEFAULT_TEST_ON_RETURN                    = false;
public final static boolean                                                                 DEFAULT_WHILE_IDLE                        = false;
public static final long                                                                    DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final long                                                                    DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS = 30 * 1000;
public static final int                                                                     DEFAULT_NUM_TESTS_PER_EVICTION_RUN        = 3;
public static final long                                                                    DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS    = 1000L * 60L * 30L;
protected boolean                                                                           defaultAutoCommit                         = true;
protected Boolean                                                                           defaultReadOnly;
protected Integer                                                                           defaultTransactionIsolation;
protected String                                                                            defaultCatalog                            = null;
protected String                                                                            name;
protected String                                                                            username;
protected String                                                                            password;
protected String                                                                            jdbcUrl;
protected String                                                                            driverClass;
protected Properties                                                                        connectionProperties                      = new Properties();
protected PasswordCallback                                                                  passwordCallback;
protected NameCallback                                                                      userCallback;
protected ConnectionFactory                                                                 connectionFactory;
protected int                                                                               initialSize                               = DEFAULT_INITIAL_SIZE;
protected int                                                                               maxActive                                 = DEFAULT_MAX_ACTIVE_SIZE;
protected int                                                                               minIdle                                   = DEFAULT_MIN_IDLE;
protected int                                                                               maxIdle                                   = DEFAULT_MAX_IDLE;
protected long                                                                              maxWait                                   = DEFAULT_MAX_WAIT;
protected String                                                                            validationQuery                           = DEFAULT_VALIDATION_QUERY;
protected int                                                                               validationQueryTimeout                    = -1;
private boolean                                                                             testOnBorrow                              = DEFAULT_TEST_ON_BORROW;
private boolean                                                                             testOnReturn                              = DEFAULT_TEST_ON_RETURN;
private boolean                                                                             testWhileIdle                             = DEFAULT_WHILE_IDLE;
protected boolean                                                                           poolPreparedStatements                    = false;
protected boolean                                                                           sharePreparedStatements                   = false;
protected int                                                                               maxPoolPreparedStatementPerConnectionSize = 10;
protected boolean                                                                           inited                                    = false;
protected PrintWriter                                                                       logWriter                                 = new PrintWriter(
System.out);
protected List<Filter>                                                                      filters                                   = new ArrayList<Filter>();
protected ExceptionSorter                                                                   exceptionSorter                           = null;
protected Driver                                                                            driver;
protected int                                                                               queryTimeout;
protected int                                                                               transactionQueryTimeout;
protected long                                                                              createErrorCount;
protected long                                                                              createTimespan;
protected int                                                                               maxWaitThreadCount                        = -1;
protected boolean                                                                           accessToUnderlyingConnectionAllowed       = true;
protected long                                                                              timeBetweenEvictionRunsMillis             = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
protected int                                                                               numTestsPerEvictionRun                    = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
protected long                                                                              minEvictableIdleTimeMillis                = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
protected boolean                                                                           removeAbandoned;
protected long                                                                              removeAbandonedTimeoutMillis              = 300 * 1000;
protected boolean                                                                           logAbandoned;
protected int                                                                               maxOpenPreparedStatements                 = -1;
protected List<String>                                                                      connectionInitSqls;
protected String                                                                            dbType;
protected long                                                                              timeBetweenConnectErrorMillis             = DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS;
protected ValidConnectionChecker                                                            validConnectionChecker                    = null;
protected final AtomicLong                                                                  errorCount                                = new AtomicLong();
protected final AtomicLong                                                                  dupCloseCount                             = new AtomicLong();
protected long                                                                              id;
protected Date                                                                              createdTime;
protected int                                                                               connectionErrorRetryAttempts              = 30;
protected boolean                                                                           breakAfterAcquireFailure                  = false;
protected long                                                                              transactionThresholdMillis                = 0L;
protected final AtomicLong                                                                  commitCount                               = new AtomicLong();
protected final AtomicLong                                                                  startTransactionCount                     = new AtomicLong();
protected final AtomicLong                                                                  rollbackCount                             = new AtomicLong();
protected final AtomicLong                                                                  cachedPreparedStatementHitCount           = new AtomicLong();
protected final AtomicLong                                                                  preparedStatementCount                    = new AtomicLong();
protected final AtomicLong                                                                  closedPreparedStatementCount              = new AtomicLong();
protected final AtomicLong                                                                  cachedPreparedStatementCount              = new AtomicLong();
protected final AtomicLong                                                                  cachedPreparedStatementDeleteCount        = new AtomicLong();
protected final AtomicLong                                                                  cachedPreparedStatementMissCount          = new AtomicLong();
protected final Histogram                                                                   transactionHistogram                      = new Histogram(
10 * 1000,
100 * 1000);
private boolean                                                                             dupCloseLogEnable                         = true;
private ObjectName                                                                          objectName;
private final AtomicLong                                                                    executeCount                              = new AtomicLong();
protected Throwable                                                                         createError;
protected Throwable                                                                         lastError;
protected long                                                                              lastErrorTimeMillis;
protected Throwable                                                                         lastCreateError;
protected long                                                                              lastCreateErrorTimeMillis;
protected boolean                                                                           isOracle                                  = false;
protected boolean                                                                           useOracleImplicitCache                    = false;
public void setOracle(boolean isOracle) {
this.isOracle = isOracle;
throws SQLException;
private boolean                 closed                  = false;
if (this.closed) {
this.closed = true;
private final DruidPooledConnection connection;
private final long                  connectTime;
private final StackTraceElement[]   stackTrace;
public ActiveConnectionTraceInfo(DruidPooledConnection connection, long connectTime,
StackTraceElement[] stackTrace){
return (T) conn;
if (iface.isInstance(conn)) {
public class TestOraclePrefetch extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setOracle(true);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(new OracleMockDriver());
dataSource.setPoolPreparedStatements(true);
dataSource.setConnectionProperties("defaultRowPrefetch=50");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_oracle() throws Exception {
String sql = "SELECT 1";
Connection conn = dataSource.getConnection();
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
Assert.assertEquals(50, oracleConn.getDefaultRowPrefetch());
PreparedStatement stmt = conn.prepareStatement(sql);
OraclePreparedStatement oracleStmt = stmt.unwrap(OraclePreparedStatement.class);
Assert.assertEquals(50, oracleStmt.getRowPrefetch());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
OracleConnection oracleConn = conn.unwrap(OracleConnection.class);
Assert.assertEquals(50, oracleConn.getDefaultRowPrefetch());
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
OraclePreparedStatement oracleStmt = stmt.unwrap(OraclePreparedStatement.class);
Assert.assertEquals(2, oracleStmt.getRowPrefetch());
rs.close();
stmt.close();
conn.close();
dataSource.close();
public class OracleMockConnection extends MockConnection implements oracle.jdbc.OracleConnection {
private int defaultRowPrefetch = 10;
public OracleMockConnection(){
public OracleMockConnection(MockDriver driver, String url, Properties connectProperties){
super(driver, url, connectProperties);
String val = (String) connectProperties.get("defaultRowPrefetch");
if (val != null) {
defaultRowPrefetch = Integer.parseInt(val);
public Connection _getPC() {
return null;
public void abort() throws SQLException {
public void applyConnectionAttributes(Properties arg0) throws SQLException {
public void archive(int arg0, int arg1, String arg2) throws SQLException {
public void cancel() throws SQLException {
public void clearAllApplicationContext(String arg0) throws SQLException {
public void close(Properties arg0) throws SQLException {
public void close(int arg0) throws SQLException {
public void commit(EnumSet<CommitOption> arg0) throws SQLException {
public ARRAY createARRAY(String arg0, Object arg1) throws SQLException {
return null;
public BINARY_DOUBLE createBINARY_DOUBLE(double arg0) throws SQLException {
return null;
public BINARY_FLOAT createBINARY_FLOAT(float arg0) throws SQLException {
return null;
public DATE createDATE(Date arg0) throws SQLException {
return null;
public DATE createDATE(Time arg0) throws SQLException {
return null;
public DATE createDATE(Timestamp arg0) throws SQLException {
return null;
public DATE createDATE(String arg0) throws SQLException {
return null;
public DATE createDATE(Date arg0, Calendar arg1) throws SQLException {
return null;
public DATE createDATE(Time arg0, Calendar arg1) throws SQLException {
return null;
public DATE createDATE(Timestamp arg0, Calendar arg1) throws SQLException {
return null;
public INTERVALDS createINTERVALDS(String arg0) throws SQLException {
return null;
public INTERVALYM createINTERVALYM(String arg0) throws SQLException {
return null;
public NUMBER createNUMBER(boolean arg0) throws SQLException {
return null;
public NUMBER createNUMBER(byte arg0) throws SQLException {
return null;
public NUMBER createNUMBER(short arg0) throws SQLException {
return null;
public NUMBER createNUMBER(int arg0) throws SQLException {
return null;
public NUMBER createNUMBER(long arg0) throws SQLException {
return null;
public NUMBER createNUMBER(float arg0) throws SQLException {
return null;
public NUMBER createNUMBER(double arg0) throws SQLException {
return null;
public NUMBER createNUMBER(BigDecimal arg0) throws SQLException {
return null;
public NUMBER createNUMBER(BigInteger arg0) throws SQLException {
return null;
public NUMBER createNUMBER(String arg0, int arg1) throws SQLException {
return null;
public Array createOracleArray(String arg0, Object arg1) throws SQLException {
return null;
public TIMESTAMP createTIMESTAMP(Date arg0) throws SQLException {
return null;
public TIMESTAMP createTIMESTAMP(DATE arg0) throws SQLException {
return null;
public TIMESTAMP createTIMESTAMP(Time arg0) throws SQLException {
return null;
public TIMESTAMP createTIMESTAMP(Timestamp arg0) throws SQLException {
return null;
public TIMESTAMP createTIMESTAMP(String arg0) throws SQLException {
return null;
public TIMESTAMPLTZ createTIMESTAMPLTZ(Date arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPLTZ createTIMESTAMPLTZ(Time arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPLTZ createTIMESTAMPLTZ(Timestamp arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPLTZ createTIMESTAMPLTZ(String arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPLTZ createTIMESTAMPLTZ(DATE arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Date arg0) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Time arg0) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Timestamp arg0) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(String arg0) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(DATE arg0) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Date arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Time arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(Timestamp arg0, Calendar arg1) throws SQLException {
return null;
public TIMESTAMPTZ createTIMESTAMPTZ(String arg0, Calendar arg1) throws SQLException {
return null;
public AQMessage dequeue(String arg0, AQDequeueOptions arg1, byte[] arg2) throws SQLException {
return null;
public AQMessage dequeue(String arg0, AQDequeueOptions arg1, String arg2) throws SQLException {
return null;
public void enqueue(String arg0, AQEnqueueOptions arg1, AQMessage arg2) throws SQLException {
public TypeDescriptor[] getAllTypeDescriptorsInCurrentSchema() throws SQLException {
return null;
public String getAuthenticationAdaptorName() throws SQLException {
return null;
public boolean getAutoClose() throws SQLException {
return false;
public CallableStatement getCallWithKey(String arg0) throws SQLException {
return null;
public Properties getConnectionAttributes() throws SQLException {
return null;
public int getConnectionReleasePriority() throws SQLException {
public boolean getCreateStatementAsRefCursor() {
return false;
public String getCurrentSchema() throws SQLException {
return null;
public String getDataIntegrityAlgorithmName() throws SQLException {
return null;
public DatabaseChangeRegistration getDatabaseChangeRegistration(int arg0) throws SQLException {
return null;
public int getDefaultExecuteBatch() {
public int getDefaultRowPrefetch() {
return defaultRowPrefetch;
public TimeZone getDefaultTimeZone() throws SQLException {
return null;
public Object getDescriptor(String arg0) {
return null;
public String getEncryptionAlgorithmName() throws SQLException {
return null;
public short getEndToEndECIDSequenceNumber() throws SQLException {
public String[] getEndToEndMetrics() throws SQLException {
return null;
public boolean getExplicitCachingEnabled() throws SQLException {
return false;
public boolean getImplicitCachingEnabled() throws SQLException {
return false;
public boolean getIncludeSynonyms() {
return false;
public Object getJavaObject(String arg0) throws SQLException {
return null;
public Properties getProperties() {
return null;
public boolean getRemarksReporting() {
return false;
public boolean getRestrictGetTables() {
return false;
public String getSQLType(Object arg0) throws SQLException {
return null;
public String getSessionTimeZone() {
return null;
public String getSessionTimeZoneOffset() throws SQLException {
return null;
public int getStatementCacheSize() throws SQLException {
public PreparedStatement getStatementWithKey(String arg0) throws SQLException {
return null;
public int getStmtCacheSize() {
public short getStructAttrCsId() throws SQLException {
public TypeDescriptor[] getTypeDescriptorsFromList(String[][] arg0) throws SQLException {
return null;
public TypeDescriptor[] getTypeDescriptorsFromListInCurrentSchema(String[] arg0) throws SQLException {
return null;
public Properties getUnMatchedConnectionAttributes() throws SQLException {
return null;
public String getUserName() throws SQLException {
return null;
public boolean getUsingXAFlag() {
return false;
public boolean getXAErrorFlag() {
return false;
public boolean isLogicalConnection() {
return false;
public boolean isProxySession() {
return false;
public boolean isUsable() {
return false;
public void openProxySession(int arg0, Properties arg1) throws SQLException {
public void oracleReleaseSavepoint(OracleSavepoint arg0) throws SQLException {
public void oracleRollback(OracleSavepoint arg0) throws SQLException {
public OracleSavepoint oracleSetSavepoint() throws SQLException {
return null;
public OracleSavepoint oracleSetSavepoint(String arg0) throws SQLException {
return null;
public OracleConnection physicalConnectionWithin() {
return null;
public int pingDatabase() throws SQLException {
public int pingDatabase(int arg0) throws SQLException {
public CallableStatement prepareCallWithKey(String arg0) throws SQLException {
return null;
public PreparedStatement prepareStatementWithKey(String arg0) throws SQLException {
return null;
public void purgeExplicitCache() throws SQLException {
public void purgeImplicitCache() throws SQLException {
public void putDescriptor(String arg0, Object arg1) throws SQLException {
public AQNotificationRegistration[] registerAQNotification(String[] arg0, Properties[] arg1, Properties arg2)
throws SQLException {
return null;
public void registerConnectionCacheCallback(OracleConnectionCacheCallback arg0, Object arg1, int arg2)
throws SQLException {
public DatabaseChangeRegistration registerDatabaseChangeNotification(Properties arg0) throws SQLException {
return null;
public void registerSQLType(String arg0, Class arg1) throws SQLException {
public void registerSQLType(String arg0, String arg1) throws SQLException {
public void registerTAFCallback(OracleOCIFailover arg0, Object arg1) throws SQLException {
public void setApplicationContext(String arg0, String arg1, String arg2) throws SQLException {
public void setAutoClose(boolean arg0) throws SQLException {
public void setConnectionReleasePriority(int arg0) throws SQLException {
public void setCreateStatementAsRefCursor(boolean arg0) {
public void setDefaultExecuteBatch(int arg0) throws SQLException {
public void setDefaultRowPrefetch(int defaultRowPrefetch) throws SQLException {
this.defaultRowPrefetch = defaultRowPrefetch;
public void setDefaultTimeZone(TimeZone arg0) throws SQLException {
public void setEndToEndMetrics(String[] arg0, short arg1) throws SQLException {
public void setExplicitCachingEnabled(boolean arg0) throws SQLException {
public void setImplicitCachingEnabled(boolean arg0) throws SQLException {
public void setIncludeSynonyms(boolean arg0) {
public void setPlsqlWarnings(String arg0) throws SQLException {
public void setRemarksReporting(boolean arg0) {
public void setRestrictGetTables(boolean arg0) {
public void setSessionTimeZone(String arg0) throws SQLException {
public void setStatementCacheSize(int arg0) throws SQLException {
public void setStmtCacheSize(int arg0) throws SQLException {
public void setStmtCacheSize(int arg0, boolean arg1) throws SQLException {
public void setUsingXAFlag(boolean arg0) {
public void setWrapper(oracle.jdbc.OracleConnection arg0) {
public void setXAErrorFlag(boolean arg0) {
public void shutdown(DatabaseShutdownMode arg0) throws SQLException {
public void startup(DatabaseStartupMode arg0) throws SQLException {
public void startup(String arg0, int arg1) throws SQLException {
public void unregisterAQNotification(AQNotificationRegistration arg0) throws SQLException {
public void unregisterDatabaseChangeNotification(DatabaseChangeRegistration arg0) throws SQLException {
public void unregisterDatabaseChangeNotification(int arg0) throws SQLException {
public void unregisterDatabaseChangeNotification(long arg0, String arg1) throws SQLException {
public void unregisterDatabaseChangeNotification(int arg0, String arg1, int arg2) throws SQLException {
public oracle.jdbc.OracleConnection unwrap() {
return null;
public PreparedStatement prepareStatement(String sql) throws SQLException {
if (isClosed()) {
throw new MockConnectionClosedException();
return new OracleMockPreparedStatement(this, sql);
public class OracleMockDriver extends MockDriver {
public Connection connect(String url, Properties info) throws SQLException {
return new OracleMockConnection(this, url, info);
public class OracleMockPreparedStatement extends MockPreparedStatement implements oracle.jdbc.internal.OraclePreparedStatement {
private int executeBatch = 50;
private int rowPrefetch;
public OracleMockPreparedStatement(OracleMockConnection conn, String sql){
super(conn, sql);
this.rowPrefetch = conn.getDefaultRowPrefetch();
public OracleParameterMetaData OracleGetParameterMetaData() throws SQLException {
return null;
public void defineParameterType(int arg0, int arg1, int arg2) throws SQLException {
public void defineParameterTypeBytes(int arg0, int arg1, int arg2) throws SQLException {
public void defineParameterTypeChars(int arg0, int arg1, int arg2) throws SQLException {
public int getExecuteBatch() {
return executeBatch;
public ResultSet getReturnResultSet() throws SQLException {
return null;
public void registerReturnParameter(int arg0, int arg1) throws SQLException {
public void registerReturnParameter(int arg0, int arg1, int arg2) throws SQLException {
public void registerReturnParameter(int arg0, int arg1, String arg2) throws SQLException {
public int sendBatch() throws SQLException {
public void setARRAY(int arg0, ARRAY arg1) throws SQLException {
public void setARRAYAtName(String arg0, ARRAY arg1) throws SQLException {
public void setArrayAtName(String arg0, Array arg1) throws SQLException {
public void setAsciiStreamAtName(String arg0, InputStream arg1, int arg2) throws SQLException {
public void setBFILE(int arg0, BFILE arg1) throws SQLException {
public void setBFILEAtName(String arg0, BFILE arg1) throws SQLException {
public void setBLOB(int arg0, BLOB arg1) throws SQLException {
public void setBLOBAtName(String arg0, BLOB arg1) throws SQLException {
public void setBfile(int arg0, BFILE arg1) throws SQLException {
public void setBfileAtName(String arg0, BFILE arg1) throws SQLException {
public void setBigDecimalAtName(String arg0, BigDecimal arg1) throws SQLException {
public void setBinaryDouble(int arg0, double arg1) throws SQLException {
public void setBinaryDouble(int arg0, BINARY_DOUBLE arg1) throws SQLException {
public void setBinaryDoubleAtName(String arg0, double arg1) throws SQLException {
public void setBinaryDoubleAtName(String arg0, BINARY_DOUBLE arg1) throws SQLException {
public void setBinaryFloat(int arg0, float arg1) throws SQLException {
public void setBinaryFloat(int arg0, BINARY_FLOAT arg1) throws SQLException {
public void setBinaryFloatAtName(String arg0, float arg1) throws SQLException {
public void setBinaryFloatAtName(String arg0, BINARY_FLOAT arg1) throws SQLException {
public void setBinaryStreamAtName(String arg0, InputStream arg1, int arg2) throws SQLException {
public void setBlobAtName(String arg0, Blob arg1) throws SQLException {
public void setBooleanAtName(String arg0, boolean arg1) throws SQLException {
public void setByteAtName(String arg0, byte arg1) throws SQLException {
public void setBytesAtName(String arg0, byte[] arg1) throws SQLException {
public void setBytesForBlob(int arg0, byte[] arg1) throws SQLException {
public void setBytesForBlobAtName(String arg0, byte[] arg1) throws SQLException {
public void setCHAR(int arg0, CHAR arg1) throws SQLException {
public void setCHARAtName(String arg0, CHAR arg1) throws SQLException {
public void setCLOB(int arg0, CLOB arg1) throws SQLException {
public void setCLOBAtName(String arg0, CLOB arg1) throws SQLException {
public void setClobAtName(String arg0, Clob arg1) throws SQLException {
public void setCursor(int arg0, ResultSet arg1) throws SQLException {
public void setCursorAtName(String arg0, ResultSet arg1) throws SQLException {
public void setCustomDatum(int arg0, CustomDatum arg1) throws SQLException {
public void setCustomDatumAtName(String arg0, CustomDatum arg1) throws SQLException {
public void setDATE(int arg0, DATE arg1) throws SQLException {
public void setDATEAtName(String arg0, DATE arg1) throws SQLException {
public void setDateAtName(String arg0, Date arg1) throws SQLException {
public void setDateAtName(String arg0, Date arg1, Calendar arg2) throws SQLException {
public void setDisableStmtCaching(boolean arg0) {
public void setDoubleAtName(String arg0, double arg1) throws SQLException {
public void setExecuteBatch(int executeBatch) throws SQLException {
this.executeBatch = executeBatch;
public void setFixedCHAR(int arg0, String arg1) throws SQLException {
public void setFixedCHARAtName(String arg0, String arg1) throws SQLException {
public void setFloatAtName(String arg0, float arg1) throws SQLException {
public void setFormOfUse(int arg0, short arg1) {
public void setINTERVALDS(int arg0, INTERVALDS arg1) throws SQLException {
public void setINTERVALDSAtName(String arg0, INTERVALDS arg1) throws SQLException {
public void setINTERVALYM(int arg0, INTERVALYM arg1) throws SQLException {
public void setINTERVALYMAtName(String arg0, INTERVALYM arg1) throws SQLException {
public void setIntAtName(String arg0, int arg1) throws SQLException {
public void setLongAtName(String arg0, long arg1) throws SQLException {
public void setNUMBER(int arg0, NUMBER arg1) throws SQLException {
public void setNUMBERAtName(String arg0, NUMBER arg1) throws SQLException {
public void setNullAtName(String arg0, int arg1) throws SQLException {
public void setNullAtName(String arg0, int arg1, String arg2) throws SQLException {
public void setOPAQUE(int arg0, OPAQUE arg1) throws SQLException {
public void setOPAQUEAtName(String arg0, OPAQUE arg1) throws SQLException {
public void setORAData(int arg0, ORAData arg1) throws SQLException {
public void setORADataAtName(String arg0, ORAData arg1) throws SQLException {
public void setObjectAtName(String arg0, Object arg1) throws SQLException {
public void setObjectAtName(String arg0, Object arg1, int arg2) throws SQLException {
public void setObjectAtName(String arg0, Object arg1, int arg2, int arg3) throws SQLException {
public void setOracleObject(int arg0, Datum arg1) throws SQLException {
public void setOracleObjectAtName(String arg0, Datum arg1) throws SQLException {
public void setPlsqlIndexTable(int arg0, Object arg1, int arg2, int arg3, int arg4, int arg5) throws SQLException {
public void setRAW(int arg0, RAW arg1) throws SQLException {
public void setRAWAtName(String arg0, RAW arg1) throws SQLException {
public void setREF(int arg0, REF arg1) throws SQLException {
public void setREFAtName(String arg0, REF arg1) throws SQLException {
public void setROWID(int arg0, ROWID arg1) throws SQLException {
public void setROWIDAtName(String arg0, ROWID arg1) throws SQLException {
public void setRefAtName(String arg0, Ref arg1) throws SQLException {
public void setRefType(int arg0, REF arg1) throws SQLException {
public void setRefTypeAtName(String arg0, REF arg1) throws SQLException {
public void setSTRUCT(int arg0, STRUCT arg1) throws SQLException {
public void setSTRUCTAtName(String arg0, STRUCT arg1) throws SQLException {
public void setShortAtName(String arg0, short arg1) throws SQLException {
public void setStringAtName(String arg0, String arg1) throws SQLException {
public void setStringForClob(int arg0, String arg1) throws SQLException {
public void setStringForClobAtName(String arg0, String arg1) throws SQLException {
public void setStructDescriptor(int arg0, StructDescriptor arg1) throws SQLException {
public void setStructDescriptorAtName(String arg0, StructDescriptor arg1) throws SQLException {
public void setTIMESTAMP(int arg0, TIMESTAMP arg1) throws SQLException {
public void setTIMESTAMPAtName(String arg0, TIMESTAMP arg1) throws SQLException {
public void setTIMESTAMPLTZ(int arg0, TIMESTAMPLTZ arg1) throws SQLException {
public void setTIMESTAMPLTZAtName(String arg0, TIMESTAMPLTZ arg1) throws SQLException {
public void setTIMESTAMPTZ(int arg0, TIMESTAMPTZ arg1) throws SQLException {
public void setTIMESTAMPTZAtName(String arg0, TIMESTAMPTZ arg1) throws SQLException {
public void setTimeAtName(String arg0, Time arg1) throws SQLException {
public void setTimeAtName(String arg0, Time arg1, Calendar arg2) throws SQLException {
public void setTimestampAtName(String arg0, Timestamp arg1) throws SQLException {
public void setTimestampAtName(String arg0, Timestamp arg1, Calendar arg2) throws SQLException {
public void setURLAtName(String arg0, URL arg1) throws SQLException {
public void setUnicodeStreamAtName(String arg0, InputStream arg1, int arg2) throws SQLException {
public void clearDefines() throws SQLException {
public void closeWithKey(String arg0) throws SQLException {
public int creationState() {
public void defineColumnType(int arg0, int arg1) throws SQLException {
public void defineColumnType(int arg0, int arg1, int arg2) throws SQLException {
public void defineColumnType(int arg0, int arg1, String arg2) throws SQLException {
public void defineColumnType(int arg0, int arg1, int arg2, short arg3) throws SQLException {
public void defineColumnTypeBytes(int arg0, int arg1, int arg2) throws SQLException {
public void defineColumnTypeChars(int arg0, int arg1, int arg2) throws SQLException {
public int getLobPrefetchSize() {
public long getRegisteredQueryId() throws SQLException {
public String[] getRegisteredTableNames() throws SQLException {
return null;
public int getRowPrefetch() {
return rowPrefetch;
public boolean isNCHAR(int arg0) throws SQLException {
return false;
public void setDatabaseChangeRegistration(DatabaseChangeRegistration arg0) throws SQLException {
public void setLobPrefetchSize(int arg0) throws SQLException {
public void setResultSetCache(OracleResultSetCache arg0) throws SQLException {
public void setRowPrefetch(int rowPrefetch) throws SQLException {
this.rowPrefetch = rowPrefetch;
public long getChecksum() throws SQLException {
public boolean getFixedString() {
return false;
public SqlKind getSqlKind() throws SQLException {
return null;
public int getcacheState() {
public boolean getserverCursor() {
return false;
public int getstatementType() {
public void setFixedString(boolean arg0) {
public void setSnapshotSCN(long arg0) throws SQLException {
public void enterExplicitCache() throws SQLException {
public void enterImplicitCache() throws SQLException {
public void exitExplicitCacheToActive() throws SQLException {
public void exitExplicitCacheToClose() throws SQLException {
public void exitImplicitCacheToActive() throws SQLException {
public void exitImplicitCacheToClose() throws SQLException {
public String getOriginalSql() throws SQLException {
return null;
public void setCharacterStreamAtName(String arg0, Reader arg1, int arg2) throws SQLException {
public void setCheckBindTypes(boolean arg0) {
public void setInternalBytes(int arg0, byte[] arg1, int arg2) throws SQLException {
public JdbcSqlStat createSqlStat(StatementProxy statement, String sql) {
if (inited) {
throw new IllegalStateException();
public class DruidNativeJdbcExtractor extends NativeJdbcExtractorAdapter {
protected Connection doGetNativeConnection(Connection con) throws SQLException {
return (Connection) con.unwrap(Connection.class);
public Statement getNativeStatement(Statement stmt) throws SQLException {
return (Statement) stmt.unwrap(Statement.class);
public PreparedStatement getNativePreparedStatement(PreparedStatement ps) throws SQLException {
return (PreparedStatement) ps.unwrap(PreparedStatement.class);
public CallableStatement getNativeCallableStatement(CallableStatement cs) throws SQLException {
return (CallableStatement) cs.unwrap(CallableStatement.class);
public ResultSet getNativeResultSet(ResultSet rs) throws SQLException {
return (ResultSet) rs.unwrap(ResultSet.class);
DruidNativeJdbcExtractor extractor = new DruidNativeJdbcExtractor();
public int getDriverMajorVersion() {
if (this.driver == null) {
return -1;
return this.driver.getMajorVersion();
public int getDriverMinorVersion() {
if (this.driver == null) {
return -1;
return this.driver.getMinorVersion();
int getDriverMajorVersion();
int getDriverMinorVersion();
resultSet.setConstructNano();
event.putContext(TRACE_RS_CURSOR_INDEX, resultSet.getCursorIndex());
event.putContext(TRACE_RS_CURSOR_INDEX, resultSet.getCursorIndex());
event.putContext(TRACE_RS_CURSOR_INDEX, resultSet.getCursorIndex());
event.putContext("rs.fetchRowIndex", resultSet.getCursorIndex());
resultSet.setConstructNano();
void setConstructNano();
public void setConstructNano() {
if (this.constructNano <= 0) {
this.constructNano = System.nanoTime();
intervalExpr.setUnit(MySqlIntervalUnit.valueOf(unit.toUpperCase()));
if ((!autoCommit) && holder.isUnderlyingAutoCommit()) {
public class DruidConsole {
private ProxyClient           proxy;
private Console               console;
private PrintWriter           out;
private List<DataSourceEntry> entries = new ArrayList<DataSourceEntry>();
private DruidConsole(){
console = System.console();
out = console.writer();
public void run() throws Exception {
proxy = ProxyClient.getProxyClient("10.20.133.134", 9006, null, null);
proxy.connect();
for (;;) {
String line = console.readLine();
if ("exit".equals(line)) {
if ("ls".equals(line)) {
if ("desc".equals(line)) {
desc(line);
if (line.startsWith("show ")) {
show(line);
public void show(String line) throws Exception {
String[] items = line.split(" ");
DataSourceEntry current;
String arg = items[1];
int index = Integer.parseInt(arg);
current = entries.get(index);
long interval = 0;
String tmp = items[2];
interval = Long.parseLong(tmp);
String[] attributes = new String[] { "CreateCount", "DestroyCount", "ActivePeak", "ActiveCount", "PoolingCount", "CommitCount", "RollbackCount" };
String[] titles = attributes;
for (int i = 0; i < titles.length; ++i) {
if (i != 0) {
out.print("tt");
out.print(titles[i]);
out.println();
for (int i = 0; i < 10; ++i) {
AttributeList values = proxy.getAttributes(current.getObjectName(), attributes);
for (int j = 0; j < attributes.length; ++j) {
Attribute attribute = (Attribute) values.get(j);
if (j != 0) {
out.print("tt");
out.print(attribute.getValue());
out.println();
Thread.sleep(interval);
public void ls(String line) throws Exception {
entries.clear();
Map<ObjectName, MBeanInfo> beans = proxy.getMBeans(null);
for (Map.Entry<ObjectName, MBeanInfo> entry : beans.entrySet()) {
if ("com.alibaba.druid.pool.DruidDataSource".equals(entry.getValue().getClassName())) {
entries.add(new DataSourceEntry(entry.getKey(), entry.getValue()));
for (int i = 0; i < entries.size(); ++i) {
out.println(i + " : " + entries.get(i).getObjectName());
public void desc(String line) throws Exception {
String arg = line.substring("desc ".length());
int index = Integer.parseInt(arg);
DataSourceEntry current = entries.get(index);
MBeanInfo mbeanInfo = current.getMbeanInfo();
String[] attributes = new String[mbeanInfo.getAttributes().length];
for (int i = 0; i < attributes.length; ++i) {
MBeanAttributeInfo attr = mbeanInfo.getAttributes()[i];
attributes[i] = attr.getName();
AttributeList values = proxy.getAttributes(current.getObjectName(), attributes);
for (int i = 0; i < attributes.length; ++i) {
out.println("t" + attributes[i] + " : " + values.get(i));
public static void main(String[] args) throws Exception {
DruidConsole console = new DruidConsole();
console.run();
static class DataSourceEntry {
private final ObjectName objectName;
private final MBeanInfo  mbeanInfo;
public DataSourceEntry(ObjectName objectName, MBeanInfo mbeanInfo){
this.objectName = objectName;
this.mbeanInfo = mbeanInfo;
public ObjectName getObjectName() {
return objectName;
public MBeanInfo getMbeanInfo() {
return mbeanInfo;
public interface JConsoleContext {
public static String CONNECTION_STATE_PROPERTY = "connectionState";
public enum ConnectionState {
CONNECTED,
DISCONNECTED,
CONNECTING
public MBeanServerConnection getMBeanServerConnection();
public ConnectionState getConnectionState();
public void addPropertyChangeListener(PropertyChangeListener listener);
public void removePropertyChangeListener(PropertyChangeListener listener);
public class LocalVirtualMachine {
private String  address;
private String  commandLine;
private String  displayName;
private int     vmid;
private boolean isAttachSupported;
public LocalVirtualMachine(int vmid, String commandLine, boolean canAttach, String connectorAddress){
this.vmid = vmid;
this.commandLine = commandLine;
this.address = connectorAddress;
this.isAttachSupported = canAttach;
this.displayName = getDisplayName(commandLine);
private static String getDisplayName(String commandLine) {
String[] res = commandLine.split(" ", 2);
if (res[0].endsWith(".jar")) {
File jarfile = new File(res[0]);
String displayName = jarfile.getName();
if (res.length == 2) {
displayName += " " + res[1];
return displayName;
return commandLine;
public int vmid() {
return vmid;
public boolean isManageable() {
return (address != null);
public boolean isAttachable() {
return isAttachSupported;
public void startManagementAgent() throws IOException {
if (address != null) {
if (!isAttachable()) {
throw new IOException("This virtual machine "" + vmid + "" does not support dynamic attach.");
loadManagementAgent();
if (address == null) {
throw new IOException("Fails to find connector address");
public String connectorAddress() {
return address;
public String displayName() {
return displayName;
public String toString() {
return commandLine;
public static Map<Integer, LocalVirtualMachine> getAllVirtualMachines() {
Map<Integer, LocalVirtualMachine> map = new HashMap<Integer, LocalVirtualMachine>();
getMonitoredVMs(map);
getAttachableVMs(map);
return map;
private static void getMonitoredVMs(Map<Integer, LocalVirtualMachine> map) {
MonitoredHost host;
host = MonitoredHost.getMonitoredHost(new HostIdentifier((String) null));
vms = host.activeVms();
} catch (java.net.URISyntaxException sx) {
throw new InternalError(sx.getMessage());
} catch (MonitorException mx) {
throw new InternalError(mx.getMessage());
for (Object vmid : vms) {
if (vmid instanceof Integer) {
int pid = ((Integer) vmid).intValue();
String name = vmid.toString(); 
boolean attachable = false;
String address = null;
MonitoredVm mvm = host.getMonitoredVm(new VmIdentifier(name));
name = MonitoredVmUtil.commandLine(mvm);
attachable = MonitoredVmUtil.isAttachable(mvm);
address = ConnectorAddressLink.importFrom(pid);
mvm.detach();
} catch (Exception x) {
map.put((Integer) vmid, new LocalVirtualMachine(pid, name, attachable, address));
private static final String LOCAL_CONNECTOR_ADDRESS_PROP = "com.sun.management.jmxremote.localConnectorAddress";
private static void getAttachableVMs(Map<Integer, LocalVirtualMachine> map) {
List<VirtualMachineDescriptor> vms = VirtualMachine.list();
for (VirtualMachineDescriptor vmd : vms) {
Integer vmid = Integer.valueOf(vmd.id());
if (!map.containsKey(vmid)) {
boolean attachable = false;
String address = null;
VirtualMachine vm = VirtualMachine.attach(vmd);
attachable = true;
Properties agentProps = vm.getAgentProperties();
address = (String) agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
vm.detach();
} catch (AttachNotSupportedException x) {
} catch (IOException x) {
map.put(vmid, new LocalVirtualMachine(vmid.intValue(), vmd.displayName(), attachable, address));
} catch (NumberFormatException e) {
public static LocalVirtualMachine getLocalVirtualMachine(int vmid) {
Map<Integer, LocalVirtualMachine> map = getAllVirtualMachines();
LocalVirtualMachine lvm = map.get(vmid);
if (lvm == null) {
boolean attachable = false;
String address = null;
String name = String.valueOf(vmid); 
VirtualMachine vm = VirtualMachine.attach(name);
attachable = true;
Properties agentProps = vm.getAgentProperties();
address = (String) agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
vm.detach();
lvm = new LocalVirtualMachine(vmid, name, attachable, address);
} catch (AttachNotSupportedException x) {
x.printStackTrace();
} catch (IOException x) {
x.printStackTrace();
return lvm;
private void loadManagementAgent() throws IOException {
VirtualMachine vm = null;
String name = String.valueOf(vmid);
vm = VirtualMachine.attach(name);
} catch (AttachNotSupportedException x) {
IOException ioe = new IOException(x.getMessage());
ioe.initCause(x);
throw ioe;
String home = vm.getSystemProperties().getProperty("java.home");
String agent = home + File.separator + "jre" + File.separator + "lib" + File.separator + "management-agent.jar";
File f = new File(agent);
if (!f.exists()) {
agent = home + File.separator + "lib" + File.separator + "management-agent.jar";
f = new File(agent);
if (!f.exists()) {
throw new IOException("Management agent not found");
agent = f.getCanonicalPath();
vm.loadAgent(agent, "com.sun.management.jmxremote");
} catch (AgentLoadException x) {
IOException ioe = new IOException(x.getMessage());
ioe.initCause(x);
throw ioe;
} catch (AgentInitializationException x) {
IOException ioe = new IOException(x.getMessage());
ioe.initCause(x);
throw ioe;
Properties agentProps = vm.getAgentProperties();
address = (String) agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
vm.detach();
public class ProxyClient implements JConsoleContext {
private ConnectionState                          connectionState                = ConnectionState.DISCONNECTED;
private SwingPropertyChangeSupport               propertyChangeSupport          = new SwingPropertyChangeSupport(
private static Map<String, ProxyClient>          cache                          = Collections.synchronizedMap(new HashMap<String, ProxyClient>());
private volatile boolean                         isDead                         = true;
private String                                   hostName                       = null;
private int                                      port                           = 0;
private String                                   userName                       = null;
private String                                   password                       = null;
private boolean                                  hasPlatformMXBeans             = false;
private boolean                                  hasHotSpotDiagnosticMXBean     = false;
private boolean                                  hasCompilationMXBean           = false;
private boolean                                  supportsLockUsage              = false;
private LocalVirtualMachine                      lvm;
private String                                   advancedUrl                    = null;
private JMXServiceURL                            jmxUrl                         = null;
private MBeanServerConnection                    mbsc                           = null;
private SnapshotMBeanServerConnection            server                         = null;
private JMXConnector                             jmxc                           = null;
private RMIServer                                stub                           = null;
private static final SslRMIClientSocketFactory   sslRMIClientSocketFactory      = new SslRMIClientSocketFactory();
private String                                   registryHostName               = null;
private int                                      registryPort                   = 0;
private boolean                                  vmConnector                    = false;
private boolean                                  sslRegistry                    = false;
private boolean                                  sslStub                        = false;
final private String                             connectionName;
final private String                             displayName;
private ClassLoadingMXBean                       classLoadingMBean              = null;
private CompilationMXBean                        compilationMBean               = null;
private MemoryMXBean                             memoryMBean                    = null;
private OperatingSystemMXBean                    operatingSystemMBean           = null;
private RuntimeMXBean                            runtimeMBean                   = null;
private ThreadMXBean                             threadMBean                    = null;
private com.sun.management.OperatingSystemMXBean sunOperatingSystemMXBean       = null;
private HotSpotDiagnosticMXBean                  hotspotDiagnosticMXBean        = null;
private List<GarbageCollectorMXBean>             garbageCollectorMBeans         = null;
final static private String                      HOTSPOT_DIAGNOSTIC_MXBEAN_NAME = "com.sun.management:type=HotSpotDiagnostic";
private ProxyClient(String hostName, int port, String userName, String password) throws IOException{
this.connectionName = getConnectionName(hostName, port, userName);
this.displayName = connectionName;
if (hostName.equals("localhost") && port == 0) {
this.hostName = hostName;
this.port = port;
final String urlPath = "/jndi/rmi:
JMXServiceURL url = new JMXServiceURL("rmi", "", 0, urlPath);
setParameters(url, userName, password);
vmConnector = true;
registryHostName = hostName;
registryPort = port;
checkSslConfig();
private ProxyClient(String url, String userName, String password) throws IOException{
this.advancedUrl = url;
this.connectionName = getConnectionName(url, userName);
this.displayName = connectionName;
setParameters(new JMXServiceURL(url), userName, password);
private ProxyClient(LocalVirtualMachine lvm) throws IOException{
this.lvm = lvm;
this.connectionName = getConnectionName(lvm);
this.displayName = "pid: " + lvm.vmid() + " " + lvm.displayName();
private void setParameters(JMXServiceURL url, String userName, String password) {
this.jmxUrl = url;
this.hostName = jmxUrl.getHost();
this.port = jmxUrl.getPort();
this.userName = userName;
this.password = password;
private static void checkStub(Remote stub, Class<? extends Remote> stubClass) {
if (stub.getClass() != stubClass) {
if (!Proxy.isProxyClass(stub.getClass())) {
throw new SecurityException("Expecting a " + stubClass.getName() + " stub!");
InvocationHandler handler = Proxy.getInvocationHandler(stub);
if (handler.getClass() != RemoteObjectInvocationHandler.class) {
throw new SecurityException("Expecting a dynamic proxy instance with a "
+ RemoteObjectInvocationHandler.class.getName()
+ " invocation handler!");
stub = (Remote) handler;
RemoteRef ref = ((RemoteObject) stub).getRef();
if (ref.getClass() != UnicastRef2.class) {
throw new SecurityException("Expecting a " + UnicastRef2.class.getName() + " remote reference in stub!");
LiveRef liveRef = ((UnicastRef2) ref).getLiveRef();
RMIClientSocketFactory csf = liveRef.getClientSocketFactory();
if (csf == null || csf.getClass() != SslRMIClientSocketFactory.class) {
throw new SecurityException("Expecting a " + SslRMIClientSocketFactory.class.getName()
+ " RMI client socket factory in stub!");
private static final String                  rmiServerImplStubClassName = "javax.management.remote.rmi.RMIServerImpl_Stub";
private static final Class<? extends Remote> rmiServerImplStubClass;
Class<? extends Remote> serverStubClass = null;
serverStubClass = Class.forName(rmiServerImplStubClassName).asSubclass(Remote.class);
} catch (ClassNotFoundException e) {
throw (InternalError) new InternalError(e.getMessage()).initCause(e);
rmiServerImplStubClass = serverStubClass;
private void checkSslConfig() throws IOException {
Registry registry;
registry = LocateRegistry.getRegistry(registryHostName, registryPort, sslRMIClientSocketFactory);
stub = (RMIServer) registry.lookup("jmxrmi");
} catch (NotBoundException nbe) {
throw (IOException) new IOException(nbe.getMessage()).initCause(nbe);
sslRegistry = true;
} catch (IOException e) {
registry = LocateRegistry.getRegistry(registryHostName, registryPort);
stub = (RMIServer) registry.lookup("jmxrmi");
} catch (NotBoundException nbe) {
throw (IOException) new IOException(nbe.getMessage()).initCause(nbe);
sslRegistry = false;
checkStub(stub, rmiServerImplStubClass);
sslStub = true;
} catch (SecurityException e) {
sslStub = false;
public boolean isSslRmiRegistry() {
if (!isVmConnector()) {
throw new UnsupportedOperationException("ProxyClient.isSslRmiRegistry() is only supported if this "
+ "ProxyClient is a JMX connector for a JMX VM agent");
return sslRegistry;
public boolean isSslRmiStub() {
if (!isVmConnector()) {
throw new UnsupportedOperationException("ProxyClient.isSslRmiStub() is only supported if this "
+ "ProxyClient is a JMX connector for a JMX VM agent");
return sslStub;
public boolean isVmConnector() {
return vmConnector;
private void setConnectionState(ConnectionState state) {
ConnectionState oldState = this.connectionState;
this.connectionState = state;
propertyChangeSupport.firePropertyChange(CONNECTION_STATE_PROPERTY, oldState, state);
public ConnectionState getConnectionState() {
return this.connectionState;
void flush() {
if (server != null) {
server.flush();
void connect() {
setConnectionState(ConnectionState.CONNECTING);
tryConnect();
setConnectionState(ConnectionState.CONNECTED);
} catch (Exception e) {
e.printStackTrace();
setConnectionState(ConnectionState.DISCONNECTED);
private void tryConnect() throws IOException {
if (jmxUrl == null && "localhost".equals(hostName) && port == 0) {
this.jmxc = null;
this.mbsc = ManagementFactory.getPlatformMBeanServer();
this.server = Snapshot.newSnapshot(mbsc);
if (lvm != null) {
if (!lvm.isManageable()) {
lvm.startManagementAgent();
if (!lvm.isManageable()) {
throw new IOException(lvm + "not manageable");
if (this.jmxUrl == null) {
this.jmxUrl = new JMXServiceURL(lvm.connectorAddress());
if (userName == null && password == null) {
if (isVmConnector()) {
if (stub == null) {
checkSslConfig();
this.jmxc = new RMIConnector(stub, null);
jmxc.connect();
this.jmxc = JMXConnectorFactory.connect(jmxUrl);
Map<String, String[]> env = new HashMap<String, String[]>();
env.put(JMXConnector.CREDENTIALS, new String[] { userName, password });
if (isVmConnector()) {
if (stub == null) {
checkSslConfig();
this.jmxc = new RMIConnector(stub, null);
jmxc.connect(env);
this.jmxc = JMXConnectorFactory.connect(jmxUrl, env);
this.mbsc = jmxc.getMBeanServerConnection();
this.server = Snapshot.newSnapshot(mbsc);
this.isDead = false;
ObjectName on = new ObjectName(THREAD_MXBEAN_NAME);
this.hasPlatformMXBeans = server.isRegistered(on);
this.hasHotSpotDiagnosticMXBean = server.isRegistered(new ObjectName(HOTSPOT_DIAGNOSTIC_MXBEAN_NAME));
if (this.hasPlatformMXBeans) {
MBeanOperationInfo[] mopis = server.getMBeanInfo(on).getOperations();
for (MBeanOperationInfo op : mopis) {
if (op.getName().equals("findDeadlockedThreads")) {
this.supportsLockUsage = true;
on = new ObjectName(COMPILATION_MXBEAN_NAME);
this.hasCompilationMXBean = server.isRegistered(on);
} catch (MalformedObjectNameException e) {
throw new InternalError(e.getMessage());
} catch (IntrospectionException e) {
InternalError ie = new InternalError(e.getMessage());
ie.initCause(e);
} catch (InstanceNotFoundException e) {
InternalError ie = new InternalError(e.getMessage());
ie.initCause(e);
} catch (ReflectionException e) {
InternalError ie = new InternalError(e.getMessage());
ie.initCause(e);
if (hasPlatformMXBeans) {
getRuntimeMXBean();
public static ProxyClient getProxyClient(LocalVirtualMachine lvm) throws IOException {
final String key = getCacheKey(lvm);
ProxyClient proxyClient = cache.get(key);
if (proxyClient == null) {
proxyClient = new ProxyClient(lvm);
cache.put(key, proxyClient);
return proxyClient;
public static String getConnectionName(LocalVirtualMachine lvm) {
return Integer.toString(lvm.vmid());
private static String getCacheKey(LocalVirtualMachine lvm) {
return Integer.toString(lvm.vmid());
public static ProxyClient getProxyClient(String url, String userName, String password) throws IOException {
final String key = getCacheKey(url, userName, password);
ProxyClient proxyClient = cache.get(key);
if (proxyClient == null) {
proxyClient = new ProxyClient(url, userName, password);
cache.put(key, proxyClient);
return proxyClient;
public static String getConnectionName(String url, String userName) {
if (userName != null && userName.length() > 0) {
return userName + "@" + url;
return url;
private static String getCacheKey(String url, String userName, String password) {
return (url == null ? "" : url) + ":" + (userName == null ? "" : userName) + ":"
+ (password == null ? "" : password);
public static ProxyClient getProxyClient(String hostName, int port, String userName, String password)
throws IOException {
final String key = getCacheKey(hostName, port, userName, password);
ProxyClient proxyClient = cache.get(key);
if (proxyClient == null) {
proxyClient = new ProxyClient(hostName, port, userName, password);
cache.put(key, proxyClient);
return proxyClient;
public static String getConnectionName(String hostName, int port, String userName) {
String name = hostName + ":" + port;
if (userName != null && userName.length() > 0) {
return userName + "@" + name;
return name;
private static String getCacheKey(String hostName, int port, String userName, String password) {
return (hostName == null ? "" : hostName) + ":" + port + ":" + (userName == null ? "" : userName) + ":"
+ (password == null ? "" : password);
public String connectionName() {
return connectionName;
public String getDisplayName() {
return displayName;
public String toString() {
if (!isConnected()) {
return displayName + " (disconnected)";
return displayName;
public MBeanServerConnection getMBeanServerConnection() {
return mbsc;
public SnapshotMBeanServerConnection getSnapshotMBeanServerConnection() {
return server;
public String getUrl() {
return advancedUrl;
public String getHostName() {
return hostName;
public int getPort() {
return port;
public int getVmid() {
return (lvm != null) ? lvm.vmid() : 0;
public String getUserName() {
return userName;
public String getPassword() {
return password;
public void disconnect() {
stub = null;
if (jmxc != null) {
jmxc.close();
} catch (IOException e) {
classLoadingMBean = null;
compilationMBean = null;
memoryMBean = null;
operatingSystemMBean = null;
runtimeMBean = null;
threadMBean = null;
sunOperatingSystemMXBean = null;
garbageCollectorMBeans = null;
if (!isDead) {
isDead = true;
setConnectionState(ConnectionState.DISCONNECTED);
public String[] getDomains() throws IOException {
return server.getDomains();
public Map<ObjectName, MBeanInfo> getMBeans(String domain) throws IOException {
ObjectName name = null;
if (domain != null) {
name = new ObjectName(domain + ":*");
} catch (MalformedObjectNameException e) {
assert (false);
Set mbeans = server.queryNames(name, null);
Map<ObjectName, MBeanInfo> result = new HashMap<ObjectName, MBeanInfo>(mbeans.size());
Iterator iterator = mbeans.iterator();
while (iterator.hasNext()) {
Object object = iterator.next();
if (object instanceof ObjectName) {
ObjectName o = (ObjectName) object;
MBeanInfo info = server.getMBeanInfo(o);
result.put(o, info);
} catch (IntrospectionException e) {
} catch (InstanceNotFoundException e) {
} catch (ReflectionException e) {
return result;
public AttributeList getAttributes(ObjectName name, String[] attributes) throws IOException {
AttributeList list = null;
list = server.getAttributes(name, attributes);
} catch (InstanceNotFoundException e) {
} catch (ReflectionException e) {
return list;
public void setAttribute(ObjectName name, Attribute attribute) throws InvalidAttributeValueException,
MBeanException, IOException {
server.setAttribute(name, attribute);
} catch (InstanceNotFoundException e) {
} catch (AttributeNotFoundException e) {
assert (false);
} catch (ReflectionException e) {
public Object invoke(ObjectName name, String operationName, Object[] params, String[] signature)
throws IOException,
MBeanException {
Object result = null;
result = server.invoke(name, operationName, params, signature);
} catch (InstanceNotFoundException e) {
} catch (ReflectionException e) {
return result;
public synchronized ClassLoadingMXBean getClassLoadingMXBean() throws IOException {
if (hasPlatformMXBeans && classLoadingMBean == null) {
classLoadingMBean = newPlatformMXBeanProxy(server, CLASS_LOADING_MXBEAN_NAME, ClassLoadingMXBean.class);
return classLoadingMBean;
public synchronized CompilationMXBean getCompilationMXBean() throws IOException {
if (hasCompilationMXBean && compilationMBean == null) {
compilationMBean = newPlatformMXBeanProxy(server, COMPILATION_MXBEAN_NAME, CompilationMXBean.class);
return compilationMBean;
public synchronized Collection<GarbageCollectorMXBean> getGarbageCollectorMXBeans() throws IOException {
if (garbageCollectorMBeans == null) {
ObjectName gcName = null;
gcName = new ObjectName(GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + ",*");
} catch (MalformedObjectNameException e) {
assert (false);
Set mbeans = server.queryNames(gcName, null);
if (mbeans != null) {
garbageCollectorMBeans = new ArrayList<GarbageCollectorMXBean>();
Iterator iterator = mbeans.iterator();
while (iterator.hasNext()) {
ObjectName on = (ObjectName) iterator.next();
String name = GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + ",name=" + on.getKeyProperty("name");
GarbageCollectorMXBean mBean = newPlatformMXBeanProxy(server, name, GarbageCollectorMXBean.class);
garbageCollectorMBeans.add(mBean);
return garbageCollectorMBeans;
public synchronized MemoryMXBean getMemoryMXBean() throws IOException {
if (hasPlatformMXBeans && memoryMBean == null) {
memoryMBean = newPlatformMXBeanProxy(server, MEMORY_MXBEAN_NAME, MemoryMXBean.class);
return memoryMBean;
public synchronized RuntimeMXBean getRuntimeMXBean() throws IOException {
if (hasPlatformMXBeans && runtimeMBean == null) {
runtimeMBean = newPlatformMXBeanProxy(server, RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
return runtimeMBean;
public synchronized ThreadMXBean getThreadMXBean() throws IOException {
if (hasPlatformMXBeans && threadMBean == null) {
threadMBean = newPlatformMXBeanProxy(server, THREAD_MXBEAN_NAME, ThreadMXBean.class);
return threadMBean;
public synchronized OperatingSystemMXBean getOperatingSystemMXBean() throws IOException {
if (hasPlatformMXBeans && operatingSystemMBean == null) {
operatingSystemMBean = newPlatformMXBeanProxy(server, OPERATING_SYSTEM_MXBEAN_NAME,
OperatingSystemMXBean.class);
return operatingSystemMBean;
public synchronized com.sun.management.OperatingSystemMXBean getSunOperatingSystemMXBean() throws IOException {
ObjectName on = new ObjectName(OPERATING_SYSTEM_MXBEAN_NAME);
if (sunOperatingSystemMXBean == null) {
if (server.isInstanceOf(on, "com.sun.management.OperatingSystemMXBean")) {
sunOperatingSystemMXBean = newPlatformMXBeanProxy(server, OPERATING_SYSTEM_MXBEAN_NAME,
com.sun.management.OperatingSystemMXBean.class);
} catch (InstanceNotFoundException e) {
return null;
} catch (MalformedObjectNameException e) {
return null; 
return sunOperatingSystemMXBean;
public synchronized HotSpotDiagnosticMXBean getHotSpotDiagnosticMXBean() throws IOException {
if (hasHotSpotDiagnosticMXBean && hotspotDiagnosticMXBean == null) {
hotspotDiagnosticMXBean = newPlatformMXBeanProxy(server, HOTSPOT_DIAGNOSTIC_MXBEAN_NAME,
HotSpotDiagnosticMXBean.class);
return hotspotDiagnosticMXBean;
public <T> T getMXBean(ObjectName objName, Class<T> interfaceClass) throws IOException {
return newPlatformMXBeanProxy(server, objName.toString(), interfaceClass);
public long[] findDeadlockedThreads() throws IOException {
ThreadMXBean tm = getThreadMXBean();
if (supportsLockUsage && tm.isSynchronizerUsageSupported()) {
return tm.findDeadlockedThreads();
return tm.findMonitorDeadlockedThreads();
public synchronized void markAsDead() {
disconnect();
public boolean isDead() {
return isDead;
boolean isConnected() {
return !isDead();
boolean hasPlatformMXBeans() {
return this.hasPlatformMXBeans;
boolean hasHotSpotDiagnosticMXBean() {
return this.hasHotSpotDiagnosticMXBean;
boolean isLockUsageSupported() {
return supportsLockUsage;
public boolean isRegistered(ObjectName name) throws IOException {
return server.isRegistered(name);
public void addPropertyChangeListener(PropertyChangeListener listener) {
propertyChangeSupport.addPropertyChangeListener(listener);
public void addWeakPropertyChangeListener(PropertyChangeListener listener) {
if (!(listener instanceof WeakPCL)) {
listener = new WeakPCL(listener);
propertyChangeSupport.addPropertyChangeListener(listener);
public void removePropertyChangeListener(PropertyChangeListener listener) {
if (!(listener instanceof WeakPCL)) {
for (PropertyChangeListener pcl : propertyChangeSupport.getPropertyChangeListeners()) {
if (pcl instanceof WeakPCL && ((WeakPCL) pcl).get() == listener) {
listener = pcl;
propertyChangeSupport.removePropertyChangeListener(listener);
private class WeakPCL extends WeakReference<PropertyChangeListener> implements PropertyChangeListener {
WeakPCL(PropertyChangeListener referent){
super(referent);
public void propertyChange(PropertyChangeEvent pce) {
PropertyChangeListener pcl = get();
if (pcl == null) {
dispose();
pcl.propertyChange(pce);
private void dispose() {
removePropertyChangeListener(this);
public interface SnapshotMBeanServerConnection extends MBeanServerConnection {
public void flush();
public static class Snapshot {
private Snapshot(){
public static SnapshotMBeanServerConnection newSnapshot(MBeanServerConnection mbsc) {
final InvocationHandler ih = new SnapshotInvocationHandler(mbsc);
return (SnapshotMBeanServerConnection) Proxy.newProxyInstance(Snapshot.class.getClassLoader(),
new Class[] { SnapshotMBeanServerConnection.class },
static class SnapshotInvocationHandler implements InvocationHandler {
private final MBeanServerConnection   conn;
private Map<ObjectName, NameValueMap> cachedValues = newMap();
private Map<ObjectName, Set<String>>  cachedNames  = newMap();
@SuppressWarnings("serial")
private static final class NameValueMap extends HashMap<String, Object> {
SnapshotInvocationHandler(MBeanServerConnection conn){
this.conn = conn;
synchronized void flush() {
cachedValues = newMap();
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
final String methodName = method.getName();
if (methodName.equals("getAttribute")) {
return getAttribute((ObjectName) args[0], (String) args[1]);
} else if (methodName.equals("getAttributes")) {
return getAttributes((ObjectName) args[0], (String[]) args[1]);
} else if (methodName.equals("flush")) {
return null;
return method.invoke(conn, args);
} catch (InvocationTargetException e) {
throw e.getCause();
private Object getAttribute(ObjectName objName, String attrName) throws MBeanException,
InstanceNotFoundException,
AttributeNotFoundException,
ReflectionException, IOException {
final NameValueMap values = getCachedAttributes(objName, Collections.singleton(attrName));
Object value = values.get(attrName);
if (value != null || values.containsKey(attrName)) {
return value;
return conn.getAttribute(objName, attrName);
private AttributeList getAttributes(ObjectName objName, String[] attrNames) throws InstanceNotFoundException,
ReflectionException, IOException {
final NameValueMap values = getCachedAttributes(objName, new TreeSet<String>(Arrays.asList(attrNames)));
final AttributeList list = new AttributeList();
for (String attrName : attrNames) {
final Object value = values.get(attrName);
if (value != null || values.containsKey(attrName)) {
list.add(new Attribute(attrName, value));
return list;
private synchronized NameValueMap getCachedAttributes(ObjectName objName, Set<String> attrNames)
throws InstanceNotFoundException,
ReflectionException,
IOException {
NameValueMap values = cachedValues.get(objName);
if (values != null && values.keySet().containsAll(attrNames)) {
return values;
attrNames = new TreeSet<String>(attrNames);
Set<String> oldNames = cachedNames.get(objName);
if (oldNames != null) {
attrNames.addAll(oldNames);
values = new NameValueMap();
final AttributeList attrs = conn.getAttributes(objName, attrNames.toArray(new String[attrNames.size()]));
for (Attribute attr : attrs.asList()) {
values.put(attr.getName(), attr.getValue());
cachedValues.put(objName, values);
cachedNames.put(objName, attrNames);
return values;
private static <K, V> Map<K, V> newMap() {
return new HashMap<K, V>();
public class TestMySqlPing extends TestCase {
private String jdbcUrl;
private String user;
private String password;
private String driverClass;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:mysql:
user = "dragoon_admin";
password = "dragoon_root";
driverClass = "com.mysql.jdbc.Driver";
public void test_o() throws Exception {
Class.forName(driverClass);
Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
com.mysql.jdbc.Connection oracleConn = (com.mysql.jdbc.Connection) conn;
for (int i = 0; i < 10; ++i) {
ping_1000(oracleConn);
select_1000(oracleConn);
conn.close();
private void ping_1000(com.mysql.jdbc.Connection oracleConn) throws SQLException {
long startMillis = System.currentTimeMillis();
final int COUNT = 10000;
for (int i = 0; i < COUNT; ++i) {
pring(oracleConn);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("ping : " + millis);
private void select_1000(com.mysql.jdbc.Connection oracleConn) throws SQLException {
long startMillis = System.currentTimeMillis();
final int COUNT = 10000;
for (int i = 0; i < COUNT; ++i) {
select(oracleConn);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("select : " + millis);
public void pring(com.mysql.jdbc.Connection oracleConn) throws SQLException {
oracleConn.ping();
public void select(com.mysql.jdbc.Connection oracleConn) throws SQLException {
Statement stmt = oracleConn.createStatement();
stmt.execute("SELECT 'x'");
stmt.close();
public class TestOraclePing extends TestCase {
private String jdbcUrl;
private String user;
private String password;
private String driverClass;
private String SQL;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.81:1521:ointest3";
user = "alibaba";
password = "deYcR7facWSJtCuDpm2r";
SQL = "SELECT * FROM AV_INFO WHERE ID = ?";
driverClass = "oracle.jdbc.driver.OracleDriver";
public void test_o() throws Exception {
Class.forName(driverClass);
Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
OracleConnection oracleConn = (OracleConnection) conn;
for (int i = 0; i < 10; ++i) {
ping_1000(oracleConn);
select_1000(oracleConn);
conn.close();
private void ping_1000(OracleConnection oracleConn) throws SQLException {
long startMillis = System.currentTimeMillis();
final int COUNT = 1000;
for (int i = 0; i < COUNT; ++i) {
pring(oracleConn);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("ping : " + millis);
private void select_1000(OracleConnection oracleConn) throws SQLException {
long startMillis = System.currentTimeMillis();
final int COUNT = 1000;
for (int i = 0; i < COUNT; ++i) {
select(oracleConn);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("select : " + millis);
public void pring(OracleConnection oracleConn) throws SQLException {
oracleConn.pingDatabase(1000);
public void select(OracleConnection oracleConn) throws SQLException {
Statement stmt = oracleConn.createStatement();
stmt.execute("SELECT 1 FROM DUAL");
stmt.close();
static String url = "jdbc:jtds:sqlserver:
static String user = "sa";
static String password = "hello123";
static String driver = "net.sourceforge.jtds.jdbc.Driver";
c3p0.setDriverClass(driver);
dao_c3p0.execute(Sqls.create("create table msg(message varchar(5))")); 
public class TestSqlServer extends TestCase {
private String jdbcUrl;
private String user;
private String password;
private String driverClass;
private String SQL;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:jtds:sqlserver:
user = "sa";
password = "hello123";
SQL = "SELECT * FROM AV_INFO WHERE ID = ?";
driverClass = "net.sourceforge.jtds.jdbc.Driver";
public void test_0 () throws Exception {
Class.forName(driverClass);
Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
conn.close();
public final static int RevisionVersion = 19;
if (name != null) {
return name;
return "DataSource-" + System.identityHashCode(this);
@SuppressWarnings("restriction")
Set<?> vms;
@SuppressWarnings("restriction")
Set<ObjectName> mbeans = server.queryNames(name, null);
Iterator<ObjectName> iterator = mbeans.iterator();
Set<ObjectName> mbeans = server.queryNames(gcName, null);
Iterator<ObjectName> iterator = mbeans.iterator();
@SuppressWarnings("restriction")
public class LinkedTransferQueue<E> extends AbstractQueue<E>
implements TransferQueue<E>, java.io.Serializable {
private static final long serialVersionUID = -3223113410248163686L;
private static final boolean MP =
Runtime.getRuntime().availableProcessors() > 1;
private static final int FRONT_SPINS   = 1 << 7;
private static final int CHAINED_SPINS = FRONT_SPINS >>> 1;
static final int SWEEP_THRESHOLD = 32;
static final class Node {
final boolean isData;   
volatile Object item;   
volatile Node next;
volatile Thread waiter; 
final boolean casNext(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
final boolean casItem(Object cmp, Object val) {
return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
Node(Object item, boolean isData) {
UNSAFE.putObject(this, itemOffset, item); 
this.isData = isData;
final void forgetNext() {
UNSAFE.putObject(this, nextOffset, this);
final void forgetContents() {
UNSAFE.putObject(this, itemOffset, this);
UNSAFE.putObject(this, waiterOffset, null);
final boolean isMatched() {
Object x = item;
return (x == this) || ((x == null) == isData);
final boolean isUnmatchedRequest() {
return !isData && item == null;
final boolean cannotPrecede(boolean haveData) {
boolean d = isData;
return d != haveData && (x = item) != this && (x != null) == d;
final boolean tryMatchData() {
Object x = item;
if (x != null && x != this && casItem(x, null)) {
LockSupport.unpark(waiter);
return true;
return false;
private static final sun.misc.Unsafe UNSAFE;
private static final long itemOffset;
private static final long nextOffset;
private static final long waiterOffset;
UNSAFE = getUnsafe();
Class<?> k = Node.class;
itemOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("item"));
nextOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("next"));
waiterOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("waiter"));
} catch (Exception e) {
throw new Error(e);
transient volatile Node head;
private transient volatile Node tail;
private transient volatile int sweepVotes;
private boolean casTail(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
private boolean casHead(Node cmp, Node val) {
return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);
private boolean casSweepVotes(int cmp, int val) {
return UNSAFE.compareAndSwapInt(this, sweepVotesOffset, cmp, val);
private static final int NOW   = 0; 
private static final int ASYNC = 1; 
private static final int SYNC  = 2; 
private static final int TIMED = 3; 
@SuppressWarnings("unchecked")
static <E> E cast(Object item) {
return (E) item;
private E xfer(E e, boolean haveData, int how, long nanos) {
if (haveData && (e == null))
throw new NullPointerException();
Node s = null;                        
for (;;) {                            
for (Node h = head, p = h; p != null;) { 
boolean isData = p.isData;
Object item = p.item;
if (item != p && (item != null) == isData) { 
if (isData == haveData)   
if (p.casItem(item, e)) { 
for (Node q = p; q != h;) {
Node n = q.next;  
if (head == h && casHead(h, n == null ? q : n)) {
h.forgetNext();
}                 
if ((h = head)   == null ||
(q = h.next) == null || !q.isMatched())
break;        
LockSupport.unpark(p.waiter);
return cast(item);
Node n = p.next;
p = (p != n) ? n : (h = head); 
if (how != NOW) {                 
if (s == null)
s = new Node(e, haveData);
Node pred = tryAppend(s, haveData);
if (pred == null)
continue retry;           
if (how != ASYNC)
return awaitMatch(s, pred, e, (how == TIMED), nanos);
return e; 
private Node tryAppend(Node s, boolean haveData) {
for (Node t = tail, p = t;;) {        
Node n, u;                        
if (p == null && (p = head) == null) {
if (casHead(null, s))
return s;                 
else if (p.cannotPrecede(haveData))
return null;                  
else if ((n = p.next) != null)    
p = p != t && t != (u = tail) ? (t = u) : 
(p != n) ? n : null;      
else if (!p.casNext(null, s))
p = p.next;                   
if (p != t) {                 
while ((tail != t || !casTail(t, s)) &&
(t = tail)   != null &&
(s = t.next) != null && 
(s = s.next) != null && s != t);
private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {
long lastTime = timed ? System.nanoTime() : 0L;
Thread w = Thread.currentThread();
int spins = -1; 
ThreadLocalRandom randomYields = null; 
for (;;) {
Object item = s.item;
if (item != e) {                  
s.forgetContents();           
return cast(item);
if ((w.isInterrupted() || (timed && nanos <= 0)) &&
s.casItem(e, s)) {        
unsplice(pred, s);
if (spins < 0) {                  
if ((spins = spinsFor(pred, s.isData)) > 0)
randomYields = ThreadLocalRandom.current();
else if (spins > 0) {             
if (randomYields.nextInt(CHAINED_SPINS) == 0)
Thread.yield();           
else if (s.waiter == null) {
s.waiter = w;                 
else if (timed) {
long now = System.nanoTime();
if ((nanos -= now - lastTime) > 0)
LockSupport.parkNanos(this, nanos);
lastTime = now;
LockSupport.park(this);
private static int spinsFor(Node pred, boolean haveData) {
if (MP && pred != null) {
if (pred.isData != haveData)      
return FRONT_SPINS + CHAINED_SPINS;
if (pred.isMatched())             
return FRONT_SPINS;
if (pred.waiter == null)          
return CHAINED_SPINS;
final Node succ(Node p) {
Node next = p.next;
return (p == next) ? head : next;
private Node firstOfMode(boolean isData) {
for (Node p = head; p != null; p = succ(p)) {
if (!p.isMatched())
return (p.isData == isData) ? p : null;
return null;
private E firstDataItem() {
for (Node p = head; p != null; p = succ(p)) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p)
return cast(item);
else if (item == null)
return null;
return null;
private int countOfMode(boolean data) {
int count = 0;
for (Node p = head; p != null; ) {
if (!p.isMatched()) {
if (p.isData != data)
if (++count == Integer.MAX_VALUE) 
Node n = p.next;
if (n != p)
count = 0;
return count;
final class Itr implements Iterator<E> {
private Node nextNode;   
private E nextItem;      
private Node lastRet;    
private Node lastPred;   
private void advance(Node prev) {
Node r, b; 
if ((r = lastRet) != null && !r.isMatched())
lastPred = r;    
else if ((b = lastPred) == null || b.isMatched())
lastPred = null; 
Node s, n;       
while ((s = b.next) != null &&
s != b && s.isMatched() &&
(n = s.next) != null && n != s)
b.casNext(s, n);
this.lastRet = prev;
for (Node p = prev, s, n;;) {
s = (p == null) ? head : p.next;
if (s == null)
else if (s == p) {
Object item = s.item;
if (s.isData) {
if (item != null && item != s) {
nextItem = LinkedTransferQueue.<E>cast(item);
nextNode = s;
else if (item == null)
if (p == null)
else if ((n = s.next) == null)
else if (s == n)
p.casNext(s, n);
nextNode = null;
nextItem = null;
advance(null);
public final boolean hasNext() {
return nextNode != null;
public final E next() {
Node p = nextNode;
if (p == null) throw new NoSuchElementException();
E e = nextItem;
advance(p);
public final void remove() {
final Node lastRet = this.lastRet;
if (lastRet == null)
throw new IllegalStateException();
this.lastRet = null;
if (lastRet.tryMatchData())
unsplice(lastPred, lastRet);
final void unsplice(Node pred, Node s) {
s.forgetContents(); 
if (pred != null && pred != s && pred.next == s) {
Node n = s.next;
if (n == null ||
(n != s && pred.casNext(s, n) && pred.isMatched())) {
for (;;) {               
Node h = head;
if (h == pred || h == s || h == null)
return;          
if (!h.isMatched())
Node hn = h.next;
if (hn == null)
return;          
if (hn != h && casHead(h, hn))
h.forgetNext();  
if (pred.next != pred && s.next != s) { 
for (;;) {           
int v = sweepVotes;
if (v < SWEEP_THRESHOLD) {
if (casSweepVotes(v, v + 1))
else if (casSweepVotes(v, 0)) {
private void sweep() {
for (Node p = head, s, n; p != null && (s = p.next) != null; ) {
if (!s.isMatched())
else if ((n = s.next) == null) 
else if (s == n)    
p.casNext(s, n);
private boolean findAndRemove(Object e) {
if (e != null) {
for (Node pred = null, p = head; p != null; ) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p && e.equals(item) &&
p.tryMatchData()) {
unsplice(pred, p);
return true;
else if (item == null)
if ((p = p.next) == pred) { 
pred = null;
return false;
public LinkedTransferQueue() {
public LinkedTransferQueue(Collection<? extends E> c) {
addAll(c);
public void put(E e) {
xfer(e, true, ASYNC, 0);
public boolean offer(E e, long timeout, TimeUnit unit) {
xfer(e, true, ASYNC, 0);
return true;
public boolean offer(E e) {
xfer(e, true, ASYNC, 0);
return true;
public boolean add(E e) {
xfer(e, true, ASYNC, 0);
return true;
public boolean tryTransfer(E e) {
return xfer(e, true, NOW, 0) == null;
public void transfer(E e) throws InterruptedException {
if (xfer(e, true, SYNC, 0) != null) {
Thread.interrupted(); 
throw new InterruptedException();
public boolean tryTransfer(E e, long timeout, TimeUnit unit)
throws InterruptedException {
if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)
return true;
if (!Thread.interrupted())
return false;
throw new InterruptedException();
public E take() throws InterruptedException {
E e = xfer(null, false, SYNC, 0);
if (e != null)
Thread.interrupted();
throw new InterruptedException();
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
E e = xfer(null, false, TIMED, unit.toNanos(timeout));
if (e != null || !Thread.interrupted())
throw new InterruptedException();
public E poll() {
return xfer(null, false, NOW, 0);
public int drainTo(Collection<? super E> c) {
if (c == null)
throw new NullPointerException();
if (c == this)
throw new IllegalArgumentException();
int n = 0;
while ( (e = poll()) != null) {
public int drainTo(Collection<? super E> c, int maxElements) {
if (c == null)
throw new NullPointerException();
if (c == this)
throw new IllegalArgumentException();
int n = 0;
while (n < maxElements && (e = poll()) != null) {
public Iterator<E> iterator() {
return new Itr();
public E peek() {
return firstDataItem();
public boolean isEmpty() {
for (Node p = head; p != null; p = succ(p)) {
if (!p.isMatched())
return !p.isData;
return true;
public boolean hasWaitingConsumer() {
return firstOfMode(false) != null;
public int size() {
return countOfMode(true);
public int getWaitingConsumerCount() {
return countOfMode(false);
public boolean remove(Object o) {
return findAndRemove(o);
public boolean contains(Object o) {
if (o == null) return false;
for (Node p = head; p != null; p = succ(p)) {
Object item = p.item;
if (p.isData) {
if (item != null && item != p && o.equals(item))
return true;
else if (item == null)
return false;
public int remainingCapacity() {
return Integer.MAX_VALUE;
private void writeObject(java.io.ObjectOutputStream s)
throws java.io.IOException {
s.defaultWriteObject();
for (E e : this)
s.writeObject(e);
s.writeObject(null);
private void readObject(java.io.ObjectInputStream s)
throws java.io.IOException, ClassNotFoundException {
s.defaultReadObject();
for (;;) {
@SuppressWarnings("unchecked") E item = (E) s.readObject();
if (item == null)
offer(item);
private static final sun.misc.Unsafe UNSAFE;
private static final long headOffset;
private static final long tailOffset;
private static final long sweepVotesOffset;
UNSAFE = getUnsafe();
Class<?> k = LinkedTransferQueue.class;
headOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("head"));
tailOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("tail"));
sweepVotesOffset = UNSAFE.objectFieldOffset
(k.getDeclaredField("sweepVotes"));
} catch (Exception e) {
throw new Error(e);
static sun.misc.Unsafe getUnsafe() {
return sun.misc.Unsafe.getUnsafe();
} catch (SecurityException se) {
return java.security.AccessController.doPrivileged
(new java.security
.PrivilegedExceptionAction<sun.misc.Unsafe>() {
public sun.misc.Unsafe run() throws Exception {
java.lang.reflect.Field f = sun.misc
.Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
return (sun.misc.Unsafe) f.get(null);
} catch (java.security.PrivilegedActionException e) {
throw new RuntimeException("Could not initialize intrinsics",
e.getCause());
public interface TransferQueue<E> extends BlockingQueue<E> {
boolean tryTransfer(E e);
void transfer(E e) throws InterruptedException;
boolean tryTransfer(E e, long timeout, TimeUnit unit)
throws InterruptedException;
boolean hasWaitingConsumer();
int getWaitingConsumerCount();
final int COUNT = 10000;
final int COUNT = 10000;
map.put("CreateErrorCount", dataSource.getCreateErrorCount());
, SimpleType.DATE , SimpleType.DATE, SimpleType.LONG
, "LastErrorTime", "LastCreateErrorTime", "CreateErrorCount"
public void init() throws SQLException {
public class TestForZY {
public void foo() throws Exception {
Map<String, Map.Entry<String, Boolean>> m = new HashMap<String, Map.Entry<String, Boolean>>();
public static class A<T> {
private T value;
public class TestLinkedTransferQueue extends TestCase {
public void test_LinkedTransferQueue() throws Exception {
final LinkedTransferQueue<String> q = new LinkedTransferQueue<String>();
Thread thread = new Thread() {
public void run() {
for (;;) {
} catch (InterruptedException e) {
e.printStackTrace();
thread.start();
q.put("1");
public class TestLRU extends TestCase {
public void f_test_boneCP() throws Exception {
BoneCPDataSource ds = new BoneCPDataSource();
ds.setJdbcUrl("jdbc:mock:test");
ds.setPartitionCount(1);
ds.setMaxConnectionsPerPartition(10);
ds.setMinConnectionsPerPartition(0);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_druid() throws Exception {
DruidDataSource ds = new DruidDataSource();
ds.setUrl("jdbc:mock:test");
ds.setMaxIdle(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_dbcp() throws Exception {
BasicDataSource ds = new BasicDataSource();
ds.setUrl("jdbc:mock:test");
ds.setMaxIdle(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_c3p0() throws Exception {
ComboPooledDataSource ds = new ComboPooledDataSource();
ds.setJdbcUrl("jdbc:mock:test");
ds.setMaxPoolSize(10);
ds.setMinPoolSize(0);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_proxool() throws Exception {
ProxoolDataSource ds = new ProxoolDataSource();
ds.setDriver("com.alibaba.druid.mock.MockDriver");
ds.setDriverUrl("jdbc:mock:test");
ds.setMaximumConnectionCount(10);
ds.setMinimumConnectionCount(0);
ds.setUser("user");
ds.setPassword("password");
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public static void f(DataSource ds, int count) throws Exception {
Connection[] connections = new Connection[count];
for (int i = 0; i < count; ++i) {
connections[i] = ds.getConnection();
for (int i = 0; i < count; ++i) {
System.out.println(unwrap(connections[i]).getId());
for (int i = count - 1; i >= 0; --i) {
connections[i].close();
public static MockConnection unwrap(Connection conn) throws Exception {
if (conn instanceof ConnectionHandle) {
ConnectionHandle handle = (ConnectionHandle) conn;
return (MockConnection) handle.getInternalConnection();
if (conn instanceof NewProxyConnection) {
NewProxyConnection handle = (NewProxyConnection) conn;
Field field = NewProxyConnection.class.getDeclaredField("inner");
field.setAccessible(true);
return (MockConnection) field.get(handle);
return conn.unwrap(MockConnection.class);
public class TestPSCache extends TestCase {
public void test_boneCP() throws Exception {
BoneCPDataSource ds = new BoneCPDataSource();
ds.setJdbcUrl("jdbc:mock:test");
ds.setPartitionCount(1);
ds.setMaxConnectionsPerPartition(10);
ds.setMinConnectionsPerPartition(0);
ds.setPreparedStatementsCacheSize(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_druid() throws Exception {
DruidDataSource ds = new DruidDataSource();
ds.setUrl("jdbc:mock:test");
ds.setMaxIdle(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_dbcp() throws Exception {
BasicDataSource ds = new BasicDataSource();
ds.setUrl("jdbc:mock:test");
ds.setMaxIdle(10);
ds.setPoolPreparedStatements(true);
ds.setMaxOpenPreparedStatements(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_c3p0() throws Exception {
ComboPooledDataSource ds = new ComboPooledDataSource();
ds.setJdbcUrl("jdbc:mock:test");
ds.setMaxPoolSize(10);
ds.setMinPoolSize(0);
ds.setMaxStatements(10);
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public void f_test_proxool() throws Exception {
ProxoolDataSource ds = new ProxoolDataSource();
ds.setDriver("com.alibaba.druid.mock.MockDriver");
ds.setDriverUrl("jdbc:mock:test");
ds.setMaximumConnectionCount(10);
ds.setMinimumConnectionCount(0);
ds.setUser("user");
ds.setPassword("password");
for (int i = 0; i < 10; ++i) {
System.out.println("--------------------------------------------");
public static void f(DataSource ds, int count) throws Exception {
Connection conn = ds.getConnection();
for (int i = 0; i < count; ++i) {
PreparedStatement stmt = conn.prepareStatement("SELECT 1");
System.out.println(System.identityHashCode(unwrap(stmt)));
stmt.close();
conn.close();
public static MockPreparedStatement unwrap(PreparedStatement stmt) throws Exception {
if (stmt instanceof NewProxyPreparedStatement) {
Field field = NewProxyPreparedStatement.class.getDeclaredField("inner");
field.setAccessible(true);
return (MockPreparedStatement) field.get(stmt);
MockPreparedStatement mockStmt = stmt.unwrap(MockPreparedStatement.class);
return mockStmt;
public static MockConnection unwrap(Connection conn) throws Exception {
if (conn instanceof ConnectionHandle) {
ConnectionHandle handle = (ConnectionHandle) conn;
return (MockConnection) handle.getInternalConnection();
if (conn instanceof NewProxyConnection) {
NewProxyConnection handle = (NewProxyConnection) conn;
Field field = NewProxyConnection.class.getDeclaredField("inner");
field.setAccessible(true);
return (MockConnection) field.get(handle);
return conn.unwrap(MockConnection.class);
if (x.getExpr() instanceof SQLIdentifierExpr || x.getExpr() instanceof SQLPropertyExpr) {
String ident = x.getExpr().toString();
if (x.getExpr() instanceof SQLIdentifierExpr || x.getExpr() instanceof SQLPropertyExpr) {
String ident = x.getExpr().toString();
public class MySqlSchemaStatVisitorTest5 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT      distinct a.id "id",    a.col "col",     a.position "position",     a.panel_id "panelId"    "
+ "FROM     (select * from view_position_info) a LEFT JOIN db1.view_portal b ON a.panel_id = b.panel_id     "
+ "  LEFT JOIN (select * from view_portal_panel) c  ON a.panel_id = c.panel_id   "
+ " WHERE     b.user_id = ? and     ((b.is_grid='y' and c.param_name='is_hidden' and c.param_value='false') or      b.is_grid  != 'y') and b.user_id in (select user_id from table1 where id = 1)    ORDER BY    a.col ASC, a.position ASC";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertEquals(4, visitor.getTables().size());
Assert.assertEquals(true, visitor.containsTable("view_position_info"));
Assert.assertEquals(7, visitor.getFields().size());
JdbcSqlStat sqlStat = getSqlCounter(sql);
public class HiveLexer extends Lexer {
public HiveLexer(char[] input, int inputLength, boolean skipComment) {
super(input, inputLength, skipComment);
public void scanComment() {
if (ch != '/') {
throw new IllegalStateException();
scanChar();
if (ch == '*') {
scanChar();
while (ch == ' ') {
scanChar();
boolean isHint = false;
int startHintSp = sp + 1;
if (ch == '+') {
isHint = true;
scanChar();
for (;;) {
if (ch == '*' && buf[bp + 1] == '/') {
scanChar();
scanChar();
scanChar();
if (isHint) {
stringVal = new String(buf, np + startHintSp, (sp - startHintSp) - 2).trim();
token = Token.HINT;
stringVal = new String(buf, np, sp);
token = Token.MULTI_LINE_COMMENT;
if (ch == '/') {
scanChar();
for (;;) {
if (ch == 'r') {
if (buf[bp + 1] == 'n') {
scanChar();
if (ch == 'r') {
scanChar();
scanChar();
stringVal = new String(buf, np + 1, sp);
token = Token.LINE_COMMENT;
public class MySqlKillStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private Type type;
private SQLExpr threadId;
public static enum Type {
CONNECTION, QUERY
public Type getType() {
return type;
public void setType(Type type) {
this.type = type;
public SQLExpr getThreadId() {
return threadId;
public void setThreadId(SQLExpr threadId) {
this.threadId = threadId;
protected void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, threadId);
map.put("KILL", Token.KILL);
public SQLStatement parseKill() {
accept(Token.KILL);
MySqlKillStatement stmt = new MySqlKillStatement();
if (identifierEquals("CONNECTION")) {
stmt.setType(MySqlKillStatement.Type.CONNECTION);
lexer.nextToken();
} else if (identifierEquals("QUERY")) {
stmt.setType(MySqlKillStatement.Type.QUERY);
lexer.nextToken();
throw new ParserException("not support kill type " + lexer.token());
SQLExpr threadId = this.exprParser.expr();
stmt.setThreadId(threadId);
return stmt;
if (lexer.token() == Token.KILL) {
SQLStatement stmt = parseKill();
statementList.add(stmt);
return true;
void endVisit(MySqlKillStatement x);
boolean visit(MySqlKillStatement x);
public void endVisit(MySqlKillStatement x) {
public boolean visit(MySqlKillStatement x) {
return true;
public void endVisit(MySqlKillStatement x) {
public boolean visit(MySqlKillStatement x) {
if (MySqlKillStatement.Type.CONNECTION.equals(x.getType())) {
print("KILL CONNECTION ");
} else if (MySqlKillStatement.Type.QUERY.equals(x.getType())) {
print("KILL QUERY ");
x.getThreadId().accept(this);
return false;
KILL("KILL"),
public class Kill_Test extends TestCase {
public void test_0() throws Exception {
String sql = "KILL  QUERY 233";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("KILL QUERY 233;", text);
public void test_1() throws Exception {
String sql = "KILL  CONNECTION 233";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("KILL CONNECTION 233;", text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
for (SQLStatement stmt : stmtList) {
stmt.accept(new MySqlOutputVisitor(out));
out.append(";");
return out.toString();
sql = "select columnName from table1 where id in (select id from table3 where name = ?)";
private final int COUNT = 1000 * 1000;
private String    sql   = "SELECT      distinct a.id "id",    a.col "col",     a.position "position",     a.panel_id "panelId"    FROM     (select * from view_position_info) a LEFT JOIN db1.view_portal b ON a.panel_id = b.panel_id       LEFT JOIN (select * from view_portal_panel) c  ON a.panel_id = c.panel_id    WHERE     b.user_id = ? and     ((b.is_grid='y' and c.param_name='is_hidden' and c.param_value='false') or      b.is_grid  != 'y') and b.user_id in (select user_id from table1 where id = 1)    ORDER BY    a.col ASC, a.position ASC";
for (int i = 0; i < 5; ++i) {
List<SQLStatement> statementList =  new SQLStatementParser(sql).parseStatementList();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statementList.get(0).accept(visitor);
public class HiveLexer extends Lexer {
public HiveLexer(char[] input, int inputLength, boolean skipComment) {
super(input, inputLength, skipComment);
public void scanComment() {
if (ch != '/') {
throw new IllegalStateException();
scanChar();
if (ch == '*') {
scanChar();
while (ch == ' ') {
scanChar();
boolean isHint = false;
int startHintSp = sp + 1;
if (ch == '+') {
isHint = true;
scanChar();
for (;;) {
if (ch == '*' && buf[bp + 1] == '/') {
scanChar();
scanChar();
scanChar();
if (isHint) {
stringVal = new String(buf, np + startHintSp, (sp - startHintSp) - 2).trim();
token = Token.HINT;
stringVal = new String(buf, np, sp);
token = Token.MULTI_LINE_COMMENT;
if (ch == '/') {
scanChar();
for (;;) {
if (ch == 'r') {
if (buf[bp + 1] == 'n') {
scanChar();
if (ch == 'r') {
scanChar();
scanChar();
stringVal = new String(buf, np + 1, sp);
token = Token.LINE_COMMENT;
public class MySqlBinlogStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private SQLExpr expr;
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
this.expr = expr;
protected void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, expr);
public class MySqlKillStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private Type type;
private SQLExpr threadId;
public static enum Type {
CONNECTION, QUERY
public Type getType() {
return type;
public void setType(Type type) {
this.type = type;
public SQLExpr getThreadId() {
return threadId;
public void setThreadId(SQLExpr threadId) {
this.threadId = threadId;
protected void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, threadId);
map.put("KILL", Token.KILL);
public SQLStatement parseKill() {
accept(Token.KILL);
MySqlKillStatement stmt = new MySqlKillStatement();
if (identifierEquals("CONNECTION")) {
stmt.setType(MySqlKillStatement.Type.CONNECTION);
lexer.nextToken();
} else if (identifierEquals("QUERY")) {
stmt.setType(MySqlKillStatement.Type.QUERY);
lexer.nextToken();
throw new ParserException("not support kill type " + lexer.token());
SQLExpr threadId = this.exprParser.expr();
stmt.setThreadId(threadId);
return stmt;
public SQLStatement parseBinlog() {
acceptIdentifier("binlog");
MySqlBinlogStatement stmt = new MySqlBinlogStatement();
SQLExpr expr = this.exprParser.expr();
stmt.setExpr(expr);
return stmt;
if (lexer.token() == Token.KILL) {
SQLStatement stmt = parseKill();
statementList.add(stmt);
return true;
if (identifierEquals("BINLOG")) {
SQLStatement stmt = parseBinlog();
statementList.add(stmt);
return true;
void endVisit(MySqlKillStatement x);
boolean visit(MySqlKillStatement x);
void endVisit(MySqlBinlogStatement x);
boolean visit(MySqlBinlogStatement x);
public void endVisit(MySqlKillStatement x) {
public boolean visit(MySqlKillStatement x) {
return true;
public void endVisit(MySqlBinlogStatement x) {
public boolean visit(MySqlBinlogStatement x) {
return true;
public void endVisit(MySqlKillStatement x) {
public boolean visit(MySqlKillStatement x) {
if (MySqlKillStatement.Type.CONNECTION.equals(x.getType())) {
print("KILL CONNECTION ");
} else if (MySqlKillStatement.Type.QUERY.equals(x.getType())) {
print("KILL QUERY ");
x.getThreadId().accept(this);
return false;
public void endVisit(MySqlBinlogStatement x) {
public boolean visit(MySqlBinlogStatement x) {
print("BINLOG ");
x.getExpr().accept(this);
return false;
KILL("KILL"),
public class Binlog_Test extends TestCase {
public void test_0() throws Exception {
String sql = "binlog  'str'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("BINLOG 'str';", text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
for (SQLStatement stmt : stmtList) {
stmt.accept(new MySqlOutputVisitor(out));
out.append(";");
return out.toString();
public class Kill_Test extends TestCase {
public void test_0() throws Exception {
String sql = "KILL  QUERY 233";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("KILL QUERY 233;", text);
public void test_1() throws Exception {
String sql = "KILL  CONNECTION 233";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("KILL CONNECTION 233;", text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
for (SQLStatement stmt : stmtList) {
stmt.accept(new MySqlOutputVisitor(out));
out.append(";");
return out.toString();
sql = "select columnName from table1 where id in (select id from table3 where name = ?)";
private final int COUNT = 1000 * 1000;
private String    sql   = "SELECT      distinct a.id "id",    a.col "col",     a.position "position",     a.panel_id "panelId"    FROM     (select * from view_position_info) a LEFT JOIN db1.view_portal b ON a.panel_id = b.panel_id       LEFT JOIN (select * from view_portal_panel) c  ON a.panel_id = c.panel_id    WHERE     b.user_id = ? and     ((b.is_grid='y' and c.param_name='is_hidden' and c.param_value='false') or      b.is_grid  != 'y') and b.user_id in (select user_id from table1 where id = 1)    ORDER BY    a.col ASC, a.position ASC";
for (int i = 0; i < 5; ++i) {
List<SQLStatement> statementList =  new SQLStatementParser(sql).parseStatementList();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statementList.get(0).accept(visitor);
public interface PGSQLObject extends SQLObject {
void accept0(PGASTVisitor visitor);
public abstract class PGSQLObjectImpl extends SQLObjectImpl implements PGSQLObject {
private static final long serialVersionUID = 1L;
public PGSQLObjectImpl(){
protected void accept0(SQLASTVisitor visitor) {
this.accept0((PGASTVisitor) visitor);
public abstract void accept0(PGASTVisitor visitor);
public class PGSelectQueryBlock extends SQLSelectQueryBlock {
private static final long serialVersionUID = 1L;
private WithClause with;
private List<SQLExpr> distinctOn = new ArrayList<SQLExpr>(2);
private SQLExpr limit;
private SQLExpr offset;
private SQLOrderBy orderBy;
public WithClause getWith() {
return with;
public void setWith(WithClause with) {
this.with = with;
public SQLExpr getLimit() {
return limit;
public void setLimit(SQLExpr limit) {
this.limit = limit;
public SQLOrderBy getOrderBy() {
return orderBy;
public void setOrderBy(SQLOrderBy orderBy) {
this.orderBy = orderBy;
public SQLExpr getOffset() {
return offset;
public void setOffset(SQLExpr offset) {
this.offset = offset;
public List<SQLExpr> getDistinctOn() {
return distinctOn;
public void setDistinctOn(List<SQLExpr> distinctOn) {
this.distinctOn = distinctOn;
public static class WindowClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr name;
private List<SQLExpr> definition = new ArrayList<SQLExpr>(2);
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
public List<SQLExpr> getDefinition() {
return definition;
public void setDefinition(List<SQLExpr> definition) {
this.definition = definition;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, definition);
public static class FetchClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
public static enum Option {
FIRST, NEX
private Option option;
private SQLExpr count;
public Option getOption() {
return option;
public void setOption(Option option) {
this.option = option;
public SQLExpr getCount() {
return count;
public void setCount(SQLExpr count) {
this.count = count;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, count);
public static class ForClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
public static enum Option {
UPDATE, SH
private List<SQLExpr> of = new ArrayList<SQLExpr>(2);
private boolean noWait;
private Option option;
public Option getOption() {
return option;
public void setOption(Option option) {
this.option = option;
public List<SQLExpr> getOf() {
return of;
public void setOf(List<SQLExpr> of) {
this.of = of;
public boolean isNoWait() {
return noWait;
public void setNoWait(boolean noWait) {
this.noWait = noWait;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, of);
public static class WithClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
private boolean recursive = false;
private List<WithQuery> withQuery = new ArrayList<WithQuery>(2);
public boolean isRecursive() {
return recursive;
public void setRecursive(boolean recursive) {
this.recursive = recursive;
public List<WithQuery> getWithQuery() {
return withQuery;
public void setWithQuery(List<WithQuery> withQuery) {
this.withQuery = withQuery;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, withQuery);
public static class WithQuery extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr name;
private final List<SQLExpr> columns = new ArrayList<SQLExpr>();
private SQLSelectQuery subQuery;
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
public SQLSelectQuery getSubQuery() {
return subQuery;
public void setSubQuery(SQLSelectQuery subQuery) {
this.subQuery = subQuery;
public List<SQLExpr> getColumns() {
return columns;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, columns);
acceptChild(visitor, subQuery);
public class PGLexer extends Lexer {
public final static Keywords DEFAULT_MYSQL_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("LIMIT", Token.LIMIT);
map.put("OFFSET", Token.OFFSET);
map.put("WINDOW", Token.WINDOW);
map.put("ROW", Token.ROW);
map.put("ROWS", Token.ROWS);
map.put("ONLY", Token.ONLY);
map.put("FIRST", Token.FIRST);
map.put("NEXT", Token.NEXT);
map.put("FETCH", Token.FETCH);
map.put("OF", Token.OF);
map.put("SHARE", Token.SHARE);
map.put("NOWAIT", Token.NOWAIT);
map.put("RECURSIVE", Token.RECURSIVE);
DEFAULT_MYSQL_KEYWORDS = new Keywords(map);
public PGLexer(String input){
super(input);
super.keywods = DEFAULT_MYSQL_KEYWORDS;
public class PGSQLStatementParser extends SQLStatementParser {
public PGSQLStatementParser(String sql) throws ParserException {
this(new PGLexer(sql));
this.lexer.nextToken();
public PGSQLStatementParser(Lexer lexer) {
super(lexer);
public PGSelectParser createSQLSelectParser() {
return new PGSelectParser(this.lexer);
public class PGSelectParser extends SQLSelectParser {
public PGSelectParser(Lexer lexer) {
super(lexer);
public PGSelectParser(String sql) throws ParserException {
this(new PGLexer(sql));
this.lexer.nextToken();
protected SQLSelectQuery query() throws ParserException {
PGSelectQueryBlock queryBlock = new PGSelectQueryBlock();
if (lexer.token() == Token.WITH) {
lexer.nextToken();
PGSelectQueryBlock.WithClause withClause = new PGSelectQueryBlock.WithClause();
if (lexer.token() == Token.RECURSIVE) {
lexer.nextToken();
withClause.setRecursive(true);
for (;;) {
WithQuery withQuery = withQuery();
withClause.getWithQuery().add(withQuery);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
queryBlock.setWith(withClause);
accept(Token.SELECT);
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
if (lexer.token() == Token.ON) {
lexer.nextToken();
for (;;) {
SQLExpr expr = this.createExprParser().expr();
queryBlock.getDistinctOn().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
parseFrom(queryBlock);
parseWhere(queryBlock);
parseGroupBy(queryBlock);
if (lexer.token() == Token.WINDOW) {
lexer.nextToken();
PGSelectQueryBlock.WindowClause window = new PGSelectQueryBlock.WindowClause();
window.setName(this.expr());
accept(Token.AS);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
window.getDefinition().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
queryBlock.setOrderBy(this.createExprParser().parseOrderBy());
if (lexer.token() == Token.LIMIT) {
lexer.nextToken();
if (lexer.token() == Token.ALL) {
queryBlock.setLimit(new SQLIdentifierExpr("ALL"));
lexer.nextToken();
SQLExpr limit = expr();
queryBlock.setLimit(limit);
if (lexer.token() == Token.OFFSET) {
lexer.nextToken();
SQLExpr offset = expr();
queryBlock.setOffset(offset);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.FETCH) {
lexer.nextToken();
PGSelectQueryBlock.FetchClause fetch = new PGSelectQueryBlock.FetchClause();
if (lexer.token() == Token.FIRST) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.FIRST);
} else if (lexer.token() == Token.NEXT) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.NEXT);
throw new ParserException("expect 'FIRST' or 'NEXT'");
SQLExpr count = expr();
fetch.setCount(count);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.ONLY) {
lexer.nextToken();
throw new ParserException("expect 'ONLY'");
if (lexer.token() == Token.FOR) {
lexer.nextToken();
PGSelectQueryBlock.ForClause forClause = new PGSelectQueryBlock.ForClause();
if (lexer.token() == Token.UPDATE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.UPDATE);
} else if (lexer.token() == Token.SHARE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.SHARE);
throw new ParserException("expect 'FIRST' or 'NEXT'");
accept(Token.OF);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
forClause.getOf().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
if (lexer.token() == Token.NOWAIT) {
lexer.nextToken();
forClause.setNoWait(true);
return queryBlock;
private WithQuery withQuery() {
WithQuery withQuery = new WithQuery();
withQuery.setName(expr());
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
for (;;) {
SQLExpr expr = this.createExprParser().expr();
withQuery.getColumns().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
accept(Token.RPAREN);
accept(Token.AS);
if (lexer.token() == Token.LPAREN) {
SQLSelectQuery subQuery = query();
withQuery.setSubQuery(subQuery);
accept(Token.RPAREN);
return withQuery;
public interface PGASTVisitor extends SQLASTVisitor {
void endVisit(PGSelectQueryBlock.WindowClause x);
boolean visit(PGSelectQueryBlock.WindowClause x);
void endVisit(PGSelectQueryBlock.FetchClause x);
boolean visit(PGSelectQueryBlock.FetchClause x);
void endVisit(PGSelectQueryBlock.ForClause x);
boolean visit(PGSelectQueryBlock.ForClause x);
void endVisit(PGSelectQueryBlock.WithQuery x);
boolean visit(PGSelectQueryBlock.WithQuery x);
void endVisit(PGSelectQueryBlock.WithClause x);
boolean visit(PGSelectQueryBlock.WithClause x);
WINDOW("WINDOW"),
OFFSET("OFFSET"),
ROW("ROW"),
ROWS("ROWS"),
ONLY("ONLY"),
FIRST("FIRST"),
NEXT("NEXT"),
FETCH("FETCH"),
SHARE("SHARE"),
NOWAIT("NOWAIT"),
RECURSIVE("RECURSIVE"),
public class PGSelectIntoTest extends PGTest {
public class PGDeleteTest5 extends PGTest {
public void test_0() throws Exception {
String sql = "DELETE FROM films USING producers  WHERE producer_id = producers.id AND producers.name = 'foo';";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("films")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("producers")));
Assert.assertTrue(visitor.getFields().size() == 3);
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "producer_id")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("producers", "id")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("producers", "name")));
public class PGInsertTest0 extends PGTest {
public void test_0() throws Exception {
String sql = "INSERT INTO films VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("films")));
Assert.assertEquals(0, visitor.getFields().size());
public class PGInsertTest1 extends PGTest {
public void test_0() throws Exception {
String sql = "INSERT INTO films (code, title, did, date_prod, kind) VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getFields());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("films")));
Assert.assertEquals(5, visitor.getFields().size());
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "kind")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "code")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "date_prod")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "title")));
Assert.assertTrue(visitor.getFields().contains(new TableStat.Column("films", "did")));
protected final List<SQLUpdateSetItem> items            = new ArrayList<SQLUpdateSetItem>();
protected SQLExpr                      where;
protected SQLTableSource               tableSource;
public SQLSelectParser createSelectParser() {
public OracleSelectParser createSelectParser() {
public class PGUpdateStatement extends SQLUpdateStatement implements PGSQLStatement {
private static final long serialVersionUID = 1L;
private boolean           only             = false;
private PGWithClause      with;
private List<SQLExpr>     returning        = new ArrayList<SQLExpr>(2);
private SQLTableSource    from;
public SQLTableSource getFrom() {
return from;
public void setFrom(SQLTableSource from) {
this.from = from;
public boolean isOnly() {
return only;
public void setOnly(boolean only) {
this.only = only;
public List<SQLExpr> getReturning() {
return returning;
public void setReturning(List<SQLExpr> returning) {
this.returning = returning;
public PGWithClause getWith() {
return with;
public void setWith(PGWithClause with) {
this.with = with;
protected void accept0(SQLASTVisitor visitor) {
accept0((PGASTVisitor) visitor);
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, with);
acceptChild(visitor, tableSource);
acceptChild(visitor, items);
acceptChild(visitor, where);
visitor.endVisit(this);
public SQLUpdateStatement parseUpdateStatement() throws ParserException {
accept(Token.UPDATE);
PGUpdateStatement udpateStatement = new PGUpdateStatement();
SQLTableSource tableSource = this.exprParser.createSelectParser().parseTableSource();
udpateStatement.setTableSource(tableSource);
accept(Token.SET);
for (;;) {
SQLUpdateSetItem item = new SQLUpdateSetItem();
item.setColumn(this.exprParser.name());
accept(Token.EQ);
item.setValue(this.exprParser.expr());
udpateStatement.getItems().add(item);
if (lexer.token() == (Token.COMMA)) {
lexer.nextToken();
if (lexer.token() == (Token.WHERE)) {
lexer.nextToken();
udpateStatement.setWhere(this.exprParser.expr());
if (lexer.token() == Token.RETURNING) {
lexer.nextToken();
for (;;) {
udpateStatement.getReturning().add(this.exprParser.expr());
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
return udpateStatement;
void endVisit(PGUpdateStatement x);
boolean visit(PGUpdateStatement x);
public void endVisit(PGUpdateStatement x) {
public boolean visit(PGUpdateStatement x) {
return true;
public void endVisit(PGUpdateStatement x) {
public boolean visit(PGUpdateStatement x) {
if (x.getWith() != null) {
x.getWith().accept(this);
println();
print("UPDATE ");
if (x.isOnly()) {
print("ONLY ");
x.getTableSource().accept(this);
println();
print("SET ");
for (int i = 0, size = x.getItems().size(); i < size; ++i) {
if (i != 0) {
print(", ");
x.getItems().get(i).accept(this);
if (x.getFrom() != null) {
println();
print("FROM ");
x.getFrom().accept(this);
if (x.getWhere() != null) {
println();
print("WHERE ");
x.getWhere().accept(this);
if (x.getReturning().size() > 0) {
println();
print("RETURNING ");
printAndAccept(x.getReturning(), ", ");
return false;
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap != null) {
String alias = null;
if (x.getName() != null) {
alias = x.getName().toString();
if (alias != null) {
aliasMap.put(alias, null);
x.getQuery().accept(this);
return false;
aliasLocal.set(new HashMap<String, String>());
x.putAttribute("_original_use_mode", modeLocal.get());
modeLocal.set(Mode.Insert);
String originalTable = currentTableLocal.get();
if (x.getTableName() instanceof SQLName) {
String ident = ((SQLName) x.getTableName()).toString();
currentTableLocal.set(ident);
x.putAttribute("_old_local_", originalTable);
TableStat stat = tableStats.get(ident);
if (stat == null) {
stat = new TableStat();
tableStats.put(new TableStat.Name(ident), stat);
stat.incrementInsertCount();
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap != null) {
if (x.getAlias() != null) {
aliasMap.put(x.getAlias(), ident);
aliasMap.put(ident, ident);
accept(x.getColumns());
accept(x.getQuery());
return false;
public void endVisit(PGUpdateStatement x) {
public boolean visit(PGUpdateStatement x) {
Map<String, String> oldAliasMap = aliasLocal.get();
aliasLocal.set(new HashMap<String, String>());
if (x.getWith() != null) {
x.getWith().accept(this);
String ident = x.getTableName().toString();
currentTableLocal.set(ident);
TableStat stat = tableStats.get(ident);
if (stat == null) {
stat = new TableStat();
tableStats.put(new TableStat.Name(ident), stat);
stat.incrementUpdateCount();
Map<String, String> aliasMap = aliasLocal.get();
aliasMap.put(ident, ident);
accept(x.getItems());
accept(x.getWhere());
aliasLocal.set(oldAliasMap);
return false;
public SQLSelectParser createSelectParser() {
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap.containsKey(ident) && aliasMap.get(ident) == null) {
currentTableLocal.set(ident);
x.putAttribute("_old_local_", originalTable);
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap.containsKey(ident) && aliasMap.get(ident) == null) {
return false;
public PGSelectStatement(){
public PGSelectStatement(SQLSelect select){
super(select);
public PGSelectStatement parseSelect() throws ParserException {
return new PGSelectStatement(createSQLSelectParser().select());
if (lexer.token() == Token.SELECT) {
PGSelectStatement stmt = this.parseSelect();
stmt.setWith(with);
return stmt;
protected final HashMap<TableStat.Name, TableStat>      tableStats        = new HashMap<TableStat.Name, TableStat>();
protected final Set<Column>                             fields            = new HashSet<Column>();
protected final Set<Condition>                          conditions        = new HashSet<Condition>();
public Set<Condition> getConditions() {
return conditions;
public boolean visit(SQLBinaryOpExpr x) {
switch (x.getOperator()) {
case Equality
case NotEqual
case GreaterThan
case GreaterThanOrEqual
case LessThan
case LessThanOrEqual
case LessThanOrEqualOrGreaterThan
case NotLike
case IsNot
handleCondition(x.getLeft(), x.getOperator().name);
handleCondition(x.getRight(), x.getOperator().name);
return true;
protected void handleCondition(SQLExpr expr, String operator) {
Map<String, String> aliasMap = aliasLocal.get();
if (aliasMap == null) {
if (expr instanceof SQLPropertyExpr) {
SQLExpr owner = ((SQLPropertyExpr) expr).getOwner();
String column = ((SQLPropertyExpr) expr).getName();
if (owner instanceof SQLIdentifierExpr) {
String table = ((SQLIdentifierExpr) owner).getName();
if (aliasMap.containsKey(table)) {
table = aliasMap.get(table);
if (table != null) {
Condition condition = new Condition();
condition.setColumn(new Column(table, column));
condition.setOperator(operator);
this.conditions.add(condition);
if (expr instanceof SQLIdentifierExpr) {
String column = ((SQLIdentifierExpr) expr).getName();
String table = currentTableLocal.get();
if (table != null) {
if (aliasMap.containsKey(table)) {
table = aliasMap.get(table);
if (table != null) {
Condition condition = new Condition();
condition.setColumn(new Column(table, column));
condition.setOperator(operator);
this.conditions.add(condition);
public boolean visit(SQLInListExpr x) {
if (x.isNot()) {
handleCondition(x.getExpr(), "NOT IN");
handleCondition(x.getExpr(), "IN");
return true;
if (x.isNot()) {
handleCondition(x.getExpr(), "NOT IN");
handleCondition(x.getExpr(), "IN");
public static class Condition {
private Column column;
private String operator;
public Column getColumn() {
return column;
public void setColumn(Column column) {
this.column = column;
public String getOperator() {
return operator;
public void setOperator(String operator) {
this.operator = operator;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((column == null) ? 0 : column.hashCode());
result = prime * result + ((operator == null) ? 0 : operator.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
Condition other = (Condition) obj;
if (column == null) {
if (other.column != null) {
return false;
} else if (!column.equals(other.column)) {
return false;
if (operator == null) {
if (other.operator != null) {
return false;
} else if (!operator.equals(other.operator)) {
return false;
return true;
public String toString() {
return this.column.toString() + " " + this.operator;
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("coditions : " + visitor.getConditions());
public String toString() {
return "DEFAULT";
columns.add(new Column(table, x.getName()));
columns.add(new Column(currentTable, x.getName()));
if (expr instanceof SQLIdentifierExpr || expr instanceof SQLDefaultExpr) {
String method_name = expr.toString();
throw new ParserException("not support token:" + lexer.token());
} else if (lexer.token() != Token.IDENTIFIER && lexer.token() != Token.USER && lexer.token() != Token.PASSWORD) {
protected final Set<Column>                             columns           = new HashSet<Column>();
protected final Set<Column>                             orderByColumns    = new HashSet<Column>();
public Set<Column> getOrderByColumns() {
return orderByColumns;
columns.add(new Column(table, x.getName()));
columns.add(new Column(currentTable, x.getName()));
columns.add(new Column(currentTable, "*"));
public Set<Column> getColumns() {
return columns;
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new Column("mytable", "last_name")));
Assert.assertTrue(visitor.getColumns().contains(new Column("mytable", "first_name")));
Assert.assertTrue(visitor.getColumns().contains(new Column("mytable", "full_name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new Column("employee", "name")));
Assert.assertTrue(visitor.getColumns().contains(new Column("info", "name")));
Assert.assertTrue(visitor.getColumns().contains(new Column("info", "salary")));
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "loginCount")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users2", "name2")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users2", "id2")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(7, visitor.getColumns().size());
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("groups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("groups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "loginCount")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("emp", "salary")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("emp", "F1")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("master@emp", "salary")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "id")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "salary")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "salary")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "name")));
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "salary")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("employee", "depId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("department", "id")));
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("usergroups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "loginCount")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users2", "name2")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users2", "id2")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "groupId")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "name")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("groups", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("groups", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "id")));
Assert.assertEquals(true, visitor.getColumns().contains(new Column("users", "loginCount")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 1);
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 3);
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "producer_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("producers", "id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("producers", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 3);
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "producer_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("producers", "id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("producers", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(0, visitor.getColumns().size());
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "kind")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "code")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "date_prod")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "title")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "did")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "kind")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "code")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "date_prod")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "title")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("films", "did")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("tmp_films", "date_prod")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("tmp_films", "*")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("distributors", "did")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("distributors", "dname")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "sales_count")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("accounts", "sales_person")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("accounts", "name")));
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().contains(new Column("films", "*")));
Assert.assertTrue(visitor.getColumns().contains(new Column("films", "date_prod")));
System.out.println("fields : " + visitor.getColumns());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getColumns().size() == 0);
System.out.println("fields : " + visitor.getColumns());
public class OracleMergeStatement extends OracleStatementImpl {
private static final long      serialVersionUID = 1L;
private final List<OracleHint> hints            = new ArrayList<OracleHint>();
private SQLName                into;
private String                 alias;
private SQLTableSource         using;
private SQLExpr                on;
private MergeUpdateClause      updateClause;
private MergeInsertClause      insertClause;
private ErrorLoggingClause     errorLoggingClause;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, into);
acceptChild(visitor, using);
acceptChild(visitor, on);
acceptChild(visitor, updateClause);
acceptChild(visitor, insertClause);
acceptChild(visitor, errorLoggingClause);
visitor.endVisit(this);
public String getAlias() {
return alias;
public void setAlias(String alias) {
this.alias = alias;
public SQLName getInto() {
return into;
public void setInto(SQLName into) {
this.into = into;
public SQLTableSource getUsing() {
return using;
public void setUsing(SQLTableSource using) {
this.using = using;
public SQLExpr getOn() {
return on;
public void setOn(SQLExpr on) {
this.on = on;
public MergeUpdateClause getUpdateClause() {
return updateClause;
public void setUpdateClause(MergeUpdateClause updateClause) {
this.updateClause = updateClause;
public MergeInsertClause getInsertClause() {
return insertClause;
public void setInsertClause(MergeInsertClause insertClause) {
this.insertClause = insertClause;
public ErrorLoggingClause getErrorLoggingClause() {
return errorLoggingClause;
public void setErrorLoggingClause(ErrorLoggingClause errorLoggingClause) {
this.errorLoggingClause = errorLoggingClause;
public List<OracleHint> getHints() {
return hints;
public static class MergeUpdateClause extends OracleSQLObjectImpl {
private static final long      serialVersionUID = 1L;
private List<SQLUpdateSetItem> items            = new ArrayList<SQLUpdateSetItem>();
private SQLExpr                where;
private SQLExpr                deleteWhere;
public List<SQLUpdateSetItem> getItems() {
return items;
public void setItems(List<SQLUpdateSetItem> items) {
this.items = items;
public SQLExpr getWhere() {
return where;
public void setWhere(SQLExpr where) {
this.where = where;
public SQLExpr getDeleteWhere() {
return deleteWhere;
public void setDeleteWhere(SQLExpr deleteWhere) {
this.deleteWhere = deleteWhere;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, items);
acceptChild(visitor, where);
acceptChild(visitor, deleteWhere);
visitor.endVisit(this);
public static class MergeInsertClause extends OracleSQLObjectImpl {
private static final long serialVersionUID = 1L;
private List<SQLExpr>     columns          = new ArrayList<SQLExpr>();
private List<SQLExpr>     values           = new ArrayList<SQLExpr>();
private SQLExpr           where;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, columns);
acceptChild(visitor, columns);
acceptChild(visitor, columns);
visitor.endVisit(this);
public List<SQLExpr> getColumns() {
return columns;
public void setColumns(List<SQLExpr> columns) {
this.columns = columns;
public List<SQLExpr> getValues() {
return values;
public void setValues(List<SQLExpr> values) {
this.values = values;
public SQLExpr getWhere() {
return where;
public void setWhere(SQLExpr where) {
this.where = where;
public static class ErrorLoggingClause extends OracleSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLName           into;
private SQLExpr           simpleExpression;
private SQLExpr           limit;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, into);
acceptChild(visitor, simpleExpression);
acceptChild(visitor, limit);
visitor.endVisit(this);
public SQLName getInto() {
return into;
public void setInto(SQLName into) {
this.into = into;
public SQLExpr getSimpleExpression() {
return simpleExpression;
public void setSimpleExpression(SQLExpr simpleExpression) {
this.simpleExpression = simpleExpression;
public SQLExpr getLimit() {
return limit;
public void setLimit(SQLExpr limit) {
this.limit = limit;
public interface OracleStatement extends OracleSQLObject {
public abstract class OracleStatementImpl extends SQLStatementImpl implements OracleStatement {
private static final long serialVersionUID = 1L;
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
public abstract void accept0(OracleASTVisitor visitor);
public void parseHints(List<OracleHint> hints) {
if (lexer.token() == Token.HINT) {
hints.add(new OracleHint(lexer.stringVal()));
lexer.nextToken();
map.put("MERGE", Token.MERGE);
map.put("USING", Token.USING);
map.put("MATCHED", Token.MATCHED);
map.put("LOG", Token.LOG);
map.put("ERRORS", Token.ERRORS);
map.put("REJECT", Token.REJECT);
map.put("UNLIMITED", Token.UNLIMITED);
this.createExprParser().parseHints(queryBlock.getHints());
protected OracleExprParser createExprParser() {
if (lexer.token() == Token.MERGE) {
statementList.add(this.parseMerge());
public OracleMergeStatement parseMerge() throws ParserException {
accept(Token.MERGE);
OracleMergeStatement stmt = new OracleMergeStatement();
OracleExprParser exprParser = this.createExprParser();
exprParser.parseHints(stmt.getHints());
accept(Token.INTO);
stmt.setInto(exprParser.name());
stmt.setAlias(as());
accept(Token.USING);
SQLTableSource using = this.createSQLSelectParser().parseTableSource();
stmt.setUsing(using);
accept(Token.ON);
stmt.setOn(exprParser.expr());
boolean insertFlag = false;
if (lexer.token() == Token.WHEN) {
lexer.nextToken();
if (lexer.token() == Token.MATCHED) {
OracleMergeStatement.MergeUpdateClause updateClause = new OracleMergeStatement.MergeUpdateClause();
lexer.nextToken();
accept(Token.THEN);
accept(Token.UPDATE);
accept(Token.SET);
for (;;) {
SQLUpdateSetItem item = new SQLUpdateSetItem();
item.setColumn(this.exprParser.name());
accept(Token.EQ);
item.setValue(this.exprParser.expr());
updateClause.getItems().add(item);
if (lexer.token() == (Token.COMMA)) {
lexer.nextToken();
if (lexer.token() == Token.WHERE) {
lexer.nextToken();
updateClause.setWhere(exprParser.expr());
if (lexer.token() == Token.DELETE) {
lexer.nextToken();
accept(Token.WHERE);
updateClause.setWhere(exprParser.expr());
stmt.setUpdateClause(updateClause);
} else if (lexer.token() == Token.NOT) {
lexer.nextToken();
insertFlag = true;
if (!insertFlag) {
if (lexer.token() == Token.WHEN) {
lexer.nextToken();
if (lexer.token() == Token.NOT) {
lexer.nextToken();
insertFlag = true;
if (insertFlag) {
OracleMergeStatement.MergeInsertClause insertClause = new OracleMergeStatement.MergeInsertClause();
accept(Token.MATCHED);
accept(Token.THEN);
accept(Token.INSERT);
accept(Token.LPAREN);
exprParser.exprList(insertClause.getColumns());
accept(Token.RPAREN);
accept(Token.VALUES);
accept(Token.LPAREN);
exprParser.exprList(insertClause.getValues());
accept(Token.RPAREN);
if (lexer.token() == Token.WHERE) {
lexer.nextToken();
insertClause.setWhere(exprParser.expr());
stmt.setInsertClause(insertClause);
if (lexer.token() == Token.LOG) {
OracleMergeStatement.ErrorLoggingClause errorClause = new OracleMergeStatement.ErrorLoggingClause();
lexer.nextToken();
accept(Token.ERRORS);
if (lexer.token() == Token.INTO) {
lexer.nextToken();
errorClause.setInto(exprParser.name());
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
errorClause.setSimpleExpression(exprParser.expr());
accept(Token.RPAREN);
if (lexer.token() == Token.REJECT) {
lexer.nextToken();
accept(Token.LIMIT);
errorClause.setLimit(exprParser.expr());
stmt.setErrorLoggingClause(errorClause);
return stmt;
public boolean visit(OracleMergeStatement x) {
return true;
public void endVisit(OracleMergeStatement x) {
public boolean visit(MergeUpdateClause x) {
return true;
public void endVisit(MergeUpdateClause x) {
public boolean visit(MergeInsertClause x) {
return true;
public void endVisit(MergeInsertClause x) {
public boolean visit(ErrorLoggingClause x) {
return true;
public void endVisit(ErrorLoggingClause x) {
boolean visit(OracleMergeStatement x);
void endVisit(OracleMergeStatement x);
boolean visit(OracleMergeStatement.MergeUpdateClause x);
void endVisit(OracleMergeStatement.MergeUpdateClause x);
boolean visit(OracleMergeStatement.MergeInsertClause x);
void endVisit(OracleMergeStatement.MergeInsertClause x);
boolean visit(OracleMergeStatement.ErrorLoggingClause x);
void endVisit(OracleMergeStatement.ErrorLoggingClause x);
public boolean visit(OracleMergeStatement x) {
print("MERGE ");
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
print(" ");
print("INTO ");
x.getInto().accept(this);
if (x.getAlias() != null) {
print(" ");
print(x.getAlias());
println();
print("USING ");
x.getUsing().accept(this);
print(" ON ");
x.getOn().accept(this);
if (x.getUpdateClause() != null) {
println();
x.getUpdateClause().accept(this);
if (x.getInsertClause() != null) {
println();
x.getInsertClause().accept(this);
if (x.getErrorLoggingClause() != null) {
println();
x.getErrorLoggingClause().accept(this);
return false;
public void endVisit(OracleMergeStatement x) {
public boolean visit(MergeUpdateClause x) {
print("WHEN MATCHED THEN UPDATE SET ");
printAndAccept(x.getItems(), ", ");
if (x.getWhere() != null) {
incrementIndent();
println();
print("WHERE ");
x.getWhere().accept(this);
decrementIndent();
if (x.getDeleteWhere() != null) {
incrementIndent();
println();
print("DELETE WHERE ");
x.getDeleteWhere().accept(this);
decrementIndent();
return false;
public void endVisit(MergeUpdateClause x) {
public boolean visit(MergeInsertClause x) {
print("WHEN NOT MATCHED THEN INSERT ");
printAndAccept(x.getColumns(), ", ");
print(" VALUES (");
printAndAccept(x.getValues(), ", ");
print(")");
if (x.getWhere() != null) {
incrementIndent();
println();
print("WHERE ");
x.getWhere().accept(this);
decrementIndent();
return false;
public void endVisit(MergeInsertClause x) {
public boolean visit(ErrorLoggingClause x) {
print("LOG ERRORS ");
if (x.getInto() != null) {
print("INTO ");
x.getInto().accept(this);
print(" ");
if (x.getSimpleExpression() != null) {
print("(");
x.getSimpleExpression().accept(this);
print(")");
if (x.getLimit() != null) {
print(" REJECT LIMIT ");
x.getLimit().accept(this);
return false;
public void endVisit(ErrorLoggingClause x) {
public boolean visit(OracleMergeStatement x) {
return true;
public void endVisit(OracleMergeStatement x) {
public boolean visit(MergeUpdateClause x) {
return true;
public void endVisit(MergeUpdateClause x) {
public boolean visit(MergeInsertClause x) {
return true;
public void endVisit(MergeInsertClause x) {
public boolean visit(ErrorLoggingClause x) {
return true;
public void endVisit(ErrorLoggingClause x) {
MERGE("MERGE"),
MATCHED("MATCHED"),
LOG("LOG"),
ERRORS("ERRORS"),
REJECT("REJECT"),
UNLIMITED("UNLIMITED"),
public class OracleMergeTest extends OracleTest {
public void test_0() throws Exception {
String sql = "MERGE INTO bonuses D" + 
"   USING (SELECT employee_id, salary, department_id FROM employees" + 
"   WHERE department_id = 80) S" + 
"   ON (D.employee_id = S.employee_id)" + 
"   WHEN MATCHED THEN UPDATE SET D.bonus = D.bonus + S.salary*0.01" + 
"     DELETE WHERE (S.salary > 8000)" + 
"   WHEN NOT MATCHED THEN INSERT (D.employee_id, D.bonus)" + 
"     VALUES (S.employee_id, S.salary*0.01)" + 
"     WHERE (S.salary <= 8000);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("departments")));
Assert.assertEquals(4, visitor.getColumns().size());
"      SELECT d.department_name, SUM(d.salary) dept_total" + 
"      GROUP BY d.department_name)," + 
Assert.assertEquals(4, visitor.getColumns().size());
public class OracleErrorLoggingClause extends OracleSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLName           into;
private SQLExpr           simpleExpression;
private SQLExpr           limit;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, into);
acceptChild(visitor, simpleExpression);
acceptChild(visitor, limit);
visitor.endVisit(this);
public SQLName getInto() {
return into;
public void setInto(SQLName into) {
this.into = into;
public SQLExpr getSimpleExpression() {
return simpleExpression;
public void setSimpleExpression(SQLExpr simpleExpression) {
this.simpleExpression = simpleExpression;
public SQLExpr getLimit() {
return limit;
public void setLimit(SQLExpr limit) {
this.limit = limit;
private OracleErrorLoggingClause     errorLoggingClause;
public OracleErrorLoggingClause getErrorLoggingClause() {
public void setErrorLoggingClause(OracleErrorLoggingClause errorLoggingClause) {
OracleErrorLoggingClause errorClause = new OracleErrorLoggingClause();
public boolean visit(OracleErrorLoggingClause x) {
public void endVisit(OracleErrorLoggingClause x) {
boolean visit(OracleErrorLoggingClause x);
void endVisit(OracleErrorLoggingClause x);
public boolean visit(OracleErrorLoggingClause x) {
public void endVisit(OracleErrorLoggingClause x) {
public boolean visit(OracleErrorLoggingClause x) {
public void endVisit(OracleErrorLoggingClause x) {
public class SQLServerOutputVisitor extends SQLASTOutputVisitor implements SQLServerASTVisitor {
public SQLServerOutputVisitor(Appendable appender){
SQLServerOutputVisitor visitor = new SQLServerOutputVisitor(out);
public class SQLServerSchemaStatVisitor extends SchemaStatVisitor implements SQLServerASTVisitor {
public boolean visit(SQLServerSelectQueryBlock x) {
return visit((SQLSelectQueryBlock) x);
public void endVisit(SQLServerSelectQueryBlock x) {
endVisit((SQLSelectQueryBlock) x);
public boolean visit(Top x) {
return false;
public void endVisit(Top x) {
public interface HiveSQLObject extends SQLObject {
void accept0(HiveASTVisitor visitor);
public abstract class HiveSQLObjectImpl extends SQLObjectImpl implements HiveSQLObject {
private static final long serialVersionUID = 1L;
public void accept0(SQLASTVisitor visitor) {
if (visitor instanceof HiveASTVisitor) {
accept0((HiveASTVisitor) visitor);
throw new IllegalArgumentException("not support visitor type : " + visitor.getClass().getName());
public abstract void accept0(HiveASTVisitor visitor);
public interface HiveStatement extends SQLStatement, HiveSQLObject {
public class HiveCreateTableStatement extends SQLCreateTableStatement implements HiveStatement {
private static final long serialVersionUID = 1L;
private PartitionedBy     partitionedBy;
public PartitionedBy getPartitionedBy() {
return partitionedBy;
public void setPartitionedBy(PartitionedBy partitionedBy) {
this.partitionedBy = partitionedBy;
protected void accept0(SQLASTVisitor visitor) {
this.accept0((HiveASTVisitor) visitor);
public void accept0(HiveASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, name);
this.acceptChild(visitor, tableElementList);
this.acceptChild(visitor, partitionedBy);
visitor.endVisit(this);
public static class PartitionedBy extends HiveSQLObjectImpl {
private static final long serialVersionUID = 1L;
private String            name;
private SQLDataType       type;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public SQLDataType getType() {
return type;
public void setType(SQLDataType type) {
this.type = type;
public void accept0(HiveASTVisitor visitor) {
public final static Keywords DEFAULT_SQL_SERVER_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("WITH", Token.WITH);
map.put("CURSOR", Token.CURSOR);
map.put("TOP", Token.TOP);
DEFAULT_SQL_SERVER_KEYWORDS = new Keywords(map);
public HiveLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public HiveLexer(String input) {
super(input);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public class HiveStatementParser extends SQLStatementParser {
public HiveStatementParser(Lexer lexer){
super(lexer);
public HiveStatementParser(String sql){
super(new HiveLexer(sql));
this.lexer.nextToken();
public interface HiveASTVisitor extends SQLASTVisitor {
void endVisit(HiveCreateTableStatement x);
boolean visit(HiveCreateTableStatement x);
public class HiveASTVisitorAdapter extends SQLASTVisitorAdapter implements HiveASTVisitor {
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
return true;
public class HiveOutputVisitor extends SQLASTOutputVisitor implements HiveASTVisitor {
public HiveOutputVisitor(Appendable appender){
super(appender);
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
visit((SQLCreateTableStatement) x);
return false;
public class HiveSchemaStatVisitor extends SchemaStatVisitor implements HiveASTVisitor {
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
return false;
public boolean visit(SQLCreateTableStatement x) {
for (SQLTableElement e : x.getTableElementList()) {
e.setParent(x);
String tableName = x.getName().toString();
TableStat stat = new TableStat();
stat.incrementCreateCount();
tableStats.put(new TableStat.Name(tableName), stat);
return true;
public boolean visit(SQLColumnDefinition x) {
String tableName = null;
SQLObject parent = x.getParent();
if (parent instanceof SQLCreateTableStatement) {
tableName = ((SQLCreateTableStatement) parent).getName().toString();
if (tableName == null) {
return true;
String columnName = x.getName().toString();
columns.add(new Column(tableName, columnName));
return true;
int createCount = 0;
public int getCreateCount() {
return createCount;
public void incrementCreateCount() {
this.createCount++;
if (createCount > 0) {
buf.append("Create");
public class HiveCreateTableTest extends HiveTest {
public void test_hive() throws Exception {
String sql = "CREATE TABLE pokes (foo INT, bar STRING);";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("pokes")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("pokes", "foo")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("pokes", "bar")));
public class HiveSelectTest extends HiveTest {
public void test_hive() throws Exception {
String sql = "SELECT COUNT(*) FROM u_data;";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("u_data")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("u_data", "*")));
public class HiveSelectTest2 extends HiveTest {
public void test_hive() throws Exception {
String sql = "SELECT a.foo FROM invites a WHERE a.ds='2008-08-15';";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("invites")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "foo")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "ds")));
public class HiveTest extends TestCase {
protected String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
HiveOutputVisitor visitor = new HiveOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public interface HiveSQLObject extends SQLObject {
void accept0(HiveASTVisitor visitor);
public abstract class HiveSQLObjectImpl extends SQLObjectImpl implements HiveSQLObject {
private static final long serialVersionUID = 1L;
public void accept0(SQLASTVisitor visitor) {
if (visitor instanceof HiveASTVisitor) {
accept0((HiveASTVisitor) visitor);
throw new IllegalArgumentException("not support visitor type : " + visitor.getClass().getName());
public abstract void accept0(HiveASTVisitor visitor);
public interface HiveStatement extends SQLStatement, HiveSQLObject {
public class HiveCreateTableStatement extends SQLCreateTableStatement implements HiveStatement {
private static final long serialVersionUID = 1L;
private PartitionedBy     partitionedBy;
public PartitionedBy getPartitionedBy() {
return partitionedBy;
public void setPartitionedBy(PartitionedBy partitionedBy) {
this.partitionedBy = partitionedBy;
protected void accept0(SQLASTVisitor visitor) {
this.accept0((HiveASTVisitor) visitor);
public void accept0(HiveASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, name);
this.acceptChild(visitor, tableElementList);
this.acceptChild(visitor, partitionedBy);
visitor.endVisit(this);
public static class PartitionedBy extends HiveSQLObjectImpl {
private static final long serialVersionUID = 1L;
private String            name;
private SQLDataType       type;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public SQLDataType getType() {
return type;
public void setType(SQLDataType type) {
this.type = type;
public void accept0(HiveASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, type);
visitor.endVisit(this);
public class HiveCreateTableParser extends SQLCreateTableParser {
public HiveCreateTableParser(String sql){
super(new HiveLexer(sql));
this.lexer.nextToken();
public HiveCreateTableParser(Lexer lexer){
super(lexer);
protected HiveCreateTableStatement newCreateStatement() {
return new HiveCreateTableStatement();
public SQLCreateTableStatement parseCrateTable(boolean acceptCreate) {
HiveCreateTableStatement stmt = (HiveCreateTableStatement) super.parseCrateTable(acceptCreate);
if (lexer.token() == Token.PARTITIONED) {
lexer.nextToken();
accept(Token.BY);
accept(Token.LPAREN);
PartitionedBy partitionedBy = new PartitionedBy();
partitionedBy.setName(exprParser.name().toString());
partitionedBy.setType(exprParser.parseDataType());
accept(Token.RPAREN);
stmt.setPartitionedBy(partitionedBy);
return stmt;
public final static Keywords DEFAULT_SQL_SERVER_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCE", Token.REFERENCE);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("WITH", Token.WITH);
map.put("PARTITIONED", Token.PARTITIONED);
DEFAULT_SQL_SERVER_KEYWORDS = new Keywords(map);
public HiveLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public HiveLexer(String input) {
super(input);
super.keywods = DEFAULT_SQL_SERVER_KEYWORDS;
public class HiveStatementParser extends SQLStatementParser {
public HiveStatementParser(Lexer lexer){
super(lexer);
public HiveStatementParser(String sql){
super(new HiveLexer(sql));
this.lexer.nextToken();
public HiveCreateTableParser getSQLCreateTableParser() {
return new HiveCreateTableParser(lexer);
public interface HiveASTVisitor extends SQLASTVisitor {
void endVisit(HiveCreateTableStatement x);
boolean visit(HiveCreateTableStatement x);
void endVisit(HiveCreateTableStatement.PartitionedBy x);
boolean visit(HiveCreateTableStatement.PartitionedBy x);
public class HiveASTVisitorAdapter extends SQLASTVisitorAdapter implements HiveASTVisitor {
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
return true;
public void endVisit(HiveCreateTableStatement.PartitionedBy x) {
public boolean visit(HiveCreateTableStatement.PartitionedBy x) {
return true;
public class HiveOutputVisitor extends SQLASTOutputVisitor implements HiveASTVisitor {
public HiveOutputVisitor(Appendable appender){
super(appender);
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
visit((SQLCreateTableStatement) x);
if (x.getPartitionedBy() != null) {
println();
x.getPartitionedBy().accept(this);
return false;
public void endVisit(PartitionedBy x) {
public boolean visit(PartitionedBy x) {
print("PARTITIONED BY (");
print(x.getName());
print(" ");
x.getType().accept(this);
print(")");
return false;
public class HiveSchemaStatVisitor extends SchemaStatVisitor implements HiveASTVisitor {
public void endVisit(HiveCreateTableStatement x) {
public boolean visit(HiveCreateTableStatement x) {
return visit((SQLCreateTableStatement) x);
public void endVisit(HiveCreateTableStatement.PartitionedBy x) {
public boolean visit(HiveCreateTableStatement.PartitionedBy x) {
return false;
SQLCreateTableStatement createTable = newCreateStatement();
protected SQLCreateTableStatement newCreateStatement() {
return new SQLCreateTableStatement();
PARTITIONED("PARTITIONED"),
public boolean visit(SQLCreateTableStatement x) {
for (SQLTableElement e : x.getTableElementList()) {
e.setParent(x);
String tableName = x.getName().toString();
TableStat stat = new TableStat();
stat.incrementCreateCount();
tableStats.put(new TableStat.Name(tableName), stat);
return true;
public boolean visit(SQLColumnDefinition x) {
String tableName = null;
SQLObject parent = x.getParent();
if (parent instanceof SQLCreateTableStatement) {
tableName = ((SQLCreateTableStatement) parent).getName().toString();
if (tableName == null) {
return true;
String columnName = x.getName().toString();
columns.add(new Column(tableName, columnName));
return true;
int createCount = 0;
public int getCreateCount() {
return createCount;
public void incrementCreateCount() {
this.createCount++;
if (createCount > 0) {
buf.append("Create");
public class HiveCreateTableTest extends HiveTest {
public void test_hive() throws Exception {
String sql = "CREATE TABLE pokes (foo INT, bar STRING);";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("pokes")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("pokes", "foo")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("pokes", "bar")));
public class HiveCreateTableTest2 extends HiveTest {
public void test_hive() throws Exception {
String sql = "CREATE TABLE invites (foo INT, bar STRING) PARTITIONED BY (ds STRING);";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("invites")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "foo")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "bar")));
public class HiveSelectTest extends HiveTest {
public void test_hive() throws Exception {
String sql = "SELECT COUNT(*) FROM u_data;";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("u_data")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("u_data", "*")));
public class HiveSelectTest2 extends HiveTest {
public void test_hive() throws Exception {
String sql = "SELECT a.foo FROM invites a WHERE a.ds='2008-08-15';";
HiveStatementParser parser = new HiveStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
HiveSchemaStatVisitor visitor = new HiveSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("invites")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "foo")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("invites", "ds")));
public class HiveTest extends TestCase {
protected String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
HiveOutputVisitor visitor = new HiveOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public class SQLExprTableSource extends SQLTableSourceImpl {
public class SQLJoinTableSource extends SQLTableSourceImpl {
public class SQLSubqueryTableSource extends SQLTableSourceImpl {
public interface SQLTableSource extends SQLObject {
String getAlias();
void setAlias(String alias);
public abstract class SQLTableSourceImpl extends SQLObjectImpl implements SQLTableSource {
private static final long serialVersionUID = 1L;
protected String          alias;
public SQLTableSourceImpl(){
public SQLTableSourceImpl(String alias){
this.alias = alias;
public String getAlias() {
return this.alias;
public void setAlias(String alias) {
this.alias = alias;
private OracleReturningClause    returning;
private List<OracleHint>         hints            = new ArrayList<OracleHint>();
public List<OracleHint> getHints() {
return hints;
public void setHints(List<OracleHint> hints) {
this.hints = hints;
protected FlashbackQueryClause  flashback;
public FlashbackQueryClause getFlashback() {
return flashback;
public void setFlashback(FlashbackQueryClause flashback) {
this.flashback = flashback;
acceptChild(visitor, this.flashback);
protected FlashbackQueryClause  flashback;
public FlashbackQueryClause getFlashback() {
return flashback;
public void setFlashback(FlashbackQueryClause flashback) {
this.flashback = flashback;
acceptChild(visitor, this.flashback);
public interface OracleSelectTableSource extends SQLTableSource {
FlashbackQueryClause getFlashback();
void setFlashback(FlashbackQueryClause flashback);
map.put("OF", Token.OF);
this.createExprParser().parseHints(queryBlock.getHints());
FlashbackQueryClause clause = flashback();
tableReference.setFlashback(clause);
if (identifierEquals("VERSIONS")) {
private FlashbackQueryClause flashback() {
if (lexer.token() == Token.AS) {
lexer.nextToken();
if (lexer.token() == Token.OF) {
lexer.nextToken();
AsOfFlashbackQueryClause clause = new AsOfFlashbackQueryClause();
if (identifierEquals("SCN")) {
clause.setType(AsOfFlashbackQueryClause.Type.SCN);
lexer.nextToken();
accept(Token.TIMESTAMP);
clause.setType(AsOfFlashbackQueryClause.Type.TIMESTAMP);
clause.setExpr(createExprParser().primary());
return clause;
return null;
protected SQLTableSource parseTableSourceRest(OracleSelectTableSource tableSource) {
if (lexer.token() == Token.AS) {
lexer.nextToken();
if (lexer.token() == Token.OF) {
tableSource.setFlashback(flashback());
tableSource.setAlias(as());
} else if ((tableSource.getAlias() == null) || (tableSource.getAlias().length() == 0)) {
protected void parseInsert0_hinits(SQLInsertInto insertStatement) {
if (insertStatement instanceof OracleInsertStatement) {
OracleInsertStatement stmt = (OracleInsertStatement) insertStatement;
this.createExprParser().parseHints(stmt.getHints());
List<OracleHint> hints = new ArrayList<OracleHint>();
this.createExprParser().parseHints(hints);
identifierFlags['#'] = true;
if (isDigit(ch)) {
scanVariable();
token = COLON;
if (lexer.token() != Token.LITERAL_ALIAS && lexer.token() != Token.IDENTIFIER) {
throw new ParserException("error, " + lexer.token());
protected void parseInsert0_hinits(SQLInsertInto insertStatement) {
parseInsert0_hinits(insertStatement);
public class TestTransform extends OracleTest {
private String          jdbcUrl;
private String          user;
private String          password;
private DruidDataSource dataSource;
public void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.18:1521:emdb";
user = "wardon";
password = "wardon";
dataSource = new DruidDataSource();
dataSource.setInitialSize(1);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
public void test_transform() throws Exception {
String sql = "SELECT SNAP_DATE, DBNAME, SQL_ID, PIECE, SQL_TEXT" + 
"      , COMMAND_TYPE, LAST_SNAP_DATE, DB_PK, SQL_PARSE_RESULT " + 
"  FROM db_day_sql_fulltext " + 
"  ORDER BY sql_id, piece";
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
Record r = null;
while (rs.next()) {
r = new Record();
Date d1 = rs.getDate(1);
String s2 = rs.getString(2);
String sqlId = rs.getString(3);
r.setSnapshotDate(d1);
r.setDbName(s2);
r.setSqlId(sqlId);
r.setPiece(rs.getInt(4));
r.setSqlText(rs.getString(5));
r.setCommandType(rs.getInt(6));
r.setLastSnapshotDate(rs.getDate(7));
r.setDbPk(rs.getLong(8));
System.out.println(r.getSqlText());
schemaStat(r);
rs.close();
stmt.close();
conn.close();
public void schemaStat(Record r) {
String sql = r.getSqlText();
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
System.out.println(output(statementList));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println();
System.out.println();
System.out.println();
public void clearResult() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DELETE FROM db_day_sql_fulltext");
stmt.close();
conn.close();
public void f_test_migrate() throws Exception {
clearResult();
String sql = "SELECT SNAP_DATE, DBNAME, SQL_ID, PIECE, SQL_TEXT" + 
"      , COMMAND_TYPE, LAST_SNAP_DATE, DB_PK, SQL_PARSE_RESULT " + 
"  FROM db_day_sqltext " + 
"  WHERE db_pk = 40 and snap_date = trunc(sysdate) " + 
"  ORDER BY sql_id, piece";
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
Record r = null;
String lastSqlId = null;
while (rs.next()) {
Date d1 = rs.getDate(1);
String s2 = rs.getString(2);
String sqlId = rs.getString(3);
if (lastSqlId == null || !lastSqlId.equals(sqlId)) {
if (r != null) {
System.out.println(r.getSqlText());
System.out.println();
insert(r);
r = new Record();
r.setSnapshotDate(d1);
r.setDbName(s2);
r.setSqlId(sqlId);
r.setPiece(rs.getInt(4));
r.setSqlText(rs.getString(5));
r.setCommandType(rs.getInt(6));
r.setLastSnapshotDate(rs.getDate(7));
r.setDbPk(rs.getLong(8));
r.setSqlText(r.getSqlText() + rs.getString(5));
lastSqlId = sqlId;
rs.close();
stmt.close();
conn.close();
public void insert(Record r) throws Exception {
String sql = "INSERT INTO db_day_sql_fulltext " + 
"(SNAP_DATE, DBNAME, SQL_ID, PIECE, SQL_TEXT" + 
", COMMAND_TYPE, LAST_SNAP_DATE, DB_PK, SQL_PARSE_RESULT)" + 
" VALUES (?, ?, ?, ?, ?,   ?, ?, ?, ?)";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setDate(1, r.getSnapshotDate());
stmt.setString(2, r.getDbName());
stmt.setString(3, r.getSqlId());
stmt.setInt(4, r.getPiece());
stmt.setString(5, r.getSqlText());
stmt.setInt(6, r.getCommandType());
stmt.setDate(7, r.getLastSnapshotDate());
stmt.setLong(8, r.getDbPk());
stmt.setString(9, r.getSqlText());
stmt.execute();
stmt.close();
conn.close();
public static class Record {
private Date    snapshotDate;
private String  dbName;
private String  sqlId;
private String  sqlText;
private Integer piece;
private Integer commandType;
private Date    lastSnapshotDate;
private Long    dbPk;
public Date getSnapshotDate() {
return snapshotDate;
public void setSnapshotDate(Date snapshotDate) {
this.snapshotDate = snapshotDate;
public String getDbName() {
return dbName;
public void setDbName(String dbName) {
this.dbName = dbName;
public String getSqlId() {
return sqlId;
public void setSqlId(String sqlId) {
this.sqlId = sqlId;
public String getSqlText() {
return sqlText;
public void setSqlText(String sqlText) {
this.sqlText = sqlText;
public Integer getPiece() {
return piece;
public void setPiece(Integer piece) {
this.piece = piece;
public Integer getCommandType() {
return commandType;
public void setCommandType(Integer commandType) {
this.commandType = commandType;
public Date getLastSnapshotDate() {
return lastSnapshotDate;
public void setLastSnapshotDate(Date lastSnapshotDate) {
this.lastSnapshotDate = lastSnapshotDate;
public Long getDbPk() {
return dbPk;
public void setDbPk(Long dbPk) {
this.dbPk = dbPk;
public String toString() {
return JSON.toJSONString(this);
public class SQLAssignItem extends SQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr           target;
private SQLExpr           value;
public SQLAssignItem(){
public SQLAssignItem(SQLExpr target, SQLExpr value){
this.target = target;
this.value = value;
public SQLExpr getTarget() {
return target;
public void setTarget(SQLExpr target) {
this.target = target;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void output(StringBuffer buf) {
target.output(buf);
buf.append(" = ");
value.output(buf);
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.target);
acceptChild(visitor, this.value);
visitor.endVisit(this);
private List<SQLAssignItem>        items            = new ArrayList<SQLAssignItem>();
this.items.add(new SQLAssignItem(target, value));
public List<SQLAssignItem> getItems() {
public void setItems(List<SQLAssignItem> items) {
SQLAssignItem item = items.get(i);
public class OracleAlterSessionStatement extends OracleStatementImpl {
private static final long   serialVersionUID = 1L;
private List<SQLAssignItem> items            = new ArrayList<SQLAssignItem>();
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, items);
visitor.endVisit(this);
public List<SQLAssignItem> getItems() {
return items;
public void setItems(List<SQLAssignItem> items) {
this.items = items;
public class OracleMethodInvokeStatement extends OracleStatementImpl {
private static final long   serialVersionUID = 1L;
private SQLMethodInvokeExpr expr;
public OracleMethodInvokeStatement(){
public OracleMethodInvokeStatement(SQLMethodInvokeExpr expr){
this.expr = expr;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, expr);
visitor.endVisit(this);
public SQLMethodInvokeExpr getExpr() {
return expr;
public void setExpr(SQLMethodInvokeExpr expr) {
this.expr = expr;
public class OracleTruncateStatement extends SQLTruncateStatement implements OracleStatement {
private static final long serialVersionUID = 1L;
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public  void accept0(OracleASTVisitor visitor) {
map.put("SESSION", Token.SESSION);
queryBlock.setGroupBy(groupBy);
} else if (lexer.token() == (Token.HAVING)) {
lexer.nextToken();
SQLSelectGroupByClause groupBy = new SQLSelectGroupByClause();
groupBy.setHaving(this.createExprParser().expr());
if (lexer.token() == (Token.GROUP)) {
lexer.nextToken();
accept(Token.BY);
for (;;) {
if (identifierEquals("GROUPING")) {
GroupingSetExpr groupingSet = new GroupingSetExpr();
lexer.nextToken();
acceptIdentifier("SETS");
accept(Token.LPAREN);
createExprParser().exprList(groupingSet.getParameters());
accept(Token.RPAREN);
groupBy.getItems().add(groupingSet);
groupBy.getItems().add(this.createExprParser().expr());
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
statementList.add(parserAlter());
if (lexer.token() == Token.TRUNCATE) {
statementList.add(this.parseTruncate());
if (lexer.token() == Token.IDENTIFIER) {
SQLExpr expr = exprParser.expr();
if (expr instanceof SQLMethodInvokeExpr) {
OracleMethodInvokeStatement stmt = new OracleMethodInvokeStatement((SQLMethodInvokeExpr) expr);
statementList.add(stmt);
throw new ParserException("expr : " + expr);
public SQLStatement parseTruncate() {
return super.parseTruncate();
public OracleStatement parserAlter() {
accept(Token.ALTER);
if (lexer.token() == Token.SESSION) {
lexer.nextToken();
OracleAlterSessionStatement stmt = new OracleAlterSessionStatement();
if (lexer.token() == Token.SET) {
lexer.nextToken();
parseAssignItems(stmt.getItems());
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
return stmt;
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
List<OracleHint> hints = new ArrayList<OracleHint>();
this.createExprParser().parseHints(hints);
stmt.setHints(hints);
OracleMultiInsertStatement stmt = parseMultiInsert();
stmt.setHints(hints);
return stmt;
public OracleMultiInsertStatement parseMultiInsert() {
public boolean visit(OracleAlterSessionStatement x) {
return true;
public void endVisit(OracleAlterSessionStatement x) {
public boolean visit(OracleMethodInvokeStatement x) {
return true;
public void endVisit(OracleMethodInvokeStatement x) {
boolean visit(OracleAlterSessionStatement x);
void endVisit(OracleAlterSessionStatement x);
boolean visit(OracleMethodInvokeStatement x);
void endVisit(OracleMethodInvokeStatement x);
public boolean visit(OracleAlterSessionStatement x) {
print("ALTER SESSION SET ");
printAndAccept(x.getItems(), ", ");
return false;
public void endVisit(OracleAlterSessionStatement x) {
public boolean visit(OracleMethodInvokeStatement x) {
x.getExpr().accept(this);
return false;
public void endVisit(OracleMethodInvokeStatement x) {
public boolean visit(OracleAlterSessionStatement x) {
return false;
public void endVisit(OracleAlterSessionStatement x) {
public boolean visit(OracleMethodInvokeStatement x) {
return false;
public void endVisit(OracleMethodInvokeStatement x) {
if (lexer.token() == Token.KEY) {
name = new SQLPropertyExpr(name, "KEY");
lexer.nextToken();
return name;
if (lexer.token() == Token.YEAR || lexer.token() == Token.DAY || lexer.token() == Token.KEY) {
queryBlock.setGroupBy(groupBy);
} else if (lexer.token() == (Token.HAVING)) {
lexer.nextToken();
SQLSelectGroupByClause groupBy = new SQLSelectGroupByClause();
groupBy.setHaving(this.createExprParser().expr());
accept(Token.TRUNCATE);
accept(Token.TABLE);
SQLTruncateStatement stmt = new SQLTruncateStatement();
for (;;) {
SQLName name = this.exprParser.name();
stmt.getTableNames().add(name);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
return stmt;
parseAssignItems(stmt.getItems());
return stmt;
public void parseAssignItems(List<SQLAssignItem> items) {
SQLAssignItem item = new SQLAssignItem();
items.add(item);
ADVISE("ADVISE"),
SESSION("SESSION"),
public boolean visit(SQLAssignItem x) {
void endVisit(SQLAssignItem x);
boolean visit(SQLAssignItem x);
public void endVisit(SQLAssignItem x) {
public boolean visit(SQLAssignItem x) {
public class OracleAlterSessionTest extends OracleTest {
public void test_0() throws Exception {
String sql = "alter session set current_schema=retl";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class StorageItem extends OracleSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLName           name;
private SQLExpr           value;
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, value);
visitor.endVisit(this);
public class OracleAlterTableAddConstaint extends OracleAlterTableItem {
private static final long serialVersionUID = 1L;
private SQLConstaint      constraint;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, constraint);
visitor.endVisit(this);
public SQLConstaint getConstraint() {
return constraint;
public void setConstraint(SQLConstaint constraint) {
this.constraint = constraint;
public class OracleAlterTableRenameTo extends OracleAlterTableItem {
private static final long serialVersionUID = 1L;
private SQLExpr           to;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, to);
visitor.endVisit(this);
public SQLExpr getTo() {
return to;
public void setTo(SQLExpr to) {
this.to = to;
public class OracleCreateTableStatement extends SQLCreateTableStatement implements OracleStatement {
private SQLSelect         select;
private boolean           inMemoryMetadata;
private boolean           cursorSpecificSegment;
private Boolean           parallel;
private List<StorageItem> storage          = new ArrayList<StorageItem>();
public Boolean getParallel() {
return parallel;
public void setParallel(Boolean parallel) {
this.parallel = parallel;
public boolean isCursorSpecificSegment() {
return cursorSpecificSegment;
public void setCursorSpecificSegment(boolean cursorSpecificSegment) {
this.cursorSpecificSegment = cursorSpecificSegment;
public boolean isInMemoryMetadata() {
return inMemoryMetadata;
public void setInMemoryMetadata(boolean inMemoryMetadata) {
this.inMemoryMetadata = inMemoryMetadata;
public SQLSelect getSelect() {
return select;
public void setSelect(SQLSelect select) {
this.select = select;
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
public List<StorageItem> getStorage() {
return storage;
public void setStorage(List<StorageItem> storage) {
this.storage = storage;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, name);
this.acceptChild(visitor, tableElementList);
this.acceptChild(visitor, tablespace);
this.acceptChild(visitor, select);
this.acceptChild(visitor, storage);
visitor.endVisit(this);
public class OraclePrimaryKey extends OracleSQLObjectImpl implements SQLPrimaryKey {
private static final long serialVersionUID = 1L;
private SQLName           name;
private List<SQLExpr>     columns          = new ArrayList<SQLExpr>();
private SQLExpr           usingIndex;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, columns);
acceptChild(visitor, usingIndex);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
public List<SQLExpr> getColumns() {
return columns;
public void setColumns(List<SQLExpr> columns) {
this.columns = columns;
public SQLExpr getUsingIndex() {
return usingIndex;
public void setUsingIndex(SQLExpr usingIndex) {
this.usingIndex = usingIndex;
for (;;) {
if (identifierEquals("TABLESPACE")) {
lexer.nextToken();
stmt.setTablespace(this.exprParser.name());
} else if (identifierEquals("IN_MEMORY_METADATA")) {
lexer.nextToken();
stmt.setInMemoryMetadata(true);
} else if (identifierEquals("CURSOR_SPECIFIC_SEGMENT")) {
lexer.nextToken();
stmt.setCursorSpecificSegment(true);
} else if (identifierEquals("NOPARALLEL")) {
lexer.nextToken();
stmt.setParallel(false);
} else if (identifierEquals("STORAGE")) {
lexer.nextToken();
accept(Token.LPAREN);
for (;;) {
if (lexer.token() == Token.IDENTIFIER) {
StorageItem item = new StorageItem();
item.setName(this.exprParser.name());
item.setValue(this.exprParser.expr());
stmt.getStorage().add(item);
accept(Token.RPAREN);
if (lexer.token() == Token.AS) {
OracleSelect select = new OracleSelectParser(lexer).select();
stmt.setSelect(select);
SQLColumnDefinition columnDef = this.exprParser.parseColumn();
OracleAlterTableAddColumn item = new OracleAlterTableAddColumn();
item.setColumn(columnDef);
stmt.getItems().add(item);
} else if (lexer.token() == Token.CONSTRAINT) {
stmt.getItems().add(parseConstaint());
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
stmt.getItems().add(parseAlterTableRename());
private OracleAlterTableItem parseAlterTableRename() {
acceptIdentifier("RENAME");
if (lexer.token() == Token.TO) {
lexer.nextToken();
OracleAlterTableRenameTo item = new OracleAlterTableRenameTo();
item.setTo(this.exprParser.name());
return item;
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
private OracleAlterTableAddConstaint parseConstaint() {
accept(Token.CONSTRAINT);
OracleAlterTableAddConstaint item = new OracleAlterTableAddConstaint();
SQLName name = this.exprParser.name();
if (lexer.token() == Token.PRIMARY) {
lexer.nextToken();
accept(Token.KEY);
OraclePrimaryKey primaryKey = new OraclePrimaryKey();
accept(Token.LPAREN);
this.exprParser.exprList(primaryKey.getColumns());
accept(Token.RPAREN);
item.setConstraint(primaryKey);
if (lexer.token() == Token.USING) {
lexer.nextToken();
accept(Token.INDEX);
primaryKey.setUsingIndex(this.exprParser.expr());
primaryKey.setName(name);
item.setConstraint(primaryKey);
return item;
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
public boolean visit(OracleAlterTableAddConstaint x) {
return true;
public void endVisit(OracleAlterTableAddConstaint x) {
public boolean visit(OraclePrimaryKey x) {
return true;
public void endVisit(OraclePrimaryKey x) {
public boolean visit(OracleCreateTableStatement x) {
return true;
public void endVisit(OracleCreateTableStatement x) {
public boolean visit(OracleAlterTableRenameTo x) {
return true;
public void endVisit(OracleAlterTableRenameTo x) {
public boolean visit(StorageItem x) {
return true;
public void endVisit(StorageItem x) {
boolean visit(OracleAlterTableAddConstaint x);
void endVisit(OracleAlterTableAddConstaint x);
boolean visit(OracleAlterTableRenameTo x);
void endVisit(OracleAlterTableRenameTo x);
boolean visit(OraclePrimaryKey x);
void endVisit(OraclePrimaryKey x);
boolean visit(OracleCreateTableStatement x);
void endVisit(OracleCreateTableStatement x);
boolean visit(StorageItem x);
void endVisit(StorageItem x);
public boolean visit(OracleAlterTableAddConstaint x) {
print("ADD ");
x.getConstraint().accept(this);
return false;
public void endVisit(OracleAlterTableAddConstaint x) {
public boolean visit(OraclePrimaryKey x) {
if (x.getName() != null) {
print("CONSTRAINT ");
x.getName().accept(this);
print(" ");
print("PRIMARY KEY (");
printAndAccept(x.getColumns(), ", ");
print(")");
if (x.getUsingIndex() != null) {
print(" USING INDEX ");
x.getUsingIndex().accept(this);
return false;
public void endVisit(OraclePrimaryKey x) {
public boolean visit(OracleCreateTableStatement x) {
this.visit((SQLCreateTableStatement) x);
incrementIndent();
if (x.getTablespace() != null) {
print(" TABLESPACE ");
x.getTablespace().accept(this);
if (x.isInMemoryMetadata()) {
print(" IN_MEMORY_METADATA");
if (x.isCursorSpecificSegment()) {
print(" CURSOR_SPECIFIC_SEGMENT");
if (x.getParallel() == Boolean.TRUE) {
} else if (x.getParallel() == Boolean.FALSE) {
print(" NOPARALLEL");
if (x.getStorage().size() > 0) {
print(" STORAGE (");
printAndAccept(x.getStorage(), ", ");
print(")");
if (x.getSelect() != null) {
println();
print("AS");
println();
x.getSelect().accept(this);
decrementIndent();
return false;
public void endVisit(OracleCreateTableStatement x) {
public boolean visit(OracleAlterTableRenameTo x) {
print("RENAME TO ");
x.getTo().accept(this);
return false;
public void endVisit(OracleAlterTableRenameTo x) {
public boolean visit(StorageItem x) {
x.getName().accept(this);
if (x.getValue() != null) {
print(" ");
x.getValue().accept(this);
return false;
public void endVisit(StorageItem x) {
public boolean visit(OracleAlterTableAddConstaint x) {
return false;
public void endVisit(OracleAlterTableAddConstaint x) {
public boolean visit(OraclePrimaryKey x) {
return false;
public void endVisit(OraclePrimaryKey x) {
public boolean visit(OracleCreateTableStatement x) {
this.visit((SQLCreateTableStatement) x);
return false;
public void endVisit(OracleCreateTableStatement x) {
this.endVisit((SQLCreateTableStatement) x);
public boolean visit(OracleAlterTableRenameTo x) {
return false;
public void endVisit(OracleAlterTableRenameTo x) {
public boolean visit(StorageItem x) {
return false;
public void endVisit(StorageItem x) {
if (identifierEquals("GLOBAL")) {
if (identifierEquals("TEMPORARY")) {
throw new ParserException("syntax error " + lexer.token() + " " + lexer.stringVal());
while (lexer.token() == Token.IDENTIFIER || lexer.token() == Token.LITERAL_ALIAS) {
if (token == Token.TABLE || identifierEquals("GLOBAL")) {
int size = x.getTableElementList().size();
if (size > 0) {
print(" (");
for (int i = 0; i < size; ++i) {
if (i != 0) {
print(", ");
x.getTableElementList().get(i).accept(this);
print(")");
public class OracleAlterTableTest8 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE ws_i18n_translate_item ADD CONSTRAINT ws_i18n_translate_item_pk PRIMARY KEY (id) USING INDEX ws_i18n_translate_item_pk";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleAlterTableTestRename extends OracleTest {
public void test_0() throws Exception {
String sql = 
"alter table PRODUCT_NEW_CLUSTER_YZS_0210 rename to PRODUCT_NEW_CLUSTER_YZS_0210_1";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleCreateTableTest4 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"create table tbd_qi_xiaq_100961 tablespace tbd_data as select * 1from product where company_id=10239004 ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleCreateTableTest5 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"CREATE GLOBAL TEMPORARY TABLE "SYS"."SYS_TEMP_0FD9D670A_93E068F3" ("C0" VARCHAR2(30),"C1" VARCHAR2(27) ) "
+ "IN_MEMORY_METADATA CURSOR_SPECIFIC_SEGMENT STORAGE (OBJNO 4254951178 )";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleCreateTableTest6 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"CREATE GLOBAL TEMPORARY TABLE "SYS"."SYS_TEMP_0FD9D66FD_93E068F3" ("C0" NUMBER,"C1" NUMBER ) IN_MEMORY_METADATA CURSOR_SPECIFIC_SEGMENT STORAGE (OBJNO 4254951165 ) NOPARALLEL";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
System.out.println(output(statementList));
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleGotoStatement extends OracleStatementImpl {
private static final long serialVersionUID = 1L;
private SQLName           label;
public OracleGotoStatement(){
public OracleGotoStatement(SQLName label){
this.label = label;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, label);
visitor.endVisit(this);
public SQLName getLabel() {
return label;
public void setLabel(SQLName label) {
this.label = label;
public class OracleLabelStatement extends OracleStatementImpl {
private static final long serialVersionUID = 1L;
private SQLName           label;
public OracleLabelStatement(){
public OracleLabelStatement(SQLName label){
this.label = label;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, label);
visitor.endVisit(this);
public SQLName getLabel() {
return label;
public void setLabel(SQLName label) {
this.label = label;
if (lexer.token() == Token.DOTDOT) {
lexer.nextToken();
SQLExpr upBound = expr();
return new OracleRangeExpr(expr, upBound);
map.put("GOTO", Token.GOTO);
if (buf[bp + 1] == '.') {
token = Token.LITERAL_INT;
if (lexer.token() == Token.GOTO) {
lexer.nextToken();
SQLName label = this.exprParser.name();
OracleGotoStatement stmt = new OracleGotoStatement(label);
statementList.add(stmt);
if (lexer.token() == Token.LTLT) {
lexer.nextToken();
SQLName label = this.exprParser.name();
OracleLabelStatement stmt = new OracleLabelStatement(label);
accept(Token.GTGT);
statementList.add(stmt);
public boolean visit(OracleGotoStatement x) {
return true;
public void endVisit(OracleGotoStatement x) {
public boolean visit(OracleLabelStatement x) {
return true;
public void endVisit(OracleLabelStatement x) {
boolean visit(OracleGotoStatement x);
void endVisit(OracleGotoStatement x);
boolean visit(OracleLabelStatement x);
void endVisit(OracleLabelStatement x);
public boolean visit(OracleGotoStatement x) {
print("GOTO ");
x.getLabel().accept(this);
return false;
public void endVisit(OracleGotoStatement x) {
public boolean visit(OracleLabelStatement x) {
print("<<");
x.getLabel().accept(this);
print(">>");
return false;
public void endVisit(OracleLabelStatement x) {
public boolean visit(OracleGotoStatement x) {
return false;
public void endVisit(OracleGotoStatement x) {
public boolean visit(OracleLabelStatement x) {
return false;
public void endVisit(OracleLabelStatement x) {
} else if (ch == '.') {
scanChar();
token = Token.DOTDOT;
token = Token.DOT;
if (buf[bp + 1] == '.') {
token = Token.LITERAL_INT;
GOTO("GOTO"),
DOTDOT(".."),
String sql = "DECLARE" + 
"  done  BOOLEAN;" + 
"BEGIN" + 
"  FOR i IN 1..50 LOOP" + 
"    IF done THEN" + 
"       GOTO end_loop;" + 
"    END IF;" + 
"  <<end_loop>>" + 
"  END LOOP;" + 
setAliasMap();
getAliasMap().put("DUAL", null);
setAliasMap();
setAliasMap();
setCurrentTable(ident);
setAliasMap(null);
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
public class OracleParameter extends OracleSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr           name;
private SQLDataType       dataType;
private SQLExpr           defaultValue;
public SQLExpr getDefaultValue() {
return defaultValue;
public void setDefaultValue(SQLExpr deaultValue) {
this.defaultValue = deaultValue;
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
public SQLDataType getDataType() {
return dataType;
public void setDataType(SQLDataType dataType) {
this.dataType = dataType;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, dataType);
visitor.endVisit(this);
private List<OracleParameter> parameters       = new ArrayList<OracleParameter>();
public List<OracleParameter> getParameters() {
public void setParameters(List<OracleParameter> parameters) {
public class OracleCommitStatement extends OracleStatementImpl {
private static final long serialVersionUID = 1L;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
visitor.endVisit(this);
map.put("COMMIT", Token.COMMIT);
if (lexer.token() == Token.COMMIT) {
lexer.nextToken();
OracleCommitStatement stmt = new OracleCommitStatement();
statementList.add(stmt);
OracleParameter parameter = new OracleParameter();
parameter.setName(this.exprParser.name());
parameter.setDataType(this.exprParser.parseDataType());
parameter.setDefaultValue(this.exprParser.expr());
public boolean visit(OracleParameter x) {
return true;
public void endVisit(OracleParameter x) {
public boolean visit(OracleCommitStatement x) {
return true;
public void endVisit(OracleCommitStatement x) {
boolean visit(OracleParameter x);
void endVisit(OracleParameter x);
boolean visit(OracleCommitStatement x);
void endVisit(OracleCommitStatement x);
incrementIndent();
println();
decrementIndent();
println();
for (OracleParameter param : x.getParameters()) {
public boolean visit(OracleParameter x) {
x.getName().accept(this);
print(" ");
x.getDataType().accept(this);
if (x.getDefaultValue() != null) {
print(" := ");
x.getDefaultValue().accept(this);
return false;
public void endVisit(OracleParameter x) {
public boolean visit(OracleCommitStatement x) {
print("COMMIT");
return false;
public void endVisit(OracleCommitStatement x) {
Map<String, String> aliasMap = getAliasMap();
String originalTable = getCurrentTable();
setCurrentTable((String) x.getQuery().getAttribute("table"));
setCurrentTable(originalTable);
setAliasMap();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
clearAliasMap();
clearAliasMap();
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
clearAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(table);
setCurrentTable(originalTable);
x.getRange().setParent(x);
x.getIndex().accept(this);
x.getRange().accept(this);
accept(x.getStatements());
public boolean visit(OracleParameter x) {
return false;
public void endVisit(OracleParameter x) {
public boolean visit(OracleCommitStatement x) {
return true;
public void endVisit(OracleCommitStatement x) {
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
Map<String, String> aliasMap = getAliasMap();
setCurrentTable(ident);
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
Map<String, String> oldAliasMap = getAliasMap();
setAliasMap();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
setAliasMap(oldAliasMap);
COMMIT("COMMIT"),
protected final HashMap<TableStat.Name, TableStat> tableStats     = new LinkedHashMap<TableStat.Name, TableStat>();
protected final Set<Column>                        columns        = new LinkedHashSet<Column>();
protected final Set<Condition>                     conditions     = new LinkedHashSet<Condition>();
protected final Set<Relationship>                  relationships  = new LinkedHashSet<Relationship>();
protected final Set<Column>                        orderByColumns = new LinkedHashSet<Column>();
protected final Set<Column>                        groupByColumns = new LinkedHashSet<Column>();
protected final Map<String, SQLObject>             subQueryMap    = new LinkedHashMap<String, SQLObject>();
protected Map<String, String>                      aliasLocal     = new HashMap<String, String>();
protected String                                   currentTable;
public final static String                         ATTR_TABLE     = "_table_";
public final static String                         ATTR_COLUMN    = "_column_";
private Mode                                       mode;
public void setAliasMap() {
this.setAliasMap(new HashMap<String, String>());
public void clearAliasMap() {
this.aliasLocal = null;
public void setAliasMap(Map<String, String> aliasMap) {
this.aliasLocal = aliasMap;
public Map<String, String> getAliasMap() {
return aliasLocal;
public void setCurrentTable(String table) {
this.currentTable = table;
public String getCurrentTable() {
return currentTable;
String currentTable = getCurrentTable();
Map<String, String> aliasMap = getAliasMap();
String table = getCurrentTable();
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
String originalTable = getCurrentTable();
setCurrentTable(ident);
x.putAttribute("table", getCurrentTable());
setCurrentTable(originalTable);
Map<String, String> aliasMap = getAliasMap();
String currentTable = getCurrentTable();
String currentTable = getCurrentTable();
setAliasMap();
clearAliasMap();
Map<String, String> aliasMap = getAliasMap();
Map<String, String> aliasMap = getAliasMap();
String originalTable = getCurrentTable();
setCurrentTable((String) x.getQuery().getAttribute("table"));
setCurrentTable(originalTable);
setAliasMap();
setCurrentTable(ident);
Map<String, String> aliasMap = getAliasMap();
setAliasMap();
setCurrentTable(ident);
clearAliasMap();
clearAliasMap();
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleSelectTest31 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT e1.last_name FROM employees e1" + 
"   WHERE f(" + 
"   CURSOR(SELECT e2.hire_date FROM employees e2" + 
"   WHERE e1.employee_id = e2.manager_id)," + 
"   e1.hire_date) = 1" + 
"   ORDER BY last_name;"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "last_name")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "hire_date")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "manager_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "employee_id")));
Assert.assertTrue(visitor.getOrderByColumns().contains(new TableStat.Column("employees", "last_name")));
int commentIndex = part.indexOf("--");
if (commentIndex != -1) {
part = part.substring(0, commentIndex);
if (part == null) {
private SQLExpr           objno;
acceptChild(visitor, objno);
public SQLExpr getObjno() {
return objno;
public void setObjno(SQLExpr objno) {
this.objno = objno;
} else if (identifierEquals("OBJNO")) {
lexer.nextToken();
storage.setObjno(this.exprParser.expr());
x.getFreeLists().accept(this);
x.getFreeListGroups().accept(this);
x.getBufferPool().accept(this);
if (x.getObjno() != null) {
print(" OBJNO ");
x.getObjno().accept(this);
if (part == null) {
} catch (Throwable e) {
1, 10, 100, 1000, 10 * 1000, 
100 * 1000, 1000 * 1000
for (JdbcParameter parameter : statement.getParameters().values()) {
Object value = parameter.getValue();
buf.append(String.valueOf(value));
for (JdbcParameter parameter : statement.getParameters().values()) {
public static final int BinaryInputStream     = 10001;
public static final int AsciiInputStream      = 10002;
public static final int CharacterInputStream  = 10003;
public static final int NCharacterInputStream = 10004;
public static final int URL                   = 10005;
private final int       sqlType;
private final Object    value;
private final long      length;
private final Calendar  calendar;
public JdbcParameter(int sqlType, Object value, long length, Calendar calendar){
this.value = value;
this.length = length;
this.calendar = calendar;
public JdbcParameter(int sqlType, Object value){
this(sqlType, value, -1, null);
public JdbcParameter(int sqlType, Object value, long length){
this(sqlType, value, length, null);
public JdbcParameter(int sqlType, Object value, Calendar calendar){
this(sqlType, value, -1, calendar);
public Object getValue() {
return value;
public long getLength() {
return length;
public Calendar getCalendar() {
return calendar;
public int getSqlType() {
return sqlType;
public static final int UnicodeStream         = 10006;
public static final int BYTES                 = 10007;
Map<Integer, JdbcParameter> getParameters();
protected final PreparedStatement           statement;
protected final String                      sql;
protected final Map<Integer, JdbcParameter> parameters = new TreeMap<Integer, JdbcParameter>();
public Map<Integer, JdbcParameter> getParameters() {
return parameters;
setParameter(parameterIndex, new JdbcParameter(Types.ARRAY, x));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.DECIMAL, x));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.BOOLEAN, x));
setParameter(parameterIndex, new JdbcParameter(Types.TINYINT, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.BYTES, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x));
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x, cal));
setParameter(parameterIndex, new JdbcParameter(Types.DOUBLE, x));
setParameter(parameterIndex, new JdbcParameter(Types.FLOAT, x));
setParameter(parameterIndex, new JdbcParameter(Types.INTEGER, x));
setParameter(parameterIndex, new JdbcParameter(Types.BIGINT, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x,length));
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x, length));
setParameter(parameterIndex, new JdbcParameter(Types.NVARCHAR, x));
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x));
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x));
setParameter(parameterIndex, new JdbcParameter(Types.REF, x));
setParameter(parameterIndex, new JdbcParameter(Types.ROWID, x));
setParameter(parameterIndex, new JdbcParameter(Types.SQLXML, x));
setParameter(parameterIndex, new JdbcParameter(Types.SMALLINT, x));
setParameter(parameterIndex, new JdbcParameter(Types.VARCHAR, x));
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x));
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x, cal));
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.URL, x));
setParameter(parameterIndex, new JdbcParameter(TYPE.UnicodeStream, x, length));
public void setParameter(int parameterIndex, JdbcParameter parameter) {
this.getParameters().put(parameterIndex, parameter);
public StatFilter(){
String property = System.getProperty("druid.stat.maxSqlStatCount");
if (property != null && property.length() > 0) {
maxSqlStatCount = Integer.parseInt(property);
} catch (Exception e) {
private TransactionInfo       transcationInfo;
if (!autoCommit) {
if (transcationInfo == null) {
long transactionId = this.getDirectDataSource().createTransactionId();
transcationInfo = new TransactionInfo(transactionId);
transcationInfo = null;
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (conn == null) {
throw new SQLException("connection not init");
return conn.getMetaData();
if (conn == null) {
throw new SQLException("connection not init");
if (conn == null) {
throw new SQLException("connection not init");
return conn.setSavepoint();
if (conn == null) {
throw new SQLException("connection not init");
return conn.setSavepoint(name);
if (conn == null) {
throw new SQLException("connection not init");
conn.rollback(savepoint);
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (conn == null) {
throw new SQLException("connection not init");
conn.releaseSavepoint(savepoint);
if (conn == null) {
throw new SQLException("connection not init");
return conn.createClob();
if (conn == null) {
throw new SQLException("connection not init");
return conn.createBlob();
if (conn == null) {
throw new SQLException("connection not init");
return conn.createNClob();
if (conn == null) {
throw new SQLException("connection not init");
return conn.createSQLXML();
if (conn == null) {
throw new SQLException("connection not init");
return conn.isValid(timeout);
if (conn == null) {
throw new SQLException("connection not init");
return conn.createArrayOf(typeName, elements);
if (conn == null) {
throw new SQLException("connection not init");
return conn.createStruct(typeName, attributes);
if (conn == null) {
throw new SQLException("connection not init");
public TransactionInfo getTransactionInfo() {
return null;
TransactionInfo getTransactionInfo();
private TransactionInfo       transcationInfo;
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
if (!autoCommit) {
if (transcationInfo == null) {
long transactionId = this.dataSource.createTransactionId();
transcationInfo = new TransactionInfo(transactionId);
transcationInfo = null;
public TransactionInfo getTransactionInfo() {
return transcationInfo;
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getOrderBy() != null) {
x.getOrderBy().setParent(x);
if (SQLSetQuantifier.ALL == x.getDistionOption()) print("ALL ");
else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) print("DISTINCT ");
else if (SQLSetQuantifier.DISTINCTROW == x.getDistionOption()) {
if (x.isHignPriority()) {
if (x.isSmallResult()) {
if (x.isBigResult()) {
if (x.isBufferResult()) {
if (x.getCache() != null) {
if (x.getCache().booleanValue()) {
if (x.isCalcFoundRows()) {
printSelectList(x.getSelectList());
if (x.getOutFile() != null) {
x.getOutFile().accept(this);
if (x.getOutFileCharset() != null) {
print(x.getOutFileCharset());
if (x.getOutFileColumnsTerminatedBy() != null || x.getOutFileColumnsEnclosedBy() != null
|| x.getOutFileColumnsEscaped() != null) {
if (x.getOutFileColumnsTerminatedBy() != null) {
x.getOutFileColumnsTerminatedBy().accept(this);
if (x.getOutFileColumnsEnclosedBy() != null) {
if (x.isOutFileColumnsEnclosedOptionally()) {
x.getOutFileColumnsEnclosedBy().accept(this);
if (x.getOutFileColumnsEscaped() != null) {
x.getOutFileColumnsEscaped().accept(this);
if (x.getOutFileLinesStartingBy() != null || x.getOutFileLinesTerminatedBy() != null) {
if (x.getOutFileLinesStartingBy() != null) {
x.getOutFileLinesStartingBy().accept(this);
if (x.getOutFileLinesTerminatedBy() != null) {
x.getOutFileLinesTerminatedBy().accept(this);
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
if (x.getOrderBy() != null) {
x.getOrderBy().accept(this);
if (x.getLimit() != null) {
x.getLimit().accept(this);
if (x.getProcedureName() != null) {
x.getProcedureName().accept(this);
if (x.getProcedureArgumentList().size() > 0) {
printAndAccept(x.getProcedureArgumentList(), ", ");
if (x.isForUpdate()) {
if (x.isLockInShareMode()) {
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
print(", ");
x.getRight().accept(this);
boolean isRoot = x.getParent() instanceof SQLSelectQueryBlock;
if (isRoot) {
incrementIndent();
println();
print(" ");
x.getRight().accept(this);
if (isRoot) {
decrementIndent();
if (x.getCondition() != null) {
print(" ON ");
x.getCondition().accept(this);
print(" ");
if (x.getUsing().size() > 0) {
print(" USING (");
printAndAccept(x.getUsing(), ", ");
print(")");
if (x.getFlashback() != null) {
println();
x.getFlashback().accept(this);
public boolean visit(OracleSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
printSelectList(x.getSelectList());
if (x.getInto() != null) {
x.getInto().accept(this);
if (x.getFrom() == null) {
x.getFrom().setParent(x);
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getHierachicalQueryClause() != null) {
x.getHierachicalQueryClause().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
if (x.getModelClause() != null) {
x.getModelClause().accept(this);
x.getSelect().accept(this);
println();
print(" ");
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getDeleteWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
public boolean visit(SQLServerSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
if (x.getTop() != null) {
x.getTop().accept(this);
printSelectList(x.getSelectList());
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
public boolean visit(SQLSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
printSelectList(x.getSelectList());
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
+ "UNPIVOT (yearly_total FOR order_mode IN (store AS 'direct', internet AS 'online'))n"
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS YEAR, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS YEAR, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
String expected = "SELECT *n" + "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS DAY, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS DAY, order_mode AS YEAR, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
String expected = "SELECT COUNT(*) * 10n" + "FROM orders SAMPLE (10);n";
String expected = "SELECT COUNT(*) * 10n" + "FROM orders SAMPLE (10) SEED (1);n";
Assert.assertEquals("SELECT e.salarynFROM employee entJOIN department dnWHERE e.depId = d.id;n",
public class OracleResourceTest extends OracleTest {
exec_test("bvt/parser/oracle-17.txt");
System.out.println(sql);
print(statementList);
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getOrderBy() != null) {
x.getOrderBy().setParent(x);
if (SQLSetQuantifier.ALL == x.getDistionOption()) print("ALL ");
else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) print("DISTINCT ");
else if (SQLSetQuantifier.DISTINCTROW == x.getDistionOption()) {
if (x.isHignPriority()) {
if (x.isSmallResult()) {
if (x.isBigResult()) {
if (x.isBufferResult()) {
if (x.getCache() != null) {
if (x.getCache().booleanValue()) {
if (x.isCalcFoundRows()) {
printSelectList(x.getSelectList());
if (x.getOutFile() != null) {
x.getOutFile().accept(this);
if (x.getOutFileCharset() != null) {
print(x.getOutFileCharset());
if (x.getOutFileColumnsTerminatedBy() != null || x.getOutFileColumnsEnclosedBy() != null
|| x.getOutFileColumnsEscaped() != null) {
if (x.getOutFileColumnsTerminatedBy() != null) {
x.getOutFileColumnsTerminatedBy().accept(this);
if (x.getOutFileColumnsEnclosedBy() != null) {
if (x.isOutFileColumnsEnclosedOptionally()) {
x.getOutFileColumnsEnclosedBy().accept(this);
if (x.getOutFileColumnsEscaped() != null) {
x.getOutFileColumnsEscaped().accept(this);
if (x.getOutFileLinesStartingBy() != null || x.getOutFileLinesTerminatedBy() != null) {
if (x.getOutFileLinesStartingBy() != null) {
x.getOutFileLinesStartingBy().accept(this);
if (x.getOutFileLinesTerminatedBy() != null) {
x.getOutFileLinesTerminatedBy().accept(this);
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
if (x.getOrderBy() != null) {
x.getOrderBy().accept(this);
if (x.getLimit() != null) {
x.getLimit().accept(this);
if (x.getProcedureName() != null) {
x.getProcedureName().accept(this);
if (x.getProcedureArgumentList().size() > 0) {
printAndAccept(x.getProcedureArgumentList(), ", ");
if (x.isForUpdate()) {
if (x.isLockInShareMode()) {
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
print(", ");
x.getRight().accept(this);
boolean isRoot = x.getParent() instanceof SQLSelectQueryBlock;
if (isRoot) {
incrementIndent();
println();
print(" ");
x.getRight().accept(this);
if (isRoot) {
decrementIndent();
if (x.getCondition() != null) {
print(" ON ");
x.getCondition().accept(this);
print(" ");
if (x.getUsing().size() > 0) {
print(" USING (");
printAndAccept(x.getUsing(), ", ");
print(")");
if (x.getFlashback() != null) {
println();
x.getFlashback().accept(this);
public boolean visit(OracleSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
printSelectList(x.getSelectList());
if (x.getInto() != null) {
x.getInto().accept(this);
if (x.getFrom() == null) {
x.getFrom().setParent(x);
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getHierachicalQueryClause() != null) {
x.getHierachicalQueryClause().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
if (x.getModelClause() != null) {
x.getModelClause().accept(this);
x.getSelect().accept(this);
println();
print(" ");
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getDeleteWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
public boolean visit(SQLServerSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
if (x.getTop() != null) {
x.getTop().accept(this);
printSelectList(x.getSelectList());
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
SQLObject parent = x.getParent();
boolean isRoot = parent instanceof SQLSelectQueryBlock;
boolean relational = x.getOperator() == SQLBinaryOperator.BooleanAnd
|| x.getOperator() == SQLBinaryOperator.BooleanOr;
if (isRoot && relational) {
incrementIndent();
boolean leftRational = left.getOperator() == SQLBinaryOperator.BooleanAnd
|| left.getOperator() == SQLBinaryOperator.BooleanOr;
if (leftRational) {
incrementIndent();
if (leftRational) {
decrementIndent();
if (isRoot && relational) {
decrementIndent();
if (relational) {
if (isRoot) {
incrementIndent();
println();
print(" ");
boolean rightRational = right.getOperator() == SQLBinaryOperator.BooleanAnd
|| right.getOperator() == SQLBinaryOperator.BooleanOr;
if (rightRational) {
incrementIndent();
if (rightRational) {
decrementIndent();
if (isRoot && relational) {
decrementIndent();
public boolean visit(SQLSelectQueryBlock x) {
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
printSelectList(x.getSelectList());
if (x.getFrom() != null) {
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
x.getGroupBy().accept(this);
x.getWhere().setParent(x);
x.getWhere().setParent(x);
Assert.assertEquals("SELECT 1 = 0ntOR A > ?;", text);
Assert.assertEquals("SELECT 1 = 0ntAND ID = ?;", text);
Assert.assertEquals("SELECT 1ntAND 1;", text);
Assert.assertEquals("SELECT 1ntAND NULL;", text);
Assert.assertEquals("SELECT 0ntOR NULL;", text);
String expected = "SELECT channel_desc, calendar_month_desc, co.country_id, " 
+ "TO_CHAR(sum(amount_sold), '9,999,999,999') AS SALES$n" 
+ "FROM sales, customers, times, channels, countries con" 
+ "WHERE sales.time_id = times.time_id" 
+ "ntAND sales.cust_id = customers.cust_id" 
+ "ntAND sales.channel_id = channels.channel_id" 
+ "ntAND customers.country_id = co.country_id" 
+ "ntAND channels.channel_desc IN ('Direct Sales', 'Internet')" 
+ "ntAND times.calendar_month_desc IN ('2000-09', '2000-10')"
+ "ntAND co.country_id IN ('UK', 'US')n"
+ "UNPIVOT (yearly_total FOR order_mode IN (store AS 'direct', internet AS 'online'))n"
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS YEAR, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS YEAR, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
String expected = "SELECT *n" + "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS DAY, order_mode, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS DAY, order_mode AS YEAR, order_totaln"
+ "tFROM ordersn" + ")n"
+ "PIVOT (SUM(order_total) FOR order_mode IN ('direct' AS Store, 'online' AS Internet));n";
String expected = "SELECT COUNT(*) * 10n" + "FROM orders SAMPLE (10);n";
String expected = "SELECT COUNT(*) * 10n" + "FROM orders SAMPLE (10) SEED (1);n";
Assert.assertEquals("SELECT e.salarynFROM employee entJOIN department dnWHERE e.depId = d.id;n",
public class OracleResourceTest extends OracleTest {
exec_test("bvt/parser/oracle-17.txt");
System.out.println(sql);
print(statementList);
public interface SQLPartitioningClause extends SQLObject {
private boolean               ifNotExiists = false;
private Map<String, String>   tableOptions = new HashMap<String, String>();
protected SQLSelect           query;
private SQLPartitioningClause partitioning;
public SQLPartitioningClause getPartitioning() {
return partitioning;
public void setPartitioning(SQLPartitioningClause partitioning) {
this.partitioning = partitioning;
public class MySqlPartitionByKey extends MySqlObjectImpl implements SQLPartitioningClause {
private static final long serialVersionUID = 1L;
private List<SQLName>     columns          = new ArrayList<SQLName>();
private SQLExpr           partitionCount;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, columns);
acceptChild(visitor, partitionCount);
visitor.endVisit(this);
public SQLExpr getPartitionCount() {
return partitionCount;
public void setPartitionCount(SQLExpr partitionCount) {
this.partitionCount = partitionCount;
public List<SQLName> getColumns() {
return columns;
public void setColumns(List<SQLName> columns) {
this.columns = columns;
MySqlCreateTableStatement stmt = new MySqlCreateTableStatement();
stmt.setType(SQLCreateTableStatement.Type.GLOBAL_TEMPORARY);
stmt.setIfNotExiists(true);
stmt.setName(this.exprParser.name());
stmt.getTableElementList().add(column);
stmt.getTableElementList().add(parseConstraint());
stmt.getTableElementList().add(idx);
stmt.getTableElementList().add(parseConstraint());
stmt.getTableElementList().add(parseConstraint());
stmt.getTableOptions().put("ENGINE", lexer.stringVal());
stmt.getTableOptions().put("TYPE", lexer.stringVal());
if (identifierEquals("PARTITION")) {
lexer.nextToken();
accept(Token.BY);
if (lexer.token() == Token.KEY) {
MySqlPartitionByKey clause = new MySqlPartitionByKey();
lexer.nextToken();
accept(Token.LPAREN);
for (;;) {
clause.getColumns().add(this.exprParser.name());
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
accept(Token.RPAREN);
stmt.setPartitioning(clause);
if (identifierEquals("PARTITIONS")) {
lexer.nextToken();
clause.setPartitionCount(this.exprParser.expr());
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
stmt.setQuery(query);
return stmt;
if (identifierEquals("PARTITION")) {
throw new ParserException("syntax error " + lexer.token() + " " + lexer.stringVal());
void endVisit(MySqlPartitionByKey x);
boolean visit(MySqlPartitionByKey x);
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
return true;
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
print("PARTITION BY KEY (");
printAndAccept(x.getColumns(), ", ");
print(")");
if (x.getPartitionCount() != null) {
print(" PARTITIONS ");
x.getPartitionCount().accept(this);
return false;
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
accept(x.getColumns());
return false;
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("tk")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col3")));
public interface SQLPartitioningClause extends SQLObject {
private boolean               ifNotExiists = false;
private Map<String, String>   tableOptions = new HashMap<String, String>();
protected SQLSelect           query;
private SQLPartitioningClause partitioning;
public SQLPartitioningClause getPartitioning() {
return partitioning;
public void setPartitioning(SQLPartitioningClause partitioning) {
this.partitioning = partitioning;
public class MySqlPartitionByKey extends MySqlObjectImpl implements SQLPartitioningClause {
private static final long serialVersionUID = 1L;
private List<SQLName>     columns          = new ArrayList<SQLName>();
private SQLExpr           partitionCount;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, columns);
acceptChild(visitor, partitionCount);
visitor.endVisit(this);
public SQLExpr getPartitionCount() {
return partitionCount;
public void setPartitionCount(SQLExpr partitionCount) {
this.partitionCount = partitionCount;
public List<SQLName> getColumns() {
return columns;
public void setColumns(List<SQLName> columns) {
this.columns = columns;
MySqlCreateTableStatement stmt = new MySqlCreateTableStatement();
stmt.setType(SQLCreateTableStatement.Type.GLOBAL_TEMPORARY);
stmt.setIfNotExiists(true);
stmt.setName(this.exprParser.name());
stmt.getTableElementList().add(column);
stmt.getTableElementList().add(parseConstraint());
stmt.getTableElementList().add(idx);
stmt.getTableElementList().add(parseConstraint());
stmt.getTableElementList().add(parseConstraint());
stmt.getTableOptions().put("ENGINE", lexer.stringVal());
stmt.getTableOptions().put("TYPE", lexer.stringVal());
if (identifierEquals("PARTITION")) {
lexer.nextToken();
accept(Token.BY);
if (lexer.token() == Token.KEY) {
MySqlPartitionByKey clause = new MySqlPartitionByKey();
lexer.nextToken();
accept(Token.LPAREN);
for (;;) {
clause.getColumns().add(this.exprParser.name());
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
accept(Token.RPAREN);
stmt.setPartitioning(clause);
if (identifierEquals("PARTITIONS")) {
lexer.nextToken();
clause.setPartitionCount(this.exprParser.expr());
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
stmt.setQuery(query);
return stmt;
if (identifierEquals("PARTITION")) {
throw new ParserException("syntax error " + lexer.token() + " " + lexer.stringVal());
void endVisit(MySqlPartitionByKey x);
boolean visit(MySqlPartitionByKey x);
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
return true;
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
print("PARTITION BY KEY (");
printAndAccept(x.getColumns(), ", ");
print(")");
if (x.getPartitionCount() != null) {
print(" PARTITIONS ");
x.getPartitionCount().accept(this);
return false;
public void endVisit(MySqlPartitionByKey x) {
public boolean visit(MySqlPartitionByKey x) {
accept(x.getColumns());
return false;
this.variants.put("TRUE", null);
this.variants.put("FALSE", null);
public boolean visit(SQLCurrentOfCursorExpr x) {
return false;
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("tk")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tk", "col3")));
public SQLSelectQuery query() throws ParserException {
public SQLSelectQuery query() {
public SQLSelectQuery query() throws ParserException {
public SQLSelectQuery query() throws ParserException {
public final Lexer getLexer() {
return lexer;
public SQLSelectQuery query() throws ParserException {
public class Entity {
private String         name;
private String         description;
private String         tableName;
private List<Property> properties = new ArrayList<Property>();
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getDescription() {
return description;
public void setDescription(String description) {
this.description = description;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
public List<Property> getProperties() {
return properties;
public void setProperties(List<Property> properties) {
this.properties = properties;
public class EntityMapingMySqlVisitor extends MySqlASTVisitorAdapter {
private final Entity entity;
public EntityMapingMySqlVisitor(Entity entity){
this.entity = entity;
public Entity getEntity() {
return entity;
public class Property {
private String name;
private String dbColumnName;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getDbColumnName() {
return dbColumnName;
public void setDbColumnName(String dbColumnName) {
this.dbColumnName = dbColumnName;
protected String              methodName;
this.methodName = methodName;
this.methodName = methodName;
public String getMethodName() {
public void setMethodName(String methodName) {
public class MySqlMappingVisitor extends MySqlASTVisitorAdapter {
private final Map<String, SQLExpr> mapping = new HashMap<String, SQLExpr>();
public void addMapping(String column, String targetExpr) {
print(expr.getMethodName());
print(x.getMethodName());
public class DruidMappingException extends RuntimeException {
private static final long serialVersionUID = 1L;
public DruidMappingException(){
public DruidMappingException(String message, Throwable cause){
super(message, cause);
public DruidMappingException(String message){
super(message);
public DruidMappingException(Throwable cause){
super(cause);
private String                name;
private String                description;
private String                tableName;
private Map<String, Property> properties = new LinkedHashMap<String, Property>();
public Entity(){
public Entity(String name, String description, String tableName){
this.name = name;
this.description = description;
this.tableName = tableName;
public void addProperty(Property property) {
this.properties.put(property.getName(), property);
public Property getProperty(String name) {
Property prop = this.properties.get(name);
if (prop == null) {
for (Map.Entry<String, Property> entry : properties.entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
prop = entry.getValue();
return prop;
public Map<String, Property> getProperties() {
public void setProperties(Map<String, Property> properties) {
private final LinkedHashMap<String, Entity> entities;
public EntityMapingMySqlVisitor(LinkedHashMap<String, Entity> entities){
this.entities = entities;
public Map<String, Entity> getEntities() {
return entities;
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public Entity getEntity(String name) {
Entity entity = this.entities.get(name);
if (entity == null) {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
entity = entry.getValue();
public boolean visit(SQLSelectItem x) {
x.getExpr().setParent(x);
return true;
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getSelectList().size() == 0) {
fillSelectList(x);
if (x.getSelectList().size() == 1) {
if (x.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
x.getSelectList().clear();
fillSelectList(x);
if (x.getFrom() == null) {
Entity firstEntity = this.getFirstEntity();
SQLExprTableSource from = new SQLExprTableSource(new SQLIdentifierExpr(firstEntity.getName()));
x.setFrom(from);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
public boolean visit(SQLSelectQueryBlock x) {
if (x instanceof MySqlSelectQueryBlock) {
return visit((MySqlSelectQueryBlock) x);
if (x.getSelectList().size() == 0) {
fillSelectList(x);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
protected void fillSelectList(SQLSelectQueryBlock x) {
Entity entity = getFirstEntity();
for (Property item : entity.getProperties().values()) {
x.getSelectList().add(new SQLSelectItem(new SQLIdentifierExpr(item.getName()), '"' + item.getName() + '"'));
public boolean visit(SQLIdentifierExpr x) {
String propertyName = x.getName();
Property property = null;
for (Entity entity : this.entities.values()) {
property = entity.getProperty(propertyName);
if (property != null) {
if (property == null) {
throw new DruidMappingException("property not found : " + propertyName);
String dbColumName = property.getDbColumnName();
x.setName(dbColumName);
if (x.getParent() instanceof SQLSelectItem) {
SQLSelectItem selectItem = (SQLSelectItem) x.getParent();
if (selectItem.getAlias() == null) {
selectItem.setAlias('"' + property.getName() + '"');
return false;
public boolean visit(SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr tableExpr = (SQLIdentifierExpr) expr;
String entityName = tableExpr.getName();
Entity entity = this.getEntity(entityName);
if (entity == null) {
throw new DruidMappingException("entity not foudn : " + entityName);
tableExpr.setName(entity.getTableName());
return false;
public class MappingEngine {
private LinkedHashMap<String, Entity> entities = new LinkedHashMap<String, Entity>();
public LinkedHashMap<String, Entity> getEntities() {
return entities;
public void addEntity(Entity entity) {
this.entities.put(entity.getName(), entity);
public EntityMapingMySqlVisitor createMappingVisitor() {
return new EntityMapingMySqlVisitor(entities);
public String explain(String sql) {
MySqlSelectParser selectParser = new MySqlSelectParser(sql);
SQLSelectQuery query = selectParser.query();
query.accept(this.createMappingVisitor());
return SQLUtils.toMySqlString(query);
private String desciption;
public Property(){
public Property(String name, String desciption, String dbColumnName){
this.name = name;
this.desciption = desciption;
this.dbColumnName = dbColumnName;
public String getDesciption() {
return desciption;
public void setDesciption(String desciption) {
this.desciption = desciption;
public class SQLUtils {
public static String toMySqlString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new MySqlOutputVisitor(out));
String sql = out.toString();
return sql;
public static String toOracleString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new OracleOutputVisitor(out));
String sql = out.toString();
return sql;
public static String toPGString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new PGOutputVisitor(out));
String sql = out.toString();
return sql;
public SQLExprTableSource(SQLExpr expr){
this.expr = expr;
protected final Appendable appender;
private String             indent      = "t";
private int                indentCount = 0;
public int getIndentCount() {
return indentCount;
public Appendable getAppender() {
return appender;
|| left.getOperator() == SQLBinaryOperator.BooleanOr;
boolean visit(SQLIdentifierExpr x);
public boolean visit(SQLIdentifierExpr x) {
public static List<Map<String, Object>> executeQuery(Connection conn, String sql, List<Object> parameters) {
List<Map<String, Object>> rows = new ArrayList<Map<String, Object>>();
PreparedStatement stmt = null;
ResultSet rs = null;
stmt = conn.prepareStatement(sql);
for (int i = 0, size = parameters.size(); i < size; ++i) {
Object val = parameters.get(i);
int paramIndex = i + 1;
if (val == null) {
stmt.setNull(paramIndex, Types.VARCHAR);
} else if (val instanceof BigDecimal) {
stmt.setBigDecimal(paramIndex, (BigDecimal) val);
} else if (val instanceof String) {
stmt.setString(paramIndex, (String) val);
} else if (val instanceof Date) {
long time = ((Date) val).getTime();
stmt.setTimestamp(paramIndex, new java.sql.Timestamp(time));
} else if (val instanceof Byte) {
stmt.setByte(paramIndex, (Byte) val);
} else if (val instanceof Short) {
stmt.setShort(paramIndex, (Short) val);
} else if (val instanceof Integer) {
stmt.setInt(paramIndex, (Integer) val);
} else if (val instanceof Long) {
stmt.setLong(paramIndex, (Long) val);
} else if (val instanceof Float) {
stmt.setFloat(paramIndex, (Float) val);
} else if (val instanceof Double) {
stmt.setDouble(paramIndex, (Double) val);
throw new DruidMappingException("not support parameters : " + val);
rs = stmt.executeQuery();
ResultSetMetaData rsMeta = rs.getMetaData();
while (rs.next()) {
Map<String, Object> row = new LinkedHashMap<String, Object>();
for (int i = 0, size = rsMeta.getColumnCount(); i < size; ++i) {
String columName = rsMeta.getColumnName(i + 1);
Object value = rs.getObject(i + 1);
row.put(columName, value);
rows.add(row);
} catch (SQLException e) {
throw new DruidMappingException("execute error", e);
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
return rows;
public class MappingVisitorTest extends TestCase {
public void test_0() throws Exception {
MappingEngine engine = new MappingEngine();
Entity entity = new Entity();
entity.setName("");
entity.setDescription("Device");
entity.setTableName("device");
entity.addProperty(new Property("", "", "serviceTag"));
entity.addProperty(new Property("IP", "", "ip"));
engine.addEntity(entity);
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explain("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explain("select , IP WHERE IP = '127.0.0.1'"));
public class DruidMappingException extends RuntimeException {
private static final long serialVersionUID = 1L;
public DruidMappingException(){
public DruidMappingException(String message, Throwable cause){
super(message, cause);
public DruidMappingException(String message){
super(message);
public DruidMappingException(Throwable cause){
super(cause);
private String                name;
private String                description;
private String                tableName;
private Map<String, Property> properties = new LinkedHashMap<String, Property>();
public Entity(){
public Entity(String name, String description, String tableName){
this.name = name;
this.description = description;
this.tableName = tableName;
public void addProperty(Property property) {
this.properties.put(property.getName(), property);
public Property getProperty(String name) {
Property prop = this.properties.get(name);
if (prop == null) {
for (Map.Entry<String, Property> entry : properties.entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
prop = entry.getValue();
return prop;
public Map<String, Property> getProperties() {
public void setProperties(Map<String, Property> properties) {
private final LinkedHashMap<String, Entity> entities;
public EntityMapingMySqlVisitor(LinkedHashMap<String, Entity> entities){
this.entities = entities;
public Map<String, Entity> getEntities() {
return entities;
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public Entity getEntity(String name) {
Entity entity = this.entities.get(name);
if (entity == null) {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
entity = entry.getValue();
public boolean visit(SQLSelectItem x) {
x.getExpr().setParent(x);
return true;
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getSelectList().size() == 0) {
fillSelectList(x);
if (x.getSelectList().size() == 1) {
if (x.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
x.getSelectList().clear();
fillSelectList(x);
if (x.getFrom() == null) {
Entity firstEntity = this.getFirstEntity();
SQLExprTableSource from = new SQLExprTableSource(new SQLIdentifierExpr(firstEntity.getName()));
x.setFrom(from);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
public boolean visit(SQLSelectQueryBlock x) {
if (x instanceof MySqlSelectQueryBlock) {
return visit((MySqlSelectQueryBlock) x);
if (x.getSelectList().size() == 0) {
fillSelectList(x);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
protected void fillSelectList(SQLSelectQueryBlock x) {
Entity entity = getFirstEntity();
for (Property item : entity.getProperties().values()) {
x.getSelectList().add(new SQLSelectItem(new SQLIdentifierExpr(item.getName()), '"' + item.getName() + '"'));
public boolean visit(SQLIdentifierExpr x) {
String propertyName = x.getName();
Property property = null;
for (Entity entity : this.entities.values()) {
property = entity.getProperty(propertyName);
if (property != null) {
if (property == null) {
throw new DruidMappingException("property not found : " + propertyName);
String dbColumName = property.getDbColumnName();
x.setName(dbColumName);
if (x.getParent() instanceof SQLSelectItem) {
SQLSelectItem selectItem = (SQLSelectItem) x.getParent();
if (selectItem.getAlias() == null) {
selectItem.setAlias('"' + property.getName() + '"');
return false;
public boolean visit(SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr tableExpr = (SQLIdentifierExpr) expr;
String entityName = tableExpr.getName();
Entity entity = this.getEntity(entityName);
if (entity == null) {
throw new DruidMappingException("entity not foudn : " + entityName);
tableExpr.setName(entity.getTableName());
return false;
public class MappingEngine {
private LinkedHashMap<String, Entity> entities = new LinkedHashMap<String, Entity>();
private Integer                       maxLimit;
public Integer getMaxLimit() {
return maxLimit;
public void setMaxLimit(Integer maxLimit) {
this.maxLimit = maxLimit;
public LinkedHashMap<String, Entity> getEntities() {
return entities;
public void addEntity(Entity entity) {
this.entities.put(entity.getName(), entity);
public EntityMapingMySqlVisitor createMappingVisitor() {
return new EntityMapingMySqlVisitor(entities);
public String explain(String sql) {
MySqlSelectQueryBlock query = explainToSQLObject(sql);
if (this.maxLimit != null) {
if (query.getLimit() == null) {
Limit limit = new Limit();
limit.setRowCount(new SQLNumberExpr(maxLimit));
query.setLimit(limit);
SQLNumberExpr rowCountExpr = (SQLNumberExpr) query.getLimit().getRowCount();
int rowCount = rowCountExpr.getNumber().intValue();
if (rowCount > maxLimit.intValue()) {
rowCountExpr.setNumber(maxLimit);
query.accept(this.createMappingVisitor());
return SQLUtils.toMySqlString(query);
public MySqlSelectQueryBlock explainToSQLObject(String sql) {
MySqlSelectParser selectParser = new MySqlSelectParser(sql);
MySqlSelectQueryBlock query = (MySqlSelectQueryBlock) selectParser.query();
return query;
private String desciption;
public Property(){
public Property(String name, String desciption, String dbColumnName){
this.name = name;
this.desciption = desciption;
this.dbColumnName = dbColumnName;
public String getDesciption() {
return desciption;
public void setDesciption(String desciption) {
this.desciption = desciption;
public class SQLUtils {
public static String toMySqlString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new MySqlOutputVisitor(out));
String sql = out.toString();
return sql;
public static String toOracleString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new OracleOutputVisitor(out));
String sql = out.toString();
return sql;
public static String toPGString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new PGOutputVisitor(out));
String sql = out.toString();
return sql;
public SQLExprTableSource(SQLExpr expr){
this.expr = expr;
protected final Appendable appender;
private String             indent      = "t";
private int                indentCount = 0;
public int getIndentCount() {
return indentCount;
public Appendable getAppender() {
return appender;
|| left.getOperator() == SQLBinaryOperator.BooleanOr;
boolean visit(SQLIdentifierExpr x);
public boolean visit(SQLIdentifierExpr x) {
public static List<Map<String, Object>> executeQuery(Connection conn, String sql, List<Object> parameters) {
List<Map<String, Object>> rows = new ArrayList<Map<String, Object>>();
PreparedStatement stmt = null;
ResultSet rs = null;
stmt = conn.prepareStatement(sql);
for (int i = 0, size = parameters.size(); i < size; ++i) {
Object val = parameters.get(i);
int paramIndex = i + 1;
if (val == null) {
stmt.setNull(paramIndex, Types.VARCHAR);
} else if (val instanceof BigDecimal) {
stmt.setBigDecimal(paramIndex, (BigDecimal) val);
} else if (val instanceof String) {
stmt.setString(paramIndex, (String) val);
} else if (val instanceof Date) {
long time = ((Date) val).getTime();
stmt.setTimestamp(paramIndex, new java.sql.Timestamp(time));
} else if (val instanceof Byte) {
stmt.setByte(paramIndex, (Byte) val);
} else if (val instanceof Short) {
stmt.setShort(paramIndex, (Short) val);
} else if (val instanceof Integer) {
stmt.setInt(paramIndex, (Integer) val);
} else if (val instanceof Long) {
stmt.setLong(paramIndex, (Long) val);
} else if (val instanceof Float) {
stmt.setFloat(paramIndex, (Float) val);
} else if (val instanceof Double) {
stmt.setDouble(paramIndex, (Double) val);
throw new DruidMappingException("not support parameters : " + val);
rs = stmt.executeQuery();
ResultSetMetaData rsMeta = rs.getMetaData();
while (rs.next()) {
Map<String, Object> row = new LinkedHashMap<String, Object>();
for (int i = 0, size = rsMeta.getColumnCount(); i < size; ++i) {
String columName = rsMeta.getColumnName(i + 1);
Object value = rs.getObject(i + 1);
row.put(columName, value);
rows.add(row);
} catch (SQLException e) {
throw new DruidMappingException("execute error", e);
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
return rows;
public class MappingVisitorTest extends TestCase {
MappingEngine engine = new MappingEngine();
protected void setUp() throws Exception {
Entity entity = new Entity();
entity.setName("");
entity.setDescription("Device");
entity.setTableName("device");
entity.addProperty(new Property("", "", "serviceTag"));
entity.addProperty(new Property("IP", "", "ip"));
engine.addEntity(entity);
public void test_0() throws Exception {
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explain("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explain("select , IP WHERE IP = '127.0.0.1'"));
public void test_1() throws Exception {
engine.setMaxLimit(10);
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenLIMIT 10", engine.explain("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'nLIMIT 10",
engine.explain("select , IP WHERE IP = '127.0.0.1'"));
engine.setMaxLimit(null);
public MySqlMappingVisitor createMappingVisitor() {
return new MySqlMappingVisitor(entities);
public class MySqlMappingVisitor extends MySqlASTVisitorAdapter {
public MySqlMappingVisitor(LinkedHashMap<String, Entity> entities){
public MySqlMappingVisitor createMappingVisitor() {
return new MySqlMappingVisitor(entities);
public class MySqlMappingVisitor extends MySqlASTVisitorAdapter {
private final LinkedHashMap<String, Entity> entities;
private final Map<String, SQLTableSource> tableSources = new LinkedHashMap<String, SQLTableSource>();
public MySqlMappingVisitor(LinkedHashMap<String, Entity> entities) {
this.entities = entities;
public Map<String, Entity> getEntities() {
return entities;
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public Entity getEntity(String name) {
Entity entity = this.entities.get(name);
if (entity == null) {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
entity = entry.getValue();
return entity;
public boolean visit(SQLSelectItem x) {
x.getExpr().setParent(x);
return true;
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getSelectList().size() == 0) {
fillSelectList(x);
if (x.getSelectList().size() == 1) {
if (x.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
x.getSelectList().clear();
fillSelectList(x);
if (x.getFrom() == null) {
Entity firstEntity = this.getFirstEntity();
SQLExprTableSource from = new SQLExprTableSource(
new SQLIdentifierExpr(firstEntity.getName()));
x.setFrom(from);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
public boolean visit(SQLSelectQueryBlock x) {
if (x instanceof MySqlSelectQueryBlock) {
return visit((MySqlSelectQueryBlock) x);
if (x.getSelectList().size() == 0) {
fillSelectList(x);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
return super.visit(x);
protected void fillSelectList(SQLSelectQueryBlock x) {
Entity entity = getFirstEntity();
for (Property item : entity.getProperties().values()) {
x.getSelectList().add(
new SQLSelectItem(new SQLIdentifierExpr(item.getName()),
'"' + item.getName() + '"'));
public boolean visit(SQLIdentifierExpr x) {
String propertyName = x.getName();
Property property = null;
for (Entity entity : this.entities.values()) {
property = entity.getProperty(propertyName);
if (property != null) {
if (property == null) {
throw new DruidMappingException("property not found : "
+ propertyName);
String dbColumName = property.getDbColumnName();
x.setName(dbColumName);
if (x.getParent() instanceof SQLSelectItem) {
SQLSelectItem selectItem = (SQLSelectItem) x.getParent();
if (selectItem.getAlias() == null) {
selectItem.setAlias('"' + property.getName() + '"');
return false;
public boolean visit(SQLSubqueryTableSource x) {
if (x.getAlias() != null) {
tableSources.put(x.getAlias(), x);
return true;
public boolean visit(SQLJoinTableSource x) {
if (x.getAlias() != null) {
tableSources.put(x.getAlias(), x);
return true;
public boolean visit(SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr tableExpr = (SQLIdentifierExpr) expr;
String entityName = tableExpr.getName();
Entity entity = this.getEntity(entityName);
if (entity == null) {
throw new DruidMappingException("entity not foudn : "
+ entityName);
tableExpr.setName(entity.getTableName());
if (x.getAlias() != null) {
tableSources.put(x.getAlias(), x);
return false;
private MappingProvider               provider;
public MappingVisitor createMappingVisitor() {
return provider.createMappingVisitor(this);
public SQLASTOutputVisitor createOutputVisitor(Appendable out) {
return provider.createOutputVisitor(this, out);
public String explainToSQL(String sql) {
SQLSelectQueryBlock query = provider.explainToSQLObject(this, sql);
query.accept(this.createMappingVisitor());
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor outputVisitor = createOutputVisitor(out);
query.accept(outputVisitor);
return out.toString();
public interface MappingProvider {
MappingVisitor createMappingVisitor(MappingEngine engine);
SQLASTOutputVisitor createOutputVisitor(MappingEngine engine, Appendable out);
SQLSelectQueryBlock explainToSQLObject(MappingEngine engine, String sql);
public interface MappingVisitor extends SQLASTVisitor {
Entity getFirstEntity();
Entity getEntity(String name);
Map<String, Entity> getEntities();
Map<String, SQLTableSource> getTableSources();
public class MySqlMappingProvider implements MappingProvider {
public MappingVisitor createMappingVisitor(MappingEngine engine) {
return new MySqlMappingVisitor(engine.getEntities());
public SQLASTOutputVisitor createOutputVisitor(MappingEngine engine, Appendable out) {
return new MySqlOutputVisitor(out);
public SQLSelectQueryBlock explainToSQLObject(MappingEngine engine, String sql) {
MySqlSelectParser selectParser = new MySqlSelectParser(sql);
MySqlSelectQueryBlock query = (MySqlSelectQueryBlock) selectParser.query();
Integer maxLimit = engine.getMaxLimit();
if (maxLimit != null) {
if (query.getLimit() == null) {
Limit limit = new Limit();
limit.setRowCount(new SQLNumberExpr(maxLimit));
query.setLimit(limit);
SQLNumberExpr rowCountExpr = (SQLNumberExpr) query.getLimit().getRowCount();
int rowCount = rowCountExpr.getNumber().intValue();
if (rowCount > maxLimit.intValue()) {
rowCountExpr.setNumber(maxLimit);
return query;
public class OracleMappingProvider implements MappingProvider {
public MappingVisitor createMappingVisitor(MappingEngine engine) {
return new OracleMappingVisitor(engine.getEntities());
public SQLASTOutputVisitor createOutputVisitor(MappingEngine engine, Appendable out) {
return new OracleOutputVisitor(out);
public SQLSelectQueryBlock explainToSQLObject(MappingEngine engine, String sql) {
OracleSelectParser selectParser = new OracleSelectParser(sql);
OracleSelectQueryBlock query = (OracleSelectQueryBlock) selectParser.query();
return query;
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSQL("select *"));
engine.explainToSQL("select , IP WHERE IP = '127.0.0.1'"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenLIMIT 10", engine.explainToSQL("select *"));
engine.explainToSQL("select , IP WHERE IP = '127.0.0.1'"));
private final MappingProvider         provider;
public MappingEngine(){
this(new MySqlMappingProvider());
public MappingEngine(MappingProvider provider){
this.provider = provider;
public class MSSQLServerMappingVisitor extends SQLServerASTVisitorAdapter implements MappingVisitor {
private final LinkedHashMap<String, Entity> entities;
private final Map<String, SQLTableSource>   tableSources = new LinkedHashMap<String, SQLTableSource>();
public MSSQLServerMappingVisitor(LinkedHashMap<String, Entity> entities){
this.entities = entities;
public LinkedHashMap<String, Entity> getEntities() {
return entities;
public Map<String, SQLTableSource> getTableSources() {
return tableSources;
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public Entity getEntity(String name) {
return MappingVisitorUtils.getEntity(this, name);
public boolean visit(SQLSelectItem x) {
x.getExpr().setParent(x);
return true;
public boolean visit(SQLServerSelectQueryBlock x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLSelectQueryBlock x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLSubqueryTableSource x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLJoinTableSource x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLExprTableSource x) {
return MappingVisitorUtils.visit(this, x);
public static Entity getEntity(MappingVisitor visitor, String name) {
Entity entity = visitor.getEntities().get(name);
if (entity == null) {
for (Map.Entry<String, Entity> entry : visitor.getEntities().entrySet()) {
if (entry.getKey().equalsIgnoreCase(name)) {
entity = entry.getValue();
return entity;
return MappingVisitorUtils.getEntity(this, name);
public class OracleMappingVisitor extends OracleASTVIsitorAdapter implements MappingVisitor {
private final LinkedHashMap<String, Entity> entities;
private final Map<String, SQLTableSource>   tableSources = new LinkedHashMap<String, SQLTableSource>();
public OracleMappingVisitor(LinkedHashMap<String, Entity> entities){
this.entities = entities;
public LinkedHashMap<String, Entity> getEntities() {
return entities;
public Map<String, SQLTableSource> getTableSources() {
return tableSources;
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public Entity getEntity(String name) {
return MappingVisitorUtils.getEntity(this, name);
public boolean visit(SQLSelectItem x) {
x.getExpr().setParent(x);
return true;
public boolean visit(OracleSelectQueryBlock x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLSelectQueryBlock x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLSubqueryTableSource x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLJoinTableSource x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(SQLExprTableSource x) {
return MappingVisitorUtils.visit(this, x);
public boolean visit(OracleSelectTableReference x) {
return MappingVisitorUtils.visit(this, x);
public class SQLServerASTVisitorAdapter extends SQLASTVisitorAdapter implements SQLServerASTVisitor {
public boolean visit(SQLServerSelectQueryBlock x) {
return true;
public void endVisit(SQLServerSelectQueryBlock x) {
public boolean visit(Top x) {
return true;
public void endVisit(Top x) {
public SQLSelectQueryBlock explainToSelectSQLObject(String sql) {
return provider.explainToSelectSQLObject(this, sql);
public String explainToSelectSQL(String sql) {
SQLSelectQueryBlock query = explainToSelectSQLObject(sql);
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql) {
SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql);
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql) {
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql) {
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSelectSQL("select *"));
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenLIMIT 10", engine.explainToSelectSQL("select *"));
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
return new MSSQLServerMappingVisitor(engine.getEntities());
SQLNumericLiteralExpr rowCountExpr = (SQLNumericLiteralExpr) query.getTop().getExpr();
limit.setRowCount(new SQLIntegerExpr(maxLimit));
SQLNumericLiteralExpr rowCountExpr = (SQLNumericLiteralExpr) query.getLimit().getRowCount();
public abstract void setNumber(Number number);
public void setNumber(Number number) {
if (number == null) {
this.setValue(null);
this.setValue(number.doubleValue());
public void setNumber(Number number) {
if (number == null) {
this.setValue(null);
this.setValue(number.floatValue());
public class MappingVisitorSQLServerTest extends TestCase {
MappingEngine engine = new MappingEngine(new MSSQLServerMappingProvider());
protected void setUp() throws Exception {
Entity entity = new Entity();
entity.setName("");
entity.setDescription("Device");
entity.setTableName("device");
entity.addProperty(new Property("", "", "serviceTag"));
entity.addProperty(new Property("IP", "", "ip"));
engine.addEntity(entity);
public void test_0() throws Exception {
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSelectSQL("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
public void test_1() throws Exception {
engine.setMaxLimit(10);
Assert.assertEquals("SELECT TOP 10 serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSelectSQL("select *"));
Assert.assertEquals("SELECT TOP 10 serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
Assert.assertEquals("SELECT TOP 3 serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select top 3 , IP WHERE IP = '127.0.0.1'"));
engine.setMaxLimit(null);
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'nLIMIT 3",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1' limit 3"));
return toSQL(query);
public SQLDeleteStatement explainToDeleteSQLObject(String sql) {
return provider.explainToDeleteSQLObject(this, sql);
public String explainToDeleteSQLObjectSQL(String sql) {
SQLDeleteStatement query = explainToDeleteSQLObject(sql);
query.accept(this.createMappingVisitor());
return toSQL(query);
public String toSQL(SQLObject sqlObject) {
sqlObject.accept(outputVisitor);
return new MSSQLServerMappingVisitor(engine.getEntities());
SQLNumericLiteralExpr rowCountExpr = (SQLNumericLiteralExpr) query.getTop().getExpr();
public SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql) {
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
return parser.parseDeleteStatement();
SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql);
limit.setRowCount(new SQLIntegerExpr(maxLimit));
SQLNumericLiteralExpr rowCountExpr = (SQLNumericLiteralExpr) query.getLimit().getRowCount();
public MySqlDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
return parser.parseDeleteStatement();
public OracleDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql) {
OracleStatementParser parser = new OracleStatementParser(sql);
return parser.parseDeleteStatement();
public abstract void setNumber(Number number);
public MySqlDeleteStatement parseDeleteStatement() throws ParserException {
public void setNumber(Number number) {
if (number == null) {
this.setValue(null);
this.setValue(number.doubleValue());
public void setNumber(Number number) {
if (number == null) {
this.setValue(null);
this.setValue(number.floatValue());
statementList.add(parseDeleteStatement());
public OracleDeleteStatement parseDeleteStatement() throws ParserException {
public class MappingVisitorSQLServerTest extends TestCase {
MappingEngine engine = new MappingEngine(new MSSQLServerMappingProvider());
protected void setUp() throws Exception {
Entity entity = new Entity();
entity.setName("");
entity.setDescription("Device");
entity.setTableName("device");
entity.addProperty(new Property("", "", "serviceTag"));
entity.addProperty(new Property("IP", "", "ip"));
engine.addEntity(entity);
public void test_0() throws Exception {
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSelectSQL("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
public void test_1() throws Exception {
engine.setMaxLimit(10);
Assert.assertEquals("SELECT TOP 10 serviceTag AS "", ip AS "IP"nFROM device", engine.explainToSelectSQL("select *"));
Assert.assertEquals("SELECT TOP 10 serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
Assert.assertEquals("SELECT TOP 3 serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select top 3 , IP WHERE IP = '127.0.0.1'"));
engine.setMaxLimit(null);
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'nLIMIT 3",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1' limit 3"));
public interface ExportParameterVisitor extends SQLASTVisitor {
public class ExportParameterVisitorUtils {
public static boolean exportParamterAndAccept(final List<Object> parameters, List<SQLExpr> list) {
for (int i = 0, size = list.size(); i < size; ++i) {
SQLExpr param = list.get(i);
SQLExpr result = exportParameter(parameters, param);
if (result != param) {
list.set(i, result);
return false;
public static SQLExpr exportParameter(final List<Object> parameters, final SQLExpr param) {
if (param instanceof SQLCharExpr) {
Object value = ((SQLCharExpr) param).getText();
parameters.add(value);
return new SQLVariantRefExpr("?");
if (param instanceof MySqlBooleanExpr) {
Object value = ((MySqlBooleanExpr) param).getValue();
parameters.add(value);
return new SQLVariantRefExpr("?");
if (param instanceof SQLNumericLiteralExpr) {
Object value = ((SQLNumericLiteralExpr) param).getNumber();
parameters.add(value);
return new SQLVariantRefExpr("?");
return param;
public static void exportParameter(final List<Object> parameters, SQLBinaryOpExpr x) {
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr) {
SQLExpr leftResult = ExportParameterVisitorUtils.exportParameter(parameters, x.getLeft());
if (leftResult != x.getLeft()) {
x.setLeft(leftResult);
SQLExpr rightResult = exportParameter(parameters, x.getRight());
if (rightResult != x.getRight()) {
x.setRight(rightResult);
public static void exportParameter(final List<Object> parameters, SQLBetweenExpr x) {
SQLExpr result = exportParameter(parameters, x.getBeginExpr());
if (result != x.getBeginExpr()) {
x.setBeginExpr(result);
SQLExpr result = exportParameter(parameters, x.getEndExpr());
if (result != x.getBeginExpr()) {
x.setEndExpr(result);
public class MSSQLServerExportParameterVisitor extends SQLServerASTVisitorAdapter implements ExportParameterVisitor {
private final List<Object> parameters;
public MSSQLServerExportParameterVisitor(List<Object> parameters){
this.parameters = parameters;
public List<Object> getParameters() {
return parameters;
public boolean visit(SQLSelectItem x) {
return false;
public boolean visit(SQLOrderBy x) {
return false;
public boolean visit(SQLSelectGroupByClause x) {
return false;
public boolean visit(SQLMethodInvokeExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getParameters());
return true;
public boolean visit(SQLInListExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getTargetList());
return true;
public boolean visit(SQLBetweenExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public boolean visit(SQLBinaryOpExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public ExportParameterVisitor createExportParameterVisitor(List<Object> parameters) {
return new MSSQLServerExportParameterVisitor(parameters);
ExportParameterVisitor createExportParameterVisitor(List<Object> parameters);
public class MySqlExportParameterVisitor extends MySqlASTVisitorAdapter implements ExportParameterVisitor {
private final List<Object> parameters;
public MySqlExportParameterVisitor(List<Object> parameters){
this.parameters = parameters;
public List<Object> getParameters() {
return parameters;
public boolean visit(SQLSelectItem x) {
return false;
public boolean visit(Limit x) {
return false;
public boolean visit(SQLOrderBy x) {
return false;
public boolean visit(SQLSelectGroupByClause x) {
return false;
public boolean visit(SQLMethodInvokeExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getParameters());
return true;
public boolean visit(SQLInListExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getTargetList());
return true;
public boolean visit(SQLBetweenExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public boolean visit(SQLBinaryOpExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public ExportParameterVisitor createExportParameterVisitor(List<Object> parameters) {
return new MySqlExportParameterVisitor(parameters);
public class OracleExportParameterVisitor extends OracleASTVIsitorAdapter implements ExportParameterVisitor {
private final List<Object> parameters;
public OracleExportParameterVisitor(List<Object> parameters){
this.parameters = parameters;
public List<Object> getParameters() {
return parameters;
public boolean visit(SQLSelectItem x) {
return false;
public boolean visit(SQLOrderBy x) {
return false;
public boolean visit(SQLSelectGroupByClause x) {
return false;
public boolean visit(SQLMethodInvokeExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getParameters());
return true;
public boolean visit(SQLInListExpr x) {
ExportParameterVisitorUtils.exportParamterAndAccept(this.parameters, x.getTargetList());
return true;
public boolean visit(SQLBetweenExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public boolean visit(SQLBinaryOpExpr x) {
ExportParameterVisitorUtils.exportParameter(this.parameters, x);
return true;
public ExportParameterVisitor createExportParameterVisitor(List<Object> parameters) {
return new OracleExportParameterVisitor(parameters);
public String toSQL(SQLObject sqlObject) {
return toSQL(sqlObject, false);
public String toSQL(SQLObject sqlObject, boolean exportParameter) {
if (exportParameter) {
exportParameters(sqlObject);
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor outputVisitor = createOutputVisitor(out);
sqlObject.accept(outputVisitor);
return out.toString();
public List<Map<String, Object>> executeQuery(Connection conn, String sql, List<Object> parameters) {
SQLSelectQueryBlock sqlObject = this.explainToSelectSQLObject(sql);
exportParameters(sqlObject, parameters);
String rawSql = this.toSQL(sqlObject);
return JdbcUtils.executeQuery(conn, rawSql, parameters);
public String toSQL(SQLObject sqlObject) {
return toSQL(sqlObject, false);
public String toSQL(SQLObject sqlObject, boolean exportParameter) {
if (exportParameter) {
exportParameters(sqlObject);
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor outputVisitor = createOutputVisitor(out);
sqlObject.accept(outputVisitor);
return out.toString();
public List<Map<String, Object>> select(Connection conn, String sql, List<Object> parameters) throws SQLException {
SQLSelectQueryBlock sqlObject = this.explainToSelectSQLObject(sql);
exportParameters(sqlObject, parameters);
String rawSql = this.toSQL(sqlObject);
return JdbcUtils.executeQuery(conn, rawSql, parameters);
public int delete(Connection conn, String sql, List<Object> parameters) throws SQLException {
SQLDeleteStatement sqlObject = this.explainToDeleteSQLObject(sql);
exportParameters(sqlObject, parameters);
String rawSql = this.toSQL(sqlObject);
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, parameters);
return updateCount;
public int update(Connection conn, String sql, List<Object> parameters) throws SQLException {
SQLUpdateStatement sqlObject = this.explainToUpdateSQLObject(sql);
exportParameters(sqlObject, parameters);
String rawSql = this.toSQL(sqlObject);
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, parameters);
return updateCount;
public void insert(Connection conn, String sql, List<Object> parameters) throws SQLException {
SQLInsertStatement sqlObject = this.explainToInsertSQLObject(sql);
exportParameters(sqlObject, parameters);
String rawSql = this.toSQL(sqlObject);
JdbcUtils.execute(conn, rawSql, parameters);
public static int executeUpdate(Connection conn, String sql, List<Object> parameters) throws SQLException {
PreparedStatement stmt = null;
int updateCount;
stmt = conn.prepareStatement(sql);
setParameters(stmt, parameters);
updateCount = stmt.executeUpdate();
} finally {
JdbcUtils.close(stmt);
return updateCount;
public static void execute(Connection conn, String sql, List<Object> parameters) throws SQLException {
PreparedStatement stmt = null;
stmt = conn.prepareStatement(sql);
setParameters(stmt, parameters);
stmt.executeUpdate();
} finally {
JdbcUtils.close(stmt);
public static List<Map<String, Object>> executeQuery(Connection conn, String sql, List<Object> parameters)
throws SQLException {
setParameters(stmt, parameters);
private static void setParameters(PreparedStatement stmt, List<Object> parameters) throws SQLException {
for (int i = 0, size = parameters.size(); i < size; ++i) {
Object val = parameters.get(i);
int paramIndex = i + 1;
if (val == null) {
stmt.setNull(paramIndex, Types.VARCHAR);
} else if (val instanceof BigDecimal) {
stmt.setBigDecimal(paramIndex, (BigDecimal) val);
} else if (val instanceof String) {
stmt.setString(paramIndex, (String) val);
} else if (val instanceof Date) {
long time = ((Date) val).getTime();
stmt.setTimestamp(paramIndex, new java.sql.Timestamp(time));
} else if (val instanceof Byte) {
stmt.setByte(paramIndex, (Byte) val);
} else if (val instanceof Short) {
stmt.setShort(paramIndex, (Short) val);
} else if (val instanceof Integer) {
stmt.setInt(paramIndex, (Integer) val);
} else if (val instanceof Long) {
stmt.setLong(paramIndex, (Long) val);
} else if (val instanceof Float) {
stmt.setFloat(paramIndex, (Float) val);
} else if (val instanceof Double) {
stmt.setDouble(paramIndex, (Double) val);
throw new DruidMappingException("not support parameters : " + val);
private DataSource                    dataSource;
public DataSource getDataSource() {
return dataSource;
public void setDataSource(DataSource dataSource) {
this.dataSource = dataSource;
public Connection getConnection() throws SQLException {
return this.dataSource.getConnection();
public List<Map<String, Object>> select(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return select(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public int delete(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return delete(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public int update(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return update(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public void insert(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
insert(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
private DataSource                    dataSource;
public DataSource getDataSource() {
return dataSource;
public void setDataSource(DataSource dataSource) {
this.dataSource = dataSource;
public Connection getConnection() throws SQLException {
if (dataSource == null) {
throw new SQLException("datasource not init.");
return this.dataSource.getConnection();
public List<Map<String, Object>> select(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return select(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public int delete(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return delete(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public int update(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
return update(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
public void insert(String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = getConnection();
insert(conn, sql, parameters);
} finally {
JdbcUtils.close(conn);
ObjectName objectName = new ObjectName(MBEAN_NAME);
if (!mbeanServer.isRegistered(objectName)) {
mbeanServer.registerMBean(instance, objectName);
private final AtomicLong                                        connectCount           = new AtomicLong(0);
private final static String                                     MBEAN_NAME               = "com.alibaba.druid:type=DruidDriver";
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
ObjectName objectName = new ObjectName(MBEAN_NAME);
if (!mbeanServer.isRegistered(objectName)) {
mbeanServer.registerMBean(instance, objectName);
} catch (Exception ex) {
LOG.error("register druid-driver mbean error", ex);
connectCount.incrementAndGet();
return connectCount.get();
public void resetStat() {
connectCount.set(0);
void resetStat();
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion;
public String getDruidVersion() {
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion;
String getDruidVersion();
public Entity getFirstEntity() {
for (Map.Entry<String, Entity> entry : entities.entrySet()) {
return entry.getValue();
return null;
public String explainToDeleteSQL(String sql) {
return new OracleOutputVisitor(out, false);
OracleDeleteStatement stmt = parser.parseDeleteStatement();
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableName(new SQLIdentifierExpr(entity.getName()));
return stmt;
public boolean visit(OracleDeleteStatement x) {
return true;
private static final long    serialVersionUID = 1L;
protected SQLExprTableSource tableSource;
protected SQLExpr            where;
private String               alias;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
return (SQLName) tableSource.getExpr();
this.tableSource = new SQLExprTableSource(tableName);
public void setTableName(String name) {
setTableName(new SQLIdentifierExpr(name));
acceptChild(visitor, tableSource);
if (lexer.token() == Token.SELECT) {
if (lexer.token() == (Token.DISTINCT)) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
} else if (identifierEquals("DISTINCTROW")) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCTROW);
lexer.nextToken();
} else if (lexer.token() == (Token.ALL)) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
if (identifierEquals("HIGH_PRIORITY")) {
queryBlock.setHignPriority(true);
lexer.nextToken();
if (identifierEquals("STRAIGHT_JOIN")) {
queryBlock.setStraightJoin(true);
lexer.nextToken();
if (identifierEquals("SQL_SMALL_RESULT")) {
queryBlock.setSmallResult(true);
lexer.nextToken();
if (identifierEquals("SQL_BIG_RESULT")) {
queryBlock.setBigResult(true);
lexer.nextToken();
if (identifierEquals("SQL_BUFFER_RESULT")) {
queryBlock.setBufferResult(true);
lexer.nextToken();
if (identifierEquals("SQL_CACHE")) {
queryBlock.setCache(true);
lexer.nextToken();
if (identifierEquals("SQL_NO_CACHE")) {
queryBlock.setCache(false);
lexer.nextToken();
if (identifierEquals("SQL_CALC_FOUND_ROWS")) {
queryBlock.setCalcFoundRows(true);
lexer.nextToken();
parseSelectList(queryBlock);
if (lexer.token() == (Token.INTO)) {
acceptIdentifier("OUTFILE");
SQLExpr outFile = expr();
queryBlock.setOutFile(outFile);
if (identifierEquals("FIELDS") || identifierEquals("COLUMNS")) {
if (identifierEquals("TERMINATED")) {
lexer.nextToken();
accept(Token.BY);
queryBlock.setOutFileColumnsTerminatedBy((SQLLiteralExpr) expr());
if (identifierEquals("OPTIONALLY")) {
lexer.nextToken();
queryBlock.setOutFileColumnsEnclosedOptionally(true);
if (identifierEquals("ENCLOSED")) {
lexer.nextToken();
accept(Token.BY);
queryBlock.setOutFileColumnsEnclosedBy((SQLLiteralExpr) expr());
if (identifierEquals("ESCAPED")) {
lexer.nextToken();
accept(Token.BY);
queryBlock.setOutFileColumnsEscaped((SQLLiteralExpr) expr());
if (identifierEquals("LINES")) {
if (identifierEquals("STARTING")) {
lexer.nextToken();
accept(Token.BY);
queryBlock.setOutFileLinesStartingBy((SQLLiteralExpr) expr());
identifierEquals("TERMINATED");
lexer.nextToken();
accept(Token.BY);
queryBlock.setOutFileLinesTerminatedBy((SQLLiteralExpr) expr());
if (lexer.token() == Token.DELETE) {
if (identifierEquals("LOW_PRIORITY")) {
deleteStatement.setLowPriority(true);
lexer.nextToken();
if (identifierEquals("QUICK")) {
deleteStatement.setQuick(true);
if (identifierEquals("IGNORE")) {
deleteStatement.setIgnore(true);
if (lexer.token() == Token.IDENTIFIER) {
exprParser.names(deleteStatement.getTableNames());
if (lexer.token() == Token.FROM) {
lexer.nextToken();
SQLTableSource tableSource = createSQLSelectParser().parseTableSource();
deleteStatement.setFrom(tableSource);
if (lexer.token() == Token.FROM) {
lexer.nextToken();
exprParser.names(deleteStatement.getTableNames());
if (identifierEquals("USING")) {
lexer.nextToken();
SQLTableSource tableSource = createSQLSelectParser().parseTableSource();
deleteStatement.setUsing(tableSource);
acceptChild(visitor, this.tableSource);
} else if (identifierEquals("SKIP")) {
if (lexer.token() == Token.SELECT) {
parseHints(queryBlock);
if (lexer.token() == (Token.DISTINCT)) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
} else if (lexer.token() == (Token.UNIQUE)) {
queryBlock.setDistionOption(SQLSetQuantifier.UNIQUE);
lexer.nextToken();
} else if (lexer.token() == (Token.ALL)) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
this.createExprParser().parseHints(queryBlock.getHints());
parseSelectList(queryBlock);
if (lexer.token() == Token.OUTER) {
if (lexer.token() == Token.OUTER) {
if (lexer.token() == Token.FULL) {
if (lexer.token() == Token.OUTER) {
if (lexer.token() == Token.DELETE) {
this.createExprParser().parseHints(deleteStatement.getHints());
if (lexer.token() == (Token.FROM)) {
lexer.nextToken();
if (identifierEquals("ONLY")) {
lexer.nextToken();
accept(Token.LPAREN);
SQLName tableName = exprParser.name();
deleteStatement.setTableName(tableName);
accept(Token.RPAREN);
SQLName tableName = exprParser.name();
deleteStatement.setTableName(tableName);
deleteStatement.setAlias(as());
private final boolean printPostSemi;
this(appender, true);
public OracleOutputVisitor(Appendable appender, boolean printPostSemi){
this.printPostSemi = printPostSemi;
public boolean isPrintPostSemi() {
return printPostSemi;
if (!printPostSemi) {
if (x.getTableName() != null) {
print("DELETE ");
printHints(x.getHints());
print("FROM ");
if (x.isOnly()) {
print("ONLY (");
x.getTableName().accept(this);
print(")");
x.getTableName().accept(this);
printAlias(x.getAlias());
print(" WAIT");
print(" IMMEDIATE");
acceptChild(visitor, tableSource);
public class MappingVisitorOracleTest extends TestCase {
MappingEngine engine = new MappingEngine(new OracleMappingProvider());
protected void setUp() throws Exception {
Entity entity = new Entity();
entity.setName("");
entity.setDescription("Device");
entity.setTableName("device");
entity.addProperty(new Property("", "", "serviceTag"));
entity.addProperty(new Property("IP", "", "ip"));
engine.addEntity(entity);
public void test_0() throws Exception {
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM device",
engine.explainToSelectSQL("select *"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("select , IP WHERE IP = '127.0.0.1'"));
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("WHERE IP = '127.0.0.1'"));
public void test_delete() throws Exception {
Assert.assertEquals("DELETE FROM devicenWHERE ip = '127.0.0.1'",
engine.explainToDeleteSQL("WHERE IP = '127.0.0.1'"));
MySqlDeleteStatement stmt = parser.parseDeleteStatement();
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableName(new SQLIdentifierExpr(entity.getName()));
return stmt;
private final List<SQLExprTableSource> tableSources       = new ArrayList<SQLExprTableSource>();
if (tableSources.size() == 0) {
return (SQLName) tableSources.get(0).getExpr();
SQLExprTableSource tableSource = new SQLExprTableSource(tableName);
if (tableSources.size() == 0) {
tableSources.add(tableSource);
tableSources.set(0, tableSource);
public List<SQLExprTableSource> getTableSources() {
return tableSources;
acceptChild(visitor, getTableSources());
for (;;) {
SQLName name = exprParser.name();
deleteStatement.getTableSources().add(new SQLExprTableSource(name));
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
for (;;) {
SQLName name = exprParser.name();
deleteStatement.getTableSources().add(new SQLExprTableSource(name));
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
printAndAccept(x.getTableSources(), ", ");
printAndAccept(x.getTableSources(), ", ");
if (x.getTableSources().size() == 1) {
SQLName tableName = (SQLName) x.getTableSources().get(0).getExpr();
String ident = tableName.toString();
for (SQLExprTableSource tableSource : x.getTableSources()) {
SQLExpr tableName = tableSource.getExpr();
Assert.assertEquals("SELECT serviceTag AS "", ip AS "IP"nFROM devicenWHERE ip = '127.0.0.1'",
engine.explainToSelectSQL("WHERE IP = '127.0.0.1'"));
public void test_delete() throws Exception {
Assert.assertEquals("DELETE FROM devicenWHERE ip = '127.0.0.1'",
engine.explainToDeleteSQL("WHERE IP = '127.0.0.1'"));
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
SQLUpdateStatement stmt = parser.parseUpdateStatement();
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
return stmt;
public void setTableSource(SQLExpr expr) {
this.setTableSource(new SQLExprTableSource(expr));
this.setTableSource(new SQLExprTableSource(tableName));
public void setTableSource(SQLExpr expr) {
this.setTableSource(new SQLExprTableSource(expr));
public void setTableSource(SQLExprTableSource tableSource) {
if (lexer.token() == Token.UPDATE) {
lexer.nextToken();
SQLTableSource tableSource = this.exprParser.createSelectParser().parseTableSource();
udpateStatement.setTableSource(tableSource);
println();
print("SET ");
println();
print("WHERE ");
public void test_update() throws Exception {
Assert.assertEquals("UPDATE devicenSET serviceTag = ?nWHERE ip = '127.0.0.1'",
engine.explainToUpdateSQL("SET  = ? WHERE IP = '127.0.0.1'"));
SQLInsertStatement stmt = (SQLInsertStatement) parser.parseInsert();
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
return stmt;
protected SQLExprTableSource  tableSource;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
return (SQLName) tableSource.getExpr();
this.setTableSource(new SQLExprTableSource(tableName));
public void setTableSource(SQLName tableName) {
this.setTableSource(new SQLExprTableSource(tableName));
this.acceptChild(visitor, tableSource);
this.acceptChild(visitor, getTableSource());
if (lexer.token() == Token.INSERT) {
if (identifierEquals("LOW_PRIORITY")) {
insertStatement.setLowPriority(true);
lexer.nextToken();
if (identifierEquals("DELAYED")) {
insertStatement.setDelayed(true);
lexer.nextToken();
if (identifierEquals("HIGH_PRIORITY")) {
insertStatement.setHighPriority(true);
lexer.nextToken();
if (identifierEquals("IGNORE")) {
insertStatement.setIgnore(true);
lexer.nextToken();
if (lexer.token() == Token.INTO) {
lexer.nextToken();
SQLName tableName = this.exprParser.name();
insertStatement.setTableName(tableName);
if (lexer.token() == Token.IDENTIFIER) {
insertStatement.setAlias(lexer.stringVal());
lexer.nextToken();
this.acceptChild(visitor, tableSource);
this.acceptChild(visitor, tableSource);
this.acceptChild(visitor, tableSource);
public void test_insert() throws Exception {
Assert.assertEquals("INSERT INTO devicen(serviceTag, ip)nVALUESn(?, ?)",
engine.explainToInsertSQL("(, IP) VALUES (?, ?)"));
public static void setDataSource(MappingEngine engine, SQLDeleteStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
public static void setDataSource(MappingEngine engine, SQLUpdateStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
public static void setDataSource(MappingEngine engine, SQLInsertStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
SQLUpdateStatement stmt = parser.parseUpdateStatement();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
SQLInsertStatement stmt = (SQLInsertStatement) parser.parseInsert();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
incrementIndent();
decrementIndent();
if (lexer.token() == Token.LPAREN) {
OracleInsertStatement stmt = new OracleInsertStatement();
parseInsert0(stmt, false);
stmt.setReturning(parseReturningClause());
stmt.setErrorLogging(parseErrorLoggingClause());
return stmt;
if (lexer.token() == Token.UPDATE) {
lexer.nextToken();
parseHints(update);
if (identifierEquals("ONLY")) {
update.setOnly(true);
SQLTableSource tableSource = this.exprParser.createSelectParser().parseTableSource();
update.setTableSource(tableSource);
if ((update.getAlias() == null) || (update.getAlias().length() == 0)) {
update.setAlias(as());
public OracleParameterizedOutputVisitor(Appendable appender, boolean printPostSemi){
super (appender, printPostSemi);
if (lexer.token() == Token.INSERT) {
accept(Token.INTO);
SQLName tableName = this.exprParser.name();
stmt.setTableName(tableName);
if (lexer.token() == Token.IDENTIFIER) {
stmt.setAlias(lexer.stringVal());
lexer.nextToken();
public PGSelectParser(Lexer lexer){
super(lexer);
public PGSelectParser(String sql) throws ParserException{
this(new PGLexer(sql));
this.lexer.nextToken();
public SQLSelectQuery query() throws ParserException {
PGSelectQueryBlock queryBlock = new PGSelectQueryBlock();
if (lexer.token() == Token.SELECT) {
lexer.nextToken();
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
if (lexer.token() == Token.ON) {
lexer.nextToken();
for (;;) {
SQLExpr expr = this.createExprParser().expr();
queryBlock.getDistinctOn().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
parseSelectList(queryBlock);
if (lexer.token() == Token.INTO) {
IntoClause into = new IntoClause();
lexer.nextToken();
if (lexer.token() == Token.TEMPORARY) {
lexer.nextToken();
into.setOption(IntoClause.Option.TEMPORARY);
} else if (lexer.token() == Token.TEMP) {
lexer.nextToken();
into.setOption(IntoClause.Option.TEMP);
} else if (lexer.token() == Token.UNLOGGED) {
lexer.nextToken();
into.setOption(IntoClause.Option.UNLOGGED);
if (lexer.token() == Token.TABLE) {
lexer.nextToken();
SQLExpr name = this.createExprParser().name();
into.setTable(name);
queryBlock.setInto(into);
parseFrom(queryBlock);
parseWhere(queryBlock);
parseGroupBy(queryBlock);
if (lexer.token() == Token.WINDOW) {
lexer.nextToken();
PGSelectQueryBlock.WindowClause window = new PGSelectQueryBlock.WindowClause();
window.setName(this.expr());
accept(Token.AS);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
window.getDefinition().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
queryBlock.setWindow(window);
queryBlock.setOrderBy(this.createExprParser().parseOrderBy());
if (lexer.token() == Token.LIMIT) {
lexer.nextToken();
if (lexer.token() == Token.ALL) {
queryBlock.setLimit(new SQLIdentifierExpr("ALL"));
lexer.nextToken();
SQLExpr limit = expr();
queryBlock.setLimit(limit);
if (lexer.token() == Token.OFFSET) {
lexer.nextToken();
SQLExpr offset = expr();
queryBlock.setOffset(offset);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.FETCH) {
lexer.nextToken();
PGSelectQueryBlock.FetchClause fetch = new PGSelectQueryBlock.FetchClause();
if (lexer.token() == Token.FIRST) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.FIRST);
} else if (lexer.token() == Token.NEXT) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.NEXT);
throw new ParserException("expect 'FIRST' or 'NEXT'");
SQLExpr count = expr();
fetch.setCount(count);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.ONLY) {
lexer.nextToken();
throw new ParserException("expect 'ONLY'");
queryBlock.setFetch(fetch);
if (lexer.token() == Token.FOR) {
lexer.nextToken();
PGSelectQueryBlock.ForClause forClause = new PGSelectQueryBlock.ForClause();
if (lexer.token() == Token.UPDATE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.UPDATE);
} else if (lexer.token() == Token.SHARE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.SHARE);
throw new ParserException("expect 'FIRST' or 'NEXT'");
accept(Token.OF);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
forClause.getOf().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
if (lexer.token() == Token.NOWAIT) {
lexer.nextToken();
forClause.setNoWait(true);
queryBlock.setForClause(forClause);
return queryRest(queryBlock);
if (lexer.token() == Token.INTO) {
lexer.nextToken();
SQLName tableName = this.exprParser.name();
insertStatement.setTableName(tableName);
if (lexer.token() == Token.LITERAL_ALIAS) {
insertStatement.setAlias(as());
parseInsert0_hinits(insertStatement);
if (lexer.token() == Token.IDENTIFIER) {
insertStatement.setAlias(lexer.stringVal());
lexer.nextToken();
print("VALUES");
println();
public void test_update() throws Exception {
Assert.assertEquals("UPDATE devicenSET serviceTag = ?nWHERE ip = '127.0.0.1'",
engine.explainToUpdateSQL("SET  = ? WHERE IP = '127.0.0.1'"));
public void test_insert() throws Exception {
Assert.assertEquals("INSERT INTO devicent(serviceTag, ip)nVALUESn(?, ?)",
engine.explainToInsertSQL("(, IP) VALUES (?, ?)"));
Assert.assertEquals("INSERT INTO devicent(serviceTag, ip)nVALUESn(?, ?)",
Assert.assertEquals("UPDATE t1nSET c1 = 2nWHERE c1 = (@var1 := 1);", text);
Assert.assertEquals("UPDATE tnSET i = DEFAULT(i) + 1nWHERE id < 100;", text);
validate("SELECT * FROM T WHERE ID IN (?, ?, ?)", "SELECT *nFROM TnWHERE ID IN (?)");
validate("SELECT * FROM T WHERE ID = 5", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE 1 = 0 AND ID = 5", "SELECT *nFROM TnWHERE 1 = 0nAND ID = ?");
validate("SELECT * FROM T WHERE ID = ? OR ID = ?", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
"SELECT *nFROM TnWHERE 1 = 0nOR a.id = ?");
"SELECT *nFROM TnWHERE 1 = 0nOR a.id = ?");
validateOracle("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
"UPDATE net_device d, sys_user unSET d.resp_user_id = u.idnWHERE d.resp_user_login_name = u.usernamenAND d.id IN (?)");
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out, false);
validate(sql, "SELECT *nFROM TnWHERE ID = ?");
validateOracle(sql, "SELECT *nFROM TnWHERE ID = ?");
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out, false);
Assert.assertEquals("UPDATE tnSET blob_col = LOAD_FILE('/tmp/picture')nWHERE id = 1;", text);
public static void setDataSource(MappingEngine engine, SQLDeleteStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
public static void setDataSource(MappingEngine engine, SQLUpdateStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
public static void setDataSource(MappingEngine engine, SQLInsertStatement stmt) {
if (stmt.getTableSource() == null) {
Entity entity = engine.getFirstEntity();
stmt.setTableSource(new SQLIdentifierExpr(entity.getName()));
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
MappingVisitorUtils.setDataSource(engine, stmt);
SQLUpdateStatement stmt = parser.parseUpdateStatement();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
SQLInsertStatement stmt = (SQLInsertStatement) parser.parseInsert();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
incrementIndent();
decrementIndent();
if (lexer.token() == Token.LPAREN) {
OracleInsertStatement stmt = new OracleInsertStatement();
parseInsert0(stmt, false);
stmt.setReturning(parseReturningClause());
stmt.setErrorLogging(parseErrorLoggingClause());
return stmt;
if (lexer.token() == Token.UPDATE) {
lexer.nextToken();
parseHints(update);
if (identifierEquals("ONLY")) {
update.setOnly(true);
SQLTableSource tableSource = this.exprParser.createSelectParser().parseTableSource();
update.setTableSource(tableSource);
if ((update.getAlias() == null) || (update.getAlias().length() == 0)) {
update.setAlias(as());
public OracleParameterizedOutputVisitor(Appendable appender, boolean printPostSemi){
super (appender, printPostSemi);
if (lexer.token() == Token.INSERT) {
accept(Token.INTO);
SQLName tableName = this.exprParser.name();
stmt.setTableName(tableName);
if (lexer.token() == Token.IDENTIFIER) {
stmt.setAlias(lexer.stringVal());
lexer.nextToken();
public PGSelectParser(Lexer lexer){
super(lexer);
public PGSelectParser(String sql) throws ParserException{
this(new PGLexer(sql));
this.lexer.nextToken();
public SQLSelectQuery query() throws ParserException {
PGSelectQueryBlock queryBlock = new PGSelectQueryBlock();
if (lexer.token() == Token.SELECT) {
lexer.nextToken();
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
if (lexer.token() == Token.ON) {
lexer.nextToken();
for (;;) {
SQLExpr expr = this.createExprParser().expr();
queryBlock.getDistinctOn().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
parseSelectList(queryBlock);
if (lexer.token() == Token.INTO) {
IntoClause into = new IntoClause();
lexer.nextToken();
if (lexer.token() == Token.TEMPORARY) {
lexer.nextToken();
into.setOption(IntoClause.Option.TEMPORARY);
} else if (lexer.token() == Token.TEMP) {
lexer.nextToken();
into.setOption(IntoClause.Option.TEMP);
} else if (lexer.token() == Token.UNLOGGED) {
lexer.nextToken();
into.setOption(IntoClause.Option.UNLOGGED);
if (lexer.token() == Token.TABLE) {
lexer.nextToken();
SQLExpr name = this.createExprParser().name();
into.setTable(name);
queryBlock.setInto(into);
parseFrom(queryBlock);
parseWhere(queryBlock);
parseGroupBy(queryBlock);
if (lexer.token() == Token.WINDOW) {
lexer.nextToken();
PGSelectQueryBlock.WindowClause window = new PGSelectQueryBlock.WindowClause();
window.setName(this.expr());
accept(Token.AS);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
window.getDefinition().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
queryBlock.setWindow(window);
queryBlock.setOrderBy(this.createExprParser().parseOrderBy());
if (lexer.token() == Token.LIMIT) {
lexer.nextToken();
if (lexer.token() == Token.ALL) {
queryBlock.setLimit(new SQLIdentifierExpr("ALL"));
lexer.nextToken();
SQLExpr limit = expr();
queryBlock.setLimit(limit);
if (lexer.token() == Token.OFFSET) {
lexer.nextToken();
SQLExpr offset = expr();
queryBlock.setOffset(offset);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.FETCH) {
lexer.nextToken();
PGSelectQueryBlock.FetchClause fetch = new PGSelectQueryBlock.FetchClause();
if (lexer.token() == Token.FIRST) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.FIRST);
} else if (lexer.token() == Token.NEXT) {
fetch.setOption(PGSelectQueryBlock.FetchClause.Option.NEXT);
throw new ParserException("expect 'FIRST' or 'NEXT'");
SQLExpr count = expr();
fetch.setCount(count);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
throw new ParserException("expect 'ROW' or 'ROWS'");
if (lexer.token() == Token.ONLY) {
lexer.nextToken();
throw new ParserException("expect 'ONLY'");
queryBlock.setFetch(fetch);
if (lexer.token() == Token.FOR) {
lexer.nextToken();
PGSelectQueryBlock.ForClause forClause = new PGSelectQueryBlock.ForClause();
if (lexer.token() == Token.UPDATE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.UPDATE);
} else if (lexer.token() == Token.SHARE) {
forClause.setOption(PGSelectQueryBlock.ForClause.Option.SHARE);
throw new ParserException("expect 'FIRST' or 'NEXT'");
accept(Token.OF);
for (;;) {
SQLExpr expr = this.createExprParser().expr();
forClause.getOf().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
if (lexer.token() == Token.NOWAIT) {
lexer.nextToken();
forClause.setNoWait(true);
queryBlock.setForClause(forClause);
return queryRest(queryBlock);
if (lexer.token() == Token.SELECT) {
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
if (lexer.token() == Token.TOP) {
Top top = new Top();
lexer.nextToken();
top.setExpr(createExprParser().primary());
queryBlock.setTop(top);
parseSelectList(queryBlock);
if (lexer.token() == Token.INSERT) {
accept(Token.INSERT);
if (lexer.token() == Token.INTO) {
lexer.nextToken();
SQLName tableName = this.exprParser.name();
insertStatement.setTableName(tableName);
if (lexer.token() == Token.LITERAL_ALIAS) {
insertStatement.setAlias(as());
parseInsert0_hinits(insertStatement);
if (lexer.token() == Token.IDENTIFIER) {
insertStatement.setAlias(lexer.stringVal());
lexer.nextToken();
SQLDeleteStatement deleteStatement = new SQLDeleteStatement();
if (lexer.token() == Token.DELETE) {
if (lexer.token() == (Token.FROM)) {
lexer.nextToken();
SQLName tableName = exprParser.name();
deleteStatement.setTableName(tableName);
print("VALUES");
println();
public void test_update() throws Exception {
Assert.assertEquals("UPDATE devicenSET serviceTag = ?nWHERE ip = '127.0.0.1'",
engine.explainToUpdateSQL("SET  = ? WHERE IP = '127.0.0.1'"));
public void test_insert() throws Exception {
Assert.assertEquals("INSERT INTO devicent(serviceTag, ip)nVALUESn(?, ?)",
engine.explainToInsertSQL("(, IP) VALUES (?, ?)"));
Assert.assertEquals("INSERT INTO devicent(serviceTag, ip)nVALUESn(?, ?)",
Assert.assertEquals("UPDATE t1nSET c1 = 2nWHERE c1 = (@var1 := 1);", text);
Assert.assertEquals("UPDATE tnSET i = DEFAULT(i) + 1nWHERE id < 100;", text);
validate("SELECT * FROM T WHERE ID IN (?, ?, ?)", "SELECT *nFROM TnWHERE ID IN (?)");
validate("SELECT * FROM T WHERE ID = 5", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE 1 = 0 AND ID = 5", "SELECT *nFROM TnWHERE 1 = 0nAND ID = ?");
validate("SELECT * FROM T WHERE ID = ? OR ID = ?", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
"SELECT *nFROM TnWHERE 1 = 0nOR a.id = ?");
"SELECT *nFROM TnWHERE 1 = 0nOR a.id = ?");
validateOracle("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
"UPDATE net_device d, sys_user unSET d.resp_user_id = u.idnWHERE d.resp_user_login_name = u.usernamenAND d.id IN (?)");
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out, false);
validate(sql, "SELECT *nFROM TnWHERE ID = ?");
validateOracle(sql, "SELECT *nFROM TnWHERE ID = ?");
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out, false);
Assert.assertEquals("UPDATE tnSET blob_col = LOAD_FILE('/tmp/picture')nWHERE id = 1;", text);
SQLDeleteStatement stmt = parser.parseDeleteStatement();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
SQLUpdateStatement stmt = parser.parseUpdateStatement();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
SQLInsertStatement stmt = (SQLInsertStatement) parser.parseInsert();
MappingVisitorUtils.setDataSource(engine, stmt);
return stmt;
public static String formatMySql(String sql) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
for (SQLStatement stmt : statementList) {
stmt.accept(visitor);
return out.toString();
public static String formatOracle(String sql) {
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
StringBuilder out = new StringBuilder();
OracleOutputVisitor visitor;
if (statementList.size() == 1) {
visitor = new OracleOutputVisitor(out, false);
visitor = new OracleOutputVisitor(out, true);
for (SQLStatement stmt : statementList) {
stmt.accept(visitor);
return out.toString();
public static String formatPGSql(String sql) {
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
StringBuilder out = new StringBuilder();
PGOutputVisitor visitor = new PGOutputVisitor(out);
for (SQLStatement stmt : statementList) {
stmt.accept(visitor);
return out.toString();
public class OracleWallVisitor extends OracleASTVIsitorAdapter implements WallVisitor {
public class WallFilter extends FilterAdapter {
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql)
throws SQLException {
return chain.connection_prepareStatement(connection, sql);
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int autoGeneratedKeys) throws SQLException {
return chain.connection_prepareStatement(connection, sql, autoGeneratedKeys);
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType, int resultSetConcurrency)
throws SQLException {
return chain.connection_prepareStatement(connection, sql, resultSetType, resultSetConcurrency);
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
return chain.connection_prepareStatement(connection, sql, resultSetType, resultSetConcurrency,
resultSetHoldability);
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int[] columnIndexes) throws SQLException {
return chain.connection_prepareStatement(connection, sql, columnIndexes);
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, String[] columnNames) throws SQLException {
return chain.connection_prepareStatement(connection, sql, columnNames);
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql)
throws SQLException {
return chain.connection_prepareCall(connection, sql);
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
int resultSetType, int resultSetConcurrency)
throws SQLException {
return chain.connection_prepareCall(connection, sql, resultSetType, resultSetConcurrency);
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
return chain.connection_prepareCall(connection, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
public SQLASTVisitor createWallVisitor(String dbType) throws SQLException {
throw new SQLException("dbType not support : " + dbType);
public SQLStatementParser createParser(String dbType, String sql) throws SQLException {
if (JdbcUtils.ORACLE.equals(dbType)) {
return new OracleStatementParser(sql);
if (JdbcUtils.MYSQL.equals(dbType)) {
return new MySqlStatementParser(sql);
if (JdbcUtils.POSTGRESQL.equals(dbType)) {
return new PGSQLStatementParser(sql);
if (JdbcUtils.SQL_SERVER.equals(dbType)) {
return new SQLServerStatementParser(sql);
throw new SQLException("dbType not support : " + dbType);
public interface WallVisitor extends SQLASTVisitor {
public static final String      HSQL             = "hsql";
public static final String      DB2              = "db2";
public static final String      POSTGRESQL       = "postgresql";
public static final String      SYBASE           = "sybase";
public static final String      SQL_SERVER       = "sqlserver";
public static final String      ORACLE           = "oracle";
public static final String      MYSQL            = "mysql";
public static final String      DERBY            = "derby";
return DERBY;
return MYSQL;
return ORACLE;
return SQL_SERVER;
return SYBASE;
return POSTGRESQL;
return HSQL;
return DB2;
public class IllegalConditionViolation implements Violation {
private String condition;
public IllegalConditionViolation(){
public IllegalConditionViolation(String condition){
this.condition = condition;
public String getCondition() {
return condition;
public void setCondition(String condition) {
this.condition = condition;
private final List<Violation> violations;
public OracleWallVisitor(){
this(new ArrayList<Violation>());
public OracleWallVisitor(List<Violation> violations){
this.violations = violations;
public List<Violation> getViolations() {
return violations;
public boolean visit(SQLBinaryOpExpr x) {
WallVisitorUtils.check(this, x);
return true;
public interface Violation {
public ConnectionProxy connection_connect(FilterChain chain, Properties info) throws SQLException {
return chain.connection_connect(info);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
public void check(ConnectionProxy connection, String sql) throws SQLException {
String dbType = connection.getDirectDataSource().getDbType();
SQLStatementParser parser = createParser(dbType, sql);
List<SQLStatement> statementList = parser.parseStatementList();
if (statementList.size() > 1) {
throw new SQLException("multi-statement : " + sql);
SQLStatement stmt = statementList.get(0);
SQLASTVisitor visitor = createWallVisitor(dbType);
stmt.accept(visitor);
List<Violation> getViolations();
public class WallVisitorUtils {
public static void check(WallVisitor visitor, SQLBinaryOpExpr x) {
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr) {
if (x.getOperator() == SQLBinaryOperator.Equality) {
String leftLiteral = SQLUtils.toOracleString(x.getLeft());
String rightLiteral = SQLUtils.toOracleString(x.getRight());
if (leftLiteral.equalsIgnoreCase(rightLiteral)) {
visitor.getViolations().add(new IllegalConditionViolation(SQLUtils.toOracleString(x)));
} else if (x.getOperator() == SQLBinaryOperator.NotEqual) {
String leftLiteral = SQLUtils.toOracleString(x.getLeft());
String rightLiteral = SQLUtils.toOracleString(x.getRight());
if (!leftLiteral.equalsIgnoreCase(rightLiteral)) {
visitor.getViolations().add(new IllegalConditionViolation(SQLUtils.toOracleString(x)));
public class IllegalConditionViolation implements Violation {
private String condition;
public IllegalConditionViolation(){
public IllegalConditionViolation(String condition){
this.condition = condition;
public String getCondition() {
return condition;
public void setCondition(String condition) {
this.condition = condition;
public class IllegalStatementViolation implements Violation {
private String condition;
public IllegalStatementViolation(){
public IllegalStatementViolation(String condition){
this.condition = condition;
public String getCondition() {
return condition;
public void setCondition(String condition) {
this.condition = condition;
public class MySqlWallVisitor extends MySqlASTVisitorAdapter {
private final List<Violation> violations;
public MySqlWallVisitor() {
this(new ArrayList<Violation>());
public MySqlWallVisitor(List<Violation> violations) {
this.violations = violations;
public List<Violation> getViolations() {
return violations;
public boolean visit(MySqlExecuteStatement x) {
return false;
private final List<Violation> violations;
public OracleWallVisitor(){
this(new ArrayList<Violation>());
public OracleWallVisitor(List<Violation> violations){
this.violations = violations;
public List<Violation> getViolations() {
return violations;
public boolean visit(SQLBinaryOpExpr x) {
WallVisitorUtils.check(this, x);
return true;
public interface Violation {
public ConnectionProxy connection_connect(FilterChain chain, Properties info) throws SQLException {
return chain.connection_connect(info);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
check(connection, sql);
public void check(ConnectionProxy connection, String sql) throws SQLException {
String dbType = connection.getDirectDataSource().getDbType();
SQLStatementParser parser = createParser(dbType, sql);
List<SQLStatement> statementList = parser.parseStatementList();
if (statementList.size() > 1) {
throw new SQLException("multi-statement : " + sql);
SQLStatement stmt = statementList.get(0);
SQLASTVisitor visitor = createWallVisitor(dbType);
stmt.accept(visitor);
List<Violation> getViolations();
public class WallVisitorUtils {
public static void check(WallVisitor visitor, SQLBinaryOpExpr x) {
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr) {
if (x.getOperator() == SQLBinaryOperator.Equality) {
String leftLiteral = SQLUtils.toOracleString(x.getLeft());
String rightLiteral = SQLUtils.toOracleString(x.getRight());
if (leftLiteral.equalsIgnoreCase(rightLiteral)) {
visitor.getViolations().add(new IllegalConditionViolation(SQLUtils.toOracleString(x)));
} else if (x.getOperator() == SQLBinaryOperator.NotEqual) {
String leftLiteral = SQLUtils.toOracleString(x.getLeft());
String rightLiteral = SQLUtils.toOracleString(x.getRight());
if (!leftLiteral.equalsIgnoreCase(rightLiteral)) {
visitor.getViolations().add(new IllegalConditionViolation(SQLUtils.toOracleString(x)));
public class MySqlWallVisitor extends MySqlASTVisitorAdapter implements WallVisitor {
public boolean visit(SQLBinaryOpExpr x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(SQLSelectQueryBlock x) {
if (x.getWhere() != null) {
x.getWhere().setParent(x);
return true;
public boolean visit(MySqlSelectQueryBlock x) {
return visit((SQLSelectQueryBlock) x);
if (Boolean.TRUE == getObject(x)) {
visitor.getViolations().add(new IllegalConditionViolation(SQLUtils.toSQLString(x)));
public static Object getObject(SQLBinaryOpExpr x) {
return leftLiteral.equalsIgnoreCase(rightLiteral);
if (x.getOperator() == SQLBinaryOperator.NotEqual || x.getOperator() == SQLBinaryOperator.LessThanOrGreater) {
String leftLiteral = SQLUtils.toSQLString(x.getLeft());
String rightLiteral = SQLUtils.toSQLString(x.getRight());
return !leftLiteral.equalsIgnoreCase(rightLiteral);
if (x.getOperator() == SQLBinaryOperator.Like) {
if (x.getRight() instanceof SQLCharExpr) {
String text = ((SQLCharExpr) x.getRight()).getText();
if (text.length() >= 0) {
for (char ch : text.toCharArray()) {
if (ch != '%') {
return null;
return true;
x.getLeft().setParent(x);
x.getRight().setParent(x);
if (x.getOperator() == SQLBinaryOperator.BooleanOr) {
Object leftResult = getValue(x.getLeft());
Object rightResult = getValue(x.getRight());
if (Boolean.TRUE == leftResult || Boolean.TRUE == rightResult) {
return true;
if (x.getOperator() == SQLBinaryOperator.BooleanAnd) {
Object leftResult = getValue(x.getLeft());
Object rightResult = getValue(x.getRight());
if (Boolean.FALSE == leftResult || Boolean.FALSE == rightResult) {
return false;
if (Boolean.TRUE == leftResult && Boolean.TRUE == rightResult) {
return true;
return null;
public static Object getValue(SQLExpr x) {
if (x instanceof SQLBinaryOpExpr) {
return getObject((SQLBinaryOpExpr) x);
if (x instanceof MySqlBooleanExpr) {
return ((MySqlBooleanExpr) x).getValue();
if (x instanceof SQLNotExpr) {
Object result = getValue(((SQLNotExpr) x).getExpr());
if (result != null && result instanceof Boolean) {
return !((Boolean) result).booleanValue();
return null;
public static String toSQLString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new SQLASTOutputVisitor(out));
String sql = out.toString();
return sql;
public static SQLExpr toMySqlExpr(String sql) {
MySqlLexer lexer = new MySqlLexer(sql);
lexer.nextToken();
MySqlExprParser parser = new MySqlExprParser(lexer);
SQLExpr expr = parser.expr();
if (lexer.token() != Token.EOF) {
throw new ParserException("illegal sql expr : " + sql);
return expr;
public static SQLExpr toSQLExpr(String sql) {
MySqlLexer lexer = new MySqlLexer(sql);
lexer.nextToken();
SQLExprParser parser = new SQLExprParser(lexer);
SQLExpr expr = parser.expr();
if (lexer.token() != Token.EOF) {
throw new ParserException("illegal sql expr : " + sql);
return expr;
SQLExpr restExpr = expr();
public class WallVisitorUtilsTest extends TestCase {
public void test_isTrue() throws Exception {
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("1 != 2")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("1 != 2 AND 2 = 2")));
Assert.assertEquals(Boolean.FALSE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("1 != 2 AND 2 != 2")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("23 = 23")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("NOT 23 != 23")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("f1 like '%'")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("f1 like '%%'")));
Assert.assertEquals(null, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("a1 = b1 AND f1 like '%%'")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("a1 = b1 OR f1 like '%%'")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("1 < 2")));
violations.add(new IllegalStatementViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(MySqlShowTablesStatement x) {
violations.add(new IllegalStatementViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(MySqlShowDatabasesStatement x) {
violations.add(new IllegalStatementViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(MySqlShowColumnsStatement x) {
violations.add(new IllegalStatementViolation(SQLUtils.toMySqlString(x)));
@SuppressWarnings({ "unchecked", "rawtypes" })
x.getLeft().setParent(x);
x.getRight().setParent(x);
Object leftResult = getValue(x.getLeft());
Object rightResult = getValue(x.getRight());
if (x.getOperator() == SQLBinaryOperator.BooleanOr) {
if (Boolean.TRUE == leftResult || Boolean.TRUE == rightResult) {
return true;
if (x.getOperator() == SQLBinaryOperator.BooleanAnd) {
if (Boolean.FALSE == leftResult || Boolean.FALSE == rightResult) {
return false;
if (Boolean.TRUE == leftResult && Boolean.TRUE == rightResult) {
return true;
if (x.getOperator() == SQLBinaryOperator.Equality) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return true;
if (leftResult == null || rightResult == null) {
return null;
return leftResult.equals(rightResult);
if (x.getOperator() == SQLBinaryOperator.NotEqual || x.getOperator() == SQLBinaryOperator.LessThanOrGreater) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return false;
if (leftResult == null || rightResult == null) {
return null;
return !leftResult.equals(rightResult);
if (x.getOperator() == SQLBinaryOperator.GreaterThan) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return false;
if (leftResult == null || rightResult == null) {
return null;
if (leftResult instanceof Comparable) {
return (((Comparable) leftResult).compareTo(rightResult) > 0);
if (x.getOperator() == SQLBinaryOperator.GreaterThanOrEqual) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return false;
if (leftResult == null || rightResult == null) {
return null;
if (leftResult instanceof Comparable) {
return ((Comparable) leftResult).compareTo(rightResult) >= 0;
if (x.getOperator() == SQLBinaryOperator.LessThan) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return false;
if (leftResult == null || rightResult == null) {
return null;
if (leftResult instanceof Comparable) {
return (((Comparable) leftResult).compareTo(rightResult) < 0);
if (x.getOperator() == SQLBinaryOperator.LessThanOrEqual) {
if (x.getLeft() instanceof SQLNullExpr && x.getRight() instanceof SQLNullExpr) {
return false;
if (leftResult == null || rightResult == null) {
return null;
if (leftResult instanceof Comparable) {
return ((Comparable) leftResult).compareTo(rightResult) <= 0;
if (x instanceof SQLNumericLiteralExpr) {
return ((SQLNumericLiteralExpr) x).getNumber();
Lexer lexer = new Lexer(sql);
Assert.assertEquals(Boolean.FALSE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("2 < 2")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("2 <= 2")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("2 > 1")));
Assert.assertEquals(Boolean.FALSE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("2 > 2")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("2 >= 2")));
public boolean visit(SQLDropTableStatement x) {
violations.add(new IllegalStatementViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(SQLDropTableStatement x) {
violations.add(new IllegalStatementViolation(SQLUtils.toOracleString(x)));
return false;
if (x instanceof SQLQueryExpr) {
if (isSimpleCountTableSource(((SQLQueryExpr) x).getSubQuery())) {
return Integer.valueOf(1);
public static boolean isSimpleCountTableSource(SQLTableSource tableSource) {
if (!(tableSource instanceof SQLSubqueryTableSource)) {
return false;
SQLSubqueryTableSource subQuery = (SQLSubqueryTableSource) tableSource;
return isSimpleCountTableSource(subQuery.getSelect());
public static boolean isSimpleCountTableSource(SQLSelect select) {
SQLSelectQuery query = select.getQuery();
if (query instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) query;
boolean allawTrueWhere = queryBlock.getWhere() == null || getValue(queryBlock.getWhere()) == Boolean.TRUE;
boolean simpleCount = false;
if (queryBlock.getSelectList().size() == 1) {
SQLExpr selectItemExpr = queryBlock.getSelectList().get(0).getExpr();
if (selectItemExpr instanceof SQLAggregateExpr) {
if (((SQLAggregateExpr) selectItemExpr).getMethodName().equalsIgnoreCase("COUNT")) {
simpleCount = true;
if (allawTrueWhere && simpleCount) {
return true;
return false;
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("(select count(*) from t) > 0")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("(select count(*) from t) >= 0")));
if (Boolean.TRUE == getValue(x)) {
public static Object getValue(SQLBinaryOpExpr x) {
return getValue((SQLBinaryOpExpr) x);
if (x instanceof SQLCharExpr) {
return ((SQLCharExpr) x).getText();
if (x instanceof SQLNCharExpr) {
return ((SQLNCharExpr) x).getText();
if (x instanceof SQLMethodInvokeExpr) {
return getValue((SQLMethodInvokeExpr) x);
return null;
public static Object getValue(SQLMethodInvokeExpr x) {
String methodName = x.getMethodName();
if ("len".equalsIgnoreCase(methodName) || "length".equalsIgnoreCase(methodName)) {
Object firstValue = null;
if (x.getParameters().size() > 0) {
firstValue = (getValue(x.getParameters().get(0)));
if (firstValue instanceof String) {
return ((String) firstValue).length();
boolean allawTrueWhere = false;
if (queryBlock.getWhere() == null) {
allawTrueWhere = true;
Object whereValue = getValue(queryBlock.getWhere());
if (whereValue == Boolean.TRUE) {
allawTrueWhere = true;
} else if (whereValue == Boolean.FALSE) {
return false;
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("len('44') > 0")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("len('44') >= 2")));
notTarget = exprRest(notTarget);
sqlExpr = new SQLNotExpr(notTarget);
Assert.assertEquals(Boolean.FALSE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("(select count(*) from t) < 0")));
Assert.assertEquals(Boolean.TRUE, WallVisitorUtils.getValue(SQLUtils.toSQLExpr("NOT (select count(*) from t) < 0")));
private static final long          serialVersionUID = 1L;
protected List<SQLExprTableSource> tableSources     = new ArrayList<SQLExprTableSource>();
this(new SQLExprTableSource(name));
public SQLDropTableStatement(SQLExprTableSource tableSource){
this.tableSources.add(tableSource);
public List<SQLExprTableSource> getTableSources() {
return tableSources;
public void setTableSources(List<SQLExprTableSource> tableSources) {
this.tableSources = tableSources;
this.addTableSource(new SQLExprTableSource(name));
public void addTableSource(SQLName name) {
this.addTableSource(new SQLExprTableSource(name));
public void addTableSource(SQLExprTableSource tableSource) {
tableSources.add(tableSource);
this.acceptChild(visitor, tableSources);
this.acceptChild(visitor, tableSources);
stmt.addTableSource(name);
printAndAccept(x.getTableSources(), ", ");
stmt.getTableSources().add(new SQLExprTableSource(name));
printAndAccept(x.getTableSources(), ", ");
for (SQLExprTableSource tableSource : x.getTableSources()) {
SQLName name = (SQLName) tableSource.getExpr();
parser.getLexer().setAllowComment(false); 
protected final static ThreadLocal<char[]> sbufRef      = new ThreadLocal<char[]>();
protected SymbolTable                      symbolTable  = new SymbolTable();
protected Keywords                         keywods      = Keywords.DEFAULT_KEYWORDS;
protected boolean                          skipComment  = true;
private SavePoint                          savePoint    = null;
private boolean                            allowComment = true;
public boolean isAllowComment() {
return allowComment;
public void setAllowComment(boolean allowComment) {
this.allowComment = allowComment;
if (!allowComment) {
throw new NotAllowCommentException();
public class NotAllowCommentException extends ParserException {
private static final long serialVersionUID = 1L;
public NotAllowCommentException(){
public NotAllowCommentException(String message, Throwable e){
super(message, e);
public NotAllowCommentException(String message){
super(message);
if (ch != ':' && ch != '#') {
scanVariable();
if (ch != '@' && ch != ':' && ch != '#') {
public class OracleIbatisSelectTest extends OracleTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM T WHERE F1 = #id# ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("T")));
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
public class OracleIbatisSelectTest1 extends OracleTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM T WHERE F1 = $id$";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("T")));
Assert.assertEquals(1, visitor.getTables().size());
@Deprecated
public class TransactionInfo extends com.alibaba.druid.proxy.jdbc.TransactionInfo {
public TransactionInfo(long id){
super(id);
private SQLExprTableSource         tableSource;
acceptChild(visitor, tableSource);
if (tableSource == null) {
return null;
return (SQLName) tableSource.getExpr();
this.setTableSource(new SQLExprTableSource(name));
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
private static final long          serialVersionUID = 1L;
protected List<SQLExprTableSource> tableSources     = new ArrayList<SQLExprTableSource>(2);
public List<SQLExprTableSource> getTableSources() {
return tableSources;
public void setTableSources(List<SQLExprTableSource> tableSources) {
this.tableSources = tableSources;
public void addTableSource(SQLName name) {
this.tableSources.add(new SQLExprTableSource(name));
acceptChild(visitor, tableSources);
private SQLExprTableSource         tableSource;
acceptChild(visitor, tableSource);
if (tableSource == null) {
return null;
return (SQLName) tableSource.getExpr();
this.setTableSource(new SQLExprTableSource(name));
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
acceptChild(visitor, tableSources);
stmt.addTableSource(name);
printAndAccept(x.getTableSources(), ", ");
acceptChild(visitor, tableSources);
stmt.addTableSource(name);
printlnAndAccept(x.getTableSources(), ", ");
stmt.addTableSource(name);
printAndAccept(x.getTableSources(), ", ");
for (SQLExprTableSource tableSource : x.getTableSources()) {
SQLName name = (SQLName) tableSource.getExpr();
public class AlipayUseCaseTest {
public void setUp() throws Exception {
public void tearDown() throws Exception {
public void test() {
fail("Not yet implemented"); 
public class IllegalSQLObjectViolation implements Violation {
public IllegalSQLObjectViolation(){
public IllegalSQLObjectViolation(String condition){
private WallProvider provider;
public void init(DataSourceProxy dataSource) {
this.dataSource = dataSource;
provider = createWallProvider(dataSource.getDbType());
provider.check(sql, true);
public WallProvider createWallProvider(String dbType) {
if (JdbcUtils.MYSQL.equals(dbType)) {
return new MySqlWallProvider();
throw new IllegalStateException("dbType not support : " + dbType);
public WallVisitor createWallVisitor(String dbType) throws SQLException {
return new OracleWallVisitor();
return new MySqlWallVisitor();
public abstract class WallProvider {
private static final Object           PRESENT           = new Object();
private LinkedHashMap<String, Object> whiteList;
private int                           whileListMaxSize  = 1024;
private int                           whiteSqlMaxLength = 1024;        
public synchronized void addWhiteSql(String sql) {
if (whiteList == null) {
whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);
whiteList.put(sql, PRESENT);
public synchronized boolean whiteContains(String sql) {
if (whiteList == null) {
return false;
return whiteList.get(sql) != null;
public abstract SQLStatementParser createParser(String sql);
public abstract WallVisitor createWallVisitor();
public boolean check(String sql, boolean throwException) throws WallRuntimeException {
boolean isWhite = whiteContains(sql);
if (isWhite) {
return true;
SQLStatementParser parser = createParser(sql);
parser.getLexer().setAllowComment(false); 
List<SQLStatement> statementList = parser.parseStatementList();
if (statementList.size() > 1) {
if (throwException) {
throw new WallRuntimeException("multi-statement : " + sql);
return false;
SQLStatement stmt = statementList.get(0);
WallVisitor visitor = createWallVisitor();
stmt.accept(visitor);
if (visitor.getViolations().size() > 0) {
if (throwException) {
throw new WallRuntimeException();
return false;
if (sql.length() < whiteSqlMaxLength) {
this.addWhiteSql(sql);
return true;
public class WallRuntimeException extends RuntimeException {
private static final long serialVersionUID = 1L;
public WallRuntimeException(){
public WallRuntimeException(String reason, Throwable cause){
super(reason, cause);
public WallRuntimeException(String reason){
super(reason);
public WallRuntimeException(Throwable cause){
super(cause);
public class WallSQLException extends SQLException {
private static final long serialVersionUID = 1L;
public WallSQLException(){
public WallSQLException(String reason, Throwable cause){
super(reason, cause);
public WallSQLException(String reason){
super(reason);
public WallSQLException(Throwable cause){
super(cause);
public class WallUtils {
public static boolean isValidateMySql(String sql) {
MySqlWallProvider provider = new MySqlWallProvider();
return provider.check(sql, false);
public class MySqlWallProvider extends WallProvider {
public SQLStatementParser createParser(String sql) {
return new MySqlStatementParser(sql);
public WallVisitor createWallVisitor() {
return new MySqlWallVisitor();
private Set<String>           permitFunctions = new HashSet<String>();
private Set<String>           permitSchemas   = new HashSet<String>();
public MySqlWallVisitor(){
public MySqlWallVisitor(List<Violation> violations){
permitFunctions.add("load_file");
permitSchemas.add("information_schema");
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
public boolean visit(SQLVariantRefExpr x) {
String varName = x.getName();
if (varName == null) {
return false;
if (varName.startsWith("@@")) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(SQLMethodInvokeExpr x) {
String methodName = x.getMethodName();
if (permitFunctions.contains(methodName.toLowerCase())) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
public boolean visit(SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) expr;
if (propExpr.getOwner() instanceof SQLIdentifierExpr) {
String ownerName = ((SQLIdentifierExpr) propExpr.getOwner()).getName();
if (permitSchemas.contains(ownerName.toLowerCase())) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
violations.add(new IllegalSQLObjectViolation(SQLUtils.toOracleString(x)));
public class MySqlWallTest extends TestCase {
public void testWall() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql("select 14,13,12,11,10,@@version_compile_os,8,7,6,5,4,3,2,1"));
Assert.assertTrue(WallUtils.isValidateMySql("select '@@version_compile_os'"));
Assert.assertFalse(WallUtils.isValidateMySql("select hex(load_file(0x633A2F77696E646F77732F7265706169722F73616D))"));
Assert.assertTrue(WallUtils.isValidateMySql("select 'hex(load_file(0x633A2F77696E646F77732F7265706169722F73616D))'"));
Assert.assertFalse(WallUtils.isValidateMySql("select 1 from information_schema.columns"));
Assert.assertTrue(WallUtils.isValidateMySql("select 'information_schema.columns'"));
public String toString() {
return this.condition;
private String sqlPart;
this.sqlPart = condition;
public String getSqlPart() {
return sqlPart;
public void setSqlPart(String sqlPart) {
this.sqlPart = sqlPart;
public String toString() {
return this.sqlPart;
String toString();
visitor.getViolations().get(0);
private Set<String>           permitFunctions   = new HashSet<String>();
private Set<String>           permitTablesoures = new HashSet<String>();
private Set<String>           permitSchemas     = new HashSet<String>();
permitFunctions.add("version");
permitFunctions.add("load_file");
permitFunctions.add("databse");
permitFunctions.add("schema");
permitFunctions.add("user");
permitFunctions.add("system_user");
permitFunctions.add("session_user");
permitFunctions.add("benchmark");
permitFunctions.add("connection_id");
permitFunctions.add("current_user");
permitSchemas.add("information_schema");
permitSchemas.add("mysql");
permitTablesoures.add("outfile");
public boolean visit(MySqlOutFileExpr x) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return false;
public boolean visit(SQLUnionQuery x) {
if (queryBlockFromIsNull(x.getLeft()) || queryBlockFromIsNull(x.getRight())) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
private static boolean queryBlockFromIsNull(SQLSelectQuery query) {
if (query instanceof SQLSelectQueryBlock) {
return ((SQLSelectQueryBlock) query).getFrom() == null;
return false;
public class MySqlOutFileExpr extends MySqlObjectImpl implements SQLExpr {
private static final long serialVersionUID          = 1L;
private SQLExpr           file;
private String            charset;
private SQLLiteralExpr    columnsTerminatedBy;
private boolean           columnsEnclosedOptionally = false;
private SQLLiteralExpr    columnsEnclosedBy;
private SQLLiteralExpr    columnsEscaped;
private SQLLiteralExpr    linesStartingBy;
private SQLLiteralExpr    linesTerminatedBy;
private SQLExpr           ignoreLinesNumber;
public MySqlOutFileExpr(){
public MySqlOutFileExpr(SQLExpr file){
this.file = file;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, file);
visitor.endVisit(this);
public SQLExpr getFile() {
return file;
public void setFile(SQLExpr file) {
this.file = file;
public String getCharset() {
return charset;
public void setCharset(String charset) {
this.charset = charset;
public SQLLiteralExpr getColumnsTerminatedBy() {
return columnsTerminatedBy;
public void setColumnsTerminatedBy(SQLLiteralExpr columnsTerminatedBy) {
this.columnsTerminatedBy = columnsTerminatedBy;
public boolean isColumnsEnclosedOptionally() {
return columnsEnclosedOptionally;
public void setColumnsEnclosedOptionally(boolean columnsEnclosedOptionally) {
this.columnsEnclosedOptionally = columnsEnclosedOptionally;
public SQLLiteralExpr getColumnsEnclosedBy() {
return columnsEnclosedBy;
public void setColumnsEnclosedBy(SQLLiteralExpr columnsEnclosedBy) {
this.columnsEnclosedBy = columnsEnclosedBy;
public SQLLiteralExpr getColumnsEscaped() {
return columnsEscaped;
public void setColumnsEscaped(SQLLiteralExpr columnsEscaped) {
this.columnsEscaped = columnsEscaped;
public SQLLiteralExpr getLinesStartingBy() {
return linesStartingBy;
public void setLinesStartingBy(SQLLiteralExpr linesStartingBy) {
this.linesStartingBy = linesStartingBy;
public SQLLiteralExpr getLinesTerminatedBy() {
return linesTerminatedBy;
public void setLinesTerminatedBy(SQLLiteralExpr linesTerminatedBy) {
this.linesTerminatedBy = linesTerminatedBy;
public SQLExpr getIgnoreLinesNumber() {
return ignoreLinesNumber;
public void setIgnoreLinesNumber(SQLExpr ignoreLinesNumber) {
this.ignoreLinesNumber = ignoreLinesNumber;
private boolean       hignPriority;
private boolean       straightJoin;
private boolean       smallResult;
private boolean       bigResult;
private boolean       bufferResult;
private Boolean       cache;
private boolean       calcFoundRows;
private SQLOrderBy    orderBy;
private Limit         limit;
private SQLName       procedureName;
private List<SQLExpr> procedureArgumentList = new ArrayList<SQLExpr>();
private SQLExpr       into;
private boolean       forUpdate             = false;
private boolean       lockInShareMode       = false;
public SQLExpr getInto() {
return into;
public void setInto(SQLExpr into) {
this.into = into;
acceptChild(visitor, this.into);
if (identifierEquals("outfile")) {
lexer.nextToken();
SQLExpr file = primary();
SQLExpr expr = new MySqlOutFileExpr(file);
return primaryRest(expr);
MySqlOutFileExpr outFile = new MySqlOutFileExpr();
outFile.setFile(expr());
queryBlock.setInto(outFile);
outFile.setColumnsTerminatedBy((SQLLiteralExpr) expr());
outFile.setColumnsEnclosedOptionally(true);
outFile.setColumnsEnclosedBy((SQLLiteralExpr) expr());
outFile.setColumnsEscaped((SQLLiteralExpr) expr());
outFile.setLinesStartingBy((SQLLiteralExpr) expr());
outFile.setLinesTerminatedBy((SQLLiteralExpr) expr());
boolean visit(MySqlOutFileExpr x);
void endVisit(MySqlOutFileExpr x);
public boolean visit(MySqlOutFileExpr x) {
return true;
public void endVisit(MySqlOutFileExpr x) {
if (x.getInto() != null) {
print("INTO ");
x.getInto().accept(this);
public boolean visit(MySqlOutFileExpr x) {
print("OUTFILE ");
x.getFile().accept(this);
if (x.getCharset() != null) {
print(" CHARACTER SET ");
print(x.getCharset());
if (x.getColumnsTerminatedBy() != null || x.getColumnsEnclosedBy() != null
|| x.getColumnsEscaped() != null) {
print(" COLUMNS");
if (x.getColumnsTerminatedBy() != null) {
print(" TERMINATED BY ");
x.getColumnsTerminatedBy().accept(this);
if (x.getColumnsEnclosedBy() != null) {
if (x.isColumnsEnclosedOptionally()) {
print(" OPTIONALLY");
print(" ENCLOSED BY ");
x.getColumnsEnclosedBy().accept(this);
if (x.getColumnsEscaped() != null) {
print(" ESCAPED BY ");
x.getColumnsEscaped().accept(this);
if (x.getLinesStartingBy() != null || x.getLinesTerminatedBy() != null) {
print(" LINES");
if (x.getLinesStartingBy() != null) {
print(" STARTING BY ");
x.getLinesStartingBy().accept(this);
if (x.getLinesTerminatedBy() != null) {
print(" TERMINATED BY ");
x.getLinesTerminatedBy().accept(this);
return false;
public void endVisit(MySqlOutFileExpr x) {
public boolean visit(MySqlOutFileExpr x) {
return false;
public void endVisit(MySqlOutFileExpr x) {
Assert.assertFalse(WallUtils.isValidateMySql("select 15,version()"));
Assert.assertTrue(WallUtils.isValidateMySql("select 15,'version'"));
Assert.assertFalse(WallUtils.isValidateMySql("select 1 from mysql.user"));
Assert.assertTrue(WallUtils.isValidateMySql("select 'mysql.user'"));
Assert.assertFalse(WallUtils.isValidateMySql("select 0x3C3F706870206576616C28245F504F53545B2763275D293F3E into outfile '\www\edu\1.php'"));
Assert.assertTrue(WallUtils.isValidateMySql("select 'outfile'"));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t union select 1, 2"));
public class OracleWallProvider extends WallProvider {
public SQLStatementParser createParser(String sql) {
return new OracleStatementParser(sql);
public WallVisitor createWallVisitor() {
return new OracleWallVisitor();
visitor.getViolations().add(new IllegalSQLObjectViolation(SQLUtils.toSQLString(x)));
public class OnlineOracleTest3 extends TestCase {
private String          jdbcUrl;
private String          user;
private String          password;
private DruidDataSource dataSource;
public void setUp() throws Exception {
jdbcUrl = "jdbc:oracle:thin:@10.20.149.18:1521:emdb";
user = "wardon";
password = "wardon";
dataSource = new DruidDataSource();
dataSource.setInitialSize(1);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setMaxActive(50);
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(100);
public void test_connect() throws Exception {
execute("select * from session_roles");
public void executeQuery(String sql) throws SQLException {
Connection conn = null;
Statement stmt = null;
ResultSet rs = null;
conn = dataSource.getConnection();
stmt = conn.createStatement();
rs = stmt.executeQuery(sql);
JdbcUtils.printResultSet(rs);
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
JdbcUtils.close(conn);
public void execute(String sql) throws SQLException {
Connection conn = null;
Statement stmt = null;
conn = dataSource.getConnection();
stmt = conn.createStatement();
stmt.execute(sql);
} finally {
JdbcUtils.close(stmt);
JdbcUtils.close(conn);
if(parser.getLexer().token() != Token.EOF) {
if (throwException) {
throw new WallRuntimeException("illegal statement : " + sql);
return false;
public static boolean isValidateOracle(String sql) {
OracleWallProvider provider = new OracleWallProvider();
return provider.check(sql, false);
Set<String> getPermitFunctions();
Set<String> getPermitSchemas();
Set<String> getPermitTables();
boolean containsPermitTable(String name);
Set<String> getPermitNames();
String toSQL(SQLObject obj);
private final Set<String>     permitFunctions = new HashSet<String>();
private final Set<String>     permitTables    = new HashSet<String>();
private final Set<String>     permitSchemas   = new HashSet<String>();
private final Set<String>     permiNames      = new HashSet<String>();
public Set<String> getPermitNames() {
return permiNames;
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
permitTables.add("outfile");
WallVisitorUtils.check(this, x);
WallVisitorUtils.check(this, x);
if (x.getExpr() instanceof SQLName) {
return false;
if (WallVisitorUtils.queryBlockFromIsNull(x.getLeft()) || WallVisitorUtils.queryBlockFromIsNull(x.getRight())) {
public String toSQL(SQLObject obj) {
return SQLUtils.toMySqlString(obj);
public boolean containsPermitTable(String name) {
name = WallVisitorUtils.form(name);
return permitTables.contains(name);
private final static Log      LOG             = LogFactory.getLog(OracleWallVisitor.class);
private final Set<String>     permitFunctions = new HashSet<String>();
private final Set<String>     permitTables    = new HashSet<String>();
private final Set<String>     permitSchemas   = new HashSet<String>();
private final Set<String>     permitNames     = new HashSet<String>();
addPermitFunction("sys_context");
addPermitFunction("userenv");
addPermitFunction("sys_guid");
addPermitFunction("sys_typeid");
addPermitName("uid");
addPermitName("user");
loadPermitTables();
private void loadPermitTables() {
Enumeration<URL> e = Thread.currentThread().getContextClassLoader().getResources("META-INF/druid-filter-wall-permit-function.txt");
while (e.hasMoreElements()) {
URL url = e.nextElement();
InputStream in = null;
BufferedReader reader = null;
in = url.openStream();
reader = new BufferedReader(new InputStreamReader(in));
for (;;) {
String line = reader.readLine();
if (line == null) {
line = line.trim();
if (line.length() > 0) {
addPermitTable(line);
url.openStream();
} finally {
JdbcUtils.close(reader);
JdbcUtils.close(in);
} catch (IOException e) {
LOG.error("load oracle permit tables errror", e);
public void addPermitName(String name) {
name = name.toLowerCase();
permitNames.add(name);
public void addPermitFunction(String name) {
name = name.toLowerCase();
permitFunctions.add(name);
public void addPermitTable(String name) {
name = name.toLowerCase();
permitTables.add(name);
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public boolean visit(SQLIdentifierExpr x) {
return true;
public boolean visit(SQLMethodInvokeExpr x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(OracleSelectTableReference x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(SQLExprTableSource x) {
WallVisitorUtils.check(this, x);
if (x.getExpr() instanceof SQLName) {
return false;
return true;
public boolean visit(SQLUnionQuery x) {
if (WallVisitorUtils.queryBlockFromIsNull(x.getLeft()) || WallVisitorUtils.queryBlockFromIsNull(x.getRight())) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
public String toSQL(SQLObject obj) {
return SQLUtils.toOracleString(obj);
public boolean containsPermitTable(String name) {
name = WallVisitorUtils.form(name);
return permitTables.contains(name);
public static void check(WallVisitor visitor, SQLMethodInvokeExpr x) {
String methodName = x.getMethodName();
if (visitor.getPermitFunctions().contains(methodName.toLowerCase())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public static void check(WallVisitor visitor, SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
String tableName = null;
if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) expr;
if (propExpr.getOwner() instanceof SQLIdentifierExpr) {
String ownerName = ((SQLIdentifierExpr) propExpr.getOwner()).getName();
if (visitor.getPermitSchemas().contains(ownerName.toLowerCase())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
tableName = propExpr.getName();
if (expr instanceof SQLIdentifierExpr) {
tableName = ((SQLIdentifierExpr) expr).getName();
if (tableName != null) {
tableName = form(tableName);
if (visitor.getPermitTables().contains(tableName)) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public static boolean queryBlockFromIsNull(SQLSelectQuery query) {
if (query instanceof SQLSelectQueryBlock) {
SQLTableSource from = ((SQLSelectQueryBlock) query).getFrom();
if (from == null) {
return true;
if (from instanceof SQLExprTableSource) {
SQLExpr fromExpr = ((SQLExprTableSource) from).getExpr();
if (fromExpr instanceof SQLName) {
String name = fromExpr.toString();
name = form(name);
if (name.equalsIgnoreCase("DUAL")) {
return true;
return false;
public static String form(String name) {
if (name.startsWith(""") && name.endsWith(""")) {
name = name.substring(1, name.length() - 1);
name = name.toLowerCase();
return name;
public class OracleWallTest extends TestCase {
public void testWall() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t union select 1, 2"));
Assert.assertFalse(WallUtils.isValidateOracle("select * from TAB"));
executeQuery("select * from TAB");
if(parser.getLexer().token() != Token.EOF) {
if (throwException) {
throw new WallRuntimeException("illegal statement : " + sql);
return false;
public static boolean isValidateOracle(String sql) {
OracleWallProvider provider = new OracleWallProvider();
return provider.check(sql, false);
Set<String> getPermitFunctions();
Set<String> getPermitSchemas();
Set<String> getPermitTables();
boolean containsPermitTable(String name);
Set<String> getPermitNames();
String toSQL(SQLObject obj);
private final Set<String>     permitFunctions = new HashSet<String>();
private final Set<String>     permitTables    = new HashSet<String>();
private final Set<String>     permitSchemas   = new HashSet<String>();
private final Set<String>     permiNames      = new HashSet<String>();
public Set<String> getPermitNames() {
return permiNames;
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
permitTables.add("outfile");
WallVisitorUtils.check(this, x);
WallVisitorUtils.check(this, x);
if (x.getExpr() instanceof SQLName) {
return false;
if (WallVisitorUtils.queryBlockFromIsNull(x.getLeft()) || WallVisitorUtils.queryBlockFromIsNull(x.getRight())) {
public String toSQL(SQLObject obj) {
return SQLUtils.toMySqlString(obj);
public boolean containsPermitTable(String name) {
name = WallVisitorUtils.form(name);
return permitTables.contains(name);
private final static Log      LOG             = LogFactory.getLog(OracleWallVisitor.class);
private final Set<String>     permitFunctions = new HashSet<String>();
private final Set<String>     permitTables    = new HashSet<String>();
private final Set<String>     permitSchemas   = new HashSet<String>();
private final Set<String>     permitNames     = new HashSet<String>();
addPermitFunction("sys_context");
addPermitFunction("userenv");
addPermitFunction("sys_guid");
addPermitFunction("sys_typeid");
addPermitName("uid");
addPermitName("user");
loadPermitTables();
private void loadPermitTables() {
Enumeration<URL> e = Thread.currentThread().getContextClassLoader().getResources("META-INF/druid-filter-wall-permit-function.txt");
while (e.hasMoreElements()) {
URL url = e.nextElement();
InputStream in = null;
BufferedReader reader = null;
in = url.openStream();
reader = new BufferedReader(new InputStreamReader(in));
for (;;) {
String line = reader.readLine();
if (line == null) {
line = line.trim();
if (line.length() > 0) {
addPermitTable(line);
url.openStream();
} finally {
JdbcUtils.close(reader);
JdbcUtils.close(in);
} catch (IOException e) {
LOG.error("load oracle permit tables errror", e);
public void addPermitName(String name) {
name = name.toLowerCase();
permitNames.add(name);
public void addPermitFunction(String name) {
name = name.toLowerCase();
permitFunctions.add(name);
public void addPermitTable(String name) {
name = name.toLowerCase();
permitTables.add(name);
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public boolean visit(SQLIdentifierExpr x) {
return true;
public boolean visit(SQLMethodInvokeExpr x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(OracleSelectTableReference x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(SQLExprTableSource x) {
WallVisitorUtils.check(this, x);
if (x.getExpr() instanceof SQLName) {
return false;
return true;
public boolean visit(SQLUnionQuery x) {
if (WallVisitorUtils.queryBlockFromIsNull(x.getLeft()) || WallVisitorUtils.queryBlockFromIsNull(x.getRight())) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
public String toSQL(SQLObject obj) {
return SQLUtils.toOracleString(obj);
public boolean containsPermitTable(String name) {
name = WallVisitorUtils.form(name);
return permitTables.contains(name);
public static void check(WallVisitor visitor, SQLMethodInvokeExpr x) {
String methodName = x.getMethodName();
if (visitor.getPermitFunctions().contains(methodName.toLowerCase())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public static void check(WallVisitor visitor, SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
String tableName = null;
if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) expr;
if (propExpr.getOwner() instanceof SQLIdentifierExpr) {
String ownerName = ((SQLIdentifierExpr) propExpr.getOwner()).getName();
if (visitor.getPermitSchemas().contains(ownerName.toLowerCase())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
tableName = propExpr.getName();
if (expr instanceof SQLIdentifierExpr) {
tableName = ((SQLIdentifierExpr) expr).getName();
if (tableName != null) {
tableName = form(tableName);
if (visitor.getPermitTables().contains(tableName)) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public static boolean queryBlockFromIsNull(SQLSelectQuery query) {
if (query instanceof SQLSelectQueryBlock) {
SQLTableSource from = ((SQLSelectQueryBlock) query).getFrom();
if (from == null) {
return true;
if (from instanceof SQLExprTableSource) {
SQLExpr fromExpr = ((SQLExprTableSource) from).getExpr();
if (fromExpr instanceof SQLName) {
String name = fromExpr.toString();
name = form(name);
if (name.equalsIgnoreCase("DUAL")) {
return true;
return false;
public static String form(String name) {
if (name.startsWith(""") && name.endsWith(""")) {
name = name.substring(1, name.length() - 1);
name = name.toLowerCase();
return name;
public class OracleWallPermitTableTest extends TestCase {
public void test_permitTable() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle("select * from TAB"));
Assert.assertFalse(WallUtils.isValidateOracle("select * from tab"));
Assert.assertFalse(WallUtils.isValidateOracle("select * from SYS.TAB"));
Assert.assertFalse(WallUtils.isValidateOracle("select * from SYS."TAB""));
public class WallUnionTest extends TestCase {
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t union select 1, 2"));
public void testOracle() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t union select 1, 2"));
executeQuery("select * from TAB");
WallVisitorUtils.checkCondition(this, x.getWhere());
public boolean visit(SQLSelectGroupByClause x) {
WallVisitorUtils.checkCondition(this, x.getHaving());
return true;
public boolean visit(MySqlSelectGroupBy x) {
WallVisitorUtils.checkCondition(this, x.getHaving());
return true;
public boolean visit(SQLSelectGroupByClause x) {
WallVisitorUtils.checkCondition(this, x.getHaving());
return true;
public boolean visit(SQLSelectQueryBlock x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(OracleSelectQueryBlock x) {
return visit((SQLSelectQueryBlock) x);
public static void checkCondition(WallVisitor visitor, SQLExpr x) {
if (x == null) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) query;
SQLTableSource from = queryBlock.getFrom();
if (queryBlock.getSelectList().size() == 1 && queryBlock.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
if (from instanceof SQLSubqueryTableSource) {
SQLSelectQuery subQuery = ((SQLSubqueryTableSource) from).getSelect().getQuery();
if (queryBlockFromIsNull(subQuery)) {
return true;
boolean allIsConst = true;
for (SQLSelectItem item : queryBlock.getSelectList()) {
if (getValue(item.getExpr()) == null) {
allIsConst = false;
if (allIsConst) {
return true;
Assert.assertFalse(WallUtils.isValidateOracle("SELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT'.PUT(:P1));"));
public class WallHavingTest extends TestCase {
private String sql = "SELECT F1, COUNT(*) FROM T GROUP BY F1 HAVING 1 = 1";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallUnionTest4 extends TestCase {
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql("SELECT id, product FROM T1 t UNION (SELECT * FROM (SELECT 1,'x') X)"));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle("SELECT id, product FROM T1 t UNION (SELECT * FROM (SELECT 1,'x') X)"));
public class WallSelectWhereTest extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallSelectWhereTest1 extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1 OR FID = ?";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallSelectWhereTest2 extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1 AND FID = ?";
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle(sql));
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(MySqlDeleteStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(SQLDeleteStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(SQLUpdateStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(Limit x) {
if (x.getRowCount() instanceof SQLNumericLiteralExpr) {
int rowCount = ((SQLNumericLiteralExpr) x.getRowCount()).getNumber().intValue();
if (rowCount == 0) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return true;
public boolean visit(OracleDeleteStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(SQLDeleteStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(SQLUpdateStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(OracleUpdateStatement x) {
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public class MySqlWallLimitTest extends TestCase {
public void test_permitTable() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql("SELECT * FROM T LIMIT 0"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT * FROM T LIMIT 10, 0"));
public class WallDeleteWhereTest extends TestCase {
private String sql = "DELETE FROM T WHERE 1 = 1";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallSelectWhereTest extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallSelectWhereTest1 extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1 OR FID = ?";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallSelectWhereTest2 extends TestCase {
private String sql = "SELECT F1, F2 WHERE 1 = 1 AND FID = ?";
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle(sql));
public class WallUpdateWhereTest extends TestCase {
private String sql = "UPDATE T SET F1 = 0 WHERE 1 = 1";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
private final Set<String>     permitNames     = new HashSet<String>();
this(new ArrayList<Violation>(), true);
public MySqlWallVisitor(boolean loadDefault) {
this(new ArrayList<Violation>(), loadDefault);
public MySqlWallVisitor(List<Violation> violations, boolean loadDefault){
loadDefault();
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-mysql.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql.txt");
return permitNames;
this(new ArrayList<Violation>(), true);
public OracleWallVisitor(boolean loadDefault) {
this(new ArrayList<Violation>(), loadDefault);
public OracleWallVisitor(List<Violation> violations, boolean loadDefault){
loadDefault();
public void loadDefault() {
public MySqlWallVisitor(boolean loadDefault){
if (loadDefault) {
loadDefault();
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql-default.txt");
public OracleWallVisitor(boolean loadDefault){
if (loadDefault) {
loadDefault();
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-oracle-default.txt");
private int                           whiteSqlMaxLength = 1024;                 
protected final Set<String>           permitFunctions   = new HashSet<String>();
protected final Set<String>           permitTables      = new HashSet<String>();
protected final Set<String>           permitSchemas     = new HashSet<String>();
protected final Set<String>           permitNames       = new HashSet<String>();
protected final Set<String>           permitObjects     = new HashSet<String>();
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitObjects() {
return permitObjects;
WallProvider getWallProvider();
List<Violation> getViolations();
public MySqlWallProvider(){
loadDefault();
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-mysql.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql.txt");
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql-default.txt");
return new MySqlWallVisitor(this);
private final MySqlWallProvider provider;
private final List<Violation>   violations = new ArrayList<Violation>();
public MySqlWallVisitor(MySqlWallProvider provider){
this.provider = provider;
public WallProvider getWallProvider() {
return provider;
return provider.getPermitObjects().contains(name);
return provider.getPermitTables().contains(name);
public OracleWallProvider(){
loadDefault();
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-oracle.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-oracle.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-oracle.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-oracle.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-oracle.txt");
return new OracleWallVisitor(this);
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions,
"META-INF/druid-filter-wall-permit-function-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-oracle-default.txt");
private OracleWallProvider    provider;
private final List<Violation> violations = new ArrayList<Violation>();
public OracleWallVisitor(OracleWallProvider provider){
this.provider = provider;
return provider.getPermitObjects().contains(name);
return provider.getPermitTables().contains(name);
public WallProvider getWallProvider() {
return this.provider;
if (visitor.getWallProvider().getPermitFunctions().contains(methodName.toLowerCase())) {
if (visitor.getWallProvider().getPermitSchemas().contains(ownerName.toLowerCase())) {
private boolean      inited = false;
private boolean      loadDefault;
private boolean      loadExtend;
this.inited = true;
public boolean isLoadDefault() {
return loadDefault;
public void checkInit() {
if (inited) {
throw new DruidRuntimeException("wall filter is inited");
public void setLoadDefault(boolean loadDefault) {
checkInit();
this.loadDefault = loadDefault;
public boolean isLoadExtend() {
return loadExtend;
public void setLoadExtend(boolean loadExtend) {
checkInit();
this.loadExtend = loadExtend;
return new MySqlWallProvider(this.loadDefault, this.loadExtend);
return new OracleWallProvider(this.loadDefault, this.loadExtend);
throw new IllegalStateException("dbType not support : " + dbType);
private int                           whiteSqlMaxLength = 1024;                 
protected final Set<String>           permitFunctions   = new HashSet<String>();
protected final Set<String>           permitTables      = new HashSet<String>();
protected final Set<String>           permitSchemas     = new HashSet<String>();
protected final Set<String>           permitNames       = new HashSet<String>();
protected final Set<String>           permitObjects     = new HashSet<String>();
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitObjects() {
return permitObjects;
WallProvider getWallProvider();
List<Violation> getViolations();
public MySqlWallProvider(){
this(true, true);
public MySqlWallProvider(boolean loadDefault, boolean loadExtend){
if (loadDefault) {
loadDefault();
if (loadExtend) {
loadExtend();
public void loadExtend() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-mysql.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql.txt");
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions,
"META-INF/druid-filter-wall-permit-function-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-mysql-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-mysql-default.txt");
return new MySqlWallVisitor(this);
private final MySqlWallProvider provider;
private final List<Violation>   violations = new ArrayList<Violation>();
public MySqlWallVisitor(MySqlWallProvider provider){
this.provider = provider;
public WallProvider getWallProvider() {
return provider;
return provider.getPermitObjects().contains(name);
return provider.getPermitTables().contains(name);
public OracleWallProvider(){
this(true, true);
public OracleWallProvider(boolean loadDefault, boolean loadExtend){
if (loadDefault) {
loadDefault();
if (loadExtend) {
loadExtend();
public void loadExtend() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-oracle.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-oracle.txt");
WallVisitorUtils.loadResource(this.permitFunctions, "META-INF/druid-filter-wall-permit-function-oracle.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-oracle.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-oracle.txt");
public void loadDefault() {
WallVisitorUtils.loadResource(this.permitNames, "META-INF/druid-filter-wall-permit-name-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitSchemas, "META-INF/druid-filter-wall-permit-schema-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitFunctions,
"META-INF/druid-filter-wall-permit-function-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitTables, "META-INF/druid-filter-wall-permit-table-oracle-default.txt");
WallVisitorUtils.loadResource(this.permitObjects, "META-INF/druid-filter-wall-permit-object-oracle-default.txt");
return new OracleWallVisitor(this);
private OracleWallProvider    provider;
private final List<Violation> violations = new ArrayList<Violation>();
public OracleWallVisitor(OracleWallProvider provider){
this.provider = provider;
return provider.getPermitObjects().contains(name);
return provider.getPermitTables().contains(name);
public WallProvider getWallProvider() {
return this.provider;
if (visitor.getWallProvider().getPermitFunctions().contains(methodName.toLowerCase())) {
if (visitor.getWallProvider().getPermitSchemas().contains(ownerName.toLowerCase())) {
private boolean      inited                        = false;
private boolean      checkSelectAlwayTrueCondition = true;
public WallProvider getProvider() {
return provider;
WallProvider provider;
provider = new MySqlWallProvider(this.loadDefault, this.loadExtend);
} else if (JdbcUtils.ORACLE.equals(dbType)) {
provider = new OracleWallProvider(this.loadDefault, this.loadExtend);
throw new IllegalStateException("dbType not support : " + dbType);
provider.setCheckSelectAlwayTrueCondition(this.checkSelectAlwayTrueCondition);
return provider;
WallProvider getProvider();
public WallProvider getProvider() {
public WallProvider getProvider() {
WallProvider provider = visitor.getProvider();
if (visitor.getProvider().getPermitFunctions().contains(methodName.toLowerCase())) {
if (visitor.getProvider().getPermitSchemas().contains(ownerName.toLowerCase())) {
public class WallConfig {
private boolean selelctAllow               = true;
private boolean selectWhereAlwayTrueCheck  = true;
private boolean selectHavingAlwayTrueCheck = true;
private boolean deleteAllow                = true;
private boolean deleteWhereAlwayTrueCheck  = true;
private boolean updateAllow                = true;
private boolean updateWhereAlayTrueCheck   = true;
private boolean insertAllow                = true;
private boolean mergeAllow                 = true;
public boolean isSelelctAllow() {
return selelctAllow;
public void setSelelctAllow(boolean selelctAllow) {
this.selelctAllow = selelctAllow;
public boolean isSelectWhereAlwayTrueCheck() {
return selectWhereAlwayTrueCheck;
public void setSelectWhereAlwayTrueCheck(boolean selectWhereAlwayTrueCheck) {
this.selectWhereAlwayTrueCheck = selectWhereAlwayTrueCheck;
public boolean isSelectHavingAlwayTrueCheck() {
return selectHavingAlwayTrueCheck;
public void setSelectHavingAlwayTrueCheck(boolean selectHavingAlwayTrueCheck) {
this.selectHavingAlwayTrueCheck = selectHavingAlwayTrueCheck;
public boolean isDeleteAllow() {
return deleteAllow;
public void setDeleteAllow(boolean deleteAllow) {
this.deleteAllow = deleteAllow;
public boolean isDeleteWhereAlwayTrueCheck() {
return deleteWhereAlwayTrueCheck;
public void setDeleteWhereAlwayTrueCheck(boolean deleteWhereAlwayTrueCheck) {
this.deleteWhereAlwayTrueCheck = deleteWhereAlwayTrueCheck;
public boolean isUpdateAllow() {
return updateAllow;
public void setUpdateAllow(boolean updateAllow) {
this.updateAllow = updateAllow;
public boolean isUpdateWhereAlayTrueCheck() {
return updateWhereAlayTrueCheck;
public void setUpdateWhereAlayTrueCheck(boolean updateWhereAlayTrueCheck) {
this.updateWhereAlayTrueCheck = updateWhereAlayTrueCheck;
public boolean isInsertAllow() {
return insertAllow;
public void setInsertAllow(boolean insertAllow) {
this.insertAllow = insertAllow;
public boolean isMergeAllow() {
return mergeAllow;
public void setMergeAllow(boolean mergeAllow) {
this.mergeAllow = mergeAllow;
private boolean      inited = false;
private WallConfig   config = new WallConfig();
public WallConfig getConfig() {
return config;
public void setConfig(WallConfig config) {
this.config = config;
provider = new MySqlWallProvider(config, this.loadDefault, this.loadExtend);
provider = new OracleWallProvider(config, this.loadDefault, this.loadExtend);
private static final Object           PRESENT           = new Object();
private int                           whileListMaxSize  = 1024;
private int                           whiteSqlMaxLength = 1024;                 
protected final Set<String>           permitFunctions   = new HashSet<String>();
protected final Set<String>           permitTables      = new HashSet<String>();
protected final Set<String>           permitSchemas     = new HashSet<String>();
protected final Set<String>           permitNames       = new HashSet<String>();
protected final Set<String>           permitObjects     = new HashSet<String>();
private final WallConfig              config;
public WallProvider(WallConfig config){
this.config = config;
public WallConfig getConfig() {
return config;
public MySqlWallProvider() {
this(new WallConfig());
public MySqlWallProvider(WallConfig config){
this(config, true, true);
public MySqlWallProvider(WallConfig config, boolean loadDefault, boolean loadExtend){
super(config);
this(new WallConfig());
public OracleWallProvider(WallConfig config){
this(config, true, true);
public OracleWallProvider(WallConfig config, boolean loadDefault, boolean loadExtend){
super(config);
if (!provider.getConfig().isSelectHavingAlwayTrueCheck()) {
if (binaryOpExpr.getOperator() == SQLBinaryOperator.Equality
|| binaryOpExpr.getOperator() == SQLBinaryOperator.NotEqual) {
if (binaryOpExpr.getLeft() instanceof SQLIntegerExpr
&& binaryOpExpr.getRight() instanceof SQLIntegerExpr) {
private boolean             selelctAllow               = true;
private boolean             selectWhereAlwayTrueCheck  = true;
private boolean             selectHavingAlwayTrueCheck = true;
private boolean             deleteAllow                = true;
private boolean             deleteWhereAlwayTrueCheck  = true;
private boolean             updateAllow                = true;
private boolean             updateWhereAlayTrueCheck   = true;
private boolean             insertAllow                = true;
private boolean             mergeAllow                 = true;
protected final Set<String> permitFunctions            = new HashSet<String>();
protected final Set<String> permitTables               = new HashSet<String>();
protected final Set<String> permitSchemas              = new HashSet<String>();
protected final Set<String> permitNames                = new HashSet<String>();
protected final Set<String> permitObjects              = new HashSet<String>();
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitObjects() {
return permitObjects;
private int                           whiteSqlMaxLength = 1024;        
protected final WallConfig            config;
WallConfig getConfig();
public MySqlWallProvider(){
WallVisitorUtils.loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-mysql.txt");
WallVisitorUtils.loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-mysql.txt");
WallVisitorUtils.loadResource(config.getPermitFunctions(),
"META-INF/druid-filter-wall-permit-function-mysql.txt");
WallVisitorUtils.loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-mysql.txt");
WallVisitorUtils.loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-mysql.txt");
WallVisitorUtils.loadResource(config.getPermitNames(),
"META-INF/druid-filter-wall-permit-name-mysql-default.txt");
WallVisitorUtils.loadResource(config.getPermitSchemas(),
"META-INF/druid-filter-wall-permit-schema-mysql-default.txt");
WallVisitorUtils.loadResource(config.getPermitFunctions(),
WallVisitorUtils.loadResource(config.getPermitTables(),
"META-INF/druid-filter-wall-permit-table-mysql-default.txt");
WallVisitorUtils.loadResource(config.getPermitObjects(),
"META-INF/druid-filter-wall-permit-object-mysql-default.txt");
return new MySqlWallVisitor(config);
private final WallConfig      config;
private final List<Violation> violations = new ArrayList<Violation>();
public MySqlWallVisitor(WallConfig config){
this.config = config;
public WallConfig getConfig() {
return config;
return config.getPermitObjects().contains(name);
return config.getPermitTables().contains(name);
WallVisitorUtils.loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-oracle.txt");
WallVisitorUtils.loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-oracle.txt");
WallVisitorUtils.loadResource(config.getPermitFunctions(),
"META-INF/druid-filter-wall-permit-function-oracle.txt");
WallVisitorUtils.loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-oracle.txt");
WallVisitorUtils.loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-oracle.txt");
WallVisitorUtils.loadResource(config.getPermitNames(),
"META-INF/druid-filter-wall-permit-name-oracle-default.txt");
WallVisitorUtils.loadResource(config.getPermitSchemas(),
"META-INF/druid-filter-wall-permit-schema-oracle-default.txt");
WallVisitorUtils.loadResource(config.getPermitFunctions(),
WallVisitorUtils.loadResource(config.getPermitTables(),
"META-INF/druid-filter-wall-permit-table-oracle-default.txt");
WallVisitorUtils.loadResource(config.getPermitObjects(),
"META-INF/druid-filter-wall-permit-object-oracle-default.txt");
return new OracleWallVisitor(config);
private final WallConfig      config;
public OracleWallVisitor(WallConfig config){
this.config = config;
public WallConfig getConfig() {
return config;
return config.getPermitTables().contains(name);
public boolean containsPermitObjects(String name) {
return config.getPermitObjects().contains(name);
if (!visitor.getConfig().isSelectHavingAlwayTrueCheck()) {
if (visitor.getConfig().getPermitFunctions().contains(methodName.toLowerCase())) {
if (visitor.getConfig().getPermitSchemas().contains(ownerName.toLowerCase())) {
private boolean             selelctAllow               = true;
private boolean             selectWhereAlwayTrueCheck  = true;
private boolean             selectHavingAlwayTrueCheck = true;
private boolean             deleteAllow                = true;
private boolean             deleteWhereAlwayTrueCheck  = true;
private boolean             updateAllow                = true;
private boolean             updateWhereAlayTrueCheck   = true;
private boolean             insertAllow                = true;
private boolean             mergeAllow                 = true;
protected final Set<String> permitFunctions            = new HashSet<String>();
protected final Set<String> permitTables               = new HashSet<String>();
protected final Set<String> permitSchemas              = new HashSet<String>();
protected final Set<String> permitNames                = new HashSet<String>();
protected final Set<String> permitObjects              = new HashSet<String>();
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitNames() {
return permitNames;
public Set<String> getPermitObjects() {
return permitObjects;
private int                           whiteSqlMaxLength = 1024;        
protected final WallConfig            config;
WallConfig getConfig();
public MySqlWallProvider(){
loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-mysql.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-mysql.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid-filter-wall-permit-function-mysql.txt");
loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-mysql.txt");
loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-mysql.txt");
loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-mysql-default.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-mysql-default.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid-filter-wall-permit-function-mysql-default.txt");
loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-mysql-default.txt");
loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-mysql-default.txt");
return new MySqlWallVisitor(config);
private final WallConfig      config;
private final List<Violation> violations = new ArrayList<Violation>();
public MySqlWallVisitor(WallConfig config){
this.config = config;
public WallConfig getConfig() {
return config;
return config.getPermitObjects().contains(name);
return config.getPermitTables().contains(name);
loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-oracle.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-oracle.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid-filter-wall-permit-function-oracle.txt");
loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-oracle.txt");
loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-oracle.txt");
loadResource(config.getPermitNames(), "META-INF/druid-filter-wall-permit-name-oracle-default.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid-filter-wall-permit-schema-oracle-default.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid-filter-wall-permit-function-oracle-default.txt");
loadResource(config.getPermitTables(), "META-INF/druid-filter-wall-permit-table-oracle-default.txt");
loadResource(config.getPermitObjects(), "META-INF/druid-filter-wall-permit-object-oracle-default.txt");
return new OracleWallVisitor(config);
private final WallConfig      config;
public OracleWallVisitor(WallConfig config){
this.config = config;
public WallConfig getConfig() {
return config;
return config.getPermitTables().contains(name);
public boolean containsPermitObjects(String name) {
return config.getPermitObjects().contains(name);
if (!visitor.getConfig().isSelectHavingAlwayTrueCheck()) {
if (visitor.getConfig().getPermitFunctions().contains(methodName.toLowerCase())) {
if (visitor.getConfig().getPermitSchemas().contains(ownerName.toLowerCase())) {
loadResource(config.getPermitNames(), "META-INF/druid/wall/mysql/permit-name.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid/wall/mysql/permit-schema.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid/wall/mysql/permit-function.txt");
loadResource(config.getPermitTables(), "META-INF/druid/wall/mysql/permit-table.txt");
loadResource(config.getPermitObjects(), "META-INF/druid/wall/mysql/permit-object.txt");
loadResource(config.getPermitNames(), "META-INF/druid/wall/mysql/permit-name-default.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid/wall/mysql/permit-schema-default.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid/wall/mysql/permit-function-default.txt");
loadResource(config.getPermitTables(), "META-INF/druid/wall/mysql/permit-table-default.txt");
loadResource(config.getPermitObjects(), "META-INF/druid/wall/mysql/permit-object-default.txt");
loadResource(config.getPermitNames(), "META-INF/druid/wall/oracle/permit-name.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid/wall/oracle/permit-schema.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid/wall/oracle/permit-function.txt");
loadResource(config.getPermitTables(), "META-INF/druid/wall/oracle/permit-table.txt");
loadResource(config.getPermitObjects(), "META-INF/druid/wall/oracle/permit-object.txt");
loadResource(config.getPermitNames(), "META-INF/druid/wall/oracle/permit-name-default.txt");
loadResource(config.getPermitSchemas(), "META-INF/druid/wall/oracle/permit-schema-default.txt");
loadResource(config.getPermitFunctions(), "META-INF/druid/wall/oracle/permit-function-default.txt");
loadResource(config.getPermitTables(), "META-INF/druid/wall/oracle/permit-table-default.txt");
loadResource(config.getPermitObjects(), "META-INF/druid/wall/oracle/permit-object-default.txt");
public void loadDefault(String dir) {
if (dir.endsWith("/")) {
dir = dir.substring(0, dir.length() - 1);
loadResource(getPermitNames(), dir + "/permit-name-default.txt");
loadResource(getPermitSchemas(), dir + "/permit-schema-default.txt");
loadResource(getPermitFunctions(), dir + "/permit-function-default.txt");
loadResource(getPermitTables(), dir + "/permit-table-default.txt");
loadResource(getPermitObjects(), dir + "/permit-object-default.txt");
public void loadExtend(String dir) {
if (dir.endsWith("/")) {
dir = dir.substring(0, dir.length() - 1);
loadResource(getPermitNames(), dir + "permit-name.txt");
loadResource(getPermitSchemas(), dir + "permit-schema.txt");
loadResource(getPermitFunctions(), dir + "permit-function.txt");
loadResource(getPermitTables(), dir + "permit-table.txt");
loadResource(getPermitObjects(), dir + "permit-object.txt");
config.loadDefault("META-INF/druid/wall/mysql");
config.loadExtend("META-INF/druid/wall/mysql");
return visit((SQLDeleteStatement) x);
if (!config.isDeleteAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
if (!config.isUpdateAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
public boolean visit(MySqlInsertStatement x) {
return visit((SQLInsertStatement) x);
public boolean visit(SQLInsertStatement x) {
if (!config.isInsertAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
return true;
public boolean visit(SQLSelectStatement x) {
if (!config.isSelelctAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
return true;
config.loadDefault("META-INF/druid/wall/oracle");
config.loadExtend("META-INF/druid/wall/oracle");
public boolean visit(SQLSelectStatement x) {
if (!config.isSelelctAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
return true;
public boolean visit(OracleInsertStatement x) {
return visit((SQLInsertStatement) x);
public boolean visit(SQLInsertStatement x) {
if (!config.isInsertAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
return true;
public boolean visit(OracleMultiInsertStatement x) {
if (!config.isInsertAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
return true;
public boolean visit(OracleDeleteStatement x) {
return visit((SQLDeleteStatement) x);
public boolean visit(SQLDeleteStatement x) {
if (!config.isDeleteAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean visit(OracleUpdateStatement x) {
return visit((SQLUpdateStatement) x);
public boolean visit(SQLUpdateStatement x) {
if (!config.isUpdateAllow()) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return false;
WallVisitorUtils.checkCondition(this, x.getWhere());
return true;
public boolean containsPermitSchema(String name) {
name = WallVisitorUtils.form(name);
return this.permitSchemas.contains(name);
WallVisitorUtils.checkFunction(this, x);
if (!config.isTableCheck()) {
return false;
WallVisitorUtils.checkFunction(this, x);
if (!config.isTableCheck()) {
return false;
public static void checkFunction(WallVisitor visitor, SQLMethodInvokeExpr x) {
if (!visitor.getConfig().isFunctionCheck()) {
public boolean isPermitObjects(String name) {
name = WallVisitorUtils.form(name);
return permitObjects.contains(name);
public boolean isPermitSchema(String name) {
name = WallVisitorUtils.form(name);
return this.permitSchemas.contains(name);
public boolean isPermitFunction(String name) {
name = WallVisitorUtils.form(name);
return this.permitFunctions.contains(name);
WallVisitorUtils.checkFunction(this, x);
if (!config.isTableCheck()) {
return false;
WallVisitorUtils.checkFunction(this, x);
if (!config.isTableCheck()) {
return false;
if (visitor.getConfig().isPermitObjects(owner)) {
public static void checkFunction(WallVisitor visitor, SQLMethodInvokeExpr x) {
if (visitor.getConfig().isPermitObjects(owner)) {
if (!visitor.getConfig().isFunctionCheck()) {
if (visitor.getConfig().isPermitFunction(methodName.toLowerCase())) {
return this.tableSource.getAlias();
this.tableSource.setAlias(alias);
return tableSource.getAlias();
this.tableSource.setAlias(alias);
private boolean            hignPriority;
private boolean            straightJoin;
private boolean            smallResult;
private boolean            bigResult;
private boolean            bufferResult;
private Boolean            cache;
private boolean            calcFoundRows;
private SQLOrderBy         orderBy;
private Limit              limit;
private SQLName            procedureName;
private List<SQLExpr>      procedureArgumentList = new ArrayList<SQLExpr>();
private SQLExprTableSource into;
private boolean            forUpdate             = false;
private boolean            lockInShareMode       = false;
public SQLExprTableSource getInto() {
this.into = new SQLExprTableSource(into);
public void setInto(SQLExprTableSource into) {
private SQLExprTableSource                 into;
public SQLExprTableSource getInto() {
this.into = new SQLExprTableSource(into);
public void setInto(SQLExprTableSource into) {
this.into = into;
private static final long serialVersionUID = 1L;
private PGWithClause      with;
private List<SQLExpr>     distinctOn       = new ArrayList<SQLExpr>(2);
private SQLExpr           limit;
private SQLExpr           offset;
private WindowClause      window;
private SQLOrderBy        orderBy;
private FetchClause       fetch;
private ForClause         forClause;
private IntoClause        into;
public IntoClause getInto() {
return into;
public void setInto(IntoClause into) {
this.into = into;
protected void accept0(SQLASTVisitor visitor) {
accept0((PGASTVisitor) visitor);
protected void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.with);
acceptChild(visitor, this.distinctOn);
acceptChild(visitor, this.selectList);
acceptChild(visitor, this.into);
acceptChild(visitor, this.from);
acceptChild(visitor, this.where);
acceptChild(visitor, this.groupBy);
acceptChild(visitor, this.window);
acceptChild(visitor, this.orderBy);
acceptChild(visitor, this.limit);
acceptChild(visitor, this.offset);
acceptChild(visitor, this.fetch);
acceptChild(visitor, this.forClause);
visitor.endVisit(this);
public FetchClause getFetch() {
return fetch;
public void setFetch(FetchClause fetch) {
this.fetch = fetch;
public ForClause getForClause() {
return forClause;
public void setForClause(ForClause forClause) {
this.forClause = forClause;
public WindowClause getWindow() {
return window;
public void setWindow(WindowClause window) {
this.window = window;
public PGWithClause getWith() {
return with;
public void setWith(PGWithClause with) {
this.with = with;
public SQLExpr getLimit() {
return limit;
public void setLimit(SQLExpr limit) {
this.limit = limit;
public SQLOrderBy getOrderBy() {
return orderBy;
public void setOrderBy(SQLOrderBy orderBy) {
this.orderBy = orderBy;
public SQLExpr getOffset() {
return offset;
public void setOffset(SQLExpr offset) {
this.offset = offset;
public List<SQLExpr> getDistinctOn() {
return distinctOn;
public void setDistinctOn(List<SQLExpr> distinctOn) {
this.distinctOn = distinctOn;
public static class WindowClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
private SQLExpr           name;
private List<SQLExpr>     definition       = new ArrayList<SQLExpr>(2);
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
public List<SQLExpr> getDefinition() {
return definition;
public void setDefinition(List<SQLExpr> definition) {
this.definition = definition;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, definition);
visitor.endVisit(this);
public static class FetchClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
public static enum Option {
FIRST, NEX
private Option  option;
private SQLExpr count;
public Option getOption() {
return option;
public void setOption(Option option) {
this.option = option;
public SQLExpr getCount() {
return count;
public void setCount(SQLExpr count) {
this.count = count;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, count);
visitor.endVisit(this);
public static class ForClause extends PGSQLObjectImpl {
private static final long serialVersionUID = 1L;
public static enum Option {
UPDATE, SH
private List<SQLExpr> of = new ArrayList<SQLExpr>(2);
private boolean       noWait;
private Option        option;
public Option getOption() {
return option;
public void setOption(Option option) {
this.option = option;
public List<SQLExpr> getOf() {
return of;
public void setOf(List<SQLExpr> of) {
this.of = of;
public boolean isNoWait() {
return noWait;
public void setNoWait(boolean noWait) {
this.noWait = noWait;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, of);
visitor.endVisit(this);
public static class IntoClause extends PGSQLObjectImpl {
public static enum Option {
TEMPORARY, TEMP, UNLOGGED
private static final long  serialVersionUID = 1L;
private SQLExprTableSource table;
private Option             option;
public Option getOption() {
return option;
public void setOption(Option option) {
this.option = option;
public SQLExprTableSource getTable() {
return table;
public void setTable(SQLExpr table) {
this.table = new SQLExprTableSource(table);
public void setTable(SQLExprTableSource table) {
this.table = table;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, table);
visitor.endVisit(this);
private final static Log     LOG                        = LogFactory.getLog(StatFilter.class);
public final static String   ATTR_SQL                   = "stat.sql";
public final static String   ATTR_UPDATE_COUNT          = "stat.updteCount";
protected JdbcDataSourceStat dataSourceStat;
private boolean              connectionStackTraceEnable = false;
protected DataSourceProxy    dataSource;
protected final AtomicLong   resetCount                 = new AtomicLong();
protected int                maxSqlStatCount            = 1000 * 100;
public final static String   ATTR_TRANSACTION           = "stat.tx";
@Deprecated
protected final JdbcStatementStat  statementStat              = JdbcStatManager.getInstance().getStatementStat();
@Deprecated
protected final JdbcResultSetStat  resultSetStat              = JdbcStatManager.getInstance().getResultSetStat();
this.getAttributes().put(StatFilter.ATTR_TRANSACTION, transcationInfo); 
public class TransactionInfo extends com.alibaba.druid.util.TransactionInfo {
super(id);
public class TransactionInfo {
private final long         id;
private final List<String> sqlList = new ArrayList<String>();
private final long         startTimeMillis;
private long               endTimeMillis;
this.id = id;
this.startTimeMillis = System.currentTimeMillis();
public long getId() {
return id;
public List<String> getSqlList() {
return sqlList;
public long getStartTimeMillis() {
return startTimeMillis;
public long getEndTimeMillis() {
return endTimeMillis;
public void setEndTimeMillis() {
if (endTimeMillis == 0) {
endTimeMillis = System.currentTimeMillis();
public void setEndTimeMillis(long endTimeMillis) {
this.endTimeMillis = endTimeMillis;
private final static Log          LOG                        = LogFactory.getLog(StatFilter.class);
public final static String        ATTR_SQL                   = "stat.sql";
public final static String        ATTR_UPDATE_COUNT          = "stat.updteCount";
public final static String        ATTR_TRANSACTION           = "stat.tx";
protected JdbcDataSourceStat      dataSourceStat;
protected final JdbcStatementStat statementStat              = JdbcStatManager.getInstance().getStatementStat();
protected final JdbcResultSetStat resultSetStat              = JdbcStatManager.getInstance().getResultSetStat();
private boolean                   connectionStackTraceEnable = false;
protected DataSourceProxy         dataSource;
protected final AtomicLong        resetCount                 = new AtomicLong();
protected int                     maxSqlStatCount            = 1000 * 10;
protected long                    slowSqlMillis              = 3 * 1000;
LOG.error("get property error 'druid.stat.maxSqlStatCount' : " + property);
long millis = nanoSpan / (1000 * 1000);
if (millis >= slowSqlMillis) {
List<String> lastSlowParameters = new ArrayList<String>();
for (Object value : statement.getParameters().values()) {
if (value == null) {
lastSlowParameters.add("null");
} else if (value instanceof String) {
lastSlowParameters.add("'" + value.toString() + "'");
} else if (value instanceof Number) {
lastSlowParameters.add(value.toString());
} else if (value instanceof java.util.Date) {
java.util.Date date = (java.util.Date) value;
lastSlowParameters.add(date.getClass().getSimpleName() + "(" + date.getTime() + ")");
} else if (value instanceof Boolean) {
lastSlowParameters.add(value.toString());
} else if (value instanceof InputStream) {
lastSlowParameters.add("<InputStream>");
} else if (value instanceof Clob) {
lastSlowParameters.add("<Clob>");
} else if (value instanceof NClob) {
lastSlowParameters.add("<NClob>");
} else if (value instanceof Blob) {
lastSlowParameters.add("<Blob>");
lastSlowParameters.add("<" + value.getClass() + ">");
sqlStat.setLastSlowParameters(lastSlowParameters);
Map<Integer, JdbcParameter> getParameters();
public Map<Integer, JdbcParameter> getParameters() {
return Collections.emptyMap();
return getAliveNanoTotal() / (1000 * 1000);
private List<String>     lastSlowParameters;
public List<String> getLastSlowParameters() {
return lastSlowParameters;
public void setLastSlowParameters(List<String> lastSlowParameters) {
this.lastSlowParameters = lastSlowParameters;
Map<Integer, JdbcParameter> parameters = statement.getParameters();
String[] lastSlowParameters = new String[parameters.size()];
int index = 0;
for (JdbcParameter parameter : statement.getParameters().values()) {
Object value = parameter.getValue();
lastSlowParameters[index] = "null";
lastSlowParameters[index] = "'" + value.toString() + "'";
lastSlowParameters[index] = value.toString();
lastSlowParameters[index] = date.getClass().getSimpleName() + "(" + date.getTime() + ")";
lastSlowParameters[index] = value.toString();
lastSlowParameters[index] = "<InputStream>";
lastSlowParameters[index] = "<Clob>";
lastSlowParameters[index] = "<NClob>";
lastSlowParameters[index] = "<Blob>";
lastSlowParameters[index] = "<" + value.getClass() + ">";
public static boolean isValidateMySql(String sql, WallConfig config) {
MySqlWallProvider provider = new MySqlWallProvider(config);
return provider.check(sql, false);
public static boolean isValidateOracle(String sql, WallConfig config) {
OracleWallProvider provider = new OracleWallProvider(config);
return provider.check(sql, false);
WallVisitorUtils.checkDelete(this, x);
WallVisitorUtils.checkUpdate(this, x);
WallVisitorUtils.checkDelete(this, x);
WallVisitorUtils.checkUpdate(this, x);
public static void checkDelete(WallVisitor visitor, SQLDeleteStatement x) {
if (!visitor.getConfig().isDeleteAllow()) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (x.getWhere() == null || Boolean.TRUE == getValue(x.getWhere())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public static void checkUpdate(WallVisitor visitor, SQLUpdateStatement x) {
if (!visitor.getConfig().isUpdateAllow()) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (x.getWhere() == null || Boolean.TRUE == getValue(x.getWhere())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
private String[]         lastSlowParameters;
public String[] getLastSlowParameters() {
public void setLastSlowParameters(String[] lastSlowParameters) {
new ArrayType<Long>(SimpleType.LONG, true), 
new ArrayType<Long>(SimpleType.STRING, true), 
"Histogram", 
"LastSlowParameters"
map.put("LastSlowParameters", lastSlowParameters);
public class WallDeleteTest extends TestCase {
private String sql = "DELETE FROM T WHERE F1 = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setDeleteAllow(false);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class WallDeleteWhereTest1 extends TestCase {
private String sql = "DELETE FROM T";
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql));
public class WallInsertTest extends TestCase {
private String sql = "INSERT INTO T (F1, F2) VALUES (1, 2)";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setInsertAllow(false);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class WallInsertTest2 extends TestCase {
private String sql = "INSERT INTO T (F1, F2) VALUES (1, 2)";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setInsertAllow(true);
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle(sql, config));
public class WallUpdateTest extends TestCase {
private String sql = "UPDATE T_USER SET FNAME = ? WHERE FID = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setDeleteAllow(false);
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle(sql, config));
public class WallUpdateTest1 extends TestCase {
private String sql = "UPDATE T_USER SET FNAME = ? WHERE FID = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setUpdateAllow(false);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class WallUpdateTest2 extends TestCase {
private String sql = "UPDATE T_USER SET FNAME = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setUpdateAllow(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class WallUpdateTest3 extends TestCase {
private String sql = "UPDATE T_USER SET FNAME = ? WHERE 1 = 1";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setUpdateAllow(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class WallUpdateTest4 extends TestCase {
private String sql = "UPDATE T_USER SET FNAME = ? WHERE FID = ? OR 1 = 1";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setUpdateAllow(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
void destory();
public void destory() {
public synchronized void init(DataSourceProxy dataSource) {
public synchronized void destory() {
if (dataSource == null) {
ConcurrentMap<String, JdbcDataSourceStat> dataSourceStats = JdbcStatManager.getInstance().getDataSources();
String url = dataSource.getUrl();
dataSourceStats.remove(url);
dataSource = null;
for (Filter filter : filters) {
filter.destory();
if (variants.containsKey(ident)) {
return false;
new ArrayType<String>(SimpleType.STRING, false), 
dataSource.init();
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat dataSourceStat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getCloseCount()); 
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getCloseCount());
dataSource.init();
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat stat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(0, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, stat.getConnectionStat().getCloseCount()); 
Assert.assertEquals(0, JdbcStatManager.getInstance().getDataSources().size());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getDataSources().size());
dataSource.init();
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat stat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(10, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(10, stat.getConnectionStat().getConnectCount());
void destory();
public void destory() {
public synchronized void init(DataSourceProxy dataSource) {
public synchronized void destory() {
if (dataSource == null) {
ConcurrentMap<String, JdbcDataSourceStat> dataSourceStats = JdbcStatManager.getInstance().getDataSources();
String url = dataSource.getUrl();
dataSourceStats.remove(url);
dataSource = null;
private final static Log LOG          = LogFactory.getLog(WallFilter.class);
private boolean          inited       = false;
private WallProvider     provider;
private boolean          loadDefault;
private boolean          loadExtend;
private boolean          logViolation = false;
private WallConfig       config       = new WallConfig();
public boolean isLogViolation() {
return logViolation;
public void setLogViolation(boolean logViolation) {
this.logViolation = logViolation;
provider.check(sql, true);
} catch (WallRuntimeException e) {
if (isLogViolation()) {
LOG.error("sql injection violation : " + sql, e);
for (Filter filter : filters) {
filter.destory();
if (variants.containsKey(ident)) {
return false;
new ArrayType<String>(SimpleType.STRING, false), 
dataSource.init();
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat dataSourceStat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, dataSourceStat.getConnectionStat().getCloseCount()); 
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, dataSourceStat.getConnectionStat().getCloseCount());
dataSource.init();
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat stat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(0, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(0, stat.getConnectionStat().getCloseCount()); 
Assert.assertEquals(0, JdbcStatManager.getInstance().getDataSources().size());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(1, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(1, stat.getConnectionStat().getCloseCount());
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getDataSources().size());
dataSource.init();
Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
Assert.assertEquals(1, JdbcStatManager.getInstance().getDataSources().size());
JdbcDataSourceStat stat = JdbcStatManager.getInstance().getDataSources().values().iterator().next();
Assert.assertEquals(10, stat.getConnectionStat().getConnectCount());
Assert.assertEquals(10, stat.getConnectionStat().getConnectCount());
private String              dir;
private boolean             loadDefault                = true;
private boolean             loadExtend                 = true;
public WallConfig(){
public WallConfig(String dir){
this.dir = dir;
this.init();
public String getDir() {
return dir;
public void setDir(String dir) {
this.dir = dir;
public void init() {
if (loadDefault) {
loadDefault(dir);
if (loadExtend) {
loadExtend(dir);
public boolean isLoadDefault() {
return loadDefault;
public void setLoadDefault(boolean loadDefault) {
this.loadDefault = loadDefault;
public boolean isLoadExtend() {
return loadExtend;
public void setLoadExtend(boolean loadExtend) {
this.loadExtend = loadExtend;
private String           dbType;
private WallConfig       config;
String dbType = this.dbType;
if (this.dbType == null || this.dbType.trim().length() == 0) {
this.dbType = dataSource.getDbType();
if (JdbcUtils.MYSQL.equals(dbType)) {
provider = new MySqlWallProvider(config);
if (config == null) {
config = new WallConfig(MySqlWallProvider.DEFAULT_CONFIG_DIR);
} else if (JdbcUtils.ORACLE.equals(dbType)) {
provider = new OracleWallProvider(config);
if (config == null) {
config = new WallConfig(OracleWallProvider.DEFAULT_CONFIG_DIR);
throw new IllegalStateException("dbType not support : " + dbType);
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public final static String DEFAULT_CONFIG_DIR = "META-INF/druid/wall/mysql";
this(new WallConfig(DEFAULT_CONFIG_DIR));
public final static String DEFAULT_CONFIG_DIR = "META-INF/druid/wall/oracle";
this(new WallConfig(DEFAULT_CONFIG_DIR));
public static final String      MOCK             = "mock";
return MOCK;
private String              dir;
private boolean             loadDefault                = true;
private boolean             loadExtend                 = true;
private boolean             inited;
public WallConfig(){
public boolean isInited() {
return inited;
public WallConfig(String dir){
this.dir = dir;
this.init();
public String getDir() {
return dir;
public void setDir(String dir) {
this.dir = dir;
public void init() {
if (loadDefault) {
loadDefault(dir);
if (loadExtend) {
loadExtend(dir);
inited = true;
public boolean isLoadDefault() {
return loadDefault;
public void setLoadDefault(boolean loadDefault) {
this.loadDefault = loadDefault;
public boolean isLoadExtend() {
return loadExtend;
public void setLoadExtend(boolean loadExtend) {
this.loadExtend = loadExtend;
private String           dbType;
private WallConfig       config;
String dbType = this.dbType;
if (this.dbType == null || this.dbType.trim().length() == 0) {
this.dbType = dataSource.getDbType();
if (JdbcUtils.MYSQL.equals(dbType)) {
provider = new MySqlWallProvider(config);
if (config == null) {
config = new WallConfig(MySqlWallProvider.DEFAULT_CONFIG_DIR);
} else if (JdbcUtils.ORACLE.equals(dbType)) {
provider = new OracleWallProvider(config);
if (config == null) {
config = new WallConfig(OracleWallProvider.DEFAULT_CONFIG_DIR);
throw new IllegalStateException("dbType not support : " + dbType);
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public final static String DEFAULT_CONFIG_DIR = "META-INF/druid/wall/mysql";
this(new WallConfig(DEFAULT_CONFIG_DIR));
public final static String DEFAULT_CONFIG_DIR = "META-INF/druid/wall/oracle";
this(new WallConfig(DEFAULT_CONFIG_DIR));
public static final String      MOCK             = "mock";
return MOCK;
loadConfig(dir);
public void loadConfig(String dir) {
loadResource(getPermitNames(), dir + "/permit-name.txt");
loadResource(getPermitSchemas(), dir + "/permit-schema.txt");
loadResource(getPermitFunctions(), dir + "/permit-function.txt");
loadResource(getPermitTables(), dir + "/permit-table.txt");
loadResource(getPermitObjects(), dir + "/permit-object.txt");
private boolean             selectIntoAllow            = true;
loadConfig(dir);
public void loadConfig(String dir) {
loadResource(getPermitNames(), dir + "/permit-name.txt");
loadResource(getPermitSchemas(), dir + "/permit-schema.txt");
loadResource(getPermitFunctions(), dir + "/permit-function.txt");
loadResource(getPermitTables(), dir + "/permit-table.txt");
loadResource(getPermitObjects(), dir + "/permit-object.txt");
public boolean isSelectIntoAllow() {
return selectIntoAllow;
public void setSelectIntoAllow(boolean selectIntoAllow) {
this.selectIntoAllow = selectIntoAllow;
WallVisitorUtils.checkSelelct(this, x);
WallVisitorUtils.checkSelelct(this, x);
WallVisitorUtils.checkSelelct(this, x);
WallVisitorUtils.checkSelelct(this, x);
public static void checkSelelct(WallVisitor visitor, SQLSelectQueryBlock x) {
if (!visitor.getConfig().isSelectIntoAllow() && x.getInto() != null) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (!visitor.getConfig().isSelectWhereAlwayTrueCheck()) {
SQLExpr where = x.getWhere();
if (where != null && Boolean.TRUE == getValue(where)) {
if (where instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) where;
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
protected SQLTableSource            from;
protected SQLExprTableSource        into;
public SQLExprTableSource getInto() {
return into;
public void setInto(SQLExpr into) {
this.into = new SQLExprTableSource(into);
public void setInto(SQLExprTableSource into) {
this.into = into;
private boolean       hignPriority;
private boolean       straightJoin;
private boolean       smallResult;
private boolean       bigResult;
private boolean       bufferResult;
private Boolean       cache;
private boolean       calcFoundRows;
private SQLOrderBy    orderBy;
private Limit         limit;
private SQLName       procedureName;
private List<SQLExpr> procedureArgumentList = new ArrayList<SQLExpr>();
private boolean       forUpdate             = false;
private boolean       lockInShareMode       = false;
if (identifierEquals("OUTFILE")) {
MySqlOutFileExpr outFile = new MySqlOutFileExpr();
outFile.setFile(expr());
queryBlock.setInto(outFile);
if (identifierEquals("FIELDS") || identifierEquals("COLUMNS")) {
if (identifierEquals("TERMINATED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsTerminatedBy((SQLLiteralExpr) expr());
if (identifierEquals("OPTIONALLY")) {
lexer.nextToken();
outFile.setColumnsEnclosedOptionally(true);
if (identifierEquals("ENCLOSED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsEnclosedBy((SQLLiteralExpr) expr());
if (identifierEquals("ESCAPED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsEscaped((SQLLiteralExpr) expr());
if (identifierEquals("LINES")) {
if (identifierEquals("STARTING")) {
lexer.nextToken();
accept(Token.BY);
outFile.setLinesStartingBy((SQLLiteralExpr) expr());
identifierEquals("TERMINATED");
lexer.nextToken();
accept(Token.BY);
outFile.setLinesTerminatedBy((SQLLiteralExpr) expr());
queryBlock.setInto(this.createExprParser().name());
SQLExpr expr = this.createExprParser().name();
queryBlock.setInto(expr);
private IntoOption        intoOption;
public static enum IntoOption {
TEMPORARY, TEMP, UNLOGGED
public IntoOption getIntoOption() {
return intoOption;
public void setIntoOption(IntoOption intoOption) {
this.intoOption = intoOption;
queryBlock.setIntoOption(IntoOption.TEMPORARY);
queryBlock.setIntoOption(IntoOption.TEMP);
queryBlock.setIntoOption(IntoOption.UNLOGGED);
queryBlock.setInto(new SQLExprTableSource(name));
void endVisit(PGSelectQueryBlock x);
boolean visit(PGSelectQueryBlock x);
void endVisit(PGSelectQueryBlock.WindowClause x);
public void endVisit(PGSelectQueryBlock x) {
public boolean visit(PGSelectQueryBlock x) {
return true;
if (x.getIntoOption() != null) {
print(x.getIntoOption().name());
print(" ");
public void endVisit(PGSelectQueryBlock x) {
public void endVisit(PGSelectQueryBlock x) {
public boolean visit(PGSelectQueryBlock x) {
this.visit((SQLSelectQueryBlock) x);
return false;
public class WallSelectIntoTest extends TestCase {
private String sql = "SELECT F1, F2 INTO T2 FROM T1";
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle(sql));
public class WallSelectIntoTest1 extends TestCase {
private String sql = "SELECT F1, F2 INTO T2 FROM T1";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setSelectIntoAllow(false);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
private boolean             selectIntoOutfileAllow     = false;
public boolean isSelectIntoOutfileAllow() {
return selectIntoOutfileAllow;
public void setSelectIntoOutfileAllow(boolean selectIntoOutfileAllow) {
this.selectIntoOutfileAllow = selectIntoOutfileAllow;
if (!config.isSelectIntoOutfileAllow()) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
private boolean             selectIntoOutfileAllow     = false;
private boolean             selectUnionCheck           = true;
public boolean isSelectIntoOutfileAllow() {
return selectIntoOutfileAllow;
public void setSelectIntoOutfileAllow(boolean selectIntoOutfileAllow) {
this.selectIntoOutfileAllow = selectIntoOutfileAllow;
public boolean isSelectUnionCheck() {
return selectUnionCheck;
public void setSelectUnionCheck(boolean selectUnionCheck) {
this.selectUnionCheck = selectUnionCheck;
if (!config.isSelectIntoOutfileAllow()) {
violations.add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
return true;
WallVisitorUtils.checkUnion(this, x);
WallVisitorUtils.checkUnion(this, x);
public static void checkUnion(WallVisitor visitor, SQLUnionQuery x) {
if (!visitor.getConfig().isSelectUnionCheck()) {
if (WallVisitorUtils.queryBlockFromIsNull(x.getLeft()) || WallVisitorUtils.queryBlockFromIsNull(x.getRight())) {
visitor.getViolations().add(new IllegalSQLObjectViolation(SQLUtils.toMySqlString(x)));
private boolean             schemaCheck                = true;
public boolean isSchemaCheck() {
return schemaCheck;
public void setSchemaCheck(boolean schemaCheck) {
this.schemaCheck = schemaCheck;
if (!objectCheck) {
return false;
if (!schemaCheck) {
return false;
if (!functionCheck) {
return false;
public void test_default() throws Exception {
public void test_allow() throws Exception {
WallConfig config = new WallConfig();
config.setTableCheck(false);
Assert.assertTrue(WallUtils.isValidateMySql("select benchmark( 500000, sha1( 'test' ) )", config));
public void test_permitTable_allow() throws Exception {
WallConfig config = new WallConfig();
config.setFunctionCheck(false);
Assert.assertTrue(WallUtils.isValidateOracle("select SYS_CONTEXT ('USERENV', 'CURRENT_USER') from dual", config));
public void test_permitTable_allow() throws Exception {
WallConfig config = new WallConfig();
config.setObjectCheck(false);
Assert.assertTrue(WallUtils.isValidateOracle("select  sys.LinxReadFile('c:/boot.ini') from dual", config));
Assert.assertTrue(WallUtils.isValidateOracle("select  sys.LinxRunCMD('cmd /c net user linx /add') from dual", config));
Assert.assertTrue(WallUtils.isValidateOracle("select utl_inaddr.get_host_address from DUAL", config));
Assert.assertTrue(WallUtils.isValidateOracle("select TO_CHAR(utl_inaddr.get_host_address) from DUAL", config));
Assert.assertTrue(WallUtils.isValidateOracle("SELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT'.PUT(:P1));", config));
Assert.assertTrue(WallUtils.isValidateOracle("select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES()", config));
} catch (ParserException e) {
return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));
return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));
return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));
stmt.accept(visitor);
} catch (ParserException e) {
return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));
public class SQLServerProvider extends WallProvider {
public SQLServerProvider(WallConfig config) {
super(config);
@Override
public SQLStatementParser createParser(String sql) {
return null;
@Override
public WallVisitor createWallVisitor() {
return null;
MySqlLexer lexer = new MySqlLexer(sql);
lexer.setAllowComment(false);
return new MySqlStatementParser(lexer);
OracleLexer lexer = new OracleLexer(sql);
lexer.setAllowComment(false);
return new OracleStatementParser(lexer);
public final static String DEFAULT_CONFIG_DIR = "META-INF/druid/wall/sqlserver";
public SQLServerProvider() {
this(new WallConfig(DEFAULT_CONFIG_DIR));
public SQLServerProvider(WallConfig config){
return new SQLServerStatementParser(sql);
return new SQLServerWallVisitor(config);
public class SQLServerWallVisitor implements WallVisitor {
private final WallConfig      config;
public SQLServerWallVisitor(WallConfig config) {
this.config = config;
@Override
public void endVisit(SQLAllColumnExpr x) {
@Override
public void endVisit(SQLBetweenExpr x) {
@Override
public void endVisit(SQLBinaryOpExpr x) {
@Override
public void endVisit(SQLCaseExpr x) {
@Override
public void endVisit(Item x) {
@Override
public void endVisit(SQLCharExpr x) {
@Override
public void endVisit(SQLIdentifierExpr x) {
@Override
public void endVisit(SQLInListExpr x) {
@Override
public void endVisit(SQLIntegerExpr x) {
@Override
public void endVisit(SQLExistsExpr x) {
@Override
public void endVisit(SQLNCharExpr x) {
@Override
public void endVisit(SQLNotExpr x) {
@Override
public void endVisit(SQLNullExpr x) {
@Override
public void endVisit(SQLNumberExpr x) {
@Override
public void endVisit(SQLPropertyExpr x) {
@Override
public void endVisit(SQLSelectGroupByClause x) {
@Override
public void endVisit(SQLSelectItem x) {
@Override
public void endVisit(SQLSelectStatement selectStatement) {
@Override
public void postVisit(SQLObject astNode) {
@Override
public void preVisit(SQLObject astNode) {
@Override
public boolean visit(SQLAllColumnExpr x) {
return false;
@Override
public boolean visit(SQLBetweenExpr x) {
return false;
@Override
public boolean visit(SQLBinaryOpExpr x) {
return false;
@Override
public boolean visit(SQLCaseExpr x) {
return false;
@Override
public boolean visit(Item x) {
return false;
@Override
public boolean visit(SQLCastExpr x) {
return false;
@Override
public boolean visit(SQLCharExpr x) {
return false;
@Override
public boolean visit(SQLExistsExpr x) {
return false;
@Override
public boolean visit(SQLIdentifierExpr x) {
return false;
@Override
public boolean visit(SQLInListExpr x) {
return false;
@Override
public boolean visit(SQLIntegerExpr x) {
return false;
@Override
public boolean visit(SQLNCharExpr x) {
return false;
@Override
public boolean visit(SQLNotExpr x) {
return false;
@Override
public boolean visit(SQLNullExpr x) {
return false;
@Override
public boolean visit(SQLNumberExpr x) {
return false;
@Override
public boolean visit(SQLPropertyExpr x) {
return false;
@Override
public boolean visit(SQLSelectGroupByClause x) {
return false;
@Override
public boolean visit(SQLSelectItem x) {
return false;
@Override
public void endVisit(SQLCastExpr x) {
@Override
public boolean visit(SQLSelectStatement astNode) {
return false;
@Override
public void endVisit(SQLAggregateExpr astNode) {
@Override
public boolean visit(SQLAggregateExpr astNode) {
return false;
@Override
public boolean visit(SQLVariantRefExpr x) {
return false;
@Override
public void endVisit(SQLVariantRefExpr x) {
@Override
public boolean visit(SQLQueryExpr x) {
return false;
@Override
public void endVisit(SQLQueryExpr x) {
@Override
public boolean visit(SQLUnaryExpr x) {
return false;
@Override
public void endVisit(SQLUnaryExpr x) {
@Override
public boolean visit(SQLHexExpr x) {
return false;
@Override
public void endVisit(SQLHexExpr x) {
@Override
public boolean visit(SQLBitStringLiteralExpr x) {
return false;
@Override
public void endVisit(SQLBitStringLiteralExpr x) {
@Override
public boolean visit(SQLHexStringLiteralExpr x) {
return false;
@Override
public void endVisit(SQLHexStringLiteralExpr x) {
@Override
public boolean visit(SQLDateLiteralExpr x) {
return false;
@Override
public void endVisit(SQLDateLiteralExpr x) {
@Override
public boolean visit(SQLSelect x) {
return false;
@Override
public void endVisit(SQLSelect select) {
@Override
public boolean visit(SQLSelectQueryBlock x) {
return false;
@Override
public void endVisit(SQLSelectQueryBlock x) {
@Override
public boolean visit(SQLExprTableSource x) {
return false;
@Override
public void endVisit(SQLExprTableSource x) {
@Override
public boolean visit(SQLIntervalLiteralExpr x) {
return false;
@Override
public void endVisit(SQLIntervalLiteralExpr x) {
@Override
public boolean visit(SQLOrderBy x) {
return false;
@Override
public void endVisit(SQLOrderBy x) {
@Override
public boolean visit(SQLSelectOrderByItem x) {
return false;
@Override
public void endVisit(SQLSelectOrderByItem x) {
@Override
public boolean visit(SQLDropTableStatement x) {
return false;
@Override
public void endVisit(SQLDropTableStatement x) {
@Override
public boolean visit(SQLCreateTableStatement x) {
return false;
@Override
public void endVisit(SQLCreateTableStatement x) {
@Override
public boolean visit(SQLTableElement x) {
return false;
@Override
public void endVisit(SQLTableElement x) {
@Override
public boolean visit(SQLColumnDefinition x) {
return false;
@Override
public void endVisit(SQLColumnDefinition x) {
@Override
public boolean visit(SQLDataType x) {
return false;
@Override
public void endVisit(SQLDataType x) {
@Override
public boolean visit(SQLDeleteStatement x) {
return false;
@Override
public void endVisit(SQLDeleteStatement x) {
@Override
public boolean visit(SQLCurrentOfCursorExpr x) {
return false;
@Override
public void endVisit(SQLCurrentOfCursorExpr x) {
@Override
public boolean visit(SQLInsertStatement x) {
return false;
@Override
public void endVisit(SQLInsertStatement x) {
@Override
public boolean visit(ValuesClause x) {
return false;
@Override
public void endVisit(ValuesClause x) {
@Override
public boolean visit(SQLUpdateSetItem x) {
return false;
@Override
public void endVisit(SQLUpdateSetItem x) {
@Override
public boolean visit(SQLUpdateStatement x) {
return false;
@Override
public void endVisit(SQLUpdateStatement x) {
@Override
public boolean visit(SQLCreateViewStatement x) {
return false;
@Override
public void endVisit(SQLCreateViewStatement x) {
@Override
public boolean visit(SQLUniqueConstraint x) {
return false;
@Override
public void endVisit(SQLUniqueConstraint x) {
@Override
public boolean visit(NotNullConstraint x) {
return false;
@Override
public void endVisit(NotNullConstraint x) {
@Override
public void endVisit(SQLMethodInvokeExpr x) {
@Override
public boolean visit(SQLMethodInvokeExpr x) {
return false;
@Override
public void endVisit(SQLUnionQuery x) {
@Override
public boolean visit(SQLUnionQuery x) {
return false;
@Override
public void endVisit(SQLSetStatement x) {
@Override
public boolean visit(SQLSetStatement x) {
return false;
@Override
public void endVisit(SQLAssignItem x) {
@Override
public boolean visit(SQLAssignItem x) {
return false;
@Override
public void endVisit(SQLCallStatement x) {
@Override
public boolean visit(SQLCallStatement x) {
return false;
@Override
public void endVisit(SQLJoinTableSource x) {
@Override
public boolean visit(SQLJoinTableSource x) {
return false;
@Override
public void endVisit(SQLSomeExpr x) {
@Override
public boolean visit(SQLSomeExpr x) {
return false;
@Override
public void endVisit(SQLAnyExpr x) {
@Override
public boolean visit(SQLAnyExpr x) {
return false;
@Override
public void endVisit(SQLAllExpr x) {
@Override
public boolean visit(SQLAllExpr x) {
return false;
@Override
public void endVisit(SQLInSubQueryExpr x) {
@Override
public boolean visit(SQLInSubQueryExpr x) {
return false;
@Override
public void endVisit(SQLListExpr x) {
@Override
public boolean visit(SQLListExpr x) {
return false;
@Override
public void endVisit(SQLSubqueryTableSource x) {
@Override
public boolean visit(SQLSubqueryTableSource x) {
return false;
@Override
public void endVisit(SQLTruncateStatement x) {
@Override
public boolean visit(SQLTruncateStatement x) {
return false;
@Override
public void endVisit(SQLDefaultExpr x) {
@Override
public boolean visit(SQLDefaultExpr x) {
return false;
@Override
public void endVisit(SQLCommentStatement x) {
@Override
public boolean visit(SQLCommentStatement x) {
return false;
@Override
public WallConfig getConfig() {
return null;
@Override
public List<Violation> getViolations() {
return null;
@Override
public boolean isPermitTable(String name) {
return false;
@Override
public String toSQL(SQLObject obj) {
return null;
return new MySqlStatementParser(sql);
return new OracleStatementParser(sql);
public class SQLServerWallVisitor extends SQLServerASTVisitorAdapter implements WallVisitor, SQLServerASTVisitor{
private final List<Violation> violations = new ArrayList<Violation>();
public WallConfig getConfig() {
return this.config;
public List<Violation> getViolations() {
return violations;
public boolean isPermitTable(String name) {
if(!config.isTableCheck()){
return false;
name = WallVisitorUtils.form(name);
return config.getPermitTables().contains(name);
return SQLUtils.toMySqlString(obj);
public static String toSQLServerString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new SQLServerOutputVisitor(out));
String sql = out.toString();
return sql;
public boolean checkValid(String sql) {
return check(sql).size() == 0;
return provider.checkValid(sql);
return provider.checkValid(sql);
return provider.checkValid(sql);
return provider.checkValid(sql);
} else if (JdbcUtils.SQL_SERVER.equals(dbType)) {
provider = new SQLServerProvider(config);
if (config == null) {
config = new WallConfig(SQLServerProvider.DEFAULT_CONFIG_DIR);
public static boolean isValidateSqlServer(String sql) {
SQLServerProvider provider = new SQLServerProvider();
return provider.checkValid(sql);
public static boolean isValidateSqlServer(String sql, WallConfig config) {
SQLServerProvider provider = new SQLServerProvider(config);
return provider.checkValid(sql);
public class MySqlWallPermitTableTest extends TestCase {
public void test_default() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql("select benchmark( 500000, sha1( 'test' ) )"));
public void test_allow() throws Exception {
WallConfig config = new WallConfig();
config.setTableCheck(false);
Assert.assertTrue(WallUtils.isValidateMySql("select benchmark( 500000, sha1( 'test' ) )", config));
public interface SQLServerStatement extends SQLStatement {
public class SQLServerUseStatement extends SQLServerObjectImpl implements SQLServerStatement {
private static final long serialVersionUID = 1L;
private SQLName           database;
public SQLName getDatabase() {
return database;
public void setDatabase(SQLName database) {
this.database = database;
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, database);
visitor.endVisit(this);
map.put("USE", Token.USE);
boolean visit(SQLServerUseStatement x);
void endVisit(SQLServerUseStatement x);
public boolean visit(SQLServerUseStatement x) {
return true;
public void endVisit(SQLServerUseStatement x) {
public boolean visit(SQLServerUseStatement x) {
print("USE ");
x.getDatabase().accept(this);
return false;
public void endVisit(SQLServerUseStatement x) {
public boolean visit(SQLServerUseStatement x) {
return false;
public void endVisit(SQLServerUseStatement x) {
if (lexer.token() == Token.USE) {
SQLStatement stmt = parseUse();
statementList.add(stmt);
public SQLStatement parseUse() {
throw new ParserException("TODO " + lexer.token());
USE("USE"),
public class SQLServerSelectTest extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "USE AdventureWorks2008R2;";
String expect = "USE AdventureWorks2008R2;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
Assert.assertFalse(WallUtils.isValidateSqlServer("select * from sysdatabases"));
public class SQLServerWallTest extends TestCase {
public SQLServerWallTest(String name) {
super(name);
protected void setUp() throws Exception {
super.setUp();
protected void tearDown() throws Exception {
super.tearDown();
public void test_stuff() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT @@version"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT 1  comment"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT comment1"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT user_name();"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT system_user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT loginame FROM master..sysprocesses WHERE spid = @@SPID"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, password FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, password_hash FROM master.sys.sql_logins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name + - + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, DATABASE); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, SERVER); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(master..syslogins, OBJECT);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(sa, USER);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(dbcreator);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(bulkadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(diskadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(processadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(serveradmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(setupadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(securityadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE denylogin = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE hasaccess = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE isntname = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE isntgroup = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE sysadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE securityadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE serveradmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE setupadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE processadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE diskadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE dbcreator = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE bulkadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin, sa); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE sysadmin = 1 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME()"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..sysdatabases;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME(0); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = mytable);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=sometable; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..sysobjects WHERE xtype = U;  use xtype = V for views SELECT name FROM someotherdb..sysobjects WHERE xtype = U; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT sysobjects.name as tablename, syscolumns.name as columnname FROM sysobjects JOIN syscolumns ON sysobjects.id = syscolumns.id WHERE sysobjects.xtype = U AND syscolumns.name LIKE %PASSWORD% "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT TOP 1 name FROM (SELECT TOP 9 name FROM master..syslogins ORDER BY name ASC) sq ORDER BY name DESC "));
Assert.assertFalse(WallUtils.isValidateSqlServer("WAITFOR DELAY 0:0:5 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT HOST_NAME()"));
Assert.assertFalse(WallUtils.isValidateSqlServer("BULK INSERT mydata FROM c:boot.ini;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_addlogin user, pass; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_droplogin user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC master.dbo.sp_addsrvrolemember user, sysadmin"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_helpdb master"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_helpdb pubs"));
public class SQLUseStatement extends SQLStatementImpl implements SQLStatement {
public void accept0(SQLASTVisitor visitor) {
public SQLUseStatement parseUse() {
accept(Token.USE);
SQLUseStatement stmt = new SQLUseStatement();
stmt.setDatabase(this.exprParser.name());
return stmt;
public boolean visit(SQLUseStatement x) {
print("USE ");
x.getDatabase().accept(this);
return false;
void endVisit(SQLUseStatement x);
boolean visit(SQLUseStatement x);
public void endVisit(SQLUseStatement x) {
public boolean visit(SQLUseStatement x) {
return true;
String expect = "USE AdventureWorks2008R2";
SQLStatement stmt = parser.parseStatementList().get(0);
public class SQLServerSelectTest1 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "USE AdventureWorks2008R2;";
String expect = "USE AdventureWorks2008R2";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
protected final Set<String> readOnlyTables             = new HashSet<String>();
public Set<String> getReadOnlyTables() {
return readOnlyTables;
WallVisitorUtils.checkInsert(this, x);
violations.add(new IllegalSQLObjectViolation(toSQL(x)));
WallVisitorUtils.checkInsert(this, x);
public boolean visit(InsertIntoClause x) {
WallVisitorUtils.checkInsert(this, x);
return true;
public static void checkInsert(WallVisitor visitor, SQLInsertInto x) {
checkReadOnly(visitor, x.getTableSource());
if (!visitor.getConfig().isInsertAllow()) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (x.getInto() != null) {
checkReadOnly(visitor, x.getInto());
checkReadOnly(visitor, x.getTableSource());
public static void checkReadOnly(WallVisitor visitor, SQLTableSource tableSource) {
if (tableSource instanceof SQLExprTableSource) {
String tableName = null;
SQLExpr tableNameExpr = ((SQLExprTableSource) tableSource).getExpr();
if (tableNameExpr instanceof SQLIdentifierExpr) {
tableName = tableNameExpr.toString();
} else if (tableNameExpr instanceof SQLPropertyExpr) {
tableName = ((SQLPropertyExpr) tableNameExpr).getName();
if (tableName != null) {
tableName = form(tableName);
if (visitor.getConfig().getReadOnlyTables().contains(tableName)) {
addViolation(visitor, tableSource);
} else if (tableSource instanceof SQLJoinTableSource) {
SQLJoinTableSource join = (SQLJoinTableSource) tableSource;
checkReadOnly(visitor, join.getLeft());
checkReadOnly(visitor, join.getRight());
checkReadOnly(visitor, x.getTableSource());
if (x.getInto().getExpr() instanceof SQLName) {
SQLName into = (SQLName) x.getInto().getExpr();
String ident = into.toString();
TableStat stat = getTableStat(ident);
if (stat != null) {
stat.incrementInsertCount();
accept(x.getFrom());
accept(x.getUsing());
x.getTableSource().accept(this);
String alias = x.getAlias();
if (alias != null && !aliasMap.containsKey(alias)) {
aliasMap.put(alias, ident);
if (!aliasMap.containsKey(ident)) {
aliasMap.put(ident, ident);
public class MySqlDeleteTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE a1, a2 FROM t1 AS a1 INNER JOIN t2 AS a2 WHERE a1.id=a2.id;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDeleteTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE FROM a1, a2 USING t1 AS a1 INNER JOIN t2 AS a2 WHERE a1.id=a2.id;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDeleteTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(3, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDescribeStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private SQLName           object;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, object);
visitor.endVisit(this);
public SQLName getObject() {
return object;
public void setObject(SQLName object) {
this.object = object;
if (identifierEquals("DESCRIBE")) {
SQLStatement stmt = parseDescribe();
statementList.add(stmt);
return true;
public SQLStatement parseDescribe() throws ParserException {
acceptIdentifier("DESCRIBE");
MySqlDescribeStatement stmt = new MySqlDescribeStatement();
stmt.setObject(this.exprParser.name());
return stmt;
boolean visit(MySqlDescribeStatement x);
void endVisit(MySqlDescribeStatement x);
public boolean visit(MySqlDescribeStatement x) {
return true;
public void endVisit(MySqlDescribeStatement x) {
public boolean visit(MySqlDescribeStatement x) {
print("DESCRIBE ");
x.getObject().accept(this);
return false;
public void endVisit(MySqlDescribeStatement x) {
accept(x.getFrom());
accept(x.getUsing());
x.getTableSource().accept(this);
public boolean visit(MySqlDescribeStatement x) {
getTableStat(x.getObject().toString());
return false;
public void endVisit(MySqlDescribeStatement x) {
String alias = x.getAlias();
if (alias != null && !aliasMap.containsKey(alias)) {
aliasMap.put(alias, ident);
if (!aliasMap.containsKey(ident)) {
aliasMap.put(ident, ident);
public class MySqlDeleteTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE a1, a2 FROM t1 AS a1 INNER JOIN t2 AS a2 WHERE a1.id=a2.id;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDeleteTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE FROM a1, a2 USING t1 AS a1 INNER JOIN t2 AS a2 WHERE a1.id=a2.id;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDeleteTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(3, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "id")));
public class MySqlDescribteTest extends MysqlTest {
public void test_0() throws Exception {
String sql = " DESCRIBE City";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("City")));
public class SQLServerWallPermitFunctionTest extends TestCase {
public SQLServerWallPermitFunctionTest(String name) {
super(name);
protected void setUp() throws Exception {
super.setUp();
protected void tearDown() throws Exception {
super.tearDown();
public void test_permitFunction01() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT user_name();"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME()"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME(0); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT HOST_NAME()"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_addlogin user, pass; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_droplogin user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC master.dbo.sp_addsrvrolemember user, sysadmin"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_helpdb master"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_helpdb pubs"));
public void test_permitTable01() throws Exception {
public void test_permitTable02() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT system_user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("BULK INSERT mydata FROM c:boot.ini;"));
public void test01() throws Exception {
public void test02() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(dbcreator);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(bulkadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(diskadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(processadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(serveradmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(setupadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(securityadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin, sa); "));
public class SQLServerWallPermitObjectTest extends TestCase {
public SQLServerWallPermitObjectTest(String name) {
super(name);
protected void setUp() throws Exception {
super.setUp();
protected void tearDown() throws Exception {
super.tearDown();
public void test01() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT user;"));
public class SQLServerWallPermitSchemaTest extends TestCase {
public SQLServerWallPermitSchemaTest(String name) {
super(name);
protected void setUp() throws Exception {
super.setUp();
protected void tearDown() throws Exception {
super.tearDown();
public void test_master() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, password FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, DATABASE); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, SERVER); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(master..syslogins, OBJECT);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(sa, USER);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE denylogin = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE hasaccess = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE isntname = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE isntgroup = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE sysadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE securityadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE serveradmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE setupadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE processadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE diskadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE dbcreator = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE bulkadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=sometable; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..sysobjects WHERE xtype = U;  use xtype = V for views SELECT name FROM someotherdb..sysobjects WHERE xtype = U; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE sysadmin = 1 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..sysdatabases;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT TOP 1 name FROM (SELECT TOP 9 name FROM master..syslogins ORDER BY name ASC) sq ORDER BY name DESC "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name + - + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT loginame FROM master..sysprocesses WHERE spid = @@SPID"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name, password_hash FROM master.sys.sql_logins"));
public void test01() throws Exception {
public void test02() throws Exception {
public void test03() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT sysobjects.name as tablename, syscolumns.name as columnname FROM sysobjects JOIN syscolumns ON sysobjects.id = syscolumns.id WHERE sysobjects.xtype = U AND syscolumns.name LIKE %PASSWORD% "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = mytable);"));
this.exprParser = new MySqlExprParser(lexer);
this.exprParser = new MySqlExprParser(lexer);
SQLCharExpr expr = (SQLCharExpr) exprParser.expr();
SQLCharExpr expr2 = (SQLCharExpr) exprParser.expr();
SQLCharExpr password = (SQLCharExpr) this.exprParser.expr();
SQLCharExpr text = (SQLCharExpr) this.exprParser.expr();
SQLExpr temp = this.exprParser.expr();
limit.setRowCount(exprParser.expr());
limit.setOffset(exprParser.expr());
SQLCharExpr expr = (SQLCharExpr) this.exprParser.expr();
SQLCharExpr expr2 = (SQLCharExpr) this.exprParser.expr();
this.exprParser = new OracleExprParser(lexer);
this.exprParser = new OracleExprParser(lexer);
public OracleExprParser getExprParser() {
return (OracleExprParser) exprParser;
public void parseHints(List<OracleHint> hints) {
this.getExprParser().parseHints(hints);
this.getExprParser().parseHints(stmt.getHints());
this.getExprParser().parseHints(hints);
parseHints(stmt.getHints());
parseHints(hints);
item.setWhen(this.exprParser.expr());
parseHints(deleteStatement.getHints());
super(new OracleLexer(sql));
this.lexer.nextToken();
this.exprParser = new OracleExprParser(lexer);
this.exprParser = new OracleExprParser(lexer);
SQLQueryExpr queryExpr = (SQLQueryExpr) this.exprParser.expr();
SQLName name = this.exprParser.name();
withQuery.setName(this.exprParser.expr());
SQLExpr expr = this.exprParser.expr();
public interface SQLServerExpr extends SQLExpr {
public class SQLServerObjectReferenceExpr extends SQLServerObjectImpl implements SQLServerExpr {
private static final long serialVersionUID = 1L;
private String            server;
private String            database;
private String            schema;
private String            object;
public void accept0(SQLServerASTVisitor visitor) {
public void output(StringBuffer buf) {
boolean flag = false;
if (server != null) {
buf.append(server);
buf.append('.');
flag = true;
if (database != null) {
buf.append(database);
buf.append('.');
flag = true;
if (flag) {
buf.append('.');
if (schema != null) {
buf.append(schema);
buf.append('.');
flag = true;
if (flag) {
buf.append('.');
buf.append(object);
public String getServer() {
return server;
public void setServer(String server) {
this.server = server;
public String getDatabase() {
return database;
public void setDatabase(String database) {
this.database = database;
public String getSchema() {
return schema;
public void setSchema(String schema) {
this.schema = schema;
public String getObject() {
return object;
public void setObject(String object) {
this.object = object;
public class SQLServerExprParser extends SQLExprParser {
public SQLServerExprParser(Lexer lexer){
super(lexer);
public SQLServerExprParser(String sql) throws ParserException{
super(new SQLServerLexer(sql));
this.lexer.nextToken();
this.exprParser = new SQLServerExprParser(lexer);
this.exprParser = new SQLExprParser(lexer);
this.exprParser = new SQLExprParser(lexer);
public SQLExprParser getExprParser() {
return exprParser;
SQLQueryExpr queryExpr = (SQLQueryExpr) this.exprParser.expr();
public static Test suite() {
TestSuite suite = new TestSuite(SQLServerWallTest.class.getName());
suite.addTestSuite(MySqlWallLimitTest.class);
suite.addTestSuite(MySqlWallLoadDataInfileTest.class);
suite.addTestSuite(MySqlWallPermitFunctionTest.class);
suite.addTestSuite(MySqlWallPermitTableTest.class);
suite.addTestSuite(MySqlWallPermitVariantTest.class);
suite.addTestSuite(MySqlWallTest.class);
suite.addTestSuite(OracleWallPermitFunctionTest.class);
suite.addTestSuite(OracleWallPermitObjectTest.class);
suite.addTestSuite(OracleWallPermitSchemaTest.class);
suite.addTestSuite(OracleWallPermitTableTest.class);
suite.addTestSuite(OracleWallPermitVariantTest.class);
suite.addTestSuite(OracleWallPermitVariantTest2.class);
suite.addTestSuite(OracleWallTest.class);
suite.addTestSuite(SQLServerWallPermitFunctionTest.class);
suite.addTestSuite(SQLServerWallPermitObjectTest.class);
suite.addTestSuite(SQLServerWallPermitSchemaTest.class);
suite.addTestSuite(SQLServerWallPermitTableTest.class);
suite.addTestSuite(SQLServerWallTest.class);
suite.addTestSuite(WallDeleteTest.class);
suite.addTestSuite(WallDeleteWhereTest.class);
suite.addTestSuite(WallDeleteWhereTest1.class);
suite.addTestSuite(WallDropTest.class);
suite.addTestSuite(WallDropTest1.class);
suite.addTestSuite(WallHavingTest.class);
suite.addTestSuite(WallInsertTest.class);
suite.addTestSuite(WallInsertTest2.class);
suite.addTestSuite(WallLineCommentTest.class);
suite.addTestSuite(WallMultiLineCommentTest.class);
suite.addTestSuite(WallMultiStatementTest.class);
suite.addTestSuite(WallReadOnlyTest.class);
suite.addTestSuite(WallSelectIntoTest.class);
suite.addTestSuite(WallSelectIntoTest1.class);
suite.addTestSuite(WallSelectWhereTest.class);
suite.addTestSuite(WallSelectWhereTest0.class);
suite.addTestSuite(WallSelectWhereTest1.class);
suite.addTestSuite(WallSelectWhereTest2.class);
suite.addTestSuite(WallSelectWhereTest3.class);
suite.addTestSuite(WallSelectWhereTest4.class);
suite.addTestSuite(WallSelectWhereTest5.class);
suite.addTestSuite(WallTruncateTest.class);
suite.addTestSuite(WallTruncateTest1.class);
suite.addTestSuite(WallUnionTest.class);
suite.addTestSuite(WallUnionTest2.class);
suite.addTestSuite(WallUnionTest3.class);
suite.addTestSuite(WallUnionTest4.class);
suite.addTestSuite(WallUpdateTest.class);
suite.addTestSuite(WallUpdateTest1.class);
suite.addTestSuite(WallUpdateTest2.class);
suite.addTestSuite(WallUpdateTest3.class);
suite.addTestSuite(WallUpdateTest4.class);
suite.addTestSuite(WallUpdateWhereTest.class);
suite.addTestSuite(WallVisitorUtilsTest.class);
return suite;
public class SQLServerObjectReferenceExpr extends SQLServerObjectImpl implements SQLServerExpr, SQLName {
public SQLServerObjectReferenceExpr() {
public SQLServerObjectReferenceExpr(SQLExpr owner, String name) {
if (owner instanceof SQLIdentifierExpr) {
this.database = ((SQLIdentifierExpr) owner).getName();
this.object = name;
} else if (owner instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) owner;
this.server = ((SQLIdentifierExpr) propExpr.getOwner()).getName();
this.database = propExpr.getName();
this.object = name;
throw new IllegalArgumentException(owner.toString());
if (visitor.visit(this)) {
visitor.endVisit(this);
public SQLExpr primaryRest(SQLExpr expr) throws ParserException {
if (lexer.token() == Token.DOTDOT) {
expr = nameRest((SQLName) expr);
return super.primaryRest(expr);
public SQLName nameRest(SQLName name) throws ParserException {
if (lexer.token() == Token.DOTDOT) {
lexer.nextToken();
String text = lexer.stringVal();
lexer.nextToken();
name = new SQLServerObjectReferenceExpr(name, text);
return super.nameRest(name);
protected SQLExprParser createExprParser() {
return new SQLServerExprParser(lexer);
boolean visit(SQLServerObjectReferenceExpr x);
void endVisit(SQLServerObjectReferenceExpr x);
public boolean visit(SQLServerObjectReferenceExpr x) {
return true;
public void endVisit(SQLServerObjectReferenceExpr x) {
println();
public boolean visit(SQLServerObjectReferenceExpr x) {
print(x.toString());
return false;
public void endVisit(SQLServerObjectReferenceExpr x) {
public boolean visit(SQLServerObjectReferenceExpr x) {
return false;
public void endVisit(SQLServerObjectReferenceExpr x) {
name = nameRest(name);
return name;
public SQLName nameRest(SQLName name) throws ParserException {
if (lexer.token() == Token.DOT) {
name = nameRest(name);
println();
public class SQLServerSelectTest2 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT TOP 1 name FROM (SELECT TOP 9 name FROM master..syslogins ORDER BY name ASC) sq ORDER BY name DESC ";
String expect = "SELECT TOP 1 namen" + 
"FROM (SELECT TOP 9 namen" + 
"tFROM master..sysloginsn" + 
"tORDER BY name ASCn" + 
"t) sqn" + 
"ORDER BY name DESC";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
if (ch == '.') {
scanChar();
token = Token.DOTDOTDOT;
token = Token.DOTDOT;
DOTDOTDOT("..,"),
String getSimleName();
public String getSimleName() {
return name;
public String getSimleName() {
return name;
public String getSimleName() {
return dbLink;
public SQLServerObjectReferenceExpr(){
public SQLServerObjectReferenceExpr(SQLExpr owner){
public String getSimleName() {
if (schema != null) {
return schema;
if (database != null) {
return database;
return server;
if (flag) {
buf.append('.');
if (flag) {
buf.append('.');
public SQLName nameRest(SQLName expr) throws ParserException {
SQLServerObjectReferenceExpr owner = new SQLServerObjectReferenceExpr(expr);
expr = new SQLPropertyExpr(owner, text);
return super.nameRest(expr);
@Override
public boolean visit(SQLServerObjectReferenceExpr x) {
if (config.isPermitSchema(x.getSchema()) || config.isPermitSchema(x.getDatabase())) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return true;
if (propExpr.getOwner() instanceof SQLName) {
String ownerName = ((SQLName) propExpr.getOwner()).getSimleName();
String getSimleName();
public String getSimleName() {
return name;
public String getSimleName() {
return name;
public String getSimleName() {
return dbLink;
public SQLServerObjectReferenceExpr(){
public SQLServerObjectReferenceExpr(SQLExpr owner){
public String getSimleName() {
if (schema != null) {
return schema;
if (database != null) {
return database;
return server;
if (flag) {
buf.append('.');
if (flag) {
buf.append('.');
public SQLName nameRest(SQLName expr) throws ParserException {
SQLServerObjectReferenceExpr owner = new SQLServerObjectReferenceExpr(expr);
expr = new SQLPropertyExpr(owner, text);
return super.nameRest(expr);
return SQLUtils.toSQLServerString(obj);
@Override
public boolean visit(SQLServerObjectReferenceExpr x) {
if (x.getSchema() != null && config.isPermitSchema(x.getSchema())) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
if (x.getDatabase() != null && config.isPermitSchema(x.getDatabase())) {
this.getViolations().add(new IllegalSQLObjectViolation(this.toSQL(x)));
return true;
if (propExpr.getOwner() instanceof SQLName) {
String ownerName = ((SQLName) propExpr.getOwner()).getSimleName();
public final void test_sp_addsrvrolemenber() throws Exception {
public final void test_sp_helpdb() throws Exception {
public final void test_sp_droplogin() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_droplogin user;"));
public final void test_sp_addlogin() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_addlogin user, pass; "));
public final void test_db_name() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME()"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT DB_NAME(0); "));
public final void test_host_name() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT HOST_NAME()"));
public void test_is_srvrolemember() throws Exception {
public void test_system_user() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT system_user;"));
return SQLUtils.toSQLServerString(obj);
public void test_user() throws Exception {
public void test_system_user() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT system_user;"));
public boolean visit(SQLVariantRefExpr x) {
String varName = x.getName();
if (varName == null) {
return false;
if (config.isVariantCheck() && varName.startsWith("@@")) {
violations.add(new IllegalSQLObjectViolation(toSQL(x)));
return false;
if (visitor.getConfig().isPermitObjects(owner)) {
addViolation(visitor, x);
expect = expect.replaceAll("\r\n", "n");
expect = expect.replaceAll("\r\n", "n");
expect = expect.replaceAll("\r\n", "n");
private boolean             commentAllow               = false;
public boolean isCommentAllow() {
return commentAllow;
public void setCommentAllow(boolean commentAllow) {
this.commentAllow = commentAllow;
private int                           whiteSqlMaxLength = 1024;                        
private final ReentrantReadWriteLock  lock              = new ReentrantReadWriteLock();
public void addWhiteSql(String sql) {
lock.writeLock().lock();
if (whiteList == null) {
whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);
whiteList.put(sql, PRESENT);
} finally {
lock.writeLock().unlock();
public boolean whiteContains(String sql) {
lock.readLock().lock();
if (whiteList == null) {
return false;
return whiteList.get(sql) != null;
} finally {
lock.readLock().unlock();
if (!config.isCommentAllow()) {
parser.getLexer().setAllowComment(false); 
public void setUsername(String username) {
if (inited) {
throw new UnsupportedOperationException();
this.username = username;
if (inited) {
throw new UnsupportedOperationException();
this.password = password;
if (inited) {
throw new UnsupportedOperationException();
this.jdbcUrl = jdbcUrl;
public void test_prepareStatement_error() throws Exception {
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
conn.close();
Exception error = null;
dataSource.setUsername("xxx");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_7() throws Exception {
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
conn.close();
Exception error = null;
dataSource.setPassword("xx");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public void test_error_11() throws Exception {
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
conn.close();
dataSource.getUrl();
Exception error = null;
dataSource.setUrl("x");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
public class TestMockPerf extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setInitialSize(3);
dataSource.setMinIdle(3);
dataSource.setMaxActive(20);
dataSource.init();
public void test_perf() throws Exception {
for (int i = 0; i < 10; ++i) {
long startMillis = System.currentTimeMillis();
long millis = System.currentTimeMillis() - startMillis;
System.out.println("millis : " + millis);
public void perf() throws Exception {
for (int i = 0; i < 1000 * 1000; ++i) {
Connection conn = dataSource.getConnection();
conn.close();
SimpleType.LONG, 
new ArrayType<Long>(SimpleType.LONG, true), 
public class JdbcTraceManager implements JdbcTraceManagerMBean {
private final static JdbcTraceManager instance = new JdbcTraceManager();
SimpleType.LONG, 
new ArrayType<Long>(SimpleType.LONG, true), 
public class JdbcTraceManager implements JdbcTraceManagerMBean {
private final static JdbcTraceManager instance = new JdbcTraceManager();
private boolean             multiStatementAllow        = false;
public boolean isMultiStatementAllow() {
return multiStatementAllow;
public void setMultiStatementAllow(boolean multiStatementAllow) {
this.multiStatementAllow = multiStatementAllow;
if (statementList.size() > 1 && !config.isMultiStatementAllow()) {
String text = (String) value;
if (text.length() > 100) {
text = text.substring(0, 97);
text = "'" + text + "...'";
text = "'" + text + "'";
lastSlowParameters[index] = text;
StringBuilder buf = new StringBuilder();
buf.append('[');
if (index != 0) {
buf.append(',');
buf.append("null");
buf.append('"');
String text = (String) value;
if (text.length() > 100) {
for (int i = 0; i < 97; ++i) {
char ch = text.charAt(i);
if (ch == ''') {
buf.append('\');
buf.append(ch);
buf.append(ch);
buf.append("...");
for (int i = 0; i < text.length(); ++i) {
char ch = text.charAt(i);
if (ch == ''') {
buf.append('\');
buf.append(ch);
buf.append(ch);
buf.append('"');
buf.append(value.toString());
buf.append(date.getClass().getSimpleName());
buf.append('(');
buf.append(date.getTime());
buf.append(')');
buf.append(value.toString());
buf.append("<InputStream>");
buf.append("<Clob>");
buf.append("<NClob>");
buf.append("<Blob>");
buf.append('<');
buf.append(value.getClass().getName());
buf.append('>');
buf.append(']');
sqlStat.setLastSlowParameters(buf.toString());
private String           lastSlowParameters;
public String getLastSlowParameters() {
public void setLastSlowParameters(String lastSlowParameters) {
SimpleType.STRING, 
this.lastSlowParameters = null;
public void statement_addBatch(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
check(sql);
chain.statement_addBatch(statement, sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
check(sql);
public void check(String sql) throws SQLException {
void check(String sql) throws SQLException;
chain.preparedStatement_setArray(statement, parameterIndex, x);
chain.preparedStatement_setAsciiStream(statement, parameterIndex, x);
chain.preparedStatement_setAsciiStream(statement, parameterIndex, x, length);
chain.preparedStatement_setAsciiStream(statement, parameterIndex, x, length);
chain.preparedStatement_setBigDecimal(statement, parameterIndex, x);
chain.preparedStatement_setBinaryStream(statement, parameterIndex, x);
chain.preparedStatement_setBinaryStream(statement, parameterIndex, x, length);
chain.preparedStatement_setBinaryStream(statement, parameterIndex, x, length);
chain.preparedStatement_setBlob(statement, parameterIndex, x);
chain.preparedStatement_setBlob(statement, parameterIndex, x);
chain.preparedStatement_setBlob(statement, parameterIndex, x, length);
chain.preparedStatement_setBoolean(statement, parameterIndex, x);
chain.preparedStatement_setByte(statement, parameterIndex, x);
chain.preparedStatement_setBytes(statement, parameterIndex, x);
chain.preparedStatement_setCharacterStream(statement, parameterIndex, x);
chain.preparedStatement_setCharacterStream(statement, parameterIndex, x, length);
chain.preparedStatement_setCharacterStream(statement, parameterIndex, x, length);
chain.preparedStatement_setClob(statement, parameterIndex, x);
chain.preparedStatement_setClob(statement, parameterIndex, x);
chain.preparedStatement_setClob(statement, parameterIndex, x, length);
chain.preparedStatement_setDate(statement, parameterIndex, x);
chain.preparedStatement_setDate(statement, parameterIndex, x, cal);
chain.preparedStatement_setDouble(statement, parameterIndex, x);
chain.preparedStatement_setFloat(statement, parameterIndex, x);
chain.preparedStatement_setInt(statement, parameterIndex, x);
chain.preparedStatement_setLong(statement, parameterIndex, x);
chain.preparedStatement_setNCharacterStream(statement, parameterIndex, x);
chain.preparedStatement_setNCharacterStream(statement, parameterIndex, x, length);
chain.preparedStatement_setNClob(statement, parameterIndex, x);
chain.preparedStatement_setNClob(statement, parameterIndex, x);
chain.preparedStatement_setNClob(statement, parameterIndex, x, length);
chain.preparedStatement_setNString(statement, parameterIndex, x);
chain.preparedStatement_setNull(statement, parameterIndex, sqlType);
chain.preparedStatement_setNull(statement, parameterIndex, sqlType, typeName);
chain.preparedStatement_setObject(statement, parameterIndex, x);
chain.preparedStatement_setObject(statement, parameterIndex, x, targetSqlType);
chain.preparedStatement_setObject(statement, parameterIndex, x, targetSqlType, scaleOrLength);
chain.preparedStatement_setRef(statement, parameterIndex, x);
chain.preparedStatement_setRowId(statement, parameterIndex, x);
chain.preparedStatement_setSQLXML(statement, parameterIndex, x);
chain.preparedStatement_setShort(statement, parameterIndex, x);
chain.preparedStatement_setString(statement, parameterIndex, x);
chain.preparedStatement_setTime(statement, parameterIndex, x);
chain.preparedStatement_setTime(statement, parameterIndex, x, cal);
chain.preparedStatement_setTimestamp(statement, parameterIndex, x);
chain.preparedStatement_setTimestamp(statement, parameterIndex, x, cal);
chain.preparedStatement_setURL(statement, parameterIndex, x);
connection = chain.connection_connect(info);
chain.connection_close(connection);
chain.connection_commit(connection);
chain.connection_rollback(connection);
chain.connection_rollback(connection, savepoint);
chain.statement_close(statement);
chain.resultSet_close(resultSet);
this.dataSourceStat = dataSource.getDataSourceStat();
private JdbcDataSourceStat      dataSourceStat;
dataSourceStat = new JdbcDataSourceStat(this.name, this.jdbcUrl);
@Override
public JdbcDataSourceStat getDataSourceStat() {
return dataSourceStat;
private JdbcDataSourceStat                      dataSourceStat;
dataSourceStat = new JdbcDataSourceStat(name, null);
@Override
public JdbcDataSourceStat getDataSourceStat() {
return dataSourceStat;
JdbcDataSourceStat getDataSourceStat();
private final JdbcDataSourceStat    dataSourceStat;
this.dataSourceStat = new JdbcDataSourceStat(config.getName(), config.getUrl());
public JdbcDataSourceStat getDataSourceStat() {
return dataSourceStat;
for (DataSourceProxyImpl dataSource : DruidDriver.getProxyDataSources().values()) {
Map<String, JdbcSqlStat> statMap = dataSource.getDataSourceStat().getSqlStatMap();
for (Map.Entry<String, JdbcSqlStat> entry : statMap.entrySet()) {
Map<String, Object> map = entry.getValue().getData();
map.put("URL", dataSource.getUrl());
data.put(new CompositeDataSupport(JdbcSqlStat.getCompositeType(), map));
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
Map<String, JdbcSqlStat> statMap = dataSource.getDataSourceStat().getSqlStatMap();
JdbcDataSourceStat dataSourceStat =dataSource.getDataSourceStat();
JdbcDataSourceStat stat =dataSource.getDataSourceStat();
JdbcDataSourceStat stat =dataSource.getDataSourceStat();
public void setDbType(String dbType) {
this.dbType = dbType;
if (this.dbType == null || this.dbType.length() == 0) {
this.dbType = JdbcUtils.getDbType(jdbcUrl, driverClass.getClass().getName());
provider = new MySqlWallProvider(config);
provider = new OracleWallProvider(config);
provider = new SQLServerProvider(config);
dataSource.setDbType("mysql");
dataSource.setFilters("stat,wall");
Statement stmt = conn.createStatement();
stmt.execute("SELECT 1");
stmt.close();
JdbcSqlStat sqlStat = statement.getSqlStat();
JdbcSqlStat sqlStat = statement.getSqlStat();
final JdbcSqlStat sqlStat = statement.getSqlStat();
final JdbcSqlStat sqlStat = statement.getSqlStat();
JdbcSqlStat sqlStat = statement.getSqlStat();
public final static int MinorVersion    = 2;
public final static int RevisionVersion = 0;
dataSource.setFilters("stat");
final CountDownLatch latch = new CountDownLatch(10);
Thread thread = new Thread() {
public void run() {
long startMillis = System.currentTimeMillis();
long millis = System.currentTimeMillis() - startMillis;
System.out.println("millis : " + millis);
} catch (Exception e) {
e.printStackTrace();
} finally {
latch.countDown();
thread.start();
latch.await();
stmt.execute("SELECT " + i % 1000);
buf.append("Select");
loadResource(this.permitVariants, dir + "/permit-variant.txt");
loadResource(this.permitSchemas, dir + "/permit-schema.txt");
loadResource(this.permitFunctions, dir + "/permit-function.txt");
loadResource(this.permitTables, dir + "/permit-table.txt");
loadResource(this.permitObjects, dir + "/permit-object.txt");
loadResource(this.readOnlyTables, dir + "/readonly-table.txt");
WallProvider            provider = new OracleWallProvider();
String sql = "SELECT t1.department_id, t2.*n" + 
"FROM hr_info t1, TABLE(t1.people) t2n" + 
"WHERE t2.department_id = t1.department_id;";
String columName = rsMeta.getColumnLabel(i + 1);
String columName = rsMeta.getColumnLabel(i + 1);
stmt.setObject(i + 1, parameters.get(i));
public static int executeUpdate(DataSource dataSource, String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = dataSource.getConnection();
return executeUpdate(conn, sql, parameters);
} finally {
close(conn);
public static void execute(DataSource dataSource, String sql, List<Object> parameters) throws SQLException {
Connection conn = null;
conn = dataSource.getConnection();
execute(conn, sql, parameters);
} finally {
close(conn);
public static List<Map<String, Object>> executeQuery(DataSource dataSource, String sql, List<Object> parameters)
throws SQLException {
Connection conn = null;
conn = dataSource.getConnection();
return executeQuery(conn, sql, parameters);
} finally {
close(conn);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader, length);
String text = IOUtils.read(reader, (int) length);
String text = IOUtils.read((Reader) x);
String text = IOUtils.read((Reader) x);
String text = IOUtils.read((Reader) x);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader);
String text = IOUtils.read(reader, length);
String text = IOUtils.read(reader, (int) length);
String text = IOUtils.read((Reader) x);
String text = IOUtils.read((Reader) x);
String text = IOUtils.read((Reader) x);
buf.append(IOUtils.toString(new Date(this.connecttimeMillis)));
buf.append(IOUtils.toString(new Date(this.lastActiveTimeMillis)));
list.add(IOUtils.toString(traceInfo.getStackTrace()));
map.put("ConnectionConnectErrorLastStackTrace", IOUtils.getStackTrace(lastConnectionConnectError));
map.put("StatementLastErrorStackTrace", IOUtils.getStackTrace(lastStatementError));
map.put("ResultSetLastErrorStackTrace", IOUtils.getStackTrace(lastResultSetError));
map.put("ConnectionErrorLastStackTrace", IOUtils.getStackTrace(lastConnectionError));
initStackTrace = IOUtils.toString(Thread.currentThread().getStackTrace());
buf.append(IOUtils.toString(getCreatedTime()));
responseMessage = IOUtils.read(reader);
DataSourceProxy oldDataSource = proxyDataSources.putIfAbsent(url, newDataSource);
map.put("ConnectionConnectErrorLastStackTrace", IOUtils.getStackTrace(lastConnectionConnectError));
map.put("StatementLastErrorStackTrace", IOUtils.getStackTrace(lastStatementError));
map.put("ResultSetLastErrorStackTrace", IOUtils.getStackTrace(lastResultSetError));
map.put("ConnectionErrorLastStackTrace", IOUtils.getStackTrace(lastConnectionError));
map.put("LastErrorStackTrace", IOUtils.getStackTrace(lastError));
public class IOUtils {
public static String read(Reader reader) {
final int DEFAULT_BUFFER_SIZE = 1024 * 4;
StringWriter writer = new StringWriter();
char[] buffer = new char[DEFAULT_BUFFER_SIZE];
int n = 0;
while (-1 != (n = reader.read(buffer))) {
writer.write(buffer, 0, n);
return writer.toString();
} catch (IOException ex) {
throw new IllegalStateException("read error", ex);
public static String read(Reader reader, int length) {
char[] buffer = new char[length];
int offset = 0;
int rest = length;
while ((len = reader.read(buffer, offset, rest)) != -1) {
rest -= len;
offset += len;
if (rest == 0) {
return new String(buffer, 0, length - rest);
} catch (IOException ex) {
throw new IllegalStateException("read error", ex);
public static String toString(java.util.Date date) {
if (date == null) {
return null;
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
return format.format(date);
public static String getStackTrace(Throwable ex) {
StringWriter buf = new StringWriter();
ex.printStackTrace(new PrintWriter(buf));
return buf.toString();
public static String toString(StackTraceElement[] stackTrace) {
StringBuilder buf = new StringBuilder();
for (StackTraceElement item : stackTrace) {
buf.append(item.toString());
buf.append("n");
return buf.toString();
map.put("stackTrace", IOUtils.getStackTrace(error));
license = IOUtils.read(reader);
String content = IOUtils.read(reader);
IOUtils.read(new Reader() {
IOUtils.read(new Reader() {
String text = IOUtils.read(new Reader() {
String text = IOUtils.read(new Reader() {
String text = IOUtils.read(reader, 2);
String input = IOUtils.read(reader);
String input = IOUtils.read(reader);
String input = IOUtils.read(reader);
String input = IOUtils.read(reader);
String input = IOUtils.read(reader);
String input = IOUtils.read(reader);
public boolean isRelational() {
switch (this) {
case Equality:
case Like:
case NotEqual:
case GreaterThan:
case GreaterThanOrEqual:
case LessThan:
case LessThanOrEqual:
case LessThanOrGreater:
case NotLike:
case NotLessThan:
case NotGreaterThan:
case RLike:
case NotRLike:
case RegExp:
case NotRegExp:
return true;
return false;
private boolean             mustParameterized          = false;
public boolean isMustParameterized() {
return mustParameterized;
public void setMustParameterized(boolean mustParameterized) {
this.mustParameterized = mustParameterized;
WallVisitorUtils.check(this, x);
WallVisitorUtils.check(this, x);
WallVisitorUtils.check(this, x);
public static void check(WallVisitor visitor, SQLBinaryOpExpr x) {
if (x.getOperator().isRelational()) {
if (x.getLeft() instanceof SQLName && getValue(x.getRight()) != null) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
} else if (x.getRight() instanceof SQLName && getValue(x.getLeft()) != null) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (x.getLeft() instanceof SQLName && x.getRight() instanceof SQLName) {
if (x.getLeft().toString().equalsIgnoreCase(x.getRight().toString())) {
if (x.getOperator() == SQLBinaryOperator.Equality) {
return Boolean.TRUE;
} else if (x.getOperator() == SQLBinaryOperator.NotEqual) {
return Boolean.FALSE;
switch (x.getOperator()) {
case Equality:
case Like:
return Boolean.TRUE;
case NotEqual:
case GreaterThan:
case GreaterThanOrEqual:
case LessThan:
case LessThanOrEqual:
case LessThanOrGreater:
case NotLike:
return Boolean.FALSE;
if (x.getOperator() == SQLBinaryOperator.Add) {
if (leftResult == null || rightResult == null) {
return null;
if (leftResult instanceof String || rightResult instanceof String) {
return leftResult.toString() + rightResult.toString();
if (leftResult instanceof Number || rightResult instanceof Number) {
return add((Number) leftResult, (Number) rightResult);
private static Number add(Number a, Number b) {
if (a instanceof BigDecimal) {
return ((BigDecimal) a).add(new BigDecimal(b.toString()));
return a.longValue() + b.longValue();
public class IdentEqualsTest extends TestCase {
private String     sql    = "select * from t where id = id";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class IdentEqualsTest1 extends TestCase {
private String     sql    = "select * from t where not (id != id)";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class MustParameterizedTest extends TestCase {
private String     sql    = "select * from t where id = 3";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setMustParameterized(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class MustParameterizedTest1 extends TestCase {
private String     sql    = "select * from t where id = 3 + 5";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setMustParameterized(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public interface ExportParameterVisitor extends SQLASTVisitor {
public boolean visit(SQLInListExpr x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(SQLInListExpr x) {
WallVisitorUtils.check(this, x);
return true;
public boolean visit(SQLInListExpr x) {
WallVisitorUtils.check(this, x);
return true;
public static void check(WallVisitor visitor, SQLInListExpr x) {
if (visitor.getConfig().isMustParameterized()) {
for (SQLExpr param : x.getTargetList()) {
if (getValue(param) != null) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
if (x.getOperator().isRelational() && visitor.getConfig().isMustParameterized()) {
visitor.getViolations().add(new IllegalSQLObjectViolation(visitor.toSQL(x)));
public class MustParameterizedTest2 extends TestCase {
private String     sql    = "select * from t where id in (3, 5)";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setMustParameterized(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public class MustParameterizedTest3 extends TestCase {
private String     sql    = "select * from t where id not in (3, 5)";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setMustParameterized(true);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr && x.getOperator().isRelational()) {
if (visitor.getConfig().isMustParameterized()) {
ExportParameterVisitor exportParameterVisitor = visitor.getProvider().createExportParameterVisitor();
x.getWhere().accept(exportParameterVisitor);
if (exportParameterVisitor.getParameters().size() > 0) {
addViolation(visitor, x);
if (visitor.getConfig().isMustParameterized()) {
ExportParameterVisitor exportParameterVisitor = visitor.getProvider().createExportParameterVisitor();
x.getWhere().accept(exportParameterVisitor);
if (exportParameterVisitor.getParameters().size() > 0) {
addViolation(visitor, x);
Assert.assertFalse(WallUtils.isValidateMySql("delete from t where id  != id + 3", config));
Assert.assertFalse(WallUtils.isValidateMySql("delete from t where id = 'aa' + 'bbb'", config));
if (x.getLeft() instanceof SQLLiteralExpr && x.getRight() instanceof SQLLiteralExpr && x.getOperator().isRelational()) {
checkCondition(visitor, x.getWhere());
checkCondition(visitor, x.getWhere());
private static void checkCondition(WallVisitor visitor, SQLExpr x) {
if (x == null) {
if (visitor.getConfig().isMustParameterized()) {
ExportParameterVisitor exportParameterVisitor = visitor.getProvider().createExportParameterVisitor();
x.accept(exportParameterVisitor);
if (exportParameterVisitor.getParameters().size() > 0) {
addViolation(visitor, x);
checkCondition(visitor, x.getWhere());
Assert.assertFalse(WallUtils.isValidateMySql("delete from t where id  != id + 3", config));
Assert.assertFalse(WallUtils.isValidateMySql("delete from t where id = 'aa' + 'bbb'", config));
public final static int RevisionVersion = 1;
if (null == validationQuery) {
stmt.setQueryTimeout(validationQueryTimeout);
rset = stmt.executeQuery(validationQuery);
com.mysql.jdbc.Connection mysqlConn = (com.mysql.jdbc.Connection) conn;
ping_1000(mysqlConn);
select_1000(mysqlConn);
public class TestMySqlPing2 extends TestCase {
private String          jdbcUrl;
private String          user;
private String          password;
private String          driverClass;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:mysql:
user = "dragoon_admin";
password = "dragoon_root";
driverClass = "com.mysql.jdbc.Driver";
dataSource  = new DruidDataSource();
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setMaxActive(4);
dataSource.setMinIdle(1);
dataSource.setTestOnBorrow(true);
public void test_o() throws Exception {
Connection[] connections = new Connection[3];
for (int i = 0; i < connections.length; ++i) {
connections[i] = dataSource.getConnection();
for (int i = 0; i < connections.length; ++i) {
Statement stmt = connections[i].createStatement();
ResultSet rs = stmt.executeQuery("select now()");
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
for (int i = 0; i < connections.length; ++i) {
connections[i].close();
Thread.sleep(1000 * 60 * 60); 
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select now()");
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
public void pring(com.mysql.jdbc.Connection oracleConn) throws SQLException {
oracleConn.ping();
public void select(com.mysql.jdbc.Connection oracleConn) throws SQLException {
Statement stmt = oracleConn.createStatement();
stmt.execute("SELECT 'x'");
stmt.close();
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = 7", config));
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select * from t", config));
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select * from t fid = fid", config));
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select * from t fid > 5", config));
Thread.sleep(1000 * 60 * 60 * 6); 
if (entry.getValue().getExecuteCount() == 0) {
continue;
if (entry.getValue().getExecuteCount() == 0) {
continue;
@Override
public void connection_setAutoCommit(FilterChain chain, ConnectionProxy connection, boolean autoCommit)
throws SQLException {
connectionLog("connect setAutoComment " + autoCommit + ". id " + connection.getId());
chain.connection_setAutoCommit(connection, autoCommit);
JdbcSqlStat sqlStat = resultSet.getSqlStat();
sqlStat.addResultSetHoldTimeNano(nanoSpan);
JdbcSqlStat getSqlStat();
protected final JdbcSqlStat  sqlStat;
sqlStat = this.statement.getSqlStat();
public JdbcSqlStat getSqlStat() {
return sqlStat;
private final AtomicLong resultSetHoldTimeNano = new AtomicLong();
resultSetHoldTimeNano.set(0);
SimpleType.LONG, 
"LastSlowParameters",
"ResultSetHoldTime"
map.put("TotalTime", getExecuteMillisTotal());
map.put("FetchRowCount", getFetchRowCount());
map.put("RunningCount", getRunningCount()); 
map.put("Name", getName()); 
map.put("File", getFile()); 
map.put("LastErrorMessage", lastError.getMessage()); 
map.put("LastErrorClass", lastError.getClass().getName()); 
map.put("LastErrorStackTrace", IOUtils.getStackTrace(lastError)); 
map.put("LastErrorTime", new Date(executeErrorLastTime)); 
map.put("DbType", dbType); 
map.put("URL", null); 
map.put("InTransactionCount", getInTransactionCount()); 
map.put("Histogram", this.histogram.toArray()); 
map.put("LastSlowParameters", lastSlowParameters); 
map.put("ResultSetHoldTime", getResultSetHoldTimeMilis()); 
public long getResultSetHoldTimeMilis() {
return getResultSetHoldTimeNano() / (1000 * 1000);
public long getResultSetHoldTimeNano() {
return resultSetHoldTimeNano.get();
public void addResultSetHoldTimeNano(long nano) {
resultSetHoldTimeNano.addAndGet(nano);
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE sequence_seed (value INTEGER, name VARCHAR(50))");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE t_User (id BIGINT, name VARCHAR(50))");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("insert into sequence_seed (value ,name) values (0, 'druid-spring-test')");
stmt.close();
conn.close();
IUserService service = (IUserService) context.getBean("user-service");
User user = new User();
user.setName("xx");
service.addUser(user);
Assert.assertEquals(2, filter.getConnectCount());
public interface ISequenceDao {
boolean compareAndSet(String name, int value, int expect);
int getValue(String name);
public interface ISequenceService {
long nextValue();
public interface IUserDao {
void addUser(User user);
public interface IUserService {
void addUser(User user);
public class SequenceDao extends SqlMapClientDaoSupport implements ISequenceDao {
public boolean compareAndSet(String name, int value, int expect) {
Map<String, Object> parameters = new HashMap<String, Object>();
parameters.put("name", name);
parameters.put("value", value);
parameters.put("expect", expect);
int updateCount = getSqlMapClientTemplate().update("Sequence.compareAndSet", parameters);
return updateCount == 1;
public int getValue(String name) {
return (Integer) getSqlMapClientTemplate().queryForObject("Sequence.getValue", name);
public int getValueForUpdate(String name) {
return (Integer) getSqlMapClientTemplate().queryForObject("Sequence.getValueForUpdate", name);
public class SequenceService implements SequenceServiceMBean, ISequenceService {
private ISequenceDao   dao;
private String        name      = "druid-spring-test";
private String        seed;
private AtomicInteger increment = new AtomicInteger();
public ISequenceDao getDao() {
return dao;
public void setDao(ISequenceDao dao) {
this.dao = dao;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getSeed() {
return this.seed;
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public long nextValue() {
if (seed == null) {
int value = increment.getAndIncrement();
String text = seed + "9" + Integer.toString(value);
return Long.parseLong(text);
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public synchronized void init() {
this.seed = nextSeed();
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public synchronized String nextSeed() {
for (;;) {
int value = dao.getValue(name);
if (dao.compareAndSet(name, value + 1, value)) {
if (value == 0) {
return "";
return Integer.toString(value, 9);
public interface SequenceServiceMBean {
public class User {
private long   id;
private String name;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public class UserDao extends SqlMapClientDaoSupport implements IUserDao {
public void addUser(User user) {
getSqlMapClientTemplate().insert("User.insert", user);
public class UserService implements IUserService {
private IUserDao         dao;
private ISequenceService sequenceService;
@Transactional(propagation = Propagation.REQUIRED)
public void addUser(User user) {
user.setId(sequenceService.nextValue());
dao.addUser(user);
public IUserDao getDao() {
return dao;
public void setDao(IUserDao dao) {
this.dao = dao;
public ISequenceService getSequenceService() {
return sequenceService;
public void setSequenceService(ISequenceService sequenceService) {
this.sequenceService = sequenceService;
map.put("CROSS", Token.CROSS);
if (lexer.token() == Token.CROSS) {
lexer.nextToken();
accept(Token.JOIN);
joinType = OracleSelectJoin.JoinType.CROSS_JOIN;
CROSS("CROSS"),
public class OracleSelectTest35 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select typefuncti0_.id as id104_, typefuncti0_.function_id as function2_104_, " + 
"typefuncti0_.in_container as in3_104_, typefuncti0_.inherited as inherited104_," + 
"typefuncti0_.overriding as overriding104_, typefuncti0_.sn as sn104_, " + 
"typefuncti0_.type_id as type7_104_ from com_function_ontype typefuncti0_ cross " + 
" join com_function function1_ where typefuncti0_.function_id=function1_.id " + 
"and (typefuncti0_.type_id in (? , ? , ? , ?)) and function1_.code=?"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("com_function_ontype")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("com_function")));
Assert.assertEquals(9, visitor.getColumns().size());
sqlStat.decrementRunningCount();
public void decrementRunningCount() {
runningCount.decrementAndGet();
public void handleSleep() {
if (getConnectProperties() != null) {
Object propertyValue = getConnectProperties().get("executeSleep");
if (propertyValue != null) {
long millis = Long.parseLong(propertyValue.toString());
Thread.sleep(millis);
} catch (InterruptedException e) {
handleSleep(conn);
public void handleSleep(MockConnection conn) {
if (conn != null) {
conn.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
if (mockConnection != null) {
mockConnection.handleSleep();
return bitAndRest(expr);
return bitOrRest(expr);
public class OracleSelectTest36 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select ID,name from druid_test where (name>=? or name is null) and card_id<?"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
SQLSelect select = ((SQLSelectStatement) statemen).getSelect();
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) select.getQuery();
SQLBinaryOpExpr where = (SQLBinaryOpExpr) queryBlock.getWhere();
Assert.assertEquals(SQLBinaryOperator.BooleanAnd, where.getOperator());
SQLBinaryOpExpr left = (SQLBinaryOpExpr) where.getLeft();
Assert.assertEquals(SQLBinaryOperator.BooleanOr, left.getOperator());
SQLBinaryOpExpr nameGTEQ = (SQLBinaryOpExpr) left.getLeft();
Assert.assertEquals(SQLBinaryOperator.GreaterThanOrEqual, nameGTEQ.getOperator());
SQLBinaryOpExpr nameIS = (SQLBinaryOpExpr) left.getRight();
Assert.assertEquals(SQLBinaryOperator.Is, nameIS.getOperator());
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("druid_test")));
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("druid_test", "ID")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("druid_test", "name")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("druid_test", "card_id")));
public void setMaxWait(long maxWaitMillis) {
this.maxWait = maxWaitMillis;
sql = mergeSql(sql);
sql = mergeSql(sql); 
sql = mergeSql(sql);
if (!hasSpecial) {
System.arraycopy(buf, np + 1, sbuf, 0, sp);
hasSpecial = true;
putChar(''');
return new OracleParameterizedOutputVisitor(out);
return new MySqlParameterizedOutputVisitor(out);
return new PGParameterizedOutputVisitor(out);
return new ParameterizedOutputVisitor(out);
private int                                                 maxSize        = 1000 * 1;
lock.writeLock().lock();
Iterator<Map.Entry<String, JdbcSqlStat>> iter = sqlStatMap.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, JdbcSqlStat> entry = iter.next();
JdbcSqlStat stat = entry.getValue();
if (stat.getExecuteCount() == 0) {
iter.remove();
stat.reset();
lock.writeLock().unlock();
public void test_lexer2() throws Exception {
String sql = "SELECT substr('''a''bc',0,3) FROM dual";
Lexer lexer = new Lexer(sql);
for (;;) {
lexer.nextToken();
Token tok = lexer.token();
if (tok == Token.IDENTIFIER) {
System.out.println(tok.name() + "tt" + lexer.stringVal());
} else if (tok == Token.LITERAL_INT) {
System.out.println(tok.name() + "tt" + lexer.numberString());
} else if (tok == Token.LITERAL_CHARS) {
System.out.println(tok.name() + "tt" + lexer.stringVal());
System.out.println(tok.name() + "ttt" + tok.name);
if (tok == Token.EOF) {
public class StatFilterConcurrentTest extends TestCase {
private DruidDataSource dataSource;
private StatFilter      statFilter;
private int             LOOP_COUNT = 1000 * 1;
public void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxActive(100);
statFilter = new StatFilter();
dataSource.getProxyFilters().add(statFilter);
dataSource.setConnectionProperties("executeSleep=1");
public void tearDown() throws Exception {
dataSource.close();
public void test_stat() throws Exception {
concurrent(100);
for (JdbcSqlStat sqlStat : statFilter.getDataSourceStat().getSqlStatMap().values()) {
System.out.println(sqlStat.getConcurrentMax());
public void concurrent(int threadCount) throws Exception {
Thread[] threads = new Thread[threadCount];
final CountDownLatch endLatch = new CountDownLatch(threadCount);
for (int i = 0; i < threadCount; ++i) {
threads[i] = new Thread() {
public void run() {
for (int i = 0; i < LOOP_COUNT; ++i) {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.executeUpdate("select 1");
stmt.close();
conn.close();
} catch (Exception e) {
e.printStackTrace();
} finally {
endLatch.countDown();
for (int i = 0; i < threadCount; ++i) {
threads[i].start();
endLatch.await();
if (tok == Token.WHERE) {
System.out.println("where pos : " + lexer.pos());
public class MergeStatFilter extends StatFilter {
public MergeStatFilter() {
super.setMergeSql(true);
public class MergeStatFilterTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("mergeStat");
protected void tearDown() throws Exception {
dataSource.close();
public void test_merge() throws Exception {
for (int i = 0; i < 100; ++i) {
String sql = "select * from t where id = " + i;
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute(sql);
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getDataSourceStat().getSqlStatMap().size());
public class MergeStatFilterTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("mergeStat");
protected void tearDown() throws Exception {
dataSource.close();
public void test_merge() throws Exception {
String sql = "select * from t where id = 3 or id = 5 or id = 7";
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute(sql);
stmt.close();
conn.close();
String sql = "select * from t where id = 122 or id = 55";
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute(sql);
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getDataSourceStat().getSqlStatMap()
public class OracleFormatTest extends TestCase{
public void test_formatOracle(){
String sql = SQLUtils.formatOracle("select substr('123''''a''''bc',0,3) FROM dual");
System.out.println(sql);
public enum StatementExecuteType {
ExecuteBatch,
ExecuteQuery,
ExecuteUpdate
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
if (context != null) {
context.setName(null);
context.setFile(null);
context.setSql(null);
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
String contextSql = context != null ? context.getSql() : null;
@Override
public boolean visit(MySqlUpdateStatement x) {
return visit((SQLUpdateStatement) x);
public final static void setContextSql(String val) {
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
if (context == null) {
context = JdbcStatManager.getInstance().createStatContext();
JdbcStatManager.getInstance().setStatContext(context);
context.setSql(val);
public class StatFilterTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
public void test_0() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
setStatSql("Select ?");
stmt.execute("select 1");
stmt.close();
conn.close();
public final static void setStatSql(String val) {
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
if (context == null) {
context = JdbcStatManager.getInstance().createStatContext();
JdbcStatManager.getInstance().setStatContext(context);
context.setSql(val);
if (delta > 0) {
this.updateCount.addAndGet(delta);
public final static int RevisionVersion = 2;
if (visitor.visit(this)) {
acceptChild(visitor, this.partitionBy);
acceptChild(visitor, this.orderBy);
visitor.endVisit(this);
protected SQLExprParser createExprParser() {
return new PGExprParser(lexer);
void endVisit(PGAggregateExpr x);
boolean visit(PGAggregateExpr x);
void endVisit(PGAnalytic x);
boolean visit(PGAnalytic x);
@Override
public void endVisit(PGAggregateExpr x) {
@Override
public boolean visit(PGAggregateExpr x) {
return false;
@Override
public void endVisit(PGAnalytic x) {
@Override
public boolean visit(PGAnalytic x) {
return false;
@Override
public void endVisit(PGAggregateExpr x) {
@Override
public boolean visit(PGAggregateExpr x) {
print(x.getMethodName());
print("(");
printAndAccept(x.getArguments(), ", ");
print(")");
if(x.getOver() != null){
x.getOver().accept(this);
return false;
@Override
public void endVisit(PGAnalytic x) {
@Override
public boolean visit(PGAnalytic x) {
print(" OVER (");
if(x.getPartitionBy().size() > 0){
int mark = 0;
for(SQLExpr e:x.getPartitionBy()){
if(mark++ != 0){
print(", ");
e.accept(this);
if(x.getOrderBy() != null){
x.getOrderBy().accept(this);
print(")");
return false;
@Override
public void endVisit(PGAggregateExpr x) {
@Override
public boolean visit(PGAggregateExpr x) {
return false;
@Override
public void endVisit(PGAnalytic x) {
@Override
public boolean visit(PGAnalytic x) {
return false;
if (identifierEquals("DAY") || identifierEquals("YEAR")) {
if (identifierEquals("SECOND")) {
if (identifierEquals("SECOND")) {
if (lexer.token() == Token.KEY || lexer.token() == Token.CASE || lexer.token() == Token.TIMESTAMP) {
} else if (lexer.token() == Token.TIME || lexer.token() == Token.CASE || lexer.token() == Token.AT
CURSOR("CURSOR"),
if (identifierEquals("DAY") || identifierEquals("YEAR")) {
String name = lexer.stringVal();
if (identifierEquals("SECOND")) {
OracleIntervalType type = OracleIntervalType.valueOf(lexer.stringVal());
if (identifierEquals("SECOND")) {
if (lexer.token() == Token.KEY || lexer.token() == Token.CASE || lexer.token() == Token.TIMESTAMP) {
} else if (lexer.token() == Token.TIME || lexer.token() == Token.CASE || lexer.token() == Token.AT
CURSOR("CURSOR"),
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS year, order_mode, order_totaln"
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS year, order_mode, order_totaln"
String expected = "SELECT *n" + "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS day, order_mode, order_totaln"
+ "FROM (ntSELECT EXTRACT(YEAR FROM order_date) AS day, order_mode AS YEAR, order_totaln"
String sqllist = IOUtils.read(new InputStreamReader(this.getClass().getResourceAsStream("/bvt/parser/postgresql.txt")));
String[] ss = sqllist.split("--");
for(String sql:ss)
public class OracleMappingVisitor extends OracleASTVisitorAdapter implements MappingVisitor {
public class OracleASTVisitorAdapter extends SQLASTVisitorAdapter implements OracleASTVisitor {
public class OracleExportParameterVisitor extends OracleASTVisitorAdapter implements ExportParameterVisitor {
public class OracleWallVisitor extends OracleASTVisitorAdapter implements WallVisitor {
private int     loopCount                  = 5;
dataSource.init();
String sql = SQL; 
exec_test("bvt/parser/mysql-14.txt");
public class Demo1 extends TestCase {
public void test_0() throws Exception {
String sql = "select * from user where uid = ? and uname = ?";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
SQLStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
SQLStatement first = (SQLStatement) stmtList.get(0);
GetVariantVisitor variantVisitor = new GetVariantVisitor();
first.accept(variantVisitor);
SQLVariantRefExpr firstVar = variantVisitor.getVariantList().get(0);
int varIndex = (Integer) firstVar.getAttribute("varIndex");
Integer param = (Integer) parameters.get(varIndex);
String tableName;
if (param.intValue() == 1) {
tableName = "user_1";
tableName = "user_x";
MyOracleVisitor visitor = new MyOracleVisitor(tableName);
first.accept(visitor);
String realSql = SQLUtils.toOracleString(first);
System.out.println(realSql);
private static class GetVariantVisitor extends OracleASTVisitorAdapter {
private int                     varIndex    = 0;
private List<SQLVariantRefExpr> variantList = new ArrayList<SQLVariantRefExpr>();
public boolean visit(SQLVariantRefExpr x) {
x.getAttributes().put("varIndex", varIndex++);
return true;
public boolean visit(SQLBinaryOpExpr x) {
if (x.getLeft() instanceof SQLIdentifierExpr && x.getRight() instanceof SQLVariantRefExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) x.getLeft();
String ident = identExpr.getName();
if (ident.equals("uid")) {
variantList.add((SQLVariantRefExpr) x.getRight());
return true;
public int getVarIndex() {
return varIndex;
public void setVarIndex(int varIndex) {
this.varIndex = varIndex;
public List<SQLVariantRefExpr> getVariantList() {
return variantList;
public void setVariantList(List<SQLVariantRefExpr> variantList) {
this.variantList = variantList;
private static class MyOracleVisitor extends OracleASTVisitorAdapter {
private String tableName;
public MyOracleVisitor(String tableName){
this.tableName = tableName;
public boolean visit(OracleSelectTableReference x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) expr;
String tableName = identExpr.getName();
if (tableName.equals("user")) {
identExpr.setName(this.tableName);
} else if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr proExpr = (SQLPropertyExpr) expr;
String tableName = proExpr.getName();
if (tableName.equals("user")) {
proExpr.setName(this.tableName);
return true;
public boolean visit(SQLExprTableSource x) {
SQLExpr expr = x.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) expr;
String tableName = identExpr.getName();
if (tableName.equals("user")) {
identExpr.setName(this.tableName);
} else if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr proExpr = (SQLPropertyExpr) expr;
String tableName = proExpr.getName();
if (tableName.equals("user")) {
proExpr.setName(this.tableName);
return true;
public class Demo2 extends TestCase {
public void test_0() throws Exception {
String sql = "select * from user where uid = ? and uname = ?";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
SQLStatement first = (SQLStatement) stmtList.get(0);
MyVisitor visitor = new MyVisitor();
first.accept(visitor);
SQLVariantRefExpr firstVar = visitor.getVariantList().get(0);
int varIndex = (Integer) firstVar.getAttribute("varIndex");
Integer param = (Integer) parameters.get(varIndex);
final String tableName;
if (param.intValue() == 1) {
tableName = "user_1";
tableName = "user_x";
for (SQLExprTableSource tableSource : visitor.getTableSourceList()) {
SQLExpr expr = tableSource.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) expr;
String ident = identExpr.getName();
if (ident.equals("user")) {
identExpr.setName(tableName);
} else if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr proExpr = (SQLPropertyExpr) expr;
String ident = proExpr.getName();
if (ident.equals("user")) {
proExpr.setName(tableName);
String realSql = SQLUtils.toOracleString(first);
System.out.println(realSql);
private static class MyVisitor extends MySqlASTVisitorAdapter {
private int                      varIndex        = 0;
private List<SQLVariantRefExpr>  variantList     = new ArrayList<SQLVariantRefExpr>();
private List<SQLExprTableSource> tableSourceList = new ArrayList<SQLExprTableSource>();
public boolean visit(SQLVariantRefExpr x) {
x.getAttributes().put("varIndex", varIndex++);
return true;
public boolean visit(SQLBinaryOpExpr x) {
if (x.getLeft() instanceof SQLIdentifierExpr && x.getRight() instanceof SQLVariantRefExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) x.getLeft();
String ident = identExpr.getName();
if (ident.equals("uid")) {
variantList.add((SQLVariantRefExpr) x.getRight());
return true;
public boolean visit(SQLExprTableSource x) {
tableSourceList.add(x);
return true;
public int getVarIndex() {
return varIndex;
public void setVarIndex(int varIndex) {
this.varIndex = varIndex;
public List<SQLVariantRefExpr> getVariantList() {
return variantList;
public List<SQLExprTableSource> getTableSourceList() {
return tableSourceList;
String sql = "select * from user where uid = 2 and uname = ?";
SQLExpr firstVar = visitor.getVariantList().get(0);
int userId;
if (firstVar instanceof SQLVariantRefExpr) {
int varIndex = (Integer) firstVar.getAttribute("varIndex");
userId = (Integer) parameters.get(varIndex);
userId = ((SQLNumericLiteralExpr) firstVar).getNumber().intValue();
String tableName;
if (userId == 1) {
private List<SQLExpr>  variantList     = new ArrayList<SQLExpr>();
if (x.getLeft() instanceof SQLIdentifierExpr) {
if (x.getRight() instanceof SQLVariantRefExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) x.getLeft();
String ident = identExpr.getName();
if (ident.equals("uid")) {
variantList.add(x.getRight());
} else if (x.getRight() instanceof SQLNumericLiteralExpr) {
variantList.add(x.getRight());
public List<SQLExpr> getVariantList() {
public class MySqlSelectQueryBlock extends SQLSelectQueryBlock implements MySqlObject {
if (visitor instanceof MySqlASTVisitor) {
accept0((MySqlASTVisitor) visitor);
if (visitor.visit(this)) {
acceptChild(visitor, this.selectList);
acceptChild(visitor, this.from);
acceptChild(visitor, this.where);
acceptChild(visitor, this.groupBy);
acceptChild(visitor, this.orderBy);
acceptChild(visitor, this.limit);
acceptChild(visitor, this.procedureName);
acceptChild(visitor, this.procedureArgumentList);
acceptChild(visitor, this.into);
visitor.endVisit(this);
@Override
public void accept0(MySqlASTVisitor visitor) {
String sql = "select * from user where uid = 2 and uname = ?";
SQLExpr firstVar = visitor.getVariantList().get(0);
int userId;
if (firstVar instanceof SQLVariantRefExpr) {
int varIndex = (Integer) firstVar.getAttribute("varIndex");
userId = (Integer) parameters.get(varIndex);
userId = ((SQLNumericLiteralExpr) firstVar).getNumber().intValue();
String tableName;
if (userId == 1) {
private List<SQLExpr>  variantList     = new ArrayList<SQLExpr>();
if (x.getLeft() instanceof SQLIdentifierExpr) {
if (x.getRight() instanceof SQLVariantRefExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) x.getLeft();
String ident = identExpr.getName();
if (ident.equals("uid")) {
variantList.add(x.getRight());
} else if (x.getRight() instanceof SQLNumericLiteralExpr) {
variantList.add(x.getRight());
public List<SQLExpr> getVariantList() {
public class Demo3 extends TestCase {
public void test_0() throws Exception {
String sql = "select * from user u where u.uid = 2 and uname = ?";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
String realSql = convert(sql, parameters);
System.out.println(realSql);
public void test_1() throws Exception {
String sql = "select * from user where uid = ? and uname = ?";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
String realSql = convert(sql, parameters);
System.out.println(realSql);
public void test_2() throws Exception {
String sql = "select * from (select * from user where uid = ? and uname = ?) t";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
String realSql = convert(sql, parameters);
System.out.println(realSql);
public void test_3() throws Exception {
String sql = "select * from groups where uid = ? and uname = ?";
List<Object> parameters = new ArrayList<Object>();
parameters.add(1);
parameters.add("wenshao");
String realSql = convert(sql, parameters);
System.out.println(realSql);
private String convert(String sql, List<Object> parameters) {
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList(); 
SQLStatement first = (SQLStatement) stmtList.get(0);
MyVisitor visitor = new MyVisitor();
first.accept(visitor);
if (visitor.getVariantList().size() > 0) {
SQLExpr firstVar = visitor.getVariantList().get(0);
int userId;
if (firstVar instanceof SQLVariantRefExpr) {
int varIndex = (Integer) firstVar.getAttribute("varIndex");
userId = (Integer) parameters.get(varIndex);
userId = ((SQLNumericLiteralExpr) firstVar).getNumber().intValue();
String tableName;
if (userId == 1) {
tableName = "user_1";
tableName = "user_x";
for (SQLExprTableSource tableSource : visitor.getTableSourceList()) {
SQLExpr expr = tableSource.getExpr();
if (expr instanceof SQLIdentifierExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) expr;
String ident = identExpr.getName();
if (ident.equals("user")) {
identExpr.setName(tableName);
} else if (expr instanceof SQLPropertyExpr) {
SQLPropertyExpr proExpr = (SQLPropertyExpr) expr;
String ident = proExpr.getName();
if (ident.equals("user")) {
proExpr.setName(tableName);
String realSql = SQLUtils.toOracleString(first);
return realSql;
private static class MyVisitor extends MySqlASTVisitorAdapter {
private int                      varIndex        = 0;
private List<SQLExpr>            variantList     = new ArrayList<SQLExpr>();
private List<SQLExprTableSource> tableSourceList = new ArrayList<SQLExprTableSource>();
private Map<String, String>      tableAlias      = new HashMap<String, String>();
private String                   defaultTableName;
public boolean visit(SQLVariantRefExpr x) {
x.getAttributes().put("varIndex", varIndex++);
return true;
public boolean visit(SQLBinaryOpExpr x) {
if (isUserId(x.getLeft())) {
if (x.getRight() instanceof SQLVariantRefExpr) {
SQLIdentifierExpr identExpr = (SQLIdentifierExpr) x.getLeft();
String ident = identExpr.getName();
if (ident.equals("uid")) {
variantList.add(x.getRight());
} else if (x.getRight() instanceof SQLNumericLiteralExpr) {
variantList.add(x.getRight());
return true;
private boolean isUserId(SQLExpr x) {
if (x instanceof SQLIdentifierExpr) {
if ("user".equals(defaultTableName) && "uid".equals(((SQLIdentifierExpr) x).getName())) {
return true;
return false;
if (x instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) x;
String columnName = propExpr.getName();
if (!"uid".equals(columnName)) {
return false;
if (propExpr.getOwner() instanceof SQLIdentifierExpr) {
String ownerName = ((SQLIdentifierExpr) propExpr.getOwner()).getName();
if ("user".equals(ownerName) || "user".equals(tableAlias.get(ownerName))) {
return true;
return false;
public boolean visit(SQLExprTableSource x) {
recordTableSource(x);
return true;
private String recordTableSource(SQLExprTableSource x) {
if (x.getExpr() instanceof SQLIdentifierExpr) {
String tableName = ((SQLIdentifierExpr) x.getExpr()).getName();
if (x.getAlias() != null) {
tableAlias.put(x.getAlias(), tableName);
if ("user".equals(tableName)) {
if (!tableSourceList.contains(x)) {
tableSourceList.add(x);
return tableName;
return null;
public boolean visit(SQLSelectQueryBlock queryBlock) {
if (queryBlock.getFrom() instanceof SQLExprTableSource) {
defaultTableName = recordTableSource((SQLExprTableSource) queryBlock.getFrom());
return true;
public boolean visit(MySqlSelectQueryBlock queryBlock) {
if (queryBlock.getFrom() instanceof SQLExprTableSource) {
defaultTableName = recordTableSource((SQLExprTableSource) queryBlock.getFrom());
return true;
public List<SQLExpr> getVariantList() {
return variantList;
public List<SQLExprTableSource> getTableSourceList() {
return tableSourceList;
public MappingEngine(MappingProvider provider){
this.provider = provider;
public void test_0() throws Exception {
String expected = "SELECT uid AS "", name AS ""n" + 
"FROM user_a un" + 
"WHERE u.uid = 'a'";
Assert.assertEquals(expected, sql);
public class Entity extends MappingObject {
public class MappingObject {
private Map<String, Object> attributes;
public Map<String, Object> getAttributes() {
if (attributes == null) {
attributes = new HashMap<String, Object>(1);
return attributes;
public Object getAttribute(String name) {
if (attributes == null) {
return null;
return attributes.get(name);
public void putAttribute(String name, Object value) {
if (attributes == null) {
attributes = new HashMap<String, Object>(1);
attributes.put(name, value);
public Map<String, Object> getAttributesDirect() {
return attributes;
public class Property extends MappingObject {
if (visitor.getParameters().size() > varIndex) {
Object parameter = visitor.getParameters().get(varIndex);
expr.putAttribute("mapping.value", parameter);
public class MappingContext {
private List<Object> parameters;
private boolean      generateAlias = false;
public MappingContext(){
this(new ArrayList<Object>());
public MappingContext(List<Object> parameters){
this.parameters = parameters;
public List<Object> getParameters() {
return parameters;
public void setParameters(List<Object> parameters) {
this.parameters = parameters;
public boolean isGenerateAlias() {
return generateAlias;
public void setGenerateAlias(boolean generateAlias) {
this.generateAlias = generateAlias;
return createMappingVisitor(new MappingContext(parameters));
public MappingVisitor createMappingVisitor(MappingContext context) {
return provider.createMappingVisitor(this, context);
return explainToSelectSQL(sql, new MappingContext(parameters));
public String explainToSelectSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
public MappingVisitor createMappingVisitor(MappingEngine engine, MappingContext context) {
return new MSSQLServerMappingVisitor(engine, context);
private final MappingContext              context;
this(engine, new MappingContext());
public MSSQLServerMappingVisitor(MappingEngine engine, MappingContext context){
this.context = context;
return context.getParameters();
public MappingContext getContext() {
return context;
return engine.resolveTableName(entity, context.getParameters());
return engine.resovleColumnName(entity, property, context.getParameters());
MappingVisitor createMappingVisitor(MappingEngine engine, MappingContext context);
MappingContext getContext();
if (visitor.getContext().isGenerateAlias() && selectItem.getAlias() == null) {
if (visitor.getContext().isGenerateAlias() && x.getParent() instanceof SQLSelectItem) {
if (visitor.getContext().isGenerateAlias() && selectItem.getAlias() == null) {
public MappingVisitor createMappingVisitor(MappingEngine engine, MappingContext context) {
return new MySqlMappingVisitor(engine, context);
private final MappingContext              context;
this(engine, new MappingContext());
public MySqlMappingVisitor(MappingEngine engine, MappingContext context){
this.context = context;
return context.getParameters();
public MappingContext getContext() {
return context;
return engine.resolveTableName(entity, context.getParameters());
return engine.resovleColumnName(entity, property, context.getParameters());
public MappingVisitor createMappingVisitor(MappingEngine engine, MappingContext context) {
return new OracleMappingVisitor(engine, context);
private final MappingContext              context;
this(engine, new MappingContext());
public OracleMappingVisitor(MappingEngine engine, MappingContext context){
this.context = context;
return context.getParameters();
public MappingContext getContext() {
return context;
return engine.resolveTableName(entity, context.getParameters());
return engine.resovleColumnName(entity, property, context.getParameters());
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
private static final String MAPPING_PROPERTY = "mapping.property";
private static final String MAPPING_ENTITY   = "mapping.entity";
Entity entity = (Entity) x.getAttribute(MAPPING_ENTITY);
if (entity == null) {
entity = visitor.getEntity(entityName);
if (x.getParent() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) x.getParent();
if (queryBlock.getAttribute(MAPPING_ENTITY) == null) {
queryBlock.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_ENTITY, entity);
public static boolean fillSelectList(MappingVisitor visitor, SQLSelectQueryBlock x) {
Entity entity = (Entity) x.getAttribute(MAPPING_ENTITY);
if (entity == null && x.getFrom() != null) {
entity = (Entity) x.getFrom().getAttribute(MAPPING_ENTITY);
if (entity == null) {
return false;
x.getSelectList().clear();
for (Property property : entity.getProperties().values()) {
String columnName = visitor.resovleColumnName(entity, property);
String alias = null;
if (visitor.getContext().isGenerateAlias()) {
alias = '"' + property.getName() + '"';
SQLExpr expr = new SQLIdentifierExpr(columnName);
expr.putAttribute(MAPPING_ENTITY, entity);
expr.putAttribute(MAPPING_PROPERTY, property);
SQLSelectItem selelctItem = new SQLSelectItem(expr, alias);
return true;
x.putAttribute(MAPPING_PROPERTY, property);
x.putAttribute(MAPPING_ENTITY, entity);
public static boolean visit(MappingVisitor visitor, SQLAllColumnExpr x) {
if (visitor.getContext().isExplainAllColumnToList()) {
visitor.getUnresolveList().add(x);
return true;
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_PROPERTY, property);
x.putAttribute(MAPPING_ENTITY, propertyEntity);
x.getLeft().setParent(x);
x.getRight().setParent(x);
Entity entity = (Entity) x.getLeft().getAttribute(MAPPING_ENTITY);
Property property = (Property) x.getLeft().getAttribute(MAPPING_PROPERTY);
Entity entity = (Entity) x.getLeft().getAttribute(MAPPING_ENTITY);
Property property = (Property) x.getLeft().getAttribute(MAPPING_PROPERTY);
} else if (expr instanceof SQLAllColumnExpr) {
if (resolve(visitor, (SQLAllColumnExpr) expr)) {
iter.remove();
public static boolean resolve(MappingVisitor visitor, SQLAllColumnExpr x) {
if (! (x.getParent() instanceof SQLSelectItem)) {
return true;
SQLSelectItem selectItem = (SQLSelectItem) x.getParent();
if (! (selectItem.getParent() instanceof SQLSelectQueryBlock)) {
return true;
SQLSelectQueryBlock select = (SQLSelectQueryBlock) selectItem.getParent();
if (select.getSelectList().size() == 1) {
if (select.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
boolean result = fillSelectList(visitor, select);
if (!result && visitor.getContext().isExplainAllColumnToList()) {
visitor.getUnresolveList().add(x);
return false;
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_PROPERTY, property);
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_PROPERTY, property);
SQLAllColumnExpr expr = new SQLAllColumnExpr();
SQLSelectItem selectItem = new SQLSelectItem(expr);
x.getSelectList().add(selectItem);
expr.setParent(selectItem);
from.putAttribute(MAPPING_ENTITY, firstEntity);
x.putAttribute(MAPPING_ENTITY, firstEntity);
item.getExpr().setParent(item);
x.getFrom().setParent(x);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
if (x.getInto() != null) {
x.getInto().setParent(x);
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
private static final String MAPPING_PROPERTY = "mapping.property";
private static final String MAPPING_ENTITY   = "mapping.entity";
Entity entity = (Entity) x.getAttribute(MAPPING_ENTITY);
if (entity == null) {
entity = visitor.getEntity(entityName);
if (x.getParent() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) x.getParent();
if (queryBlock.getAttribute(MAPPING_ENTITY) == null) {
queryBlock.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_ENTITY, entity);
public static boolean fillSelectList(MappingVisitor visitor, SQLSelectQueryBlock x) {
Entity entity = (Entity) x.getAttribute(MAPPING_ENTITY);
if (entity == null && x.getFrom() != null) {
entity = (Entity) x.getFrom().getAttribute(MAPPING_ENTITY);
if (entity == null) {
return false;
x.getSelectList().clear();
for (Property property : entity.getProperties().values()) {
String columnName = visitor.resovleColumnName(entity, property);
String alias = null;
if (visitor.getContext().isGenerateAlias()) {
alias = '"' + property.getName() + '"';
SQLExpr expr = new SQLIdentifierExpr(columnName);
expr.putAttribute(MAPPING_ENTITY, entity);
expr.putAttribute(MAPPING_PROPERTY, property);
SQLSelectItem selelctItem = new SQLSelectItem(expr, alias);
return true;
x.putAttribute(MAPPING_PROPERTY, property);
x.putAttribute(MAPPING_ENTITY, entity);
public static boolean visit(MappingVisitor visitor, SQLAllColumnExpr x) {
if (visitor.getContext().isExplainAllColumnToList()) {
visitor.getUnresolveList().add(x);
return true;
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_PROPERTY, property);
x.putAttribute(MAPPING_ENTITY, propertyEntity);
x.getLeft().setParent(x);
x.getRight().setParent(x);
Entity entity = (Entity) x.getLeft().getAttribute(MAPPING_ENTITY);
Property property = (Property) x.getLeft().getAttribute(MAPPING_PROPERTY);
Entity entity = (Entity) x.getLeft().getAttribute(MAPPING_ENTITY);
Property property = (Property) x.getLeft().getAttribute(MAPPING_PROPERTY);
} else if (expr instanceof SQLAllColumnExpr) {
if (resolve(visitor, (SQLAllColumnExpr) expr)) {
iter.remove();
public static boolean resolve(MappingVisitor visitor, SQLAllColumnExpr x) {
if (! (x.getParent() instanceof SQLSelectItem)) {
return true;
SQLSelectItem selectItem = (SQLSelectItem) x.getParent();
if (! (selectItem.getParent() instanceof SQLSelectQueryBlock)) {
return true;
SQLSelectQueryBlock select = (SQLSelectQueryBlock) selectItem.getParent();
if (select.getSelectList().size() == 1) {
if (select.getSelectList().get(0).getExpr() instanceof SQLAllColumnExpr) {
boolean result = fillSelectList(visitor, select);
if (!result && visitor.getContext().isExplainAllColumnToList()) {
visitor.getUnresolveList().add(x);
return false;
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_PROPERTY, property);
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
x.putAttribute(MAPPING_ENTITY, entity);
x.putAttribute(MAPPING_PROPERTY, property);
SQLAllColumnExpr expr = new SQLAllColumnExpr();
SQLSelectItem selectItem = new SQLSelectItem(expr);
x.getSelectList().add(selectItem);
expr.setParent(selectItem);
Entity firstEntity = visitor.getEngine().getFirstEntity();
from.putAttribute(MAPPING_ENTITY, firstEntity);
x.putAttribute(MAPPING_ENTITY, firstEntity);
item.getExpr().setParent(item);
x.getFrom().setParent(x);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
if (x.getInto() != null) {
x.getInto().setParent(x);
Entity entity = (Entity) tableSource.getAttribute(MAPPING_ENTITY);
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
@Override
public boolean visit(SQLAllColumnExpr x) {
return MappingVisitorUtils.visit(this, x);
return explainToDeleteSQL(sql, new MappingContext());
public String explainToDeleteSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
return explainToUpdateSQL(sql, new MappingContext());
public String explainToUpdateSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
return explainToInsertSQL(sql, new MappingContext());
public String explainToInsertSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
return parser.parseStatementList();
List<SQLStatement> explain(MappingEngine engine, String sql);
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
return parser.parseStatementList();
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
OracleStatementParser parser = new OracleStatementParser(sql);
return parser.parseStatementList();
public String explain(String sql) {
return explain(sql);
public String explain(String sql, MappingContext context) {
List<SQLStatement> stmtList = provider.explain(this, sql);
if (stmtList.size() > 0) {
throw new IllegalArgumentException(sql);
SQLStatement stmt = stmtList.get(0);
MappingVisitor visitor = this.createMappingVisitor(context);
stmt.accept(visitor);
visitor.afterResolve();
afterResole(visitor);
return toSQL(stmt);
return explainToDeleteSQL(sql, new MappingContext());
public String explainToDeleteSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
return explainToUpdateSQL(sql, new MappingContext());
public String explainToUpdateSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
return explainToInsertSQL(sql, new MappingContext());
public String explainToInsertSQL(String sql, MappingContext context) {
MappingVisitor visitor = this.createMappingVisitor(context);
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
return parser.parseStatementList();
List<SQLStatement> explain(MappingEngine engine, String sql);
public static boolean visit(MappingVisitor visitor, MySqlSelectQueryBlock x) {
Integer maxLimit = visitor.getEngine().getMaxLimit();
if (maxLimit != null) {
if (x.getLimit() == null) {
Limit limit = new Limit();
limit.setRowCount(new SQLIntegerExpr(maxLimit));
x.setLimit(limit);
SQLNumericLiteralExpr rowCountExpr = (SQLNumericLiteralExpr) x.getLimit().getRowCount();
int rowCount = rowCountExpr.getNumber().intValue();
if (rowCount > maxLimit.intValue()) {
rowCountExpr.setNumber(maxLimit);
return visit(visitor, (SQLSelectQueryBlock) x);
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
return parser.parseStatementList();
@Override
public List<SQLStatement> explain(MappingEngine engine, String sql) {
OracleStatementParser parser = new OracleStatementParser(sql);
return parser.parseStatementList();
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
public static void setTableSource(MappingEngine engine, SQLDeleteStatement stmt) {
public static void setTableSource(MappingEngine engine, SQLUpdateStatement stmt) {
public static void setTableSource(MappingEngine engine, SQLInsertStatement stmt) {
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
MappingVisitorUtils.setTableSource(engine, stmt);
private Entity       defaultEntity;
public Entity getDefaultEntity() {
return defaultEntity;
public void setDefaultEntity(Entity defaultEntity) {
this.defaultEntity = defaultEntity;
public SQLSelectQueryBlock explainToSelectSQLObject(String sql, MappingContext context) {
return provider.explainToSelectSQLObject(this, sql, context);
SQLSelectQueryBlock query = explainToSelectSQLObject(sql, context);
public SQLDeleteStatement explainToDeleteSQLObject(String sql, MappingContext context) {
return provider.explainToDeleteSQLObject(this, sql, context);
SQLDeleteStatement stmt = explainToDeleteSQLObject(sql, context);
public SQLUpdateStatement explainToUpdateSQLObject(String sql, MappingContext context) {
return provider.explainToUpdateSQLObject(this, sql, context);
SQLUpdateStatement stmt = explainToUpdateSQLObject(sql, context);
public SQLInsertStatement explainToInsertSQLObject(String sql, MappingContext context) {
return provider.explainToInsertSQLObject(this, sql, context);
SQLInsertStatement stmt = explainToInsertSQLObject(sql, context);
return select(conn, sql, new MappingContext(parameters));
public List<Map<String, Object>> select(Connection conn, String sql, MappingContext context) throws SQLException {
SQLSelectQueryBlock sqlObject = this.explainToSelectSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
String rawSql = this.toSQL(sqlObject);
return JdbcUtils.executeQuery(conn, rawSql, context.getParameters());
return delete(conn, sql, new MappingContext(parameters));
public int delete(Connection conn, String sql, MappingContext context) throws SQLException {
SQLDeleteStatement sqlObject = this.explainToDeleteSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, context.getParameters());
return update(conn, sql, new MappingContext(parameters));
public int update(Connection conn, String sql, MappingContext context) throws SQLException {
SQLUpdateStatement sqlObject = this.explainToUpdateSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, context.getParameters());
insert(conn, sql, new MappingContext(parameters));
public void insert(Connection conn, String sql, MappingContext context) throws SQLException {
SQLInsertStatement sqlObject = this.explainToInsertSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
JdbcUtils.execute(conn, rawSql, context.getParameters());
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context);
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public MySqlDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public OracleDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
private Entity       defaultEntity;
public Entity getDefaultEntity() {
return defaultEntity;
public void setDefaultEntity(Entity defaultEntity) {
this.defaultEntity = defaultEntity;
public Entity getFirstEntity(MappingContext context) {
Entity entity = context.getDefaultEntity();
if (entity != null) {
return entity;
public SQLSelectQueryBlock explainToSelectSQLObject(String sql, MappingContext context) {
return provider.explainToSelectSQLObject(this, sql, context);
SQLSelectQueryBlock query = explainToSelectSQLObject(sql, context);
public SQLDeleteStatement explainToDeleteSQLObject(String sql, MappingContext context) {
return provider.explainToDeleteSQLObject(this, sql, context);
SQLDeleteStatement stmt = explainToDeleteSQLObject(sql, context);
public SQLUpdateStatement explainToUpdateSQLObject(String sql, MappingContext context) {
return provider.explainToUpdateSQLObject(this, sql, context);
SQLUpdateStatement stmt = explainToUpdateSQLObject(sql, context);
public SQLInsertStatement explainToInsertSQLObject(String sql, MappingContext context) {
return provider.explainToInsertSQLObject(this, sql, context);
SQLInsertStatement stmt = explainToInsertSQLObject(sql, context);
return select(conn, sql, new MappingContext(parameters));
public List<Map<String, Object>> select(Connection conn, String sql, MappingContext context) throws SQLException {
SQLSelectQueryBlock sqlObject = this.explainToSelectSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
String rawSql = this.toSQL(sqlObject);
return JdbcUtils.executeQuery(conn, rawSql, context.getParameters());
return delete(conn, sql, new MappingContext(parameters));
public int delete(Connection conn, String sql, MappingContext context) throws SQLException {
SQLDeleteStatement sqlObject = this.explainToDeleteSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, context.getParameters());
return update(conn, sql, new MappingContext(parameters));
public int update(Connection conn, String sql, MappingContext context) throws SQLException {
SQLUpdateStatement sqlObject = this.explainToUpdateSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
int updateCount = JdbcUtils.executeUpdate(conn, rawSql, context.getParameters());
insert(conn, sql, new MappingContext(parameters));
public void insert(Connection conn, String sql, MappingContext context) throws SQLException {
SQLInsertStatement sqlObject = this.explainToInsertSQLObject(sql, context);
exportParameters(sqlObject, context.getParameters());
JdbcUtils.execute(conn, rawSql, context.getParameters());
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context);
SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context);
Entity firstEntity = visitor.getEngine().getFirstEntity(visitor.getContext());
public static void setTableSource(MappingEngine engine, SQLDeleteStatement stmt, MappingContext context) {
Entity entity = engine.getFirstEntity(context);
public static void setTableSource(MappingEngine engine, SQLUpdateStatement stmt, MappingContext context) {
Entity entity = engine.getFirstEntity(context);
public static void setTableSource(MappingEngine engine, SQLInsertStatement stmt, MappingContext context) {
Entity entity = engine.getFirstEntity(context);
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public MySqlDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLSelectQueryBlock explainToSelectSQLObject(MappingEngine engine, String sql, MappingContext context) {
public OracleDeleteStatement explainToDeleteSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLUpdateStatement explainToUpdateSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
public SQLInsertStatement explainToInsertSQLObject(MappingEngine engine, String sql, MappingContext context) {
MappingVisitorUtils.setTableSource(engine, stmt, context);
return dataSource.isPoolPreparedStatements();
stmt.getPreparedStatementHolder().decrementInUseCount();
initStatement(stmtHolder);
private void initStatement(PreparedStatementHolder stmtHolder) throws SQLException {
stmtHolder.incrementInUseCount();
holder.getDataSource().initStatement(this, stmtHolder.getStatement());
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
initStatement(stmtHolder);
private int                        inUseCount               = 0;
public boolean isInUse() {
return inUseCount <= 0;
public void incrementInUseCount() {
inUseCount++;
public void decrementInUseCount() {
inUseCount--;
public int getInUseCount() {
return inUseCount;
if (holder.isInUse() && (!dataSource.isSharePreparedStatements())) {
return null;
public class PSCacheTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:x1");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(10);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_noTxn() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
stmt0.close();
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertEquals(1, pooledStmt1.getPreparedStatementHolder().getInUseCount());
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt0.getPreparedStatementHolder()); 
PreparedStatement stmt2 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt2 = (DruidPooledPreparedStatement) stmt2;
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt2.getPreparedStatementHolder()); 
stmt1.close();
stmt2.close();
conn.close();
public void test_txn() throws Exception {
Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);
String sql = "select 1";
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
stmt0.close();
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertEquals(1, pooledStmt1.getPreparedStatementHolder().getInUseCount());
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt0.getPreparedStatementHolder()); 
PreparedStatement stmt2 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt2 = (DruidPooledPreparedStatement) stmt2;
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt2.getPreparedStatementHolder()); 
stmt1.close();
stmt2.close();
conn.close();
public class PSCacheTest1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:x1");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(10);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_noTxn() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
stmt0.close();
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertEquals(1, pooledStmt1.getPreparedStatementHolder().getInUseCount());
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt0.getPreparedStatementHolder()); 
PreparedStatement stmt2 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt2 = (DruidPooledPreparedStatement) stmt2;
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt2.getPreparedStatementHolder()); 
conn.close();
Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);
String sql = "select 1";
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
stmt0.close();
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertEquals(1, pooledStmt1.getPreparedStatementHolder().getInUseCount());
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt0.getPreparedStatementHolder()); 
PreparedStatement stmt2 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt2 = (DruidPooledPreparedStatement) stmt2;
Assert.assertNotSame(pooledStmt1.getPreparedStatementHolder(), pooledStmt2.getPreparedStatementHolder()); 
stmt1.close();
stmt2.close();
conn.close();
public class PSCacheTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:x1");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(10);
dataSource.setSharePreparedStatements(true);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_0() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 1";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.close();
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
Assert.assertEquals(1, pooledStmt0.getPreparedStatementHolder().getInUseCount());
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertSame(pooledStmt0.getPreparedStatementHolder(), pooledStmt1.getPreparedStatementHolder());
stmt0.close();
stmt1.close();
conn.close();
public void test_txn() throws Exception {
Connection conn = dataSource.getConnection();
conn.setAutoCommit(true);
String sql = "select 1";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.close();
PreparedStatement stmt0 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt0 = (DruidPooledPreparedStatement) stmt0;
Assert.assertEquals(1, pooledStmt0.getPreparedStatementHolder().getInUseCount());
PreparedStatement stmt1 = conn.prepareStatement(sql);
DruidPooledPreparedStatement pooledStmt1 = (DruidPooledPreparedStatement) stmt1;
Assert.assertSame(pooledStmt0.getPreparedStatementHolder(), pooledStmt1.getPreparedStatementHolder());
stmt0.close();
stmt1.close();
conn.close();
public class HttpServer {
private final static Log              LOG             = LogFactory.getLog(HttpServer.class);
protected final Server                webServer;
protected final Connector             listener;
protected final WebAppContext         webAppContext;
protected final Map<Context, Boolean> defaultContexts = new HashMap<Context, Boolean>();
public HttpServer() throws IOException{
this("stat", "0.0.0.0", 19790);
public HttpServer(String name, String bindAddress, int port) throws IOException{
webServer = new Server();
listener = createBaseListener();
listener.setHost(bindAddress);
listener.setPort(port);
webServer.addConnector(listener);
webServer.setThreadPool(new QueuedThreadPool());
final String appDir = getWebAppsPath();
ContextHandlerCollection contexts = new ContextHandlerCollection();
webServer.setHandler(contexts);
webAppContext = new WebAppContext();
webAppContext.setDisplayName("WepAppsContext");
webAppContext.setContextPath("/");
webAppContext.setWar(appDir + "/" + name);
webServer.addHandler(webAppContext);
addDefaultApps(contexts, appDir);
addDefaultServlets();
public Connector createBaseListener() throws IOException {
return HttpServer.createDefaultChannelConnector();
public static Connector createDefaultChannelConnector() {
SelectChannelConnector ret = new SelectChannelConnector();
ret.setLowResourceMaxIdleTime(10000);
ret.setAcceptQueueSize(128);
ret.setResolveNames(false);
ret.setUseDirectBuffers(false);
return ret;
protected String getWebAppsPath() throws IOException {
URL url = getClass().getClassLoader().getResource("druid-webapps");
if (url == null) throw new IOException("webapps not found in CLASSPATH");
return url.toString();
public void stop() throws Exception {
listener.close();
webServer.stop();
public void join() throws InterruptedException {
webServer.join();
public void start() throws IOException {
int port = 0;
int oriPort = listener.getPort(); 
while (true) {
port = webServer.getConnectors()[0].getLocalPort();
LOG.debug("Port returned by webServer.getConnectors()[0]." + "getLocalPort() before open() is "
+ port + ". Opening the listener on " + oriPort);
listener.open();
port = listener.getLocalPort();
LOG.debug("listener.getLocalPort() returned " + listener.getLocalPort()
+ " webServer.getConnectors()[0].getLocalPort() returned "
+ webServer.getConnectors()[0].getLocalPort());
LOG.debug("Jetty bound to port " + port);
webServer.start();
} catch (IOException ex) {
if (ex instanceof BindException) {
throw (BindException) ex;
LOG.debug("HttpServer.start() threw a non Bind IOException");
} catch (MultiException ex) {
LOG.debug("HttpServer.start() threw a MultiException");
} catch (IOException ex) {
} catch (Exception ex) {
throw new IOException("Problem starting http server", ex);
protected void addDefaultApps(ContextHandlerCollection parent, final String appDir) throws IOException {
Context staticContext = new Context(parent, "/static");
staticContext.setResourceBase(appDir + "/static");
staticContext.addServlet(DefaultServlet.class, "");
staticContext.setDisplayName("static");
setContextAttributes(staticContext);
defaultContexts.put(staticContext, true);
private void setContextAttributes(Context context) {
protected void addDefaultServlets() {
public class HttpServerTest extends TestCase {
public void test_httpServer() throws Exception {
HttpServer server = new HttpServer();
server.start();
server.stop();
public class HttpServerTest2 extends TestCase {
public void test_httpServer() throws Exception {
HttpServer server = new HttpServer();
server.start();
server.join();
public class SQLBitStringLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
public class SQLDateLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
public class SQLDefaultExpr extends SQLExprImpl implements SQLLiteralExpr {
public class SQLHexExpr extends SQLExprImpl implements SQLLiteralExpr {
public byte[] toBytes() {
return HexBin.decode(this.hex);
public class SQLHexStringLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
public class SQLIntervalLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
public interface SQLLiteralExpr extends SQLExpr {
public class SQLNullExpr extends SQLExprImpl implements SQLLiteralExpr {
public abstract class SQLNumericLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
public abstract class SQLTextLiteralExpr extends SQLExprImpl implements SQLLiteralExpr {
private boolean           global           = false;
public SQLVariantRefExpr(String name){
this.name = name;
public SQLVariantRefExpr(String name, boolean global){
this.global = global;
public boolean isGlobal() {
return global;
public void setGlobal(boolean global) {
this.global = global;
public class MySqlBinaryExpr extends MySqlExprImpl implements MySqlExpr, SQLLiteralExpr {
public void accept0(MySqlASTVisitor visitor) {
public class MySqlBooleanExpr extends MySqlExprImpl implements MySqlExpr, SQLLiteralExpr {
public void accept0(MySqlASTVisitor visitor) {
public abstract class MySqlExprImpl extends MySqlObjectImpl implements SQLExpr {
private static final long serialVersionUID = 1L;
public class MySqlHexadecimalExpr extends MySqlExprImpl implements SQLLiteralExpr {
private static final long serialVersionUID = 1L;
public void accept0(MySqlASTVisitor visitor) {
public class MySqlSetTransactionIsolationLevelStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private Boolean           global;
private String            level;
public String getLevel() {
return level;
public void setLevel(String level) {
this.level = level;
public void accept0(MySqlASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public Boolean getGlobal() {
return global;
public void setGlobal(Boolean global) {
this.global = global;
case VARIANT:
SQLVariantRefExpr varRefExpr = new SQLVariantRefExpr(lexer.stringVal());
lexer.nextToken();
if (varRefExpr.getName().equalsIgnoreCase("@@global")) {
accept(Token.DOT);
varRefExpr = new SQLVariantRefExpr(lexer.stringVal(), true);
lexer.nextToken();
} else if (varRefExpr.getName().equals("@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@'" + lexer.stringVal() + "'");
lexer.nextToken();
} else if (varRefExpr.getName().equals("@@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@@'" + lexer.stringVal() + "'");
lexer.nextToken();
return primaryRest(varRefExpr);
public SQLAssignItem parseAssignItem() {
SQLAssignItem item = new SQLAssignItem();
SQLExpr var = primary();
if (var instanceof SQLIdentifierExpr) {
String ident = ((SQLIdentifierExpr) var).getName();
if ("GLOBAL".equalsIgnoreCase(ident)) {
ident = lexer.stringVal();
lexer.nextToken();
var = new SQLVariantRefExpr(ident, true);
} else if ("SESSION".equalsIgnoreCase(ident)) {
ident = lexer.stringVal();
lexer.nextToken();
var = new SQLVariantRefExpr(ident, false);
var = new SQLVariantRefExpr(ident);
item.setTarget(var);
if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
accept(Token.EQ);
item.setValue(expr());
return item;
public void scanVariable() {
final char first = ch;
if (ch != '@' && ch != ':' && ch != '#') {
throw new SQLParseException("illegal variable");
int hash = first;
if (buf[bp + 1] == '@') {
ch = buf[++bp];
hash = 31 * hash + ch;
if (buf[bp + 1] == '`') {
for (;;) {
ch = buf[++bp];
if (ch == '`') {
ch = buf[++bp];
} else if (ch == EOI) {
throw new SQLParseException("illegal identifier");
hash = 31 * hash + ch;
continue;
this.ch = buf[bp];
stringVal = symbolTable.addSymbol(buf, np, sp, hash);
token = Token.VARIANT;
for (;;) {
ch = buf[++bp];
if (!isIdentifierChar(ch)) {
hash = 31 * hash + ch;
continue;
this.ch = buf[bp];
stringVal = symbolTable.addSymbol(buf, np, sp, hash);
token = Token.VARIANT;
MySqlUpdateStatement stmt = (MySqlUpdateStatement) super.parseUpdateStatement();
if (lexer.token() == Token.LIMIT) {
return stmt;
protected MySqlUpdateStatement createUpdateStatement() {
return new MySqlUpdateStatement();
if (identifierEquals("DESC") || identifierEquals("DESCRIBE")) {
public MySqlDescribeStatement parseDescribe() throws ParserException {
if (identifierEquals("DESC") || identifierEquals("DESCRIBE")) {
lexer.nextToken();
throw new ParserException("expect DESC, actual " + lexer.token());
public SQLStatement parseSet() throws ParserException {
accept(Token.SET);
Boolean global = null;
if (identifierEquals("GLOBAL")) {
global = Boolean.TRUE;
lexer.nextToken();
} else if (identifierEquals("SESSION")) {
global = Boolean.FALSE;
lexer.nextToken();
if (identifierEquals("TRANSACTION")) {
lexer.nextToken();
acceptIdentifier("ISOLATION");
acceptIdentifier("LEVEL");
MySqlSetTransactionIsolationLevelStatement stmt = new MySqlSetTransactionIsolationLevelStatement();
stmt.setGlobal(global);
if (identifierEquals("READ")) {
lexer.nextToken();
if (identifierEquals("UNCOMMITTED")) {
stmt.setLevel("READ UNCOMMITTED");
lexer.nextToken();
} else if (identifierEquals("WRITE")) {
stmt.setLevel("READ WRITE");
lexer.nextToken();
} else if (identifierEquals("ONLY")) {
stmt.setLevel("READ ONLY");
lexer.nextToken();
} else if (identifierEquals("COMMITTED")) {
stmt.setLevel("READ COMMITTED");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
} else if (identifierEquals("SERIALIZABLE")) {
stmt.setLevel("SERIALIZABLE");
lexer.nextToken();
} else if (identifierEquals("REPEATABLE")) {
lexer.nextToken();
if (identifierEquals("READ")) {
stmt.setLevel("REPEATABLE READ");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
return stmt;
SQLSetStatement stmt = new SQLSetStatement();
parseAssignItems(stmt.getItems());
if (global != null && global.booleanValue()) {
SQLVariantRefExpr varRef = (SQLVariantRefExpr) stmt.getItems().get(0).getTarget();
varRef.setGlobal(true);
return stmt;
boolean visit(MySqlSetTransactionIsolationLevelStatement x);
void endVisit(MySqlSetTransactionIsolationLevelStatement x);
@Override
public boolean visit(MySqlSetTransactionIsolationLevelStatement x) {
return true;
@Override
public void endVisit(MySqlSetTransactionIsolationLevelStatement x) {
if (x.isGlobal()) {
print("@@global.");
if ((!x.getName().startsWith("@")) && (!x.getName().equals("?"))) {
print("@@");
for (int i = 0; i < x.getName().length(); ++i) {
char ch = x.getName().charAt(i);
if (ch == ''') {
if (x.getName().startsWith("@@") && i == 2) {
print(ch);
} else if (x.getName().startsWith("@") && i == 1) {
print(ch);
} else if (i != 0 && i != x.getName().length() - 1) {
print("\'");
print(ch);
print(ch);
if (x.getColumnsTerminatedBy() != null || x.getColumnsEnclosedBy() != null || x.getColumnsEscaped() != null) {
print("DESC ");
@Override
public boolean visit(MySqlUpdateStatement x) {
super.visit((SQLUpdateStatement) x);
if (x.getLimit() != null) {
println();
x.getLimit().accept(this);
return false;
@Override
public void endVisit(MySqlUpdateStatement x) {
@Override
public boolean visit(MySqlSetTransactionIsolationLevelStatement x) {
return false;
@Override
public void endVisit(MySqlSetTransactionIsolationLevelStatement x) {
if (x.getGlobal() == null) {
print("SET TRANSACTION ISOLATION LEVEL ");
} else if (x.getGlobal().booleanValue()) {
print("SET GLOBAL TRANSACTION ISOLATION LEVEL ");
print("SET SESSION TRANSACTION ISOLATION LEVEL ");
print(x.getLevel());
@Override
public boolean visit(MySqlSetTransactionIsolationLevelStatement x) {
return false;
@Override
public void endVisit(MySqlSetTransactionIsolationLevelStatement x) {
public class OracleDateExpr extends SQLExprImpl implements SQLLiteralExpr, OracleExpr {
public class OracleIntervalExpr extends SQLExprImpl implements SQLLiteralExpr, OracleExpr {
public class OracleTimestampExpr extends SQLExprImpl implements SQLLiteralExpr, OracleExpr {
SQLVariantRefExpr varRefExpr = new SQLVariantRefExpr(lexer.stringVal());
if (varRefExpr.getName().equals("@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@'" + lexer.stringVal() + "'");
lexer.nextToken();
} else if (varRefExpr.getName().equals("@@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@@'" + lexer.stringVal() + "'");
lexer.nextToken();
sqlExpr = varRefExpr;
} else if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
rightExp = expr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Assignment, rightExp);
public SQLAssignItem parseAssignItem() {
SQLAssignItem item = new SQLAssignItem();
SQLExpr var = primary();
if (var instanceof SQLIdentifierExpr) {
var = new SQLVariantRefExpr(((SQLIdentifierExpr) var).getName());
item.setTarget(var);
if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
accept(Token.EQ);
item.setValue(expr());
return item;
public void match(Token token) {
if (lexer.token() != token) {
throw new SQLParseException("syntax error, expect " + token + ", actual " + lexer.token() + " "
+ lexer.stringVal());
SQLAssignItem item = exprParser.parseAssignItem();
public final class  HexBin {
static private final int  BASELENGTH   = 128;
static private final int  LOOKUPLENGTH = 16;
static final private byte [] hexNumberTable    = new byte[BASELENGTH];
static final private char [] lookUpHexAlphabet = new char[LOOKUPLENGTH];
for (int i = 0; i < BASELENGTH; i++ ) {
hexNumberTable[i] = -1;
for ( int i = '9'; i >= '0'; i--) {
hexNumberTable[i] = (byte) (i-'0');
for ( int i = 'F'; i>= 'A'; i--) {
hexNumberTable[i] = (byte) ( i-'A' + 10 );
for ( int i = 'f'; i>= 'a'; i--) {
hexNumberTable[i] = (byte) ( i-'a' + 10 );
for(int i = 0; i<10; i++ ) {
lookUpHexAlphabet[i] = (char)('0'+i);
for(int i = 10; i<=15; i++ ) {
lookUpHexAlphabet[i] = (char)('A'+i -10);
static public String encode(byte[] binaryData) {
if (binaryData == null)
return null;
int lengthData   = binaryData.length;
int lengthEncode = lengthData * 2;
char[] encodedData = new char[lengthEncode];
for (int i = 0; i < lengthData; i++) {
temp = binaryData[i];
if (temp < 0)
temp += 256;
encodedData[i*2] = lookUpHexAlphabet[temp >> 4];
encodedData[i*2+1] = lookUpHexAlphabet[temp & 0xf];
return new String(encodedData);
static public byte[] decode(String encoded) {
if (encoded == null)
return null;
int lengthData = encoded.length();
if (lengthData % 2 != 0)
return null;
char[] binaryData = encoded.toCharArray();
int lengthDecode = lengthData / 2;
byte[] decodedData = new byte[lengthDecode];
byte temp1, temp2;
char tempChar;
for( int i = 0; i<lengthDecode; i++ ){
tempChar = binaryData[i*2];
temp1 = (tempChar < BASELENGTH) ? hexNumberTable[tempChar] : -1;
if (temp1 == -1)
return null;
tempChar = binaryData[i*2+1];
temp2 = (tempChar < BASELENGTH) ? hexNumberTable[tempChar] : -1;
if (temp2 == -1)
return null;
decodedData[i] = (byte)((temp1 << 4) | temp2);
return decodedData;
public class DALParserTest extends TestCase {
public void testdesc() throws Exception {
String sql = "desc tb1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlDescribeStatement desc = parser.parseDescribe();
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(desc);
Assert.assertEquals("DESC tb1", output);
public void testdesc_1() throws Exception {
String sql = "desc db.tb1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlDescribeStatement desc = parser.parseDescribe();
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(desc);
Assert.assertEquals("DESC db.tb1", output);
public void testSet_1() throws Exception {
String sql = "seT sysVar1 = ? ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET @@sysVar1 = ?", output);
public void testSet_2() throws Exception {
String sql = "SET `sysVar1` = ?, @@gloBal . `var2` :=1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET @@`sysVar1` = ?, @@global.`var2` = 1", output);
public void testSet_3() throws Exception {
String sql = "SET @usrVar1 := ?, @@`var2` =1, @@var3:=?, @'var\'3'=?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET @usrVar1 = ?, @@`var2` = 1, @@var3 = ?, @'var\'3' = ?", output);
public void testSet_4() throws Exception {
String sql = "SET GLOBAL var1=1, SESSION var2:=2";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET @@global.var1 = 1, @@var2 = 2", output);
public void testSet_5() throws Exception {
String sql = "SET @@GLOBAL. var1=1, SESSION var2:=2";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET @@global.var1 = 1, @@var2 = 2", output);
public void testSetTxn_0() throws Exception {
String sql = "SET transaction ISOLATION LEVEL READ UNCOMMITTED";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlSetTransactionIsolationLevelStatement set = (MySqlSetTransactionIsolationLevelStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED", output);
public void testSetTxn_1() throws Exception {
String sql = "SET global transaction ISOLATION LEVEL READ COMMITTED";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlSetTransactionIsolationLevelStatement set = (MySqlSetTransactionIsolationLevelStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED", output);
public void testSetTxn_2() throws Exception {
String sql = "SET transaction ISOLATION LEVEL REPEATABLE READ ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlSetTransactionIsolationLevelStatement set = (MySqlSetTransactionIsolationLevelStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ", output);
public void testSetTxn_3() throws Exception {
String sql = "SET session transaction ISOLATION LEVEL SERIALIZABLE";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlSetTransactionIsolationLevelStatement set = (MySqlSetTransactionIsolationLevelStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(set);
Assert.assertEquals("SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE", output);
public class LiteralHexadecimalTest extends TestCase {
public void test_0() throws Exception {
String sql = "x'E982B1E7A195275C73'";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("'\s", new String(hex.toBytes(), "utf-8"));
public void test_1() throws Exception {
String sql = "x'0D0A'";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("rn", new String(hex.toBytes(), "utf-8"));
public void test_2() throws Exception {
String sql = "X'4D7953514C'";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("MySQL", new String(hex.toBytes(), "utf-8"));
public void test_3() throws Exception {
String sql = "0x5061756c";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("Paul", new String(hex.toBytes(), "utf-8"));
public void test_4() throws Exception {
String sql = "0x41";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("A", new String(hex.toBytes(), "utf-8"));
public void test_5() throws Exception {
String sql = "0x636174";
SQLHexExpr hex = (SQLHexExpr) new MySqlExprParser(sql).expr();
Assert.assertEquals("cat", new String(hex.toBytes(), "utf-8"));
private SQLExpr           name;
acceptChild(visitor, name);
public SQLExpr getName() {
return name;
public void setName(SQLExpr functionName) {
this.name = functionName;
stmt.setName(this.exprParser.name());
x.getName().accept(this);
acceptIdentifier("ZONE");
while (identifierEquals("REFERENCE")) {
acceptIdentifier("REFERENCE");
public class MySqlShowIndexesStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
private SQLName           table;
private SQLName           database;
public SQLName getTable() {
return table;
public void setTable(SQLName table) {
if (table instanceof SQLPropertyExpr) {
SQLPropertyExpr propExpr = (SQLPropertyExpr) table;
this.setDatabase((SQLName) propExpr.getOwner());
this.table = new SQLIdentifierExpr(propExpr.getName());
this.table = table;
public SQLName getDatabase() {
return database;
public void setDatabase(SQLName database) {
this.database = database;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, table);
acceptChild(visitor, database);
visitor.endVisit(this);
if (lexer.token() == Token.INDEX || identifierEquals("INDEXES")) {
lexer.nextToken();
MySqlShowIndexesStatement stmt = new MySqlShowIndexesStatement();
if (lexer.token() == Token.FROM || lexer.token() == Token.IN) {
lexer.nextToken();
SQLName table = exprParser.name();
stmt.setTable(table);
if (lexer.token() == Token.FROM || lexer.token() == Token.IN) {
lexer.nextToken();
SQLName database = exprParser.name();
stmt.setDatabase(database);
return stmt;
boolean visit(MySqlShowIndexesStatement x);
void endVisit(MySqlShowIndexesStatement x);
@Override
public boolean visit(MySqlShowIndexesStatement x) {
return true;
@Override
public void endVisit(MySqlShowIndexesStatement x) {
@Override
public boolean visit(MySqlShowIndexesStatement x) {
print("SHOW INDEX");
if (x.getTable() != null) {
print(" FROM ");
if (x.getDatabase() != null) {
x.getDatabase().accept(this);
print('.');
x.getTable().accept(this);
return false;
@Override
public void endVisit(MySqlShowIndexesStatement x) {
@Override
public boolean visit(MySqlShowIndexesStatement x) {
return false;
@Override
public void endVisit(MySqlShowIndexesStatement x) {
public void test_show_index() throws Exception {
String sql = "SHOW index from tb1 from db";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlShowIndexesStatement show = (MySqlShowIndexesStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(show);
Assert.assertEquals("SHOW INDEX FROM db.tb1", output);
public void test_show_index_1() throws Exception {
String sql = "SHOW index in tb1 in db";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlShowIndexesStatement show = (MySqlShowIndexesStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(show);
Assert.assertEquals("SHOW INDEX FROM db.tb1", output);
public void test_show_index_2() throws Exception {
String sql = "SHOW index in db.tb1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlShowIndexesStatement show = (MySqlShowIndexesStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(show);
Assert.assertEquals("SHOW INDEX FROM db.tb1", output);
public class MySqlShowPluginsStatement extends MySqlStatementImpl {
private static final long serialVersionUID = 1L;
public void accept0(MySqlASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
if (identifierEquals("PLUGINS")) {
lexer.nextToken();
MySqlShowPluginsStatement stmt = new MySqlShowPluginsStatement();
return stmt;
boolean visit(MySqlShowPluginsStatement x);
void endVisit(MySqlShowPluginsStatement x);
@Override
public boolean visit(MySqlShowPluginsStatement x) {
return true;
@Override
public void endVisit(MySqlShowPluginsStatement x) {
@Override
public boolean visit(MySqlShowPluginsStatement x) {
print("SHOW PLUGINS");
return false;
@Override
public void endVisit(MySqlShowPluginsStatement x) {
@Override
public boolean visit(MySqlShowPluginsStatement x) {
return false;
@Override
public void endVisit(MySqlShowPluginsStatement x) {
public void test_open_plugins() throws Exception {
String sql = "SHOW plugins";
MySqlStatementParser parser = new MySqlStatementParser(sql);
MySqlShowPluginsStatement show = (MySqlShowPluginsStatement) parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(show);
Assert.assertEquals("SHOW PLUGINS", output);
public class SQLAlterTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class SQLCreateTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class SQLCreateViewStatement extends SQLStatementImpl implements SQLDDLStatement {
public interface SQLDDLStatement extends SQLStatement {
public class SQLDropTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class SQLAlterTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class SQLCreateTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class SQLCreateViewStatement extends SQLStatementImpl implements SQLDDLStatement {
public interface SQLDDLStatement extends SQLStatement {
public class SQLDropTableStatement extends SQLStatementImpl implements SQLDDLStatement {
public class OracleAlterTableStatement extends SQLAlterTableStatement implements OracleDDLStatement {
public class OracleCreateTableStatement extends SQLCreateTableStatement implements OracleDDLStatement {
public interface OracleDDLStatement extends SQLDDLStatement, OracleStatement {
private boolean           ignore           = false;
if (visitor.visit(this)) {
acceptChild(visitor, getTableSource());
acceptChild(visitor, getItems());
visitor.endVisit(this);
public boolean isIgnore() {
return ignore;
public void setIgnore(boolean ignore) {
this.ignore = ignore;
public SQLStatement parseAlter() {
boolean ignore = false;
if (identifierEquals("IGNORE")) {
ignore = true;
lexer.nextToken();
if (lexer.token() == Token.TABLE) {
lexer.nextToken();
MySqlAlterTableStatement stmt = new MySqlAlterTableStatement();
stmt.setIgnore(ignore);
stmt.setName(this.exprParser.name());
for (;;) {
if (identifierEquals("ADD")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("ALTER")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("CHANGE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("MODIFY")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("DROP")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("DISABLE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("ENABLE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("RENAME")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (lexer.token() == Token.ORDER) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("CONVERT")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (lexer.token() == Token.DEFAULT) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("DISCARD")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("IMPORT")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("FORCE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("TRUNCATE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("COALESCE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("REORGANIZE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("EXCHANGE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("ANALYZE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("CHECK")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("OPTIMIZE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("REBUILD")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("REPAIR")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("REMOVE")) {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
return stmt;
boolean visit(MySqlAlterTableStatement x);
void endVisit(MySqlAlterTableStatement x);
@Override
public boolean visit(MySqlAlterTableStatement x) {
return true;
@Override
public void endVisit(MySqlAlterTableStatement x) {
@Override
public boolean visit(MySqlAlterTableStatement x) {
if (x.isIgnore()) {
print("ALTER IGNORE TABLE ");
print("ALTER TABLE ");
x.getName().accept(this);
incrementIndent();
for (SQLAlterTableItem item : x.getItems()) {
println();
item.accept(this);
decrementIndent();
return false;
@Override
public void endVisit(MySqlAlterTableStatement x) {
@Override
public boolean visit(MySqlAlterTableStatement x) {
return false;
@Override
public void endVisit(MySqlAlterTableStatement x) {
public SQLStatement parseAlter() {
Assert.assertEquals("ALTER IGNORE TABLE tb_name", output);
if (lexer.token() == Token.IF || identifierEquals("IF")) {
public void test_createTable_0() throws Exception {
String sql = "crEate temporary tabLe if not exists tb_name (fid int)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TEMPORARY TABLE IF NOT EXISTS tb_name (ntfid intn)", output);
public class SQLCreateIndexStatement extends SQLStatementImpl implements SQLDDLStatement {
private static final long          serialVersionUID = 1L;
private SQLName                    name;
private SQLName                    table;
private List<SQLSelectOrderByItem> items            = new ArrayList<SQLSelectOrderByItem>();
private String                     type;
public SQLName getTable() {
return table;
public void setTable(SQLName table) {
this.table = table;
public List<SQLSelectOrderByItem> getItems() {
return items;
public void setItems(List<SQLSelectOrderByItem> items) {
this.items = items;
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
public String getType() {
return type;
public void setType(String type) {
this.type = type;
public class MySqlCreateIndexStatement extends SQLCreateIndexStatement implements MySqlStatement {
private static final long serialVersionUID = 1L;
private String            using;
public String getUsing() {
return using;
public void setUsing(String using) {
this.using = using;
protected void accept0(SQLASTVisitor visitor) {
accept0((MySqlASTVisitor) visitor);
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getName());
acceptChild(visitor, getTable());
acceptChild(visitor, getItems());
visitor.endVisit(this);
map.put("DESC", Token.DESC);
if (lexer.token() == Token.UNIQUE || lexer.token() == Token.INDEX || identifierEquals("FULLTEXT") || identifierEquals("SPATIAL")) {
return parseCreateIndex();
public SQLStatement parseCreateIndex() throws ParserException {
MySqlCreateIndexStatement stmt = new MySqlCreateIndexStatement();
if (lexer.token() == Token.UNIQUE) {
stmt.setType("UNIQUE");
lexer.nextToken();
} else if (identifierEquals("FULLTEXT")) {
stmt.setType("FULLTEXT");
lexer.nextToken();
} else if (identifierEquals("SPATIAL")) {
stmt.setType("SPATIAL");
lexer.nextToken();
accept(Token.INDEX);
stmt.setName(this.exprParser.name());
if (identifierEquals("USING")) {
lexer.nextToken();
if (identifierEquals("BTREE")) {
stmt.setType("BTREE");
lexer.nextToken();
} else if (identifierEquals("HASH")) {
stmt.setType("HASH");
lexer.nextToken();
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
accept(Token.ON);
stmt.setTable(this.exprParser.name());
accept(Token.LPAREN);
for (;;) {
SQLSelectOrderByItem item = this.exprParser.parseSelectOrderByItem();
stmt.getItems().add(item);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
accept(Token.RPAREN);
return stmt;
if (lexer.token() == Token.CREATE) {
lexer.nextToken();
boolean visit(MySqlCreateIndexStatement x);
void endVisit(MySqlCreateIndexStatement x);
@Override
public boolean visit(MySqlCreateIndexStatement x) {
return true;
@Override
public void endVisit(MySqlCreateIndexStatement x) {
@Override
public boolean visit(MySqlCreateIndexStatement x) {
print("CREATE ");
if (x.getType() != null) {
print(x.getType());
print(" ");
print("INDEX ");
if (x.getUsing() != null) {
print("USING ");
print(x.getUsing());
print(' ');
x.getName().accept(this);
print(" ON ");
x.getTable().accept(this);
print(" (");
printAndAccept(x.getItems(), ", ");
print(")");
return false;
@Override
public void endVisit(MySqlCreateIndexStatement x) {
@Override
public boolean visit(MySqlCreateIndexStatement x) {
return false;
@Override
public void endVisit(MySqlCreateIndexStatement x) {
public class OracleCreateIndexStatement extends SQLCreateIndexStatement implements OracleDDLStatement {
private static final long serialVersionUID  = 1L;
private boolean           online            = false;
private boolean           indexOnlyTopLevel = false;
private boolean           noParallel;
private SQLExpr           parallel;
private SQLName           tablespace;
public SQLName getTablespace() {
return tablespace;
public void setTablespace(SQLName tablespace) {
this.tablespace = tablespace;
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
acceptChild(visitor, getName());
acceptChild(visitor, getTable());
acceptChild(visitor, getItems());
acceptChild(visitor, getTablespace());
stmt.setType("UNIQUE");
stmt.setType("BITMAP");
print("CREATE ");
print(x.getType());
print("INDEX ");
public void test_createTable_1() throws Exception {
String sql = "crEate tabLe if not exists tb_name (fid int)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE IF NOT EXISTS tb_name (ntfid intn)", output);
public void test_createIndex_0() throws Exception {
String sql = "create index `idx1` ON tb1 (`fname` ASC) ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE INDEX `idx1` ON tb1 (`fname` ASC)", output);
public void test_createIndex_1() throws Exception {
String sql = "create unique index `idx1` ON tb1 (`fname` desc) ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE UNIQUE INDEX `idx1` ON tb1 (`fname` DESC)", output);
private boolean           temporary        = false;
private String            option;
public boolean isTemporary() {
return temporary;
public void setTemporary(boolean temporary) {
this.temporary = temporary;
public String getOption() {
return option;
public void setOption(String option) {
this.option = option;
if (lexer.token() == Token.UNIQUE || lexer.token() == Token.INDEX || identifierEquals("FULLTEXT")
|| identifierEquals("SPATIAL")) {
if (identifierEquals("TEMPORARY")) {
lexer.nextToken();
stmt.setTemporary(true);
accept(Token.TABLE);
if (identifierEquals("RESTRICT")) {
stmt.setOption("RESTRICT");
lexer.nextToken();
} else if (identifierEquals("CASCADE")) {
stmt.setOption("CASCADE");
lexer.nextToken();
if (x.isTemporary()) {
print("DROP TEMPORARY TABLE ");
print("DROP TABLE ");
if (x.getOption() != null) {
print(' ');
print(x.getOption());
if (lexer.token() == Token.TABLE || identifierEquals("TEMPORARY")) {
public void test_drop_table_0() throws Exception {
String sql = "DROP TEMPORARY TABLE IF EXISTS tb1, tb2, tb3 RESTRICT";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DROP TEMPORARY TABLE IF EXISTS tb1, tb2, tb3 RESTRICT", output);
public void test_drop_table_1() throws Exception {
String sql = "DROP TEMPORARY TABLE IF EXISTS tb1, tb2, tb3 CASCADE";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DROP TEMPORARY TABLE IF EXISTS tb1, tb2, tb3 CASCADE", output);
public void test_drop_table_2() throws Exception {
String sql = "DROP TABLE t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DROP TABLE t1", output);
public SQLStatement parseRename() {
MySqlRenameTableStatement stmt = new MySqlRenameTableStatement();
acceptIdentifier("RENAME");
accept(Token.TABLE);
for (;;) {
MySqlRenameTableStatement.Item item = new MySqlRenameTableStatement.Item();
item.setName(this.exprParser.name());
acceptIdentifier("TO");
item.setTo(this.exprParser.name());
stmt.getItems().add(item);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
return stmt;
print("RENAME TABLE ");
identifierEquals("TO");
if (identifierEquals("TO")) {
lexer.nextToken();
acceptIdentifier("TO");
if (identifierEquals("TO")) {
if (identifierEquals("TO")) {
acceptIdentifier("TO");
if (identifierEquals("TO")) {
public void test_rename_1() throws Exception {
String sql = "rename table tb1 to ntb1,tb2 to ntb2";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("RENAME TABLE tb1 TO ntb1, tb2 TO ntb2", output);
public class DMLCallParserTest extends TestCase {
public void testCall_0() throws Exception {
String sql = "call p(?,?)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CALL p(?, ?)", output);
public void testCall_1() throws Exception {
String sql = "call p(@var1,'@var2',var3)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CALL p(@var1, '@var2', var3)", output);
public void testCall_2() throws Exception {
String sql = "call p()";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CALL p()", output);
public class DMLDeleteParserTest extends TestCase {
public void testDelete_0() throws Exception {
String sql = "deLetE LOW_PRIORITY from id1.id , id using t1 a where col1 =? ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE LOW_PRIORITY FROM id1.id, idn" + 
"USING t1 a" + 
"nWHERE col1 = ?", output);
public void testDelete_1() throws Exception {
String sql = "deLetE from id1.id  using t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM id1.id" + 
"nUSING t1", output);
public void testDelete_2() throws Exception {
String sql = "delete from offer.*,wp_image.* using offer a,wp_image b where a.member_id=b.member_id and a.member_id='abc' ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM offer.*, wp_image.*n" + 
"USING offer a, wp_image bn" + 
"WHERE a.member_id = b.member_idn" + 
"AND a.member_id = 'abc'", output);
public void testDelete_3() throws Exception {
String sql = "deLetE from id1.id where col1='adf' limit 1,?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM id1.idn" + 
"WHERE col1 = 'adf'n" + 
"LIMIT 1, ?", output);
public void testDelete_4() throws Exception {
String sql = "deLetE from id where col1='adf' ordEr by d liMit ? offset 2";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM idn" + 
"WHERE col1 = 'adf'n" + 
"ORDER BY dn" + 
"LIMIT 2, ?", output);
public void testDelete_5() throws Exception {
String sql = "deLetE id.* from t1,t2 where col1='adf'            and col2=1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE id.*n" + 
"FROM t1, t2n" + 
"WHERE col1 = 'adf'n" + 
"AND col2 = 1", output);
public void testDelete_6() throws Exception {
String sql = "deLetE id,id.t from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE id, id.tn" + 
"FROM t1", output);
public void testDelete_7() throws Exception {
String sql = "deLetE from t1 where t1.id1='abc' order by a limit 5";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM t1n" + 
"WHERE t1.id1 = 'abc'n" + 
"ORDER BY an" + 
"LIMIT 5", output);
public void testDelete_8() throws Exception {
String sql = "deLetE from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM t1", output);
public void testDelete_9() throws Exception {
String sql = "deLetE ignore tb1.*,id1.t from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE IGNORE tb1.*, id1.tn"
"FROM t1", output);
public void testDelete_10() throws Exception {
String sql = "deLetE quick tb1.*,id1.t from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE QUICK tb1.*, id1.tn"
"FROM t1", output);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
if (lexer.token() == Token.SELECT) {
SQLQueryExpr queryExpr = (SQLQueryExpr) this.exprParser.expr();
stmt.setQuery(queryExpr);
this.exprParser.exprList(stmt.getColumns());
accept(Token.RPAREN);
SQLInsertStatement.ValuesClause values = new SQLInsertStatement.ValuesClause();
stmt.getValuesList().add(values);
for (;;) {
stmt.getColumns().add(this.exprParser.name());
if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
accept(Token.EQ);
values.getValues().add(this.exprParser.expr());
} else if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLQueryExpr queryExpr = (SQLQueryExpr) this.exprParser.expr();
stmt.setQuery(queryExpr);
accept(Token.RPAREN);
if (lexer.token() == (Token.SELECT)) {
SQLSelect select = this.exprParser.createSelectParser().select();
select.setParent(insertStatement);
insertStatement.setQuery(select);
this.exprParser.exprList(insertStatement.getColumns());
SQLSelect select = this.exprParser.createSelectParser().select();
select.setParent(insertStatement);
insertStatement.setQuery(select);
} else if (lexer.token() == (Token.LPAREN)) {
lexer.nextToken();
SQLSelect select = this.exprParser.createSelectParser().select();
select.setParent(insertStatement);
insertStatement.setQuery(select);
accept(Token.RPAREN);
println();
public void testInsert_3() throws Exception {
String sql = "insErt LOW_PRIORITY t1 valueS (12e-2,1,2), (?),(default)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1nVALUES (0.12, 1, 2), (?), (DEFAULT)", output);
public void testInsert_4() throws Exception {
String sql = "insErt LOW_PRIORITY t1 select id from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1nSELECT idnFROM t1", output);
public void testInsert_5() throws Exception {
String sql = "insErt LOW_PRIORITY t1 (select id from t1) oN dupLicatE key UPDATE ex.col1=?, col2=12";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1nSELECT idnFROM t1 ON DUPLICATE KEY UPDATE ex.col1 = ?, col2 = 12", output);
public void testInsert_6() throws Exception {
String sql = "insErt LOW_PRIORITY t1 (t1.col1) valueS (123),('12''34')";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (t1.col1)nVALUES (123), ('12''34')", output);
public void testInsert_7() throws Exception {
String sql = "insErt LOW_PRIORITY t1 (col1, t1.col2) VALUE (123,'123\'4') oN dupLicatE key UPDATE ex.col1=?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (col1, t1.col2)nVALUES (123, '123''4') ON DUPLICATE KEY UPDATE ex.col1 = ?", output);
public void testInsert_8() throws Exception {
String sql = "insErt LOW_PRIORITY t1 (col1, t1.col2) select id from t3 oN dupLicatE key UPDATE ex.col1=?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (col1, t1.col2)nSELECT idnFROM t3 ON DUPLICATE KEY UPDATE ex.col1 = ?", output);
public void testInsert_9() throws Exception {
String sql = "insErt LOW_PRIORITY IGNORE intO t1 (col1) ( select id from t3) ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY IGNORE INTO t1 (col1)nSELECT idnFROM t3", output);
public class DMLReplaceParserTest extends TestCase {
public void testReplace_0() throws Exception {
String sql = "ReplaCe LOW_PRIORITY intO test.t1 seT t1.id1:=?, id2='123'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO test.t1 (t1.id1, id2)nVALUES (?, '123')", output);
public void testReplace_1() throws Exception {
String sql = "ReplaCe   test.t1 seT t1.id1:=? ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE INTO test.t1 (t1.id1)nVALUES (?)", output);
public void testReplace_2() throws Exception {
String sql = "ReplaCe t1 value (123,?) ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE INTO t1nVALUES (123, ?)", output);
public void testReplace_3() throws Exception {
String sql = "ReplaCe LOW_PRIORITY t1 valueS (12e-2), (?)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1nVALUES (0.12), (?)", output);
public void testReplace_4() throws Exception {
String sql = "ReplaCe LOW_PRIORITY t1 select id from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1ntSELECT idntFROM t1", output);
public void testReplace_5() throws Exception {
String sql = "ReplaCe delayed t1 select id from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE DELAYED INTO t1ntSELECT idntFROM t1", output);
public void testReplace_6() throws Exception {
String sql = "ReplaCe LOW_PRIORITY t1 (select id from t1) ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1ntSELECT idntFROM t1", output);
public void testReplace_7() throws Exception {
String sql = "ReplaCe LOW_PRIORITY t1 (t1.col1) valueS (123),('12''34')";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1 (t1.col1)nVALUES (123), ('12''34')", output);
public void testReplace_8() throws Exception {
String sql = "ReplaCe LOW_PRIORITY t1 (col1, t1.col2) VALUE (123,'123\'4') ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1 (col1, t1.col2)nVALUES (123, '123''4')", output);
public void testReplace_9() throws Exception {
String sql = "REPLACE LOW_PRIORITY t1 (col1, t1.col2) select id from t3 ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1 (col1, t1.col2)ntSELECT idntFROM t3", output);
public void testReplace_10() throws Exception {
String sql = "replace LOW_PRIORITY  intO t1 (col1) ( select id from t3) ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("REPLACE LOW_PRIORITY INTO t1 (col1)ntSELECT idntFROM t3", output);
public class SQLRollbackStatement extends SQLStatementImpl {
protected void accept0(SQLASTVisitor visitor) {
public class SQLSavePointStatement extends SQLStatementImpl {
private static final long serialVersionUID = 1L;
private SQLExpr           name;
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public class MySqlIgnoreIndexHint extends MySqlIndexHintImpl {
private static final long serialVersionUID = 1L;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getIndexList());
visitor.endVisit(this);
SQLRollbackStatement stmt = new SQLRollbackStatement();
public void endVisit(SQLRollbackStatement x) {
@Override
public boolean visit(SQLRollbackStatement x) {
print("ROLLBACK");
if (x.getTo() != null) {
print(" TO ");
x.getTo().accept(this);
return false;
boolean visit(SQLRollbackStatement x);
void endVisit(SQLRollbackStatement x);
public boolean visit(SQLRollbackStatement x) {
return true;
public void endVisit(SQLRollbackStatement x) {
public class DMLUpdateParserTest extends TestCase {
public void test_update_0() throws Exception {
String sql = "upDate LOw_PRIORITY IGNORE test.t1 sEt t1.col1=?, col2=DefaulT";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE LOW_PRIORITY IGNORE test.t1nSET t1.col1 = ?, col2 = DEFAULT", output);
public void test_update_1() throws Exception {
String sql = "upDate  IGNORE (t1) set col2=DefaulT order bY t1.col2 ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE IGNORE t1nSET col2 = DEFAULTnORDER BY t1.col2", output);
public void test_update_2() throws Exception {
String sql = "upDate   (test.t1) SET col2=DefaulT order bY t1.col2 limit ? offset 1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE test.t1nSET col2 = DEFAULTnORDER BY t1.col2nLIMIT 1, ?", output);
public void test_update_3() throws Exception {
String sql = "upDate LOW_PRIORITY  t1, test.t2 SET col2=DefaulT , col2='123''4'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE LOW_PRIORITY t1, test.t2nSET col2 = DEFAULT, col2 = '123''4'", output);
public void test_update_4() throws Exception {
String sql = "upDate LOW_PRIORITY  t1, test.t2 SET col2:=DefaulT , col2='123''4' where id='a'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE LOW_PRIORITY t1, test.t2nSET col2 = DEFAULT, col2 = '123''4'nWHERE id = 'a'", output);
public class MTSParserTest extends TestCase {
public void test_mts_0() throws Exception {
String sql = "  savepoint xx";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SAVEPOINT xx", output);
public class SQLReleaseSavePointStatement extends SQLStatementImpl {
private static final long serialVersionUID = 1L;
private SQLExpr           name;
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
if (identifierEquals("RELEASE")) {
SQLStatement stmt = parseReleaseSavePoint();
statementList.add(stmt);
continue;
if (identifierEquals("ROLLBACK")) {
lexer.nextToken();
if (identifierEquals("WORK")) {
lexer.nextToken();
SQLRollbackStatement stmt = new SQLRollbackStatement();
if (identifierEquals("TO")) {
lexer.nextToken();
if (identifierEquals("SAVEPOINT")) {
lexer.nextToken();
stmt.setTo(this.exprParser.name());
statementList.add(stmt);
continue;
public SQLStatement parseReleaseSavePoint() {
acceptIdentifier("RELEASE");
acceptIdentifier("SAVEPOINT");
SQLReleaseSavePointStatement stmt = new SQLReleaseSavePointStatement();
stmt.setName(this.exprParser.name());
return stmt;
@Override
public boolean visit(SQLReleaseSavePointStatement x) {
print("RELEASE SAVEPOINT ");
x.getName().accept(this);
return false;
boolean visit(SQLReleaseSavePointStatement x);
void endVisit(SQLReleaseSavePointStatement x);
public boolean visit(SQLReleaseSavePointStatement x) {
return true;
public void endVisit(SQLReleaseSavePointStatement x) {
public void test_mts_1() throws Exception {
String sql = "  savepoint SAVEPOINT";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SAVEPOINT SAVEPOINT", output);
public void test_mts_2() throws Exception {
String sql = "  savepoInt `select`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SAVEPOINT `select`", output);
public void test_mts_3() throws Exception {
String sql = "Release sAVEPOINT xx   ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("RELEASE SAVEPOINT xx", output);
public void test_rollback_0() throws Exception {
String sql = "rollBack to x1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ROLLBACK TO x1", output);
public void test_rollback_1() throws Exception {
String sql = "rollBack work to x1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ROLLBACK TO x1", output);
public void test_rollback_2() throws Exception {
String sql = "rollBack work to savepoint x1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ROLLBACK TO x1", output);
public class MySqlLockTableStatement extends MySqlStatementImpl {
private static final long  serialVersionUID = 1L;
private SQLExprTableSource tableSource;
private LockType           lockType;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
public void setTableSource(SQLName name) {
this.tableSource = new SQLExprTableSource(name);
public LockType getLockType() {
return lockType;
public void setLockType(LockType lockType) {
this.lockType = lockType;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, tableSource);
visitor.endVisit(this);
public static enum LockType {
READ("READ"), READ_LOCAL("READ LOCAL"), WRITE("WRITE"), LOW_PRIORITY_WRITE("LOW_PRIORITY WRITE");
public final String name;
LockType(String name){
this.name = name;
if (lexer.token() == Token.LOCK) {
lexer.nextToken();
acceptIdentifier("TABLES");
MySqlLockTableStatement stmt = new MySqlLockTableStatement();
stmt.setTableSource(this.exprParser.name());
if (identifierEquals("READ")) {
lexer.nextToken();
if (identifierEquals("LOCAL")) {
lexer.nextToken();
stmt.setLockType(LockType.READ_LOCAL);
stmt.setLockType(LockType.READ);
} else if (identifierEquals("WRITE")) {
stmt.setLockType(LockType.WRITE);
} else if (identifierEquals("LOW_PRIORITY")) {
lexer.nextToken();
acceptIdentifier("WRITE");
stmt.setLockType(LockType.LOW_PRIORITY_WRITE);
statementList.add(stmt);
return true;
boolean visit(MySqlLockTableStatement x);
void endVisit(MySqlLockTableStatement x);
@Override
public boolean visit(MySqlLockTableStatement x) {
return true;
@Override
public void endVisit(MySqlLockTableStatement x) {
@Override
public boolean visit(MySqlLockTableStatement x) {
print("LOCK TABLES ");
x.getTableSource().accept(this);
if (x.getLockType() != null) {
print(' ');
print(x.getLockType().name);
return false;
@Override
public void endVisit(MySqlLockTableStatement x) {
@Override
public boolean visit(MySqlLockTableStatement x) {
return false;
@Override
public void endVisit(MySqlLockTableStatement x) {
if (parseStatementListDialect(statementList)) {
continue;
public void test_lockTable() throws Exception {
String sql = "LOCK TABLES t1 READ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("LOCK TABLES t1 READ", output);
public void test_lockTable_1() throws Exception {
String sql = "LOCK TABLES t2 READ LOCAL;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("LOCK TABLES t2 READ LOCAL", output);
public class OracleHint extends SQLObjectImpl implements SQLHint {
protected void accept0(SQLASTVisitor visitor) {
public void parseHints(List<SQLHint> hints) {
if (lexer.token() == Token.HINT) {
hints.add(new OracleHint(lexer.stringVal()));
lexer.nextToken();
public boolean visit(OracleHint x) {
print(x.getText());
return false;
void endVisit(OracleHint x);
boolean visit(OracleHint x);
public boolean visit(OracleHint x) {
return true;
public void endVisit(OracleHint x) {
public class SQLCommentHint extends SQLObjectImpl implements SQLHint {
public SQLCommentHint(){
public SQLCommentHint(String text){
hints.add(new SQLCommentHint(lexer.stringVal()));
public void endVisit(SQLCommentHint x) {
hints.add(new SQLCommentHint(lexer.stringVal()));
public boolean visit(SQLCommentHint x) {
void endVisit(SQLCommentHint x);
boolean visit(SQLCommentHint x);
public boolean visit(SQLCommentHint x) {
public void endVisit(SQLCommentHint x) {
public static SQLASTOutputVisitor createFormatOutputVisitor(Appendable out, List<SQLStatement> statementList,
String dbType) {
public static List<SQLStatement> parseStatements(String sql, String dbType) {
SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, dbType);
return parser.parseStatementList();
@Override
protected void accept0(SQLASTVisitor visitor) {
if (visitor instanceof MySqlASTVisitor) {
accept0((MySqlASTVisitor) visitor);
visitor.visit(this);
visitor.endVisit(this);
public void accept0(MySqlASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
if (visitor.visit(this)) {
acceptChild(visitor, this.getItems());
acceptChild(visitor, this.getHaving());
visitor.endVisit(this);
boolean visit(MySqlCharExpr x);
void endVisit(MySqlCharExpr x);
@Override
public boolean visit(MySqlCharExpr x) {
return false;
@Override
public void endVisit(MySqlCharExpr x) {
print(x.toString());
@Override
public boolean visit(MySqlCharExpr x) {
print(x.toString());
return false;
@Override
public void endVisit(MySqlCharExpr x) {
@Override
public boolean visit(MySqlCharExpr x) {
return false;
@Override
public void endVisit(MySqlCharExpr x) {
public class HBaseConnection implements Connection {
private Configuration         config;
private boolean               autoCommit = true;
private String                catalog;
private int                   transactionIsolation;
private int                   holdability;
private Map<String, Class<?>> typeMap    = new HashMap<String, Class<?>>();
private SQLWarning            warings;
public HBaseConnection(Properties info){
config = new Configuration();
this.setClientInfo(info);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Configuration.class) {
return (T) config;
if (iface == Connection.class || iface == HBaseConnection.class) {
return (T) this;
return null;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == Configuration.class) {
return true;
if (iface == Connection.class || iface == HBaseConnection.class) {
return true;
return false;
public Statement createStatement() throws SQLException {
return new HBaseStatement(this);
public PreparedStatement prepareStatement(String sql) throws SQLException {
throw new SQLFeatureNotSupportedException();
public CallableStatement prepareCall(String sql) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String nativeSQL(String sql) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setAutoCommit(boolean autoCommit) throws SQLException {
this.autoCommit = autoCommit;
public boolean getAutoCommit() throws SQLException {
return autoCommit;
public void commit() throws SQLException {
public void rollback() throws SQLException {
public void close() throws SQLException {
public boolean isClosed() throws SQLException {
return false;
public DatabaseMetaData getMetaData() throws SQLException {
return null;
public void setReadOnly(boolean readOnly) throws SQLException {
public boolean isReadOnly() throws SQLException {
return false;
public void setCatalog(String catalog) throws SQLException {
this.catalog = catalog;
public String getCatalog() throws SQLException {
return catalog;
public void setTransactionIsolation(int level) throws SQLException {
this.transactionIsolation = level;
public int getTransactionIsolation() throws SQLException {
return transactionIsolation;
public SQLWarning getWarnings() throws SQLException {
return warings;
public void clearWarnings() throws SQLException {
this.warings = null;
public void setWarings(SQLWarning warings) {
this.warings = warings;
public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
throw new SQLFeatureNotSupportedException();
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
throws SQLException {
throw new SQLFeatureNotSupportedException();
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Map<String, Class<?>> getTypeMap() throws SQLException {
return typeMap;
public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
this.typeMap = map;
public void setHoldability(int holdability) throws SQLException {
this.holdability = holdability;
public int getHoldability() {
return holdability;
public Savepoint setSavepoint() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Savepoint setSavepoint(String name) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void rollback(Savepoint savepoint) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void releaseSavepoint(Savepoint savepoint) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
throws SQLException {
throw new SQLFeatureNotSupportedException();
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
throw new SQLFeatureNotSupportedException();
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
throw new SQLFeatureNotSupportedException();
public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
throw new SQLFeatureNotSupportedException();
public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
throw new SQLFeatureNotSupportedException();
public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Clob createClob() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Blob createBlob() throws SQLException {
throw new SQLFeatureNotSupportedException();
public NClob createNClob() throws SQLException {
throw new SQLFeatureNotSupportedException();
public SQLXML createSQLXML() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isValid(int timeout) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setClientInfo(String name, String value) throws SQLClientInfoException {
this.config.set(name, value);
public void setClientInfo(Properties properties) {
for (Map.Entry<Object, Object> entry : properties.entrySet()) {
if (entry.getKey() != null && entry.getValue() != null) {
config.set(entry.getKey().toString(), entry.getValue().toString());
public String getClientInfo(String name) throws SQLException {
return config.get(name);
public Properties getClientInfo() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
throw new SQLFeatureNotSupportedException();
public class HBaseDriver implements Driver {
public Connection connect(String url, Properties info) throws SQLException {
return null;
public boolean acceptsURL(String url) throws SQLException {
return false;
public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
return null;
public int getMajorVersion() {
public int getMinorVersion() {
public boolean jdbcCompliant() {
return false;
public class HBasePreparedStatement extends HBaseStatement implements PreparedStatement {
private final List<Object>    parameters        = new ArrayList<Object>();
private MockParameterMetaData metadata          = new MockParameterMetaData();
private MockResultSetMetaData resultSetMetaData = new MockResultSetMetaData();
public HBasePreparedStatement(HBaseConnection conn){
super(conn);
public void setNull(int parameterIndex, int sqlType) throws SQLException {
parameters.add(parameterIndex - 1, null);
public void setBoolean(int parameterIndex, boolean x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setByte(int parameterIndex, byte x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setShort(int parameterIndex, short x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setInt(int parameterIndex, int x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setLong(int parameterIndex, long x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setFloat(int parameterIndex, float x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setDouble(int parameterIndex, double x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setString(int parameterIndex, String x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBytes(int parameterIndex, byte[] x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setDate(int parameterIndex, Date x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setTime(int parameterIndex, Time x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void clearParameters() throws SQLException {
checkOpen();
parameters.clear();
public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setObject(int parameterIndex, Object x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void addBatch() throws SQLException {
checkOpen();
public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public void setRef(int parameterIndex, Ref x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBlob(int parameterIndex, Blob x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setClob(int parameterIndex, Clob x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setArray(int parameterIndex, Array x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public ResultSetMetaData getMetaData() throws SQLException {
checkOpen();
return resultSetMetaData;
public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
parameters.add(parameterIndex - 1, null);
public void setURL(int parameterIndex, URL x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public ParameterMetaData getParameterMetaData() throws SQLException {
checkOpen();
return metadata;
public void setRowId(int parameterIndex, RowId x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setNString(int parameterIndex, String value) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void setNClob(int parameterIndex, NClob value) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void setClob(int parameterIndex, Reader value, long length) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
parameters.add(parameterIndex - 1, inputStream);
public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
parameters.add(parameterIndex - 1, xmlObject);
public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
parameters.add(parameterIndex - 1, x);
public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
parameters.add(parameterIndex - 1, value);
public void setClob(int parameterIndex, Reader reader) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
parameters.add(parameterIndex - 1, inputStream);
public void setNClob(int parameterIndex, Reader reader) throws SQLException {
parameters.add(parameterIndex - 1, reader);
public ResultSet executeQuery() throws SQLException {
return null;
public int executeUpdate() throws SQLException {
public boolean execute() throws SQLException {
checkOpen();
return false;
public class HBaseStatement implements Statement {
private HBaseConnection conn;
public HBaseStatement(HBaseConnection conn){
this.conn = conn;
public <T> T unwrap(Class<T> iface) throws SQLException {
return null;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
return false;
public ResultSet executeQuery(String sql) throws SQLException {
return null;
public int executeUpdate(String sql) throws SQLException {
public void close() throws SQLException {
public int getMaxFieldSize() throws SQLException {
public void setMaxFieldSize(int max) throws SQLException {
public int getMaxRows() throws SQLException {
public void setMaxRows(int max) throws SQLException {
public void setEscapeProcessing(boolean enable) throws SQLException {
public int getQueryTimeout() throws SQLException {
public void setQueryTimeout(int seconds) throws SQLException {
public void cancel() throws SQLException {
public SQLWarning getWarnings() throws SQLException {
return null;
public void clearWarnings() throws SQLException {
public void setCursorName(String name) throws SQLException {
public boolean execute(String sql) throws SQLException {
return false;
public ResultSet getResultSet() throws SQLException {
return null;
public int getUpdateCount() throws SQLException {
public boolean getMoreResults() throws SQLException {
return false;
public void setFetchDirection(int direction) throws SQLException {
public int getFetchDirection() throws SQLException {
public void setFetchSize(int rows) throws SQLException {
public int getFetchSize() throws SQLException {
public int getResultSetConcurrency() throws SQLException {
public int getResultSetType() throws SQLException {
public void addBatch(String sql) throws SQLException {
public void clearBatch() throws SQLException {
public int[] executeBatch() throws SQLException {
return null;
public Connection getConnection() throws SQLException {
return conn;
public boolean getMoreResults(int current) throws SQLException {
return false;
public ResultSet getGeneratedKeys() throws SQLException {
return null;
public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
public int executeUpdate(String sql, String[] columnNames) throws SQLException {
public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
return false;
public boolean execute(String sql, int[] columnIndexes) throws SQLException {
return false;
public boolean execute(String sql, String[] columnNames) throws SQLException {
return false;
public int getResultSetHoldability() throws SQLException {
public boolean isClosed() throws SQLException {
return false;
public void setPoolable(boolean poolable) throws SQLException {
public boolean isPoolable() throws SQLException {
return false;
public void checkOpen() {
public class HBaseConnectTest extends TestCase {
public void test_connection() throws Exception {
Configuration config = new Configuration();
config.set("dfs.support.append", "true");
config.set("hbase.rootdir", "hdfs:
config.set("hbase.cluster.distributed", "true");
config.set("hbase.master", "10.20.153.63:60000");
config.set("hbase.zookeeper.quorum", "10.20.153.63");
config.set("zookeeper.session.timeout", "30000");
config.set("hbase.regionserver.handler.count", "100");
config.set("hbase.client.keyvalue.maxsize", "67108864");
HTable table = new HTable(config, "test");
Put put = new Put(Bytes.toBytes("1001"));
put.add(Bytes.toBytes("d"), Bytes.toBytes("id"), Bytes.toBytes("x1001"));
table.put(put);
table.close();
private int        maxFieldSize;
private int        maxRows;
private int        queryTimeout;
private boolean    escapeProcessing;
private String     cursorName;
private SQLWarning warnings;
public int getMaxFieldSize() throws SQLException {
checkOpen();
return maxFieldSize;
public void setMaxFieldSize(int max) throws SQLException {
checkOpen();
this.maxFieldSize = max;
public int getMaxRows() throws SQLException {
checkOpen();
return maxRows;
public void setMaxRows(int max) throws SQLException {
checkOpen();
this.maxRows = max;
public void setEscapeProcessing(boolean enable) throws SQLException {
checkOpen();
this.escapeProcessing = enable;
public boolean isEscapeProcessing() {
return escapeProcessing;
public int getQueryTimeout() throws SQLException {
checkOpen();
return queryTimeout;
public void setQueryTimeout(int seconds) throws SQLException {
checkOpen();
this.queryTimeout = seconds;
public void setCursorName(String name) throws SQLException {
checkOpen();
cursorName = name;
public String getCursorName() {
return cursorName;
public SQLWarning getWarnings() throws SQLException {
checkOpen();
return warnings;
public void clearWarnings() throws SQLException {
checkOpen();
warnings = null;
public void setWarning(SQLWarning warning) {
this.warnings = warning;
public class HBaseStatement extends StatementBase implements Statement {
super(conn);
public void close() throws SQLException {
public void commit() throws SQLException {
public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Blob createBlob() throws SQLException {
public Clob createClob() throws SQLException {
public NClob createNClob() throws SQLException {
public SQLXML createSQLXML() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Statement createStatement() throws SQLException {
return new HBaseStatement(this);
public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
throws SQLException {
throw new SQLFeatureNotSupportedException();
public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
throw new SQLFeatureNotSupportedException();
public Properties getClientInfo() throws SQLException {
public String getClientInfo(String name) throws SQLException {
return config.get(name);
public DatabaseMetaData getMetaData() throws SQLException {
return null;
public String getUrl() {
return url;
public boolean isClosed() throws SQLException {
return false;
public boolean isValid(int timeout) throws SQLException {
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == Configuration.class) {
return true;
if (iface == Connection.class || iface == HBaseConnection.class) {
return true;
return false;
public String nativeSQL(String sql) throws SQLException {
public CallableStatement prepareCall(String sql) throws SQLException {
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
public PreparedStatement prepareStatement(String sql) throws SQLException {
return new HBasePreparedStatement(this, sql);
public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
return new HBasePreparedStatement(this, sql);
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
throws SQLException {
return new HBasePreparedStatement(this, sql);
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
return new HBasePreparedStatement(this, sql);
public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
return new HBasePreparedStatement(this, sql);
public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
HBasePreparedStatement stmt = new HBasePreparedStatement(this, sql);
stmt.setColumnNames(columnNames);
return stmt;
public void releaseSavepoint(Savepoint savepoint) throws SQLException {
public void rollback() throws SQLException {
public void rollback(Savepoint savepoint) throws SQLException {
throw new SQLFeatureNotSupportedException();
public void setClientInfo(String name, String value) throws SQLClientInfoException {
this.config.set(name, value);
public Savepoint setSavepoint() throws SQLException {
public Savepoint setSavepoint(String name) throws SQLException {
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == Configuration.class) {
return (T) config;
if (iface == Connection.class || iface == HBaseConnection.class) {
return (T) this;
return null;
private final String sql;
private String[]     columnNames;
public HBasePreparedStatement(HBaseConnection conn, String sql){
this.sql = sql;
public String[] getColumnNames() {
return columnNames;
public void setColumnNames(String[] columnNames) {
this.columnNames = columnNames;
public String getSql() {
return sql;
private String                url;
private Properties            info;
public ConnectionBase(String url, Properties info){
this.url = url;
this.info = info;
public String getUrl() {
return url;
public Properties getConnectProperties() {
return info;
super(url, info);
super(url, connectProperties);
private String                url;
private Properties            info;
public ConnectionBase(String url, Properties info){
this.url = url;
this.info = info;
public String getUrl() {
return url;
public Properties getConnectProperties() {
return info;
super(url, info);
public HBasePreparedStatement prepareStatement(String sql) throws SQLException {
return prepareStatement(sql);
return prepareStatement(sql);
return prepareStatement(sql);
return prepareStatement(sql);
HBasePreparedStatement stmt = prepareStatement(sql);
super(url, connectProperties);
config = new Configuration(false);
public static String PREFIX = "jdbc:druid-hbase:";
public HBaseConnection connect(String url, Properties info) throws SQLException {
if (!acceptsURL(url)) {
return null;
String rest = url.substring(PREFIX.length());
info.put("hbase.zookeeper.quorum", rest);
return url.startsWith(PREFIX);
public class HBaseDriverTest extends TestCase {
public void test_0 () throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase::10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM test");
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
config = new Configuration(false);
public ResultSet executeQuery(String sql, List<Object> parameters) throws SQLException {
String dbType = this.getConnectProperties().getProperty("dbType");
List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, dbType);
if (stmtList.size() != 1) {
throw new SQLException("not support multi-statement");
SQLStatement stmt = stmtList.get(0);
throw new SQLException("TODO");
public static String PREFIX = "jdbc:druid-hbase:";
public HBaseConnection connect(String url, Properties info) throws SQLException {
if (!acceptsURL(url)) {
return null;
String rest = url.substring(PREFIX.length());
info.put("hbase.zookeeper.quorum", rest);
return url.startsWith(PREFIX);
private final String    sql;
private String[]        columnNames;
private HBaseConnection hbaseConnection;
this.hbaseConnection = conn;
return hbaseConnection.executeQuery(sql, getParameters());
List<SQLStatement> stmtList = parser.parseStatementList();
if (parser.getLexer().token() != Token.EOF) {
throw new DruidRuntimeException("syntax error : " + sql);
return stmtList;
public class HBaseDriverTest extends TestCase {
public void test_0 () throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase::10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM test");
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
public abstract class ResultSetBase implements ResultSet {
protected boolean  closed         = false;
private boolean    wasNull        = false;
private SQLWarning warning;
private String     cursorName;
private int        fetchSize      = 0;
private int        fetchDirection = 0;
private Statement  statement;
public ResultSetBase(Statement statement){
this.statement = statement;
public boolean isClosed() throws SQLException {
return closed;
public void updateNString(int columnIndex, String x) throws SQLException {
updateObject(columnIndex, x);
public void updateNString(String columnLabel, String x) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(int columnIndex, NClob x) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(String columnLabel, NClob x) throws SQLException {
updateObject(columnLabel, x);
public NClob getNClob(int columnIndex) throws SQLException {
return (NClob) getObject(columnIndex);
public NClob getNClob(String columnLabel) throws SQLException {
return (NClob) getObject(columnLabel);
public SQLXML getSQLXML(int columnIndex) throws SQLException {
return (SQLXML) getObject(columnIndex);
public SQLXML getSQLXML(String columnLabel) throws SQLException {
return (SQLXML) getObject(columnLabel);
public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
updateObject(columnIndex, x);
public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
updateObject(columnLabel, x);
public String getNString(int columnIndex) throws SQLException {
return (String) getObject(columnIndex);
public String getNString(String columnLabel) throws SQLException {
return (String) getObject(columnLabel);
public Reader getNCharacterStream(int columnIndex) throws SQLException {
return (Reader) getObject(columnIndex);
public Reader getNCharacterStream(String columnLabel) throws SQLException {
return (Reader) getObject(columnLabel);
public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateBlob(int columnIndex, InputStream x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateBlob(String columnLabel, InputStream x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateClob(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateClob(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(int columnIndex, Reader x, long length) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(String columnLabel, Reader x, long length) throws SQLException {
updateObject(columnLabel, x);
public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
updateObject(columnIndex, x);
public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
updateObject(columnIndex, x);
public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
updateObject(columnLabel, x);
public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
updateObject(columnLabel, x);
public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void updateBlob(int columnIndex, InputStream x) throws SQLException {
updateObject(columnIndex, x);
public void updateBlob(String columnLabel, InputStream x) throws SQLException {
updateObject(columnLabel, x);
public void updateClob(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateClob(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public void updateNClob(int columnIndex, Reader x) throws SQLException {
updateObject(columnIndex, x);
public void updateNClob(String columnLabel, Reader x) throws SQLException {
updateObject(columnLabel, x);
public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
throw new SQLFeatureNotSupportedException();
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
return null;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
if (iface.isInstance(this)) {
return true;
return false;
public void close() throws SQLException {
this.closed = true;
public boolean wasNull() throws SQLException {
if (closed) {
throw new SQLException();
return wasNull;
public abstract Object getObjectInternal(int columnIndex);
public Object getObject(int columnIndex) throws SQLException {
Object obj = getObjectInternal(columnIndex);
wasNull = (obj == null);
return obj;
public Object getObject(String columnLabel) throws SQLException {
return getObject(findColumn(columnLabel));
public int findColumn(String columnLabel) throws SQLException {
return Integer.parseInt(columnLabel);
public Reader getCharacterStream(int columnIndex) throws SQLException {
return (Reader) getObject(columnIndex);
public Reader getCharacterStream(String columnLabel) throws SQLException {
return (Reader) getObject(columnLabel);
public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
return (BigDecimal) getObject(columnIndex);
public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
return getBigDecimal(Integer.parseInt(columnLabel));
public void clearWarnings() throws SQLException {
if (closed) {
throw new SQLException();
warning = null;
public void setWarning(SQLWarning warning) {
this.warning = warning;
public String getCursorName() throws SQLException {
if (closed) {
throw new SQLException();
return cursorName;
public void setCursorName(String cursorName) {
this.cursorName = cursorName;
public SQLWarning getWarnings() throws SQLException {
if (closed) {
throw new SQLException();
return warning;
public void setFetchDirection(int direction) throws SQLException {
if (closed) {
throw new SQLException();
this.fetchDirection = direction;
public int getFetchDirection() throws SQLException {
if (closed) {
throw new SQLException();
return fetchDirection;
public void setFetchSize(int rows) throws SQLException {
if (closed) {
throw new SQLException();
this.fetchSize = rows;
public int getFetchSize() throws SQLException {
if (closed) {
throw new SQLException();
return fetchSize;
public boolean rowUpdated() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean rowInserted() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean rowDeleted() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public void updateNull(int columnIndex) throws SQLException {
updateObject(columnIndex, null);
public void updateBoolean(int columnIndex, boolean x) throws SQLException {
updateObject(columnIndex, x);
public void updateByte(int columnIndex, byte x) throws SQLException {
updateObject(columnIndex, x);
public void updateShort(int columnIndex, short x) throws SQLException {
updateObject(columnIndex, x);
public void updateInt(int columnIndex, int x) throws SQLException {
updateObject(columnIndex, x);
public void updateLong(int columnIndex, long x) throws SQLException {
updateObject(columnIndex, x);
public void updateFloat(int columnIndex, float x) throws SQLException {
updateObject(columnIndex, x);
public void updateDouble(int columnIndex, double x) throws SQLException {
updateObject(columnIndex, x);
public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
updateObject(columnIndex, x);
public void updateString(int columnIndex, String x) throws SQLException {
updateObject(columnIndex, x);
public void updateBytes(int columnIndex, byte[] x) throws SQLException {
updateObject(columnIndex, x);
public void updateDate(int columnIndex, Date x) throws SQLException {
updateObject(columnIndex, x);
public void updateTime(int columnIndex, Time x) throws SQLException {
updateObject(columnIndex, x);
public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
updateObject(columnIndex, x);
public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
updateObject(columnIndex, x);
public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
updateObject(columnIndex, x);
public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
updateObject(columnIndex, x);
public void updateObject(int columnIndex, Object x, int scaleOrLength) throws SQLException {
updateObject(columnIndex, x);
public void updateNull(String columnLabel) throws SQLException {
updateObject(columnLabel, null);
public void updateBoolean(String columnLabel, boolean x) throws SQLException {
updateObject(columnLabel, x);
public void updateByte(String columnLabel, byte x) throws SQLException {
updateObject(columnLabel, x);
public void updateShort(String columnLabel, short x) throws SQLException {
updateObject(columnLabel, x);
public void updateInt(String columnLabel, int x) throws SQLException {
updateObject(columnLabel, x);
public void updateLong(String columnLabel, long x) throws SQLException {
updateObject(columnLabel, x);
public void updateFloat(String columnLabel, float x) throws SQLException {
updateObject(columnLabel, x);
public void updateDouble(String columnLabel, double x) throws SQLException {
updateObject(columnLabel, x);
public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
updateObject(columnLabel, x);
public void updateString(String columnLabel, String x) throws SQLException {
updateObject(columnLabel, x);
public void updateBytes(String columnLabel, byte[] x) throws SQLException {
updateObject(columnLabel, x);
public void updateDate(String columnLabel, Date x) throws SQLException {
updateObject(columnLabel, x);
public void updateTime(String columnLabel, Time x) throws SQLException {
updateObject(columnLabel, x);
public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
updateObject(columnLabel, x);
public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
updateObject(columnLabel, x);
public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
updateObject(columnLabel, x);
public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
updateObject(columnLabel, reader);
public void updateObject(String columnLabel, Object x, int scaleOrLength) throws SQLException {
updateObject(columnLabel, x);
public void updateObject(String columnLabel, Object x) throws SQLException {
updateObject(Integer.parseInt(columnLabel), x);
public void insertRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void updateRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void deleteRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void refreshRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void cancelRowUpdates() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void moveToInsertRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public void moveToCurrentRow() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public Statement getStatement() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
return statement;
public Object getObject(int columnIndex, Map<String, Class<?>> map) throws SQLException {
return getObject(columnIndex);
public Ref getRef(int columnIndex) throws SQLException {
return (Ref) getObject(columnIndex);
public Blob getBlob(int columnIndex) throws SQLException {
return (Blob) getObject(columnIndex);
public Clob getClob(int columnIndex) throws SQLException {
return (Clob) getObject(columnIndex);
public Array getArray(int columnIndex) throws SQLException {
return (Array) getObject(columnIndex);
public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
return getObject(columnLabel);
public Ref getRef(String columnLabel) throws SQLException {
return (Ref) getObject(columnLabel);
public Blob getBlob(String columnLabel) throws SQLException {
return (Blob) getObject(columnLabel);
public Clob getClob(String columnLabel) throws SQLException {
return (Clob) getObject(columnLabel);
public Array getArray(String columnLabel) throws SQLException {
return (Array) getObject(columnLabel);
public Date getDate(int columnIndex, Calendar cal) throws SQLException {
return (Date) getObject(columnIndex);
public Date getDate(String columnLabel, Calendar cal) throws SQLException {
return (Date) getObject(columnLabel);
public Time getTime(int columnIndex, Calendar cal) throws SQLException {
return (Time) getObject(columnIndex);
public Time getTime(String columnLabel, Calendar cal) throws SQLException {
return (Time) getObject(columnLabel);
public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
return (Timestamp) getObject(columnIndex);
public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
return (Timestamp) getObject(columnLabel);
public URL getURL(int columnIndex) throws SQLException {
return (URL) getObject(columnIndex);
public URL getURL(String columnLabel) throws SQLException {
return (URL) getObject(columnLabel);
public void updateRef(int columnIndex, Ref x) throws SQLException {
updateObject(columnIndex, x);
public void updateRef(String columnLabel, Ref x) throws SQLException {
updateObject(columnLabel, x);
public void updateBlob(int columnIndex, Blob x) throws SQLException {
updateObject(columnIndex, x);
public void updateBlob(String columnLabel, Blob x) throws SQLException {
updateObject(columnLabel, x);
public void updateClob(int columnIndex, Clob x) throws SQLException {
updateObject(columnIndex, x);
public void updateClob(String columnLabel, Clob x) throws SQLException {
updateObject(columnLabel, x);
public void updateArray(int columnIndex, Array x) throws SQLException {
updateObject(columnIndex, x);
public void updateArray(String columnLabel, Array x) throws SQLException {
updateObject(columnLabel, x);
public RowId getRowId(int columnIndex) throws SQLException {
return (RowId) getObject(columnIndex);
public RowId getRowId(String columnLabel) throws SQLException {
return (RowId) getObject(columnLabel);
public void updateRowId(int columnIndex, RowId x) throws SQLException {
updateObject(columnIndex, x);
public void updateRowId(String columnLabel, RowId x) throws SQLException {
updateObject(columnLabel, x);
public int getHoldability() throws SQLException {
if (closed) {
throw new SQLException("resultSet closed");
public String getString(int columnIndex) throws SQLException {
return (String) getObject(columnIndex);
public boolean getBoolean(int columnIndex) throws SQLException {
Object obj = getObject(columnIndex);
if (obj == null) {
return false;
return ((Boolean) obj).booleanValue();
public byte getByte(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.byteValue();
public short getShort(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.shortValue();
public int getInt(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.intValue();
public long getLong(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.longValue();
public float getFloat(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.floatValue();
public double getDouble(int columnIndex) throws SQLException {
Number number = (Number) getObject(columnIndex);
if (number == null) {
return number.doubleValue();
public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
return (BigDecimal) getObject(columnIndex);
public byte[] getBytes(int columnIndex) throws SQLException {
return (byte[]) getObject(columnIndex);
public Date getDate(int columnIndex) throws SQLException {
return (Date) getObject(columnIndex);
public Time getTime(int columnIndex) throws SQLException {
return (Time) getObject(columnIndex);
public Timestamp getTimestamp(int columnIndex) throws SQLException {
return (Timestamp) getObject(columnIndex);
public InputStream getAsciiStream(int columnIndex) throws SQLException {
return (InputStream) getObject(columnIndex);
public InputStream getUnicodeStream(int columnIndex) throws SQLException {
return (InputStream) getObject(columnIndex);
public InputStream getBinaryStream(int columnIndex) throws SQLException {
return (InputStream) getObject(columnIndex);
public String getString(String columnLabel) throws SQLException {
return getString(Integer.parseInt(columnLabel));
public boolean getBoolean(String columnLabel) throws SQLException {
return getBoolean(Integer.parseInt(columnLabel));
public byte getByte(String columnLabel) throws SQLException {
return getByte(Integer.parseInt(columnLabel));
public short getShort(String columnLabel) throws SQLException {
return getShort(Integer.parseInt(columnLabel));
public int getInt(String columnLabel) throws SQLException {
return getInt(Integer.parseInt(columnLabel));
public long getLong(String columnLabel) throws SQLException {
return getLong(Integer.parseInt(columnLabel));
public float getFloat(String columnLabel) throws SQLException {
return getFloat(Integer.parseInt(columnLabel));
public double getDouble(String columnLabel) throws SQLException {
return getDouble(Integer.parseInt(columnLabel));
public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
return getBigDecimal(Integer.parseInt(columnLabel), scale);
public byte[] getBytes(String columnLabel) throws SQLException {
return getBytes(Integer.parseInt(columnLabel));
public Date getDate(String columnLabel) throws SQLException {
return getDate(Integer.parseInt(columnLabel));
public Time getTime(String columnLabel) throws SQLException {
return getTime(Integer.parseInt(columnLabel));
public Timestamp getTimestamp(String columnLabel) throws SQLException {
return getTimestamp(Integer.parseInt(columnLabel));
public InputStream getAsciiStream(String columnLabel) throws SQLException {
return getAsciiStream(Integer.parseInt(columnLabel));
public InputStream getUnicodeStream(String columnLabel) throws SQLException {
return getUnicodeStream(Integer.parseInt(columnLabel));
public InputStream getBinaryStream(String columnLabel) throws SQLException {
return getBinaryStream(Integer.parseInt(columnLabel));
public boolean isBeforeFirst() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean isAfterLast() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean isFirst() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean isLast() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public void beforeFirst() throws SQLException {
if (closed) {
throw new SQLException();
public void afterLast() throws SQLException {
if (closed) {
throw new SQLException();
public boolean first() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean last() throws SQLException {
if (closed) {
throw new SQLException();
return false;
public int getRow() throws SQLException {
if (closed) {
throw new SQLException();
public boolean absolute(int row) throws SQLException {
if (closed) {
throw new SQLException();
return false;
public boolean relative(int rows) throws SQLException {
if (closed) {
throw new SQLException();
return false;
public int getType() throws SQLException {
if (closed) {
throw new SQLException();
public int getConcurrency() throws SQLException {
if (closed) {
throw new SQLException();
public ResultSet executeQuery(HBaseStatementInterface jdbcHbaseStmt, String sql, List<Object> parameters) throws SQLException {
String dbType = this.getConnectProperties().getProperty("dbType");
List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, dbType);
if (stmtList.size() != 1) {
throw new SQLException("not support multi-statement");
SQLSelectStatement stmt = (SQLSelectStatement) stmtList.get(0);
SQLSelectQueryBlock selectQueryBlock = (SQLSelectQueryBlock) stmt.getSelect().getQuery();
SQLExprTableSource tableSource = (SQLExprTableSource) selectQueryBlock.getFrom();
String tableName = ((SQLIdentifierExpr) tableSource.getExpr()).getName();
HTable htable = new HTable(config, tableName);
Scan scan = new Scan();
ResultScanner scanner = htable.getScanner(scan);
return new HBaseResultSet(jdbcHbaseStmt, scanner);
} catch (SQLException ex) {
} catch (Exception ex) {
throw new SQLException("executeQuery error", ex);
String rest = url.substring(PREFIX.length() + 1);
public class HBasePreparedStatement extends PreparedStatementBase implements PreparedStatement, HBaseStatementInterface {
public HBaseConnection getConnection() throws SQLException {
return hbaseConnection;
return hbaseConnection.executeQuery(this, sql, getParameters());
public class HBaseResultSet extends ResultSetBase {
private HBaseStatementInterface statement;
private ResultScanner           scanner;
private Result                  result;
public HBaseResultSet(HBaseStatementInterface statement, ResultScanner scanner){
super(statement);
this.statement = statement;
this.scanner = scanner;
public Statement getStatement() throws SQLException {
return statement;
public boolean next() throws SQLException {
result = scanner.next();
return result != null && !result.isEmpty();
} catch (IOException ex) {
throw new SQLException("read next error", ex);
public ResultSetMetaData getMetaData() throws SQLException {
return null;
public boolean previous() throws SQLException {
return false;
public void updateObject(int columnIndex, Object x) throws SQLException {
public Object getObjectInternal(int columnIndex) {
return null;
public void close() throws SQLException {
scanner.close();
} catch (Exception ex) {
throw new SQLException("close error", ex);
super.close();
public class HBaseStatement extends StatementBase implements Statement, HBaseStatementInterface {
public HBaseConnection getConnection() throws SQLException {
public interface HBaseStatementInterface extends Statement {
HBaseConnection getConnection() throws SQLException;
public class MockResultSet extends ResultSetBase implements ResultSet {
private int                   rowIndex = -1;
private List<Object[]>        rows     = new ArrayList<Object[]>();
private MockResultSetMetaData metaData = new MockResultSetMetaData();
super(statement);
public Object getObjectInternal(int columnIndex) {
public synchronized boolean previous() throws SQLException {
if (rowIndex > 0) {
rowIndex--;
return true;
SQLStatement sqlStmt = stmtList.get(0);
if (sqlStmt instanceof SQLSelectStatement) {
SQLSelectStatement selectStmt = (SQLSelectStatement) sqlStmt;
SQLSelectQueryBlock selectQueryBlock = (SQLSelectQueryBlock) selectStmt.getSelect().getQuery();
SQLExprTableSource tableSource = (SQLExprTableSource) selectQueryBlock.getFrom();
String tableName = ((SQLIdentifierExpr) tableSource.getExpr()).getName();
SingleTableQueryExecutePlan singleTableQueryExecuetePlan = new SingleTableQueryExecutePlan();
singleTableQueryExecuetePlan.setTableName(tableName);
this.executePlan = singleTableQueryExecuetePlan;
throw new SQLException("TODO");
return this.executePlan.executeQuery(this);
HBaseResultSet executeQuery(HBasePreparedStatement statement) throws SQLException;
public HBaseResultSet executeQuery(HBasePreparedStatement statement) throws SQLException {
public void test_select_0 () throws Exception {
} else if (sqlStmt instanceof SQLInsertStatement) {
SQLInsertStatement insertStmt = (SQLInsertStatement) sqlStmt;
String tableName = ((SQLIdentifierExpr) insertStmt.getTableSource().getExpr()).getName();
throw new SQLException("TODO");
void execute(HBasePreparedStatement statement);
public class ExecutePlanAdapter implements ExecutePlan {
public HBaseResultSet executeQuery(HBasePreparedStatement statement) throws SQLException {
throw new UnsupportedOperationException();
public void execute(HBasePreparedStatement statement) {
throw new UnsupportedOperationException();
public class InsertExecutePlan extends ExecutePlanAdapter {
public class SingleTableQueryExecutePlan extends ExecutePlanAdapter {
public class HBaseDriverInsertTest extends TestCase {
public void test_select_0() throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase:10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("INSERT INTO test_user (id, name) VALUES (?, ?)");
stmt.setInt(1, 33);
stmt.setString(2, "ljw");
stmt.execute();
stmt.close();
conn.close();
} else if (sqlStmt instanceof SQLInsertStatement) {
SQLInsertStatement insertStmt = (SQLInsertStatement) sqlStmt;
String tableName = ((SQLIdentifierExpr) insertStmt.getTableSource().getExpr()).getName();
throw new SQLException("TODO");
void execute(HBasePreparedStatement statement);
public class ExecutePlanAdapter implements ExecutePlan {
public HBaseResultSet executeQuery(HBasePreparedStatement statement) throws SQLException {
throw new UnsupportedOperationException();
public void execute(HBasePreparedStatement statement) {
throw new UnsupportedOperationException();
public class InsertExecutePlan extends SingleTableExecutePlan {
public void execute(HBasePreparedStatement statement) {
throw new UnsupportedOperationException();
public class SingleTableExecutePlan extends ExecutePlanAdapter {
private String tableName;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
public class SingleTableQueryExecutePlan extends SingleTableExecutePlan {
HTableInterface htable = connection.getHTable(getTableName());
public class HBaseDriverInsertTest extends TestCase {
public void test_select_0() throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase:10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("INSERT INTO test_user (id, name) VALUES (?, ?)");
stmt.setInt(1, 33);
stmt.setString(2, "ljw");
stmt.execute();
stmt.close();
conn.close();
void execute(HBasePreparedStatement statement) throws SQLException;
public void execute(HBasePreparedStatement statement) throws SQLException {
public void execute(HBasePreparedStatement statement) throws SQLException {
HBaseConnection connection = statement.getConnection();
HTableInterface htable = connection.getHTable(getTableName());
throw new UnsupportedOperationException();
} catch (SQLException e) {
} catch (Exception e) {
throw new SQLException("executeQuery error", e);
InsertExecutePlan insertExecutePlan = new InsertExecutePlan();
insertExecutePlan.setTableName(tableName);
private Map<String, SQLExpr> columns = new LinkedHashMap<String, SQLExpr>();
private byte[]               family  = Bytes.toBytes("d");
Put put = new Put();
for (int i = 0; i < columns.size(); ++i) {
htable.put(put);
public Map<String, SQLExpr> getColumns() {
return columns;
public void setColumns(Map<String, SQLExpr> columns) {
this.columns = columns;
SQLEvalVisitor evalVisitor = SQLEvalVisitorUtils.createEvalVisitor(dbType);
insertStmt.accept(evalVisitor);
InsertExecutePlan insertExecutePlan = new InsertExecutePlan();
insertExecutePlan.setTableName(tableName);
for (int i = 0; i < insertStmt.getColumns().size(); ++i) {
SQLExpr columnExpr = insertStmt.getColumns().get(i);
SQLExpr valueExpr = insertStmt.getValues().getValues().get(i);
String columnName = ((SQLIdentifierExpr) columnExpr).getName();
insertExecutePlan.getColumns().put(columnName, valueExpr);
this.executePlan = insertExecutePlan;
this.executePlan.execute(this);
boolean execute(HBasePreparedStatement statement) throws SQLException;
public boolean execute(HBasePreparedStatement statement) throws SQLException {
private Map<String, SQLExpr> columns = new LinkedHashMap<String, SQLExpr>();
private byte[]               family  = Bytes.toBytes("d");
public boolean execute(HBasePreparedStatement statement) throws SQLException {
String dbType = connection.getConnectProperties().getProperty("dbType");
Put put = null;
for (Map.Entry<String, SQLExpr> entry : columns.entrySet()) {
String column = entry.getKey();
SQLExpr valueExpr = entry.getValue();
Object value = SQLEvalVisitorUtils.eval(dbType, valueExpr, statement.getParameters());
if (value == null) {
byte[] bytes;
if (value instanceof String) {
String strValue = (String) value;
bytes = Bytes.toBytes(strValue);
} else if (value instanceof Integer) {
int intValue = ((Integer) value).intValue();
bytes = Bytes.toBytes(intValue);
throw new SQLException("TODO"); 
if (put == null) { 
put = new Put(bytes);
byte[] qualifier = Bytes.toBytes(column);
put.add(family, qualifier, bytes);
htable.put(put);
return false;
public Map<String, SQLExpr> getColumns() {
return columns;
public void setColumns(Map<String, SQLExpr> columns) {
this.columns = columns;
private List<Object> parameters       = new ArrayList<Object>();
private int          variantIndex     = -1;
private boolean      markVariantIndex = true;
public boolean isMarkVariantIndex() {
return markVariantIndex;
public void setMarkVariantIndex(boolean markVariantIndex) {
this.markVariantIndex = markVariantIndex;
boolean isMarkVariantIndex();
void setMarkVariantIndex(boolean markVariantIndex);
private List<Object> parameters       = new ArrayList<Object>();
private int          variantIndex     = -1;
private boolean      markVariantIndex = true;
public boolean isMarkVariantIndex() {
return markVariantIndex;
public void setMarkVariantIndex(boolean markVariantIndex) {
this.markVariantIndex = markVariantIndex;
if (visitor.getParameters().size() > 0) {
boolean containsValue = attributes.containsKey(EVAL_VALUE);
if (!containsValue) {
Object value = visitor.getParameters().get(varIndex.intValue());
attributes.put(EVAL_VALUE, value);
} else if (value instanceof Long) {
long longValue = ((Long) value).longValue();
bytes = Bytes.toBytes(longValue);
} else if (value instanceof Boolean) {
boolean booleanValue = ((Boolean) value).booleanValue();
bytes = Bytes.toBytes(booleanValue);
PreparedStatement stmt = conn.prepareStatement("INSERT INTO test_user (id, name, gender) VALUES (?, ?, ?)");
stmt.setString(3, "M");
protected boolean  wasNull        = false;
if ("id".equals(columnName)) { 
return result.getRow();
this.wasNull = value == null;
public int getInt(String columnName) throws SQLException {
byte[] bytes = getBytes(columnName);
if (bytes == null) {
return Bytes.toInt(bytes);
public BigDecimal getBigDecimal(String columnName) throws SQLException {
byte[] bytes = getBytes(columnName);
if (bytes == null) {
return null;
return Bytes.toBigDecimal(bytes);
} else if (value instanceof BigDecimal) {
BigDecimal decimalValue = (BigDecimal) value;
bytes = Bytes.toBytes(decimalValue);
HTableInterface htable = connection.getHTable(getTableName());
for (int i = 0; i < 10; ++i) {
PreparedStatement stmt = conn.prepareStatement("INSERT INTO test_user (id, name, gender, salary) VALUES (?, ?, ?, ?)");
stmt.setInt(1, i);
stmt.setString(2, "user-" + i);
stmt.setString(3, "M");
stmt.setBigDecimal(4, new BigDecimal((i + 1) * 1000));
stmt.execute();
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user");
System.out.print(rs.getInt("id"));
System.out.print(rs.getString("name"));
System.out.print(' ');
System.out.print(rs.getString("gender"));
System.out.print(' ');
System.out.print(rs.getBigDecimal("salary"));
protected boolean  wasNull        = false;
SQLEvalVisitor evalVisitor = SQLEvalVisitorUtils.createEvalVisitor(dbType);
selectStmt.accept(evalVisitor);
if ("id".equals(columnName)) { 
return result.getRow();
this.wasNull = value == null;
public int getInt(String columnName) throws SQLException {
byte[] bytes = getBytes(columnName);
if (bytes == null) {
return Bytes.toInt(bytes);
public BigDecimal getBigDecimal(String columnName) throws SQLException {
byte[] bytes = getBytes(columnName);
if (bytes == null) {
return null;
return Bytes.toBigDecimal(bytes);
} else if (value instanceof BigDecimal) {
BigDecimal decimalValue = (BigDecimal) value;
bytes = Bytes.toBytes(decimalValue);
HTableInterface htable = connection.getHTable(getTableName());
private List<String> columeNames = new ArrayList<String>();
public SingleTableQueryExecutePlan(){
public List<String> getColumeNames() {
return columeNames;
for (int i = 0; i < 10; ++i) {
PreparedStatement stmt = conn.prepareStatement("INSERT INTO test_user (id, name, gender, salary) VALUES (?, ?, ?, ?)");
stmt.setInt(1, i);
stmt.setString(2, "user-" + i);
stmt.setString(3, "M");
stmt.setBigDecimal(4, new BigDecimal((i + 1) * 1000));
stmt.execute();
stmt.close();
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user");
System.out.print(rs.getInt("id"));
System.out.print(rs.getString("name"));
System.out.print(' ');
System.out.print(rs.getString("gender"));
System.out.print(' ');
System.out.print(rs.getBigDecimal("salary"));
public class HBaseUtils {
public static byte[] toBytes(Object value) throws IOException {
if (value == null) {
return null;
byte[] bytes;
if (value instanceof String) {
String strValue = (String) value;
bytes = Bytes.toBytes(strValue);
} else if (value instanceof Integer) {
int intValue = ((Integer) value).intValue();
bytes = Bytes.toBytes(intValue);
} else if (value instanceof Long) {
long longValue = ((Long) value).longValue();
bytes = Bytes.toBytes(longValue);
} else if (value instanceof Boolean) {
boolean booleanValue = ((Boolean) value).booleanValue();
bytes = Bytes.toBytes(booleanValue);
} else if (value instanceof BigDecimal) {
BigDecimal decimalValue = (BigDecimal) value;
bytes = Bytes.toBytes(decimalValue);
throw new IOException("TODO"); 
return bytes;
byte[] bytes = HBaseUtils.toBytes(value);
String dbType = connection.getConnectProperties().getProperty("dbType");
for (SQLExpr item : conditions) {
SQLBinaryOpExpr condition = (SQLBinaryOpExpr) item;
String fieldName = ((SQLIdentifierExpr) condition.getLeft()).getName();
Object value = SQLEvalVisitorUtils.eval(dbType, condition.getRight(), statement.getParameters());
byte[] bytes = HBaseUtils.toBytes(value);
if ("id".equals(fieldName)) {
if (condition.getOperator() == SQLBinaryOperator.GreaterThan) {
scan.setStartRow(bytes);
} else if (condition.getOperator() == SQLBinaryOperator.LessThan) {
scan.setStopRow(bytes);
throw new SQLException("TODO");
public static Object getValue(SQLObject sqlObject) {
if (sqlObject instanceof SQLNumericLiteralExpr) {
return ((SQLNumericLiteralExpr) sqlObject).getNumber();
return sqlObject.getAttributes().get(EVAL_VALUE);
Object value = getValue(sqlObject);
if (condition.getOperator() == SQLBinaryOperator.GreaterThanOrEqual) {
} else if (condition.getOperator() == SQLBinaryOperator.LessThanOrEqual) {
RowFilter filter = new RowFilter(CompareOp.LESS_OR_EQUAL, new BinaryComparator(bytes));
setFilter(scan, filter);
void setFilter(Scan scan, Filter filter) {
if (scan.getFilter() == null) {
scan.setFilter(filter);
} else if (scan.getFilter() instanceof FilterList) {
FilterList filterList = (FilterList) scan.getFilter();
filterList.addFilter(filter);
FilterList filterList = new FilterList(scan.getFilter(), filter);
scan.setFilter(filterList);
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user where id >= 3 and id <= ?");
private byte[]        family      = Bytes.toBytes("d");
byte[] qualifier = Bytes.toBytes(fieldName);
CompareOp compareOp;
if (condition.getOperator() == SQLBinaryOperator.Equality) {
compareOp = CompareOp.EQUAL;
} else if (condition.getOperator() == SQLBinaryOperator.GreaterThan) {
compareOp = CompareOp.GREATER;
} else if (condition.getOperator() == SQLBinaryOperator.GreaterThanOrEqual) {
compareOp = CompareOp.GREATER_OR_EQUAL;
} else if (condition.getOperator() == SQLBinaryOperator.LessThan) {
compareOp = CompareOp.LESS;
} else if (condition.getOperator() == SQLBinaryOperator.LessThanOrEqual) {
compareOp = CompareOp.LESS_OR_EQUAL;
} else if (condition.getOperator() == SQLBinaryOperator.NotEqual) {
compareOp = CompareOp.NOT_EQUAL;
throw new SQLException("TODO");
SingleColumnValueFilter filter = new SingleColumnValueFilter(family, qualifier, compareOp, bytes);
setFilter(scan, filter);
CompareOp toCompareOp(SQLBinaryOperator operator) {
switch (operator) {
case Equality
return CompareOp.EQUAL;
case NotEqual
return CompareOp.NOT_EQUAL;
case GreaterThan
return CompareOp.GREATER;
case GreaterThanOrEqual
return CompareOp.GREATER_OR_EQUAL;
case LessThan
return CompareOp.LESS;
case LessThanOrEqual
return CompareOp.LESS_OR_EQUAL;
throw new UnsupportedOperationException("TODO");
public class HBaseDriverTest_notRowFilter extends TestCase {
public void test_select_0 () throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase:10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user where name <= ?");
stmt.setString(1, "user-5");
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
System.out.print(rs.getInt("id"));
System.out.print(' ');
System.out.print(rs.getString("name"));
System.out.print(' ');
System.out.print(rs.getString("gender"));
System.out.print(' ');
System.out.print(rs.getBigDecimal("salary"));
System.out.println();
rs.close();
stmt.close();
conn.close();
public class ResultSetMetaDataBase implements ResultSetMetaData {
public ResultSetMetaDataBase(){
private final List<ColumnMetaData> columns = new ArrayList<ColumnMetaData>();
public List<ColumnMetaData> getColumns() {
return columns;
@SuppressWarnings("unchecked")
@Override
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isAssignableFrom(ResultSetMetaDataBase.class)) {
return (T) this;
return null;
@Override
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == null) {
return false;
return ResultSetMetaDataBase.class.isAssignableFrom(iface);
@Override
public int getColumnCount() throws SQLException {
return columns.size();
@Override
public boolean isAutoIncrement(int column) throws SQLException {
return columns.get(column - 1).isAutoIncrement();
@Override
public boolean isCaseSensitive(int column) throws SQLException {
return columns.get(column - 1).isCaseSensitive();
@Override
public boolean isSearchable(int column) throws SQLException {
return columns.get(column - 1).isSearchable();
@Override
public boolean isCurrency(int column) throws SQLException {
return columns.get(column - 1).isCurrency();
@Override
public int isNullable(int column) throws SQLException {
return columns.get(column - 1).getNullable();
@Override
public boolean isSigned(int column) throws SQLException {
return columns.get(column - 1).isSigned();
@Override
public int getColumnDisplaySize(int column) throws SQLException {
return columns.get(column - 1).getColumnDisplaySize();
@Override
public String getColumnLabel(int column) throws SQLException {
return columns.get(column - 1).getColumnLabel();
@Override
public String getColumnName(int column) throws SQLException {
return columns.get(column - 1).getColumnName();
@Override
public String getSchemaName(int column) throws SQLException {
return columns.get(column - 1).getSchemaName();
@Override
public int getPrecision(int column) throws SQLException {
return columns.get(column - 1).getPrecision();
@Override
public int getScale(int column) throws SQLException {
return columns.get(column - 1).getScale();
@Override
public String getTableName(int column) throws SQLException {
return columns.get(column - 1).getTableName();
@Override
public String getCatalogName(int column) throws SQLException {
return columns.get(column - 1).getCatalogName();
@Override
public int getColumnType(int column) throws SQLException {
return columns.get(column - 1).getColumnType();
@Override
public String getColumnTypeName(int column) throws SQLException {
return columns.get(column - 1).getColumnTypeName();
@Override
public boolean isReadOnly(int column) throws SQLException {
return columns.get(column - 1).isReadOnly();
@Override
public boolean isWritable(int column) throws SQLException {
return columns.get(column - 1).isWritable();
@Override
public boolean isDefinitelyWritable(int column) throws SQLException {
return columns.get(column - 1).isDefinitelyWritable();
@Override
public String getColumnClassName(int column) throws SQLException {
return columns.get(column - 1).getColumnClassName();
public static class ColumnMetaData {
private boolean autoIncrement = false;
private boolean caseSensitive;
private boolean searchable;
private boolean currency;
private int     nullable      = 0;
private boolean signed;
private int     columnDisplaySize;
private String  columnLabel;
private String  columnName;
private String  schemaName;
private int     precision;
private int     scale;
private String  tableName;
private String  catalogName;
private int     columnType;
private String  columnTypeName;
private boolean readOnly;
private boolean writable;
private boolean definitelyWritable;
private String  columnClassName;
public boolean isAutoIncrement() {
return autoIncrement;
public void setAutoIncrement(boolean autoIncrement) {
this.autoIncrement = autoIncrement;
public boolean isCaseSensitive() {
return caseSensitive;
public void setCaseSensitive(boolean caseSensitive) {
this.caseSensitive = caseSensitive;
public boolean isSearchable() {
return searchable;
public void setSearchable(boolean searchable) {
this.searchable = searchable;
public boolean isCurrency() {
return currency;
public void setCurrency(boolean currency) {
this.currency = currency;
public int getNullable() {
return nullable;
public void setNullable(int nullable) {
this.nullable = nullable;
public boolean isSigned() {
return signed;
public void setSigned(boolean signed) {
this.signed = signed;
public int getColumnDisplaySize() {
return columnDisplaySize;
public void setColumnDisplaySize(int columnDisplaySize) {
this.columnDisplaySize = columnDisplaySize;
public String getColumnLabel() {
return columnLabel;
public void setColumnLabel(String columnLabel) {
this.columnLabel = columnLabel;
public String getColumnName() {
return columnName;
public void setColumnName(String columnName) {
this.columnName = columnName;
public String getSchemaName() {
return schemaName;
public void setSchemaName(String schemaName) {
this.schemaName = schemaName;
public int getPrecision() {
return precision;
public void setPrecision(int precision) {
this.precision = precision;
public int getScale() {
return scale;
public void setScale(int scale) {
this.scale = scale;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
public String getCatalogName() {
return catalogName;
public void setCatalogName(String catalogName) {
this.catalogName = catalogName;
public int getColumnType() {
return columnType;
public void setColumnType(int columnType) {
this.columnType = columnType;
public String getColumnTypeName() {
return columnTypeName;
public void setColumnTypeName(String columnTypeName) {
this.columnTypeName = columnTypeName;
public boolean isReadOnly() {
return readOnly;
public void setReadOnly(boolean readOnly) {
this.readOnly = readOnly;
public boolean isWritable() {
return writable;
public void setWritable(boolean writable) {
this.writable = writable;
public boolean isDefinitelyWritable() {
return definitelyWritable;
public void setDefinitelyWritable(boolean definitelyWritable) {
this.definitelyWritable = definitelyWritable;
public String getColumnClassName() {
return columnClassName;
public void setColumnClassName(String columnClassName) {
this.columnClassName = columnClassName;
public class MockResultSetMetaData extends ResultSetMetaDataBase implements ResultSetMetaData {
public MockResultSetMetaData(){
public class HBaseDriverTest_getIndex extends TestCase {
public void test_select_0 () throws Exception {
HBaseDriver driver = new HBaseDriver();
Connection conn = driver.connect("jdbc:druid-hbase:10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user where id >= 3 and id <= ?");
stmt.setInt(1, 6);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
System.out.print(rs.getInt(1));
System.out.print(' ');
System.out.print(rs.getString(2));
System.out.print(' ');
System.out.print(rs.getString(3));
System.out.print(' ');
System.out.print(rs.getBigDecimal(4));
System.out.println();
rs.close();
stmt.close();
conn.close();
public abstract Object getObjectInternal(int columnIndex) throws SQLException;
return getColumn(column).isAutoIncrement();
return getColumn(column).isCaseSensitive();
return getColumn(column).isSearchable();
return getColumn(column).isCurrency();
return getColumn(column).getNullable();
return getColumn(column).isSigned();
return getColumn(column).getColumnDisplaySize();
return getColumn(column).getColumnLabel();
public ColumnMetaData getColumn(int column) {
return columns.get(column - 1);
return getColumn(column).getColumnName();
return getColumn(column).getSchemaName();
return getColumn(column).getPrecision();
return getColumn(column).getScale();
return getColumn(column).getTableName();
return getColumn(column).getCatalogName();
return getColumn(column).getColumnType();
return getColumn(column).getColumnTypeName();
return getColumn(column).isReadOnly();
return getColumn(column).isWritable();
return getColumn(column).isDefinitelyWritable();
return getColumn(column).getColumnClassName();
HBaseResultSetMetaData resultMetaData = new HBaseResultSetMetaData();
for (SQLSelectItem selectItem : selectQueryBlock.getSelectList()) {
ColumnMetaData columnMetaData = new ColumnMetaData();
if (selectItem.getAlias() != null) {
columnMetaData.setColumnLabel(selectItem.getAlias());
columnMetaData.setColumnName(SQLUtils.toSQLString(selectItem.getExpr(), dbType));
columnMetaData.setColumnType(Types.BINARY);
resultMetaData.getColumns().add(columnMetaData);
singleTableQueryExecuetePlan.setResultMetaData(resultMetaData);
private HBaseResultSetMetaData  metaData;
public HBaseResultSetMetaData getMetaData() throws SQLException {
return metaData;
public void setMetaData(HBaseResultSetMetaData metaData) {
this.metaData = metaData;
public Object getObjectInternal(int columnIndex) throws SQLException {
ColumnMetaData column = this.metaData.getColumn(columnIndex);
return getObjectInternal(column.getColumnName(), column.getColumnType());
public Object getObjectInternal(String columnName, int type) throws SQLException {
byte[] bytes = getBytes(columnName);
switch (type) {
case Types.TINY
return bytes[0];
case Types.SM
return Bytes.toShort(bytes);
case Types.INTEG
return Bytes.toInt(bytes);
case Types.BIG
return Bytes.toLong(bytes);
case Types.DECIM
return Bytes.toBigDecimal(bytes);
case Types.BOO
return Bytes.toBoolean(bytes);
case Types.VARCH
case Types.CH
case Types.NCH
case Types.NVARCH
return Bytes.toString(bytes);
case Types.D
return new java.sql.Date(Bytes.toLong(bytes));
case Types.TIMESTAMP
return new java.sql.Timestamp(Bytes.toLong(bytes));
case Types.NU
case Types.VARBINARY
case Types.BINARY
case Types.ROWID
return bytes;
public String getString(int columnIndex) throws SQLException {
byte[] bytes = getBytes(columnIndex);
return Bytes.toString(bytes);
public byte[] getBytes(int columnIndex) throws SQLException {
ColumnMetaData column = this.metaData.getColumn(columnIndex);
return getBytes(column.getColumnName());
if (bytes == null) {
return Bytes.toInt(bytes);
public int getInt(int columnIndex) throws SQLException {
byte[] bytes = getBytes(columnIndex);
if (bytes == null) {
return null;
return Bytes.toBigDecimal(bytes);
public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
byte[] bytes = getBytes(columnIndex);
public class HBaseResultSetMetaData extends ResultSetMetaDataBase {
private List<String>           columeNames = new ArrayList<String>();
private List<SQLExpr>          conditions  = new ArrayList<SQLExpr>();
private byte[]                 family      = Bytes.toBytes("d");
private HBaseResultSetMetaData resultMetaData;
public HBaseResultSetMetaData getResultMetaData() {
return resultMetaData;
public void setResultMetaData(HBaseResultSetMetaData resultMetaData) {
this.resultMetaData = resultMetaData;
HBaseResultSet resultSet = new HBaseResultSet(statement, htable, scanner);
resultSet.setMetaData(resultMetaData);
return resultSet;
return new HStatement(this);
public HPreparedStatement prepareStatement(String sql) throws SQLException {
return new HPreparedStatement(this, sql);
HPreparedStatement stmt = prepareStatement(sql);
private HStatementInterface statement;
private HResultSetMetaData  metaData;
public HBaseResultSet(HStatementInterface statement, HTableInterface htable, ResultScanner scanner){
public HResultSetMetaData getMetaData() throws SQLException {
public void setMetaData(HResultSetMetaData metaData) {
public class HDriver implements Driver {
public class HPreparedStatement extends PreparedStatementBase implements PreparedStatement, HStatementInterface {
public HPreparedStatement(HBaseConnection conn, String sql) throws SQLException{
HResultSetMetaData resultMetaData = new HResultSetMetaData();
public class HResultSetMetaData extends ResultSetMetaDataBase {
public class HStatement extends StatementBase implements Statement, HStatementInterface {
public HStatement(HBaseConnection conn){
public interface HStatementInterface extends Statement {
HBaseResultSet executeQuery(HPreparedStatement statement) throws SQLException;
boolean execute(HPreparedStatement statement) throws SQLException;
public HBaseResultSet executeQuery(HPreparedStatement statement) throws SQLException {
public boolean execute(HPreparedStatement statement) throws SQLException {
public boolean execute(HPreparedStatement statement) throws SQLException {
private HResultSetMetaData resultMetaData;
public HResultSetMetaData getResultMetaData() {
public void setResultMetaData(HResultSetMetaData resultMetaData) {
public HBaseResultSet executeQuery(HPreparedStatement statement) throws SQLException {
HDriver driver = new HDriver();
HDriver driver = new HDriver();
HDriver driver = new HDriver();
HDriver driver = new HDriver();
public class HMapping {
private Map<String, HMappingColumn> columns = new LinkedHashMap<String, HMappingColumn>();
public Collection<HMappingColumn> getColumns() {
return Collections.unmodifiableCollection(columns.values());
public void addColumn(HMappingColumn column) {
this.columns.put(column.getName(), column);
public HMappingColumn getColumn(String columnName) {
return columns.get(columnName);
public class HMappingColumn {
private String   name;
private Class<?> type;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public Class<?> getType() {
return type;
public void setType(Class<?> type) {
this.type = type;
private final HEngine       engine;
public HBaseConnection(HEngine engine, Properties info){
super(engine.getUrl(), info);
this.engine = engine;
public HEngine getEngine() {
return engine;
return engine.getConfig().get(name);
engine.getConfig().set(entry.getKey().toString(), entry.getValue().toString());
this.engine.getConfig().set(name, value);
return (T) engine.getConfig();
public HTableInterface getHTable(String tableName) {
return engine.getHTable(tableName);
HEngine engine = HEngine.getHEngine(url, info);
return new HBaseConnection(engine, info);
public class HEngine {
private static ConcurrentMap<String, HEngine> engines = new ConcurrentHashMap<String, HEngine>();
public static HEngine getHEngine(String url, Properties connectProperties) {
HEngine engine = engines.get(url);
if (engine == null) {
engine = new HEngine(url, connectProperties);
engines.putIfAbsent(url, engine);
engine = engines.get(url);
return engine;
private final String        url;
private HTablePool          tablePool;
private final Configuration config;
public HEngine(String url, Properties connectProperties){
this.url = url;
config = new Configuration(false);
public String getUrl() {
return url;
public HTablePool getTablePool() {
return tablePool;
public Configuration getConfig() {
return config;
public HTableInterface getHTable(String tableName) {
return tablePool.getTable(tableName);
private HMappingColumn              keyColumn;
public HMappingColumn getKeyColumn() {
return keyColumn;
public void setKeyColumn(HMappingColumn keyColumn) {
keyColumn.setKey(true);
this.keyColumn = keyColumn;
private String            name;
private Class<?>          type;
private transient boolean key = false;
public boolean isKey() {
return key;
public void setKey(boolean key) {
this.key = key;
private final HEngine       engine;
public HBaseConnection(HEngine engine, Properties info){
super(engine.getUrl(), info);
this.engine = engine;
public HEngine getEngine() {
return engine;
return engine.getConfig().get(name);
engine.getConfig().set(entry.getKey().toString(), entry.getValue().toString());
this.engine.getConfig().set(name, value);
return (T) engine.getConfig();
public HTableInterface getHTable(String tableName) {
return engine.getHTable(tableName);
HEngine engine = HEngine.getHEngine(url, info);
return new HBaseConnection(engine, info);
public class HEngine {
private final static Log LOG = LogFactory.getLog(HEngine.class);
private static ConcurrentMap<String, HEngine> engines = new ConcurrentHashMap<String, HEngine>();
public static HEngine getHEngine(String url, Properties connectProperties) {
HEngine engine = engines.get(url);
if (engine == null) {
engine = new HEngine(url, connectProperties);
engines.putIfAbsent(url, engine);
engine = engines.get(url);
return engine;
private final String  url;
private HTablePool    tablePool;
private int           htablePoolMaxSize = 256;
private Configuration config;
public HEngine(String url, Properties connectProperties){
this.url = url;
config = new Configuration(false);
if (connectProperties != null) {
String propValue = connectProperties.getProperty("htable.pool.size");
if (propValue != null) {
htablePoolMaxSize = Integer.parseInt(propValue);
} catch (NumberFormatException ex) {
LOG.error("parse property 'htable.pool.size' error", ex);
public String getUrl() {
return url;
public HTablePool getTablePool() {
return tablePool;
public Configuration getConfig() {
return config;
public synchronized HTableInterface getHTable(String tableName) {
if (tablePool == null) {
tablePool = new HTablePool(config, htablePoolMaxSize);
return tablePool.getTable(tableName);
private HMappingColumn              keyColumn;
public HMappingColumn getKeyColumn() {
return keyColumn;
public void setKeyColumn(HMappingColumn keyColumn) {
keyColumn.setKey(true);
this.keyColumn = keyColumn;
private String            name;
private Class<?>          type;
private transient boolean key = false;
public boolean isKey() {
return key;
public void setKey(boolean key) {
this.key = key;
private final static Log                      LOG     = LogFactory.getLog(HEngine.class);
private final String                    url;
private HTablePool                      tablePool;
private int                             htablePoolMaxSize = 256;
private Configuration                   config;
private ConcurrentMap<String, HMapping> mappings          = new ConcurrentHashMap<String, HMapping>();
public ConcurrentMap<String, HMapping> getMappings() {
return mappings;
private String                      tableName;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
private final static Log                      LOG     = LogFactory.getLog(HEngine.class);
private final String                    url;
private HTablePool                      tablePool;
private int                             htablePoolMaxSize = 256;
private Configuration                   config;
private ConcurrentMap<String, HMapping> mappings          = new ConcurrentHashMap<String, HMapping>();
public ConcurrentMap<String, HMapping> getMappings() {
return mappings;
HTableInterface htable = connection.getHTable(getTableName());
private String                      tableName;
public String getTableName() {
return tableName;
public void setTableName(String tableName) {
this.tableName = tableName;
public class HCreateTableStatement extends SQLCreateTableStatement {
private static final long serialVersionUID = 1L;
public class HFamilyDefinition extends SQLObjectImpl implements SQLTableElement {
private static final long serialVersionUID = 1L;
protected void accept0(SQLASTVisitor visitor) {
public class HSelectQueryBlock extends SQLSelectQueryBlock {
private static final long serialVersionUID = 1L;
public class HStatementParser {
public class HCreateTableStatement extends SQLCreateTableStatement {
private static final long serialVersionUID = 1L;
public class HFamilyDefinition extends SQLObjectImpl implements SQLTableElement {
private static final long serialVersionUID = 1L;
private String            columnName;
private Integer           blockSize;
private Integer           minVersions;
private Integer           maxVersions;
private String            compressionType;
private String            compactionCompressionType;
private Boolean           inMemory;
private Integer           timeToLive;
private Boolean           blockCacheEnabled;
private String            bloomFilterType;
protected void accept0(SQLASTVisitor visitor) {
public String getColumnName() {
return columnName;
public void setColumnName(String columnName) {
this.columnName = columnName;
public Integer getBlockSize() {
return blockSize;
public void setBlockSize(Integer blockSize) {
this.blockSize = blockSize;
public Integer getMinVersions() {
return minVersions;
public void setMinVersions(Integer minVersions) {
this.minVersions = minVersions;
public Integer getMaxVersions() {
return maxVersions;
public void setMaxVersions(Integer maxVersions) {
this.maxVersions = maxVersions;
public String getCompressionType() {
return compressionType;
public void setCompressionType(String compressionType) {
this.compressionType = compressionType;
public String getCompactionCompressionType() {
return compactionCompressionType;
public void setCompactionCompressionType(String compactionCompressionType) {
this.compactionCompressionType = compactionCompressionType;
public Boolean getInMemory() {
return inMemory;
public void setInMemory(Boolean inMemory) {
this.inMemory = inMemory;
public Integer getTimeToLive() {
return timeToLive;
public void setTimeToLive(Integer timeToLive) {
this.timeToLive = timeToLive;
public Boolean getBlockCacheEnabled() {
return blockCacheEnabled;
public void setBlockCacheEnabled(Boolean blockCacheEnabled) {
this.blockCacheEnabled = blockCacheEnabled;
public String getBloomFilterType() {
return bloomFilterType;
public void setBloomFilterType(String bloomFilterType) {
this.bloomFilterType = bloomFilterType;
public class HSelectQueryBlock extends SQLSelectQueryBlock {
private static final long serialVersionUID = 1L;
public class HStatementParser {
public class HBQLCreateMappingStatement extends SQLStatementImpl implements HBQLStatement {
private static final long serialVersionUID = 1L;
public class HBQLCreateTableStatement extends SQLCreateTableStatement {
public class HBQLFamilyDefinition extends SQLObjectImpl implements SQLTableElement {
public class HBQLSelectQueryBlock extends SQLSelectQueryBlock {
public interface HBQLStatement extends SQLStatement {
public class HBQLStatementParser {
public interface HBQLVisitor extends SQLASTVisitor {
public class HBQLCreateMappingStatement extends SQLStatementImpl implements HBQLStatement {
private static final long serialVersionUID = 1L;
private HMapping          mapping          = new HMapping();
public HMapping getMapping() {
return mapping;
public void setMapping(HMapping mapping) {
this.mapping = mapping;
public class HBQLCreateTableStatement extends SQLCreateTableStatement {
public class HBQLFamilyDefinition extends SQLObjectImpl implements SQLTableElement {
public class HBQLSelectQueryBlock extends SQLSelectQueryBlock {
public interface HBQLStatement extends SQLStatement {
public class HBQLStatementParser extends SQLStatementParser {
protected SQLExprParser exprParser;
public HBQLStatementParser(String sql){
super(sql);
this.exprParser = new SQLExprParser(lexer);
public HBQLStatementParser(Lexer lexer){
super(lexer);
this.exprParser = new SQLExprParser(lexer);
public interface HBQLVisitor extends SQLASTVisitor {
public class HBQLStatementParser extends SQLStatementParser {
protected SQLExprParser exprParser;
public HBQLStatementParser(String sql){
super(sql);
this.exprParser = new SQLExprParser(lexer);
public HBQLStatementParser(Lexer lexer){
super(lexer);
this.exprParser = new SQLExprParser(lexer);
return new SQLSelectParser(this);
protected SQLExprParser exprParser;
public SQLSelectParser(SQLExprParser exprParser){
super(exprParser.getLexer());
this.exprParser = exprParser;
return new SQLSelectParser(this.exprParser);
createView.setSubQuery(new SQLSelectParser(this.exprParser).select());
SQLSelect query = new MySqlSelectParser(this.exprParser).select();
return new MySqlSelectParser(this);
public MySqlSelectParser(SQLExprParser exprParser){
super(exprParser);
this(new MySqlExprParser(sql));
return new SQLSelectStatement(new MySqlSelectParser(this.exprParser).select());
return new MySqlSelectParser(this.exprParser);
if (iface == PreparedStatementHolder.class) {
return (T) this.holder;
holder.incrementHitCount();
OracleConnection oracleConn;
OraclePreparedStatement oracleStmt;
PreparedStatementHolder stmtHolder;
oracleConn = conn.unwrap(OracleConnection.class);
oracleStmt = stmt.unwrap(OraclePreparedStatement.class);
Assert.assertEquals(50, oracleStmt.getRowPrefetch());
stmtHolder = stmt.unwrap(PreparedStatementHolder.class);
Assert.assertNotNull(stmtHolder);
Assert.assertEquals(0, stmtHolder.getHitCount());
OracleConnection oracleConn2 = conn.unwrap(OracleConnection.class);
Assert.assertEquals(50, oracleConn2.getDefaultRowPrefetch());
Assert.assertSame(oracleConn, oracleConn2);
PreparedStatementHolder stmtHolder2 = stmt.unwrap(PreparedStatementHolder.class);
Assert.assertSame(stmtHolder2, stmtHolder);
Assert.assertEquals(1, stmtHolder.getHitCount());
rs.close();
stmt.close();
OraclePreparedStatement oracleStmt2 = stmt.unwrap(OraclePreparedStatement.class);
Assert.assertSame(oracleStmt, oracleStmt2);
private String          dbType = "hbase";
public class HBQLShowStatement extends HBQLStatementImpl {
private static final long serialVersionUID = 1L;
public void accept0(HBQLVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public class HBQLStatementImpl extends SQLStatementImpl {
private static final long serialVersionUID = 1L;
protected void accept0(SQLASTVisitor visitor) {
if (visitor instanceof HBQLVisitor) {
accept0((HBQLVisitor) visitor);
throw new IllegalArgumentException("not support visitor type : " + visitor.getClass().getName());
public void accept0(HBQLVisitor visitor) {
throw new UnsupportedOperationException(this.getClass().getName());
public class HBQLExprParser extends SQLExprParser {
public HBQLExprParser(String sql) throws ParserException{
super(sql);
public HBQLExprParser(Lexer lexer){
super(lexer);
public SQLStatement parseShow() {
acceptIdentifier("SHOW");
acceptIdentifier("TABLES");
return new HBQLShowStatement();
public class HBQLOutputVisitor extends SQLASTOutputVisitor implements HBQLVisitor {
public HBQLOutputVisitor(Appendable appender){
super(appender);
public void endVisit(HBQLShowStatement x) {
public boolean visit(HBQLShowStatement x) {
print("SHOW TABLES");
return false;
void endVisit(HBQLShowStatement x);
boolean visit(HBQLShowStatement x);
if (JdbcUtils.HBASE.equals(dbType)) {
return new HBQLStatementParser(sql);
if (JdbcUtils.HBASE.equals(dbType)) {
return new HBQLExprParser(sql);
if (identifierEquals("SHOW")) {
SQLStatement stmt = parseShow();
statementList.add(stmt);
continue;
public SQLStatement parseShow() {
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
public static final String      HBASE            = "hbase";
public class HBQLShowTableTest extends TestCase {
public void test_select_0 () throws Exception {
HDriver driver = new HDriver();
Connection conn = driver.connect("jdbc:druid-hbase:10.20.153.63", new Properties());
PreparedStatement stmt = conn.prepareStatement("SHOW TABLES");
stmt.setInt(1, 6);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
System.out.print(rs.getString(1));
System.out.println();
rs.close();
stmt.close();
conn.close();
JdbcUtils.printResultSet(rs);
HResultSet executeQuery(HPreparedStatementImpl statement) throws SQLException;
boolean execute(HPreparedStatementImpl statement) throws SQLException;
public HResultSet executeQuery(HPreparedStatementImpl statement) throws SQLException {
public boolean execute(HPreparedStatementImpl statement) throws SQLException {
public boolean execute(HPreparedStatementImpl statement) throws SQLException {
public HResultSet executeQuery(HPreparedStatementImpl statement) throws SQLException {
public boolean execute(HPreparedStatementImpl statement) throws SQLException {
public HBaseResultSet executeQuery(HPreparedStatementImpl statement) throws SQLException {
return new HStatementImpl(this);
public HPreparedStatementImpl prepareStatement(String sql) throws SQLException {
return new HPreparedStatementImpl(this, sql);
HPreparedStatementImpl stmt = prepareStatement(sql);
private HStatement statement;
public HBaseResultSet(HStatement statement, HTableInterface htable, ResultScanner scanner){
public interface HPreparedStatement extends HStatement {
public class HPreparedStatementImpl extends PreparedStatementBase implements PreparedStatement, HStatement {
private final String    sql;
private String[]        columnNames;
private HBaseConnection hbaseConnection;
private ExecutePlan     executePlan;
private String          dbType = "hbase";
public HPreparedStatementImpl(HBaseConnection conn, String sql) throws SQLException{
super(conn);
this.sql = sql;
this.hbaseConnection = conn;
private void splitCondition(List<SQLExpr> conditions, SQLExpr expr) {
if (expr instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryExpr = (SQLBinaryOpExpr) expr;
if (binaryExpr.getOperator() == SQLBinaryOperator.BooleanAnd) {
splitCondition(conditions, binaryExpr.getLeft());
splitCondition(conditions, binaryExpr.getRight());
conditions.add(expr);
public void init() throws SQLException {
List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, dbType);
if (stmtList.size() != 1) {
throw new SQLException("not support multi-statement");
SQLStatement sqlStmt = stmtList.get(0);
if (sqlStmt instanceof SQLSelectStatement) {
SQLSelectStatement selectStmt = (SQLSelectStatement) sqlStmt;
SQLEvalVisitor evalVisitor = SQLEvalVisitorUtils.createEvalVisitor(dbType);
selectStmt.accept(evalVisitor);
SQLSelectQueryBlock selectQueryBlock = (SQLSelectQueryBlock) selectStmt.getSelect().getQuery();
SQLExprTableSource tableSource = (SQLExprTableSource) selectQueryBlock.getFrom();
String tableName = ((SQLIdentifierExpr) tableSource.getExpr()).getName();
SingleTableQueryExecutePlan singleTableQueryExecuetePlan = new SingleTableQueryExecutePlan();
singleTableQueryExecuetePlan.setTableName(tableName);
splitCondition(singleTableQueryExecuetePlan.getConditions(), selectQueryBlock.getWhere());
HResultSetMetaData resultMetaData = new HResultSetMetaData();
for (SQLSelectItem selectItem : selectQueryBlock.getSelectList()) {
ColumnMetaData columnMetaData = new ColumnMetaData();
if (selectItem.getAlias() != null) {
columnMetaData.setColumnLabel(selectItem.getAlias());
columnMetaData.setColumnName(SQLUtils.toSQLString(selectItem.getExpr(), dbType));
columnMetaData.setColumnType(Types.BINARY);
resultMetaData.getColumns().add(columnMetaData);
singleTableQueryExecuetePlan.setResultMetaData(resultMetaData);
this.executePlan = singleTableQueryExecuetePlan;
} else if (sqlStmt instanceof SQLInsertStatement) {
SQLInsertStatement insertStmt = (SQLInsertStatement) sqlStmt;
SQLEvalVisitor evalVisitor = SQLEvalVisitorUtils.createEvalVisitor(dbType);
insertStmt.accept(evalVisitor);
String tableName = ((SQLIdentifierExpr) insertStmt.getTableSource().getExpr()).getName();
InsertExecutePlan insertExecutePlan = new InsertExecutePlan();
insertExecutePlan.setTableName(tableName);
for (int i = 0; i < insertStmt.getColumns().size(); ++i) {
SQLExpr columnExpr = insertStmt.getColumns().get(i);
SQLExpr valueExpr = insertStmt.getValues().getValues().get(i);
String columnName = ((SQLIdentifierExpr) columnExpr).getName();
insertExecutePlan.getColumns().put(columnName, valueExpr);
this.executePlan = insertExecutePlan;
} else if (sqlStmt instanceof HBQLShowStatement) {
ShowTablesPlan showTablePlan = new ShowTablesPlan();
this.executePlan = showTablePlan;
throw new SQLException("TODO");
public ExecutePlan getExecutePlan() {
return executePlan;
public String[] getColumnNames() {
return columnNames;
public void setColumnNames(String[] columnNames) {
this.columnNames = columnNames;
public String getSql() {
return sql;
public HBaseConnection getConnection() throws SQLException {
return hbaseConnection;
public ResultSet executeQuery() throws SQLException {
return this.executePlan.executeQuery(this);
public int executeUpdate() throws SQLException {
public boolean execute() throws SQLException {
this.executePlan.execute(this);
return false;
public interface HStatement extends Statement {
HBaseConnection getConnection() throws SQLException;
public class HStatementImpl extends StatementBase implements Statement, HStatement {
private HBaseConnection conn;
public HStatementImpl(HBaseConnection conn){
super(conn);
this.conn = conn;
public HBaseConnection getConnection() throws SQLException {
return conn;
public void checkOpen() {
public interface HPreparedStatement extends PreparedStatement, HStatement {
public class HPreparedStatementImpl extends PreparedStatementBase implements HPreparedStatement {
if (iface == HEngine.class) {
return (T) engine;
public interface HPreparedStatement extends PreparedStatement, HStatement {
public class HPreparedStatementImpl extends PreparedStatementBase implements HPreparedStatement {
private ConcurrentMap<String, HMappingTable> mappings          = new ConcurrentHashMap<String, HMappingTable>();
public ConcurrentMap<String, HMappingTable> getMappings() {
private HMappingTable           mapping;
public HMappingTable getMapping() {
public void setMapping(HMappingTable mapping) {
private HMappingTable          mapping          = new HMappingTable();
public HMappingTable getMapping() {
public void setMapping(HMappingTable mapping) {
private HMappingTable            mapping;
public HMappingTable getMapping() {
public void setMapping(HMappingTable mapping) {
public class HMappingTable {
public HScannerResultSet executeQuery(HPreparedStatementImpl statement) throws SQLException {
HScannerResultSet resultSet = new HScannerResultSet(statement, htable, scanner);
public class HScannerResultSet extends ResultSetBase implements HResultSet {
public HScannerResultSet(HStatement statement, HTableInterface htable, ResultScanner scanner){
public interface HMapping {
private HStatement      statement;
private ResultScanner   scanner;
private HTableInterface htable;
private Result          result;
private byte[]          family = Bytes.toBytes("d");
private HMapping        mapping;
public HMapping getMapping() {
public void setMapping(HMapping mapping) {
private HMappingTable      mapping;
byte[] getFamily(String columnName);
byte[] getQualifier(String columnName);
boolean isRow(String columnName);
Object getObject(Result result, String name);
public class HMappingDefaultImpl implements HMapping {
private byte[] family = Bytes.toBytes("d");
public Object getObject(Result result, String columnName) {
byte[] family = this.getFamily(columnName);
byte[] bytes;
if (isRow(columnName)) {
bytes = result.getRow();
byte[] qualifier = Bytes.toBytes(columnName);
bytes = result.getValue(family, qualifier);
return bytes;
public byte[] getFamily(String columnName) {
return family;
public byte[] getQualifier(String columnName) {
return Bytes.toBytes(columnName);
public boolean isRow(String columnName) {
if ("id".equals(columnName)) {
return true;
return false;
byte[] getRow(Result result, String columnName);
bytes = getRow(result, columnName);
public byte[] getRow(Result result, String columnName) {
return result.getRow();
public class JakartaCommonsLoggingImpl implements com.alibaba.druid.support.logging.Log {
public class DefaultHandler {
public interface HConnection extends Connection {
public HBaseConnectionImpl connect(String url, Properties info) throws SQLException {
return new HBaseConnectionImpl(engine, info);
HBaseConnectionImpl getConnection() throws SQLException;
HBaseConnectionImpl connection = statement.getConnection();
HBaseConnectionImpl connection = statement.getConnection();
public class HBaseConnectionImpl extends ConnectionBase implements HConnection {
public HBaseConnectionImpl(HEngine engine, Properties info){
if (iface == Connection.class || iface == HBaseConnectionImpl.class) {
if (iface == Connection.class || iface == HBaseConnectionImpl.class) {
private HBaseConnectionImpl hbaseConnection;
public HPreparedStatementImpl(HBaseConnectionImpl conn, String sql) throws SQLException{
public HBaseConnectionImpl getConnection() throws SQLException {
private HBaseConnectionImpl conn;
public HStatementImpl(HBaseConnectionImpl conn){
public HBaseConnectionImpl getConnection() throws SQLException {
public interface HConnection extends Connection {
HPreparedStatementImpl prepareStatement(String sql) throws SQLException;
public HConnection connect(String url, Properties info) throws SQLException {
HStatement getStatement() throws SQLException;
HConnection getConnection() throws SQLException;
public HStatement getStatement() throws SQLException {
return (HStatement) statement;
public HStatement getStatement() throws SQLException {
protected boolean           closed         = false;
protected boolean           wasNull        = false;
private SQLWarning          warning;
private String              cursorName;
private int                 fetchSize      = 0;
private int                 fetchDirection = 0;
protected Statement         statement;
public interface HConnection extends Connection {
HPreparedStatementImpl prepareStatement(String sql) throws SQLException;
public HConnection connect(String url, Properties info) throws SQLException {
public HResultSet executeQuery() throws SQLException;
HStatement getStatement() throws SQLException;
HConnection getConnection() throws SQLException;
HResultSet getResultSet() throws SQLException;
public HStatement getStatement() throws SQLException {
return (HStatement) statement;
private final String        sql;
private String[]            columnNames;
private ExecutePlan         executePlan;
private String              dbType = "hbase";
public HResultSet executeQuery() throws SQLException {
public HResultSet getResultSet() throws SQLException {
return (HResultSet) super.getResultSet();
public HStatement getStatement() throws SQLException {
public HResultSet getResultSet() throws SQLException {
return (HResultSet) super.getResultSet();
protected boolean           closed         = false;
protected boolean           wasNull        = false;
private SQLWarning          warning;
private String              cursorName;
private int                 fetchSize      = 0;
private int                 fetchDirection = 0;
protected Statement         statement;
HResultSetMetaDataImpl resultMetaData = new HResultSetMetaDataImpl();
public class HResultSetMetaDataImpl extends ResultSetMetaDataBase {
public class HScannerResultSetImpl extends ResultSetBase implements HResultSet {
public HScannerResultSetImpl(HStatement statement, HTableInterface htable, ResultScanner scanner){
public HResultSetMetaDataImpl getMetaData() throws SQLException {
return (HResultSetMetaDataImpl) metaData;
public void setMetaData(HResultSetMetaDataImpl metaData) {
HResultSetMetaDataImpl metaData = new HResultSetMetaDataImpl();
HResultSetMetaDataImpl meta = (HResultSetMetaDataImpl) this.metaData;
private HResultSetMetaDataImpl resultMetaData;
public HResultSetMetaDataImpl getResultMetaData() {
public void setResultMetaData(HResultSetMetaDataImpl resultMetaData) {
public HScannerResultSetImpl executeQuery(HPreparedStatementImpl statement) throws SQLException {
HScannerResultSetImpl resultSet = new HScannerResultSetImpl(statement, htable, scanner);
HStatement createStatement() throws SQLException;;
public HStatement createStatement() throws SQLException {
public HStatement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
public HStatement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
"com.alibaba.druid.support.logging.JakartaCommonsLoggingImpl");
tryImplementation("org.apache.log4j.Logger", "com.alibaba.druid.support.logging.Log4jImpl");
tryImplementation("java.util.logging.Logger", "com.alibaba.druid.support.logging.Jdk14LoggingImpl");
tryImplementation("java.lang.Object", "com.alibaba.druid.support.logging.NoLoggingImpl");
super(new HBQLLexer(sql));
this.lexer.nextToken();
public class HBQLLexer extends Lexer {
public final static Keywords DEFAULT_HBQL_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.put("EXISTS", Token.EXISTS);
map.put("THEN", Token.THEN);
map.put("AS", Token.AS);
map.put("GROUP", Token.GROUP);
map.put("BY", Token.BY);
map.put("HAVING", Token.HAVING);
map.put("DELETE", Token.DELETE);
map.put("ORDER", Token.ORDER);
map.put("INDEX", Token.INDEX);
map.put("FOR", Token.FOR);
map.put("SCHEMA", Token.SCHEMA);
map.put("FOREIGN", Token.FOREIGN);
map.put("REFERENCES", Token.REFERENCES);
map.put("CHECK", Token.CHECK);
map.put("PRIMARY", Token.PRIMARY);
map.put("KEY", Token.KEY);
map.put("CONSTRAINT", Token.CONSTRAINT);
map.put("DEFAULT", Token.DEFAULT);
map.put("VIEW", Token.VIEW);
map.put("CREATE", Token.CREATE);
map.put("VALUES", Token.VALUES);
map.put("ALTER", Token.ALTER);
map.put("TABLE", Token.TABLE);
map.put("DROP", Token.DROP);
map.put("SET", Token.SET);
map.put("INTO", Token.INTO);
map.put("UPDATE", Token.UPDATE);
map.put("NULL", Token.NULL);
map.put("IS", Token.IS);
map.put("NOT", Token.NOT);
map.put("SELECT", Token.SELECT);
map.put("INSERT", Token.INSERT);
map.put("FROM", Token.FROM);
map.put("WHERE", Token.WHERE);
map.put("AND", Token.AND);
map.put("OR", Token.OR);
map.put("XOR", Token.XOR);
map.put("DISTINCT", Token.DISTINCT);
map.put("UNIQUE", Token.UNIQUE);
map.put("ALL", Token.ALL);
map.put("UNION", Token.UNION);
map.put("INTERSECT", Token.INTERSECT);
map.put("MINUS", Token.MINUS);
map.put("INNER", Token.INNER);
map.put("LEFT", Token.LEFT);
map.put("RIGHT", Token.RIGHT);
map.put("FULL", Token.FULL);
map.put("ON", Token.ON);
map.put("OUTER", Token.OUTER);
map.put("JOIN", Token.JOIN);
map.put("NEW", Token.NEW);
map.put("CASE", Token.CASE);
map.put("WHEN", Token.WHEN);
map.put("END", Token.END);
map.put("WHEN", Token.WHEN);
map.put("ELSE", Token.ELSE);
map.put("EXISTS", Token.EXISTS);
map.put("CAST", Token.CAST);
map.put("IN", Token.IN);
map.put("ASC", Token.ASC);
map.put("DESC", Token.DESC);
map.put("LIKE", Token.LIKE);
map.put("ESCAPE", Token.ESCAPE);
map.put("BETWEEN", Token.BETWEEN);
map.put("INTERVAL", Token.INTERVAL);
map.put("LOCK", Token.LOCK);
map.put("SOME", Token.SOME);
map.put("ANY", Token.ANY);
map.put("TRUNCATE", Token.TRUNCATE);
map.put("IF", Token.IF);
map.put("TRUE", Token.TRUE);
map.put("FALSE", Token.FALSE);
map.put("LIMIT", Token.LIMIT);
DEFAULT_HBQL_KEYWORDS = new Keywords(map);
public HBQLLexer(String input){
super(input);
super.keywods = DEFAULT_HBQL_KEYWORDS;
super(new HBQLExprParser(sql));
private byte[] family    = Bytes.toBytes("d");
private String rowColumn = "id";
public byte[] getFamily() {
return family;
public void setFamily(byte[] family) {
this.family = family;
public String getRowColumn() {
return rowColumn;
public void setRowColumn(String rowColumn) {
this.rowColumn = rowColumn;
if (rowColumn.equals(columnName)) {
public abstract class HMappingAdapter implements HMapping {
public byte[] getQualifier(String columnName) {
return Bytes.toBytes(columnName);
public byte[] getRow(Result result, String columnName) {
return result.getRow();
public Object getObject(Result result, String columnName) {
byte[] family = this.getFamily(columnName);
byte[] bytes;
if (isRow(columnName)) {
bytes = getRow(result, columnName);
byte[] qualifier = Bytes.toBytes(columnName);
bytes = result.getValue(family, qualifier);
return bytes;
public class HMappingDefaultImpl extends HMappingAdapter implements HMapping {
HPreparedStatement prepareStatement(String sql) throws SQLException;
HPreparedStatement prepareStatement(String sql, HMapping mapping) throws SQLException;
throw new SQLFeatureNotSupportedException();
throw new SQLFeatureNotSupportedException();
throw new SQLFeatureNotSupportedException();
throw new SQLFeatureNotSupportedException();
public HPreparedStatement prepareStatement(String sql, HMapping mapping) throws SQLException {
throw new SQLFeatureNotSupportedException();
public abstract class HMappingAdapter implements HMapping {
public byte[] getQualifier(String columnName) {
return Bytes.toBytes(columnName);
public byte[] getRow(Result result, String columnName) {
return result.getRow();
public Object getObject(Result result, String columnName) {
byte[] family = this.getFamily(columnName);
byte[] bytes;
if (isRow(columnName)) {
bytes = getRow(result, columnName);
byte[] qualifier = Bytes.toBytes(columnName);
bytes = result.getValue(family, qualifier);
return bytes;
public class HMappingDefaultImpl extends HMappingAdapter implements HMapping {
return prepareStatement(sql, (HMapping) null);
public HPreparedStatementImpl prepareStatement(String sql, HMapping mapping) throws SQLException {
return new HPreparedStatementImpl(this, sql, mapping);
private HMapping            mapping;
public HPreparedStatementImpl(HBaseConnectionImpl conn, String sql, HMapping mapping) throws SQLException{
this.mapping = mapping;
public HMapping getMapping() {
return mapping;
return prepareStatement(sql, (HMapping) null);
public HPreparedStatementImpl prepareStatement(String sql, HMapping mapping) throws SQLException {
return new HPreparedStatementImpl(this, sql, mapping);
private HMapping            mapping;
public HPreparedStatementImpl(HBaseConnectionImpl conn, String sql, HMapping mapping) throws SQLException{
this.mapping = mapping;
public HMapping getMapping() {
return mapping;
singleTableQueryExecuetePlan.setMapping(mapping);
private List<String>           columeNames = new ArrayList<String>();
private List<SQLExpr>          conditions  = new ArrayList<SQLExpr>();
private byte[]                 family      = Bytes.toBytes("d");
private HMapping               mapping;
public HMapping getMapping() {
public void setMapping(HMapping mapping) {
HMapping mapping = this.mapping;
if (mapping == null) {
mapping = new HMappingDefaultImpl();
if (mapping.isRow(fieldName)) {
byte[] qualifier = mapping.getQualifier(fieldName);
byte[] family = mapping.getFamily(fieldName);
HMapping mapping = this.getMapping();
if (mapping == null) {
mapping = new HMappingDefaultImpl();
byte[] bytes = mapping.toBytes(column, value);
if (mapping.isRow(column)) {
byte[] family = mapping.getFamily(column);
byte[] qualifier = mapping.getQualifier(column);
private String   tableName;
private HMapping mapping;
public HMapping getMapping() {
return mapping;
public void setMapping(HMapping mapping) {
this.mapping = mapping;
HMapping mapping = this.getMapping();
if (mapping == null) {
mapping = new HMappingDefaultImpl();
byte[] bytes = mapping.toBytes(fieldName, value);
if (mapping.isRow(fieldName)) {
byte[] qualifier = mapping.getQualifier(fieldName);
byte[] family = mapping.getFamily(fieldName);
Object getObject(Result result, String columnName);
byte[] toBytes(String columnName, Object value) throws IOException;
public byte[] toBytes(String columnName, Object value) throws IOException {
if (value == null) {
return null;
byte[] bytes;
if (value instanceof String) {
String strValue = (String) value;
bytes = Bytes.toBytes(strValue);
} else if (value instanceof Integer) {
int intValue = ((Integer) value).intValue();
bytes = Bytes.toBytes(intValue);
} else if (value instanceof Long) {
long longValue = ((Long) value).longValue();
bytes = Bytes.toBytes(longValue);
} else if (value instanceof Boolean) {
boolean booleanValue = ((Boolean) value).booleanValue();
bytes = Bytes.toBytes(booleanValue);
} else if (value instanceof BigDecimal) {
BigDecimal decimalValue = (BigDecimal) value;
bytes = Bytes.toBytes(decimalValue);
throw new IOException("TODO"); 
return bytes;
HMapping mapping = this.mapping;
if (mapping == null) {
mapping = new HMappingDefaultImpl();
private String                 dbType      = "hbase";
private Scan                   scan;
private HPreparedStatementImpl statement;
scan = new Scan();
this.statement = statement;
setFilter(condition);
} finally {
scan = null;
this.statement = null;
private void setFilter(SQLBinaryOpExpr condition) throws IOException,
SQLException {
HMapping mapping = this.getMapping();
String fieldName = ((SQLIdentifierExpr) condition.getLeft()).getName();
Object value = SQLEvalVisitorUtils.eval(dbType, condition.getRight(), statement.getParameters());
byte[] bytes = mapping.toBytes(fieldName, value);
if (mapping.isRow(fieldName)) {
if (condition.getOperator() == SQLBinaryOperator.GreaterThanOrEqual) {
scan.setStartRow(bytes);
} else if (condition.getOperator() == SQLBinaryOperator.LessThan) {
scan.setStopRow(bytes);
} else if (condition.getOperator() == SQLBinaryOperator.LessThanOrEqual) {
RowFilter filter = new RowFilter(CompareOp.LESS_OR_EQUAL, new BinaryComparator(bytes));
setFilter(scan, filter);
throw new SQLException("TODO");
byte[] qualifier = mapping.getQualifier(fieldName);
byte[] family = mapping.getFamily(fieldName);
CompareOp compareOp = toCompareOp(condition.getOperator());
SingleColumnValueFilter filter = new SingleColumnValueFilter(family, qualifier, compareOp, bytes);
setFilter(scan, filter);
List<Filter> filters = new ArrayList<Filter>();
filters.add(parentFilter);
filters.add(filter);
return new FilterList(filterOp, filters);
PreparedStatement stmt = conn.prepareStatement("SELECT id, name, gender, salary FROM test_user where id = 3 or id = ? or name = 'user-4'");
List<SQLExpr> groupList = new ArrayList<SQLExpr>();
SQLExpr left = x.getLeft();
for (;;) {
if (left instanceof SQLBinaryOpExpr && ((SQLBinaryOpExpr) left).getOperator() == x.getOperator()) {
SQLBinaryOpExpr binaryLeft = (SQLBinaryOpExpr) left;
groupList.add(binaryLeft.getRight());
left = binaryLeft.getLeft();
groupList.add(left);
for (int i = groupList.size() - 1; i >= 0; --i) {
SQLExpr item = groupList.get(i);
visitBinaryLeft(item, x.getOperator());
if (relational) {
println();
print(" ");
print(x.getOperator().name);
print(" ");
visitorBinaryRight(x);
return false;
private void visitorBinaryRight(SQLBinaryOpExpr x) {
private void visitBinaryLeft(SQLExpr left, SQLBinaryOperator op) {
if (left instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryLeft = (SQLBinaryOpExpr) left;
boolean leftRational = binaryLeft.getOperator() == SQLBinaryOperator.BooleanAnd
|| binaryLeft.getOperator() == SQLBinaryOperator.BooleanOr;
if (binaryLeft.getOperator().priority > op.priority) {
if (leftRational) {
incrementIndent();
print('(');
left.accept(this);
print(')');
if (leftRational) {
decrementIndent();
left.accept(this);
left.accept(this);
x.getRight().accept(this);
if (!"?".equals(x.getName())) {
return false;
public class BigOrTest extends TestCase {
public void testBigOr() throws Exception {
StringBuilder buf = new StringBuilder();
buf.append("SELECT * FROM T WHERE FID = ?");
for (int i = 0; i < 10000; ++i) {
buf.append(" OR FID = " + i);
String sql = buf.toString();
List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, null);
String text = SQLUtils.toSQLString(stmtList.get(0));
System.out.println(text);
public SQLStatement parseShow() {
acceptIdentifier("SHOW");
if (identifierEquals("TABLES")) {
lexer.nextToken();
HiveShowTablesStatement stmt = new HiveShowTablesStatement();
if (lexer.token() == Token.LITERAL_CHARS) {
stmt.setPattern((SQLCharExpr) exprParser.primary());
return stmt;
throw new ParserException("TODO " + lexer.info());
public class MySqlAlterTableTest1 extends TestCase {
public void test_alter_0() throws Exception {
String sql = "ALTER TABLE t1 RENAME t2;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("RENAME TABLE t1 TO t2", output);
int varIndex = ((SQLVariantRefExpr) expr).getIndex();
if (varIndex != -1 && visitor.getParameters().size() > varIndex) {
private int               index            = -1;
public int getIndex() {
return index;
public void setIndex(int index) {
this.index = index;
private int                                varIndex     = -1;
public int nextVarIndex() {
return ++varIndex;
if (!hasSpecial) {
System.arraycopy(buf, np + 1, sbuf, 0, sp);
hasSpecial = true;
putChar(''');
SQLVariantRefExpr quesVarRefExpr = new SQLVariantRefExpr("?");
quesVarRefExpr.setIndex(lexer.nextVarIndex());
sqlExpr = quesVarRefExpr;
int varIndex = x.getIndex();
if (varIndex != -1 && visitor.getParameters().size() > varIndex) {
Object value = visitor.getParameters().get(varIndex);
dataSource.setMaxOpenPreparedStatements(30);
Assert.assertEquals(-1, myStmt.updateCount.intValue());
public void test_execute_multi() throws Exception {
MyPreparedStatement myStmtA = null;
MyPreparedStatement myStmtB = null;
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("update t set id = ?");
myStmtA = stmt.unwrap(MyPreparedStatement.class);
Assert.assertNull(myStmtA.updateCount);
stmt.setString(1, "xxx");
stmt.execute();
Assert.assertNotNull(myStmtA.updateCount);
Assert.assertEquals(1, stmt.getUpdateCount());
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("update t set id = ?");
myStmtB = stmt.unwrap(MyPreparedStatement.class);
Assert.assertSame(myStmtA, myStmtB);
Assert.assertNotNull(myStmtB.updateCount);
stmt.setString(1, "xxx");
stmt.execute();
Assert.assertNotNull(myStmtB.updateCount);
Assert.assertEquals(1, stmt.getUpdateCount());
stmt.close();
conn.close();
public boolean execute() throws SQLException {
updateCount = null;
return false;
public ResultSet executeQuery() throws SQLException {
updateCount = -1;
return super.executeQuery();
if (driver != null) {
return driver.createMockStatement(this);
return createMockCallableStatement(sql);
MockCallableStatement stmt = createMockCallableStatement(sql);
MockCallableStatement stmt = createMockCallableStatement(sql);
private MockCallableStatement createMockCallableStatement(String sql) {
if (driver != null) {
return driver.createMockCallableStatement(this, sql);
return new MockCallableStatement(this, sql);
public MockCallableStatement createMockCallableStatement(MockConnection conn, String sql) {
return new MockCallableStatement(conn, sql);
MockConnection conn = getConnection();
if (conn != null && conn.getDriver() != null) {
if (conn != null) {
conn.handleSleep();
protected void cloneTo(DruidAbstractDataSource to) {
to.defaultAutoCommit = this.defaultAutoCommit;
to.defaultReadOnly = this.defaultReadOnly;
to.defaultTransactionIsolation = this.defaultTransactionIsolation;
to.defaultCatalog = this.defaultCatalog;
to.name = this.name;
to.username = this.username;
to.password = this.password;
to.jdbcUrl = this.jdbcUrl;
to.driverClass = this.driverClass;
to.connectionProperties = this.connectionProperties;
to.passwordCallback = this.passwordCallback;
to.userCallback = this.userCallback;
to.connectionFactory = this.connectionFactory;
to.initialSize = this.initialSize;
to.maxActive = this.maxActive;
to.minIdle = this.minIdle;
to.maxIdle = this.maxIdle;
to.maxWait = this.maxWait;
to.validationQuery = this.validationQuery;
to.validationQueryTimeout = this.validationQueryTimeout;
to.testOnBorrow = this.testOnBorrow;
to.testOnReturn = this.testOnReturn;
to.testWhileIdle = this.testWhileIdle;
to.poolPreparedStatements = this.poolPreparedStatements;
to.sharePreparedStatements = this.sharePreparedStatements;
to.maxPoolPreparedStatementPerConnectionSize = this.maxPoolPreparedStatementPerConnectionSize;
to.logWriter = this.logWriter;
if (this.filters != null) {
to.filters = new ArrayList<Filter>(this.filters);
to.exceptionSorter = this.exceptionSorter;
to.driver = this.driver;
to.queryTimeout = this.queryTimeout;
to.transactionQueryTimeout = this.transactionQueryTimeout;
to.accessToUnderlyingConnectionAllowed = this.accessToUnderlyingConnectionAllowed;
to.timeBetweenEvictionRunsMillis = this.timeBetweenEvictionRunsMillis;
to.numTestsPerEvictionRun = this.numTestsPerEvictionRun;
to.minEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;
to.removeAbandoned = this.removeAbandoned;
to.removeAbandonedTimeoutMillis = this.removeAbandonedTimeoutMillis;
to.logAbandoned = this.logAbandoned;
to.maxOpenPreparedStatements = this.maxOpenPreparedStatements;
if (connectionInitSqls != null) {
to.connectionInitSqls = new ArrayList<String>(this.connectionInitSqls);
to.dbType = this.dbType;
to.timeBetweenConnectErrorMillis = this.timeBetweenConnectErrorMillis;
to.validConnectionChecker = this.validConnectionChecker;
to.connectionErrorRetryAttempts = this.connectionErrorRetryAttempts;
to.breakAfterAcquireFailure = this.breakAfterAcquireFailure;
to.transactionThresholdMillis = this.transactionThresholdMillis;
to.dupCloseLogEnable = this.dupCloseLogEnable;
to.isOracle = this.isOracle;
to.useOracleImplicitCache = this.useOracleImplicitCache;
public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable {
public DruidDataSource clone() {
DruidDataSource x = new DruidDataSource();
cloneTo(x);
return x;
public class TestClone extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUsername("xxx1");
dataSource.setPassword("ppp");
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("stat");
dataSource.setMaxOpenPreparedStatements(30);
public void test_clone() throws Exception {
Connection conn_0 = dataSource.getConnection();
Connection conn_1 = dataSource.getConnection();
Connection conn_2 = dataSource.getConnection();
DruidDataSource clone = dataSource.clone();
clone.init();
dataSource.close();
Assert.assertEquals(dataSource.getUrl(), clone.getUrl());
Assert.assertEquals(dataSource.getUsername(), clone.getUsername());
Assert.assertEquals(dataSource.getPassword(), clone.getPassword());
Assert.assertEquals(dataSource.getFilterClassNames(), clone.getFilterClassNames());
Assert.assertEquals(dataSource.getMaxOpenPreparedStatements(), clone.getMaxOpenPreparedStatements());
PreparedStatement ps_0 = conn_0.prepareStatement("select 1");
ResultSet rs = ps_0.executeQuery();
rs.next();
rs.close();
ps_0.close();
Assert.assertFalse(conn_0.isClosed());
Assert.assertFalse(conn_1.isClosed());
Assert.assertFalse(conn_2.isClosed());
MockConnection mockConn_0 = conn_0.unwrap(MockConnection.class);
MockConnection mockConn_1 = conn_1.unwrap(MockConnection.class);
MockConnection mockConn_2 = conn_2.unwrap(MockConnection.class);
Assert.assertFalse(mockConn_0.isClosed());
Assert.assertFalse(mockConn_1.isClosed());
Assert.assertFalse(mockConn_2.isClosed());
conn_0.close(); 
conn_1.close(); 
conn_2.close(); 
Assert.assertTrue(mockConn_0.isClosed());
Assert.assertTrue(mockConn_1.isClosed());
Assert.assertTrue(mockConn_2.isClosed());
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public Object clone() throws CloneNotSupportedException {
return cloneDruidDataSource();
public DruidDataSource cloneDruidDataSource() {
DruidDataSource clone = (DruidDataSource) dataSource.clone();
Connection conn_3 = dataSource.getConnection();
Connection conn_4 = dataSource.getConnection();
Connection conn_5 = dataSource.getConnection();
conn_3.close();
conn_4.close();
conn_5.close();
Connection conn_6 = dataSource.getConnection();
Connection conn_7 = dataSource.getConnection();
Connection conn_8 = dataSource.getConnection();
conn_6.close();
conn_7.close();
conn_8.close();
final AtomicLong errorCount = new AtomicLong();
errorCount.incrementAndGet();
Assert.assertEquals(0, errorCount.get());
if (conn == null) {
throw new SQLException("connect error, url " + url);
if (this.pos < filterSize) {
nextFilter().dataSource_recycle(this, connection);
if (this.pos < filterSize) {
DruidPooledConnection conn = nextFilter().dataSource_connect(this, dataSource, maxWaitMillis);
return conn;
public final static int RevisionVersion = 4;
@SuppressWarnings("resource")
if (lexer.token() == Token.HINT) {
lexer.nextToken();
continue;
public class CobarHintsTest extends TestCase {
public void test_0 () throws Exception {
String sql = "!cobar: select,4,ireport.dm_mdm_mem_prod_noeff_sdt0.admin_member_seq=45654723 select * from t";
SQLUtils.formatMySql(sql);
private DruidDataSource dataSource = new DruidDataSource();
protected void tearDown() throws Exception {
dataSource.close();
public static final String      HIVE             = "hive";
public static final String      H2               = "h2";
return H2;
private int      initialSize                = 1;
public class TestH2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:h2:mem:");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(10);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_h2() throws Exception {
Assert.assertSame(JdbcUtils.H2, dataSource.getDbType());
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT ?");
stmt.setString(1, "xxxx");
ResultSet rs = stmt.executeQuery();
rs.next();
Assert.assertEquals("xxxx", rs.getString(1));
rs.close();
stmt.close();
conn.close();
String sql = "call dbms_session.set_identifier('nfs_special_syncview')";
private static final String     DB2_DRIVER       = "COM.ibm.db2.jdbc.app.DB2Driver";
private static final String     ORACLE_DRIVER    = "oracle.jdbc.driver.OracleDriver";
private static final String     MYSQL_DRIVER     = "com.mysql.jdbc.Driver";
private static final String     H2_DRIVER        = "org.h2.Driver";
return MYSQL_DRIVER;
return ORACLE_DRIVER;
return DB2_DRIVER;
return H2_DRIVER;
public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource {
@Override
public PooledConnection getPooledConnection() throws SQLException {
return getConnection(maxWait);
@Override
public PooledConnection getPooledConnection(String user, String password) throws SQLException {
throw new UnsupportedOperationException("Not supported by DruidDataSource");
conn.setAutoCommit(false);
conn.commit();
public class MySqlFormatTest extends TestCase {
public void test_0() throws Exception {
String text = "CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));";
Assert.assertEquals("CREATE TABLE customer (n" + 
"ta INT, n" + 
"tb CHAR(20), n" + 
"tINDEX(a)n" + 
")", SQLUtils.format(text, JdbcUtils.MYSQL));
public class OracleFormatTest2 extends TestCase {
public void test_formatOracle() throws Exception {
String text = "SELECT count(*) FROM T1, (SELECT DISTINCT parent_id AS parentId FROM T2 a1 WHERE FSEQ IN (?) AND NOT order_from = ? AND status IN (?) ) b WHERE ID = b.parentId AND GMT_CREATE >= to_date(?, ?) AND GMT_CREATE <= to_date(?, ?)";
String formatedText = SQLUtils.format(text, JdbcUtils.ORACLE);
System.out.println(formatedText);
public class PGFormatTest extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE TABLE foo (fooid int, foosubid int, fooname text);";
String formatedSql = SQLUtils.format(sql, JdbcUtils.POSTGRESQL);
Assert.assertEquals("CREATE TABLE foo (n" + 
"tfooid int, n" + 
"tfoosubid int, n" + 
"tfooname textn" + 
")", formatedSql);
public class PGSelectTest1 extends PGTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM t1 CROSS JOIN t2;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public class PGSelectTest2 extends PGTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM t1 NATURAL INNER JOIN t2;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public final int COUNT                      = 1000 * 1000;
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
return MBeanServer.class;
protected void setUp() throws Exception {
super.setUp();
System.out.println();
String mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.POSTGRESQL);
System.out.println(mergedSql);
Assert.assertEquals(2, visitor.getColumns().size());
String mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.POSTGRESQL);
System.out.println(mergedSql);
public void test_2() throws Exception {
String sql = "            select    offerId ,   offerIds    from cnres.function_select_get_self_rel_offer_by_behavior      ('    350740   ')       as a(offerId numeric,offerIds character varying(4000))     ";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
Assert.assertEquals(2, visitor.getColumns().size());
String mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.POSTGRESQL);
System.out.println(mergedSql);
public void test_3() throws Exception {
String sql = "            select    memberId ,   offerIds    from cnres.function_select_get_seller_hot_offer_list('\'-1\'')    as a(memberId character varying(20),offerIds character varying(4000))     ";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
String mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.POSTGRESQL);
System.out.println(mergedSql);
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
ResultSet rs = stmt.executeQuery("SELECT 1");
rs.close();
DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
public class SpringIbatisFilterTest extends TestCase {
"com/alibaba/druid/pool/ibatis/spring-config-ibatis.xml");
DISTINCT, ALL, UNIQUE
return Option.UNIQUE.equals(this.getOption());
this.setOption(Option.UNIQUE);
OracleAggregateExpr aggregateExpr;
aggregateExpr = new OracleAggregateExpr(methodName, SQLAggregateExpr.Option.UNIQUE);
} else if (lexer.token() == (Token.ALL)) {
public void test_oracle_unique() throws Exception {
Assert.assertEquals("SELECT COUNT(UNIQUE *)nFROM t", SQLUtils.format("select count(unique *) from t", JdbcUtils.ORACLE));
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE sequence_seed");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE t_User");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE sequence_seed");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE t_User");
stmt.close();
conn.close();
public class JMXExporterTest extends TestCase {
public void test_export() throws Exception {
String file = "com/alibaba/druid/jmx/spring_stat_export.xml";
ObjectName objectName = new ObjectName("com.alibaba.druid:type=JdbcStatManager");
Assert.assertFalse(ManagementFactory.getPlatformMBeanServer().isRegistered(objectName)); 
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(file);
Assert.assertTrue(ManagementFactory.getPlatformMBeanServer().isRegistered(objectName)); 
context.close();
Assert.assertFalse(ManagementFactory.getPlatformMBeanServer().isRegistered(objectName));
+ "TO_CHAR(SUM(amount_sold), '9,999,999,999') AS SALES$n" 
ClassNotFoundException exception = null;
} catch (ClassNotFoundException e) {
exception = e;
return (Driver) Thread.currentThread().getContextClassLoader().loadClass(driverClassName).newInstance();
} catch (IllegalAccessException e) {
throw new SQLException(e.getMessage(), e);
} catch (InstantiationException e) {
throw new SQLException(e.getMessage(), e);
private List<String> getJSONDrivers() {
List<String> drivers = new ArrayList<String>();
Map<String, Object> json = new HashMap<String, Object>();
Map<String, Object> json = getJSONDataSourceStat(identity);
List<Object> sqlStatList = getJSONDataSourceSqlStat(identity);
if (identity == null || sqlStatList == null) {
returnJSONResult(req, resp, RESULT_CODE_SUCCESS, sqlStatList);
private List<Object> getJSONDataSources() {
List<Object> drivers = new ArrayList<Object>();
private Map<String, Object> getJSONDataSourceStat(Integer id) {
private List<Object> getJSONDataSourceSqlStat(Integer id) {
List<Object> array = new ArrayList<Object>();
Map<String, Object> json = new HashMap<String, Object>();
throws IOException {
out.print(JSON.toJSONString(json));
String contextPath = req.getContextPath();
String servletPath = req.getServletPath();
String requestURI = req.getRequestURI();
if (contextPath == null) { 
contextPath = "";
String path = requestURI.substring(contextPath.length() + servletPath.length());
if (path.length() == 0 || path.equals("index.html")) {
} else if (path.equals("datasource")) {
} else if (path.equals("datasource.json")) {
} else if (path.startsWith("datasource-")) {
} else if (path.equals("sql")) {
} else if (path.equals("sql.json")) {
} else if (path.startsWith("sql-")) {
if (path.startsWith("/json/basic")) {
if (path.startsWith("/json/datasource")) {
if (path.startsWith("/json/sql")) {
returnResourceFile(path, resp);
if (path.equals("/reset-all.json")) {
resetAllStat();
returnJSONResult(request, response, RESULT_CODE_SUCCESS, null);
private void resetAllStat() {
JdbcStatManager.getInstance().reset();
DruidDataSourceStatManager.getInstance().reset();
Map<String, Object> json = new LinkedHashMap<String, Object>();
for (DruidDataSource datasource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
if (System.identityHashCode(datasource) == identity) {
return datasource;
Map<String, Object> json = new LinkedHashMap<String, Object>();
Map<String, Object> json = new LinkedHashMap<String, Object>();
json.put("URL", dataSource.getUrl());
json.put("UserName", dataSource.getUsername());
Map<String, Object> json = new LinkedHashMap<String, Object>();
if (indexFrom < 0 || indexTo < 0 || indexFrom > indexTo) {
ObjectName objectName = DruidDataSourceStatManager.add(this, this.name);
this.setObjectName(objectName);
public static SchemaStatVisitor createSchemaStatVisitor(Appendable out, List<SQLStatement> statementList,
String dbType) {
if (JdbcUtils.ORACLE.equals(dbType)) {
if (statementList.size() == 1) {
return new OracleSchemaStatVisitor();
return new OracleSchemaStatVisitor();
if (JdbcUtils.MYSQL.equals(dbType)) {
return new MySqlSchemaStatVisitor();
if (JdbcUtils.POSTGRESQL.equals(dbType)) {
return new PGSchemaStatVisitor();
if (JdbcUtils.SQL_SERVER.equals(dbType)) {
return new SQLServerSchemaStatVisitor();
return new SchemaStatVisitor();
public synchronized static ObjectName add(DruidDataSource dataSource, String name) {
if (name != null) {
objectName = new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + name);
return objectName;
public class OraclePerfTest extends TestCase {
private String sql;
protected void setUp() throws Exception {
sql = "SELECT * FROM T";
public void test_pert() throws Exception {
for (int i = 0; i < 10; ++i) {
perfMySql(sql);
long perfMySql(String sql) {
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 1000; ++i) {
execMySql(sql);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("MySqlt" + millis);
return millis;
private String execMySql(String sql) {
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.println();
return out.toString();
public class MySqlPerfTest extends TestCase {
jdbcUrl = "jdbc:mysql:
user = "dragoon";
password = "dragoon";
public class StatViewServlet extends HttpServlet {
public final static int RevisionVersion = 5;
dataSourceStat = new JdbcDataSourceStat(this.name, this.jdbcUrl, this.dbType);
this.dataSourceStat = new JdbcDataSourceStat(config.getName(), config.getUrl(), dbType);
if (JdbcUtils.H2.equals(dbType)) {
return new MySqlOutputVisitor(out);
if (JdbcUtils.H2.equals(dbType)) {
return new MySqlStatementParser(sql);
private String                                              dbType;
this(name, url, null);
public JdbcDataSourceStat(String name, String url, String dbType){
this.dbType = dbType;
sqlStat.setDbType(this.dbType);
List<SQLStatement> statementList = SQLUtils.parseStatements(sqlStat.getSql(), sqlStat.getDbType());
if (JdbcUtils.H2.equals(dbType)) {
return new MySqlSchemaStatVisitor();
public static SchemaStatVisitor createSchemaStatVisitor(List<SQLStatement> statementList, String dbType) {
if (JdbcUtils.ORACLE.equals(dbType)) {
if (statementList.size() == 1) {
return new OracleSchemaStatVisitor();
return new OracleSchemaStatVisitor();
if (JdbcUtils.MYSQL.equals(dbType)) {
return new MySqlSchemaStatVisitor();
if (JdbcUtils.POSTGRESQL.equals(dbType)) {
return new PGSchemaStatVisitor();
if (JdbcUtils.SQL_SERVER.equals(dbType)) {
return new SQLServerSchemaStatVisitor();
return new SchemaStatVisitor();
SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, sqlStat.getDbType());
json.put("PoolingPeakTime",
dataSource.getPoolingPeakTime() == null ? null : dataSource.getPoolingPeakTime().toString());
json.put("ActivePeakTime",
dataSource.getActivePeakTime() == null ? null : dataSource.getActivePeakTime().toString());
returnJSONResult(request, response, RESULT_CODE_SUCCESS, getDataSourceStatList());
Object result = getDataSourceStatData(id);
returnJSONResult(request, response, RESULT_CODE_SUCCESS, getSqlStatDataList());
Object result = getSqlStatData(id);
content.append("<h2>FULL SQL</h2> <h4>" + sqlStat.getSql() + "</h4>");
content.append("</textarea><br />");
content.append("<br />");
content.append("<br />");
content.append("List<SQLStatement> statementList = SQLUtils.parseStatements(sqlStat.getSql(), sqlStat.getDbType())<br />");
content.append("SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, sqlStat.getDbType());<br />");
content.append("statemen.accept(visitor);<br />");
content.append("visitor.getTables() / visitor.getColumns() / visitor.getOrderByColumns() / visitor.getConditions() / visitor.getRelationships()<br />");
content.append("<br />");
private List<String> getDriversData() {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Version", VERSION.getVersionNumber());
dataMap.put("Drivers", getDriversData());
returnJSONResult(request, response, RESULT_CODE_SUCCESS, dataMap);
private List<Object> getDataSourceStatList() {
datasourceList.add(dataSourceToMapData(dataSource));
private Map<String, Object> getDataSourceStatData(Integer id) {
return datasource == null ? null : dataSourceToMapData(datasource);
private Map<String, Object> getSqlStatData(Integer id) {
return sqlStat == null ? null : getSqlStatData(sqlStat);
private Map<String, Object> getSqlStatData(JdbcSqlStat sqlStat) {
return sqlStat.getData();
} catch (JMException e) {
return null;
private List<Object> getSqlStatDataList() {
array.add(getSqlStatData(sqlStat));
private Map<String, Object> dataSourceToMapData(DruidDataSource dataSource) {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Identity", System.identityHashCode(dataSource));
dataMap.put("Name", dataSource.getName());
dataMap.put("DbType", dataSource.getDbType());
dataMap.put("DriverClassName", dataSource.getDriverClassName());
dataMap.put("URL", dataSource.getUrl());
dataMap.put("UserName", dataSource.getUsername());
dataMap.put("FilterClassNames", dataSource.getFilterClassNames());
dataMap.put("WaitThreadCount", dataSource.getWaitThreadCount());
dataMap.put("NotEmptyWaitCount", dataSource.getNotEmptyWaitCount());
dataMap.put("NotEmptyWaitMillis", dataSource.getNotEmptyWaitMillis());
dataMap.put("PoolingCount", dataSource.getPoolingCount());
dataMap.put("PoolingPeak", dataSource.getPoolingPeak());
dataMap.put("PoolingPeakTime",
dataSource.getPoolingPeakTime() == null ? null : dataSource.getPoolingPeakTime().toString());
dataMap.put("ActiveCount", dataSource.getActiveCount());
dataMap.put("ActivePeak", dataSource.getActivePeak());
dataMap.put("ActivePeakTime",
dataSource.getActivePeakTime() == null ? null : dataSource.getActivePeakTime().toString());
dataMap.put("InitialSize", dataSource.getInitialSize());
dataMap.put("MinIdle", dataSource.getMinIdle());
dataMap.put("MaxActive", dataSource.getMaxActive());
dataMap.put("TestOnBorrow", dataSource.isTestOnBorrow());
dataMap.put("TestWhileIdle", dataSource.isTestWhileIdle());
dataMap.put("LogicConnectCount", dataSource.getConnectCount());
dataMap.put("LogicCloseCount", dataSource.getCloseCount());
dataMap.put("LogicConnectErrorCount", dataSource.getConnectErrorCount());
dataMap.put("PhysicalConnectCount", dataSource.getCreateCount());
dataMap.put("PhysicalCloseCount", dataSource.getDestroyCount());
dataMap.put("PhysicalConnectErrorCount", dataSource.getCreateErrorCount());
dataMap.put("PSCacheAccessCount", dataSource.getCachedPreparedStatementAccessCount());
dataMap.put("PSCacheHitCount", dataSource.getCachedPreparedStatementHitCount());
dataMap.put("PSCacheMissCount", dataSource.getCachedPreparedStatementMissCount());
dataMap.put("StartTransactionCount", dataSource.getStartTransactionCount());
dataMap.put("TransactionHistogramValues", dataSource.getTransactionHistogramValues());
return dataMap;
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("ResultCode", resultCode);
dataMap.put("Content", content);
out.print(JSON.toJSONString(dataMap));
if (fileName.endsWith(".css")) {
response.setContentType("text/css;charset=utf-8");
} else if (fileName.endsWith(".js")) {
response.setContentType("text/javascript;charset=utf-8");
private final static int    DEFAULT_PAGE                = 1;
private final static int    DEFAULT_PER_PAGE_COUNT      = Integer.MAX_VALUE;
private static final String DEFAULT_ORDER_TYPE          = "asc";
returnJSONResult(request, response, RESULT_CODE_SUCCESS, getSqlStatDataList(request));
private List<Map<String, Object>> getSqlStatDataList(HttpServletRequest request) {
String orderBy = request.getParameter("orderBy");
String orderType = request.getParameter("orderType");
Integer page = StringUtils.stringToInteger(request.getParameter("page"));
Integer perPageCount = StringUtils.stringToInteger(request.getParameter("perPageCount"));
if (!"desc".equals(orderType)) orderType = DEFAULT_ORDER_TYPE;
if (page == null) page = DEFAULT_PAGE;
if (perPageCount == null) perPageCount = DEFAULT_PER_PAGE_COUNT;
List<Map<String, Object>> array = new ArrayList<Map<String, Object>>();
SortUtils.sortMapList(orderBy, array, DEFAULT_ORDER_TYPE.equals(orderType));
int fromIndex = (page - 1) * perPageCount;
int toIndex = page * perPageCount;
if (toIndex > array.size()) toIndex = array.size();
return array.subList(fromIndex, toIndex);
public class SortUtils {
public static void sortMapList(final String orderByKey, List<Map<String, Object>> targetList, final boolean isDesc) {
if (orderByKey == null || orderByKey.length() == 0) return;
Collections.sort(targetList, new Comparator<Map<String, Object>>() {
private int compare(Number o1, Number o2) {
return (int) (o1.doubleValue() - o2.doubleValue());
private int compare(String o1, String o2) {
return Collator.getInstance().compare(o1, o2);
private int compare(Date o1, Date o2) {
return (int) (o1.getTime() - o2.getTime());
public int compare(Map<String, Object> o1, Map<String, Object> o2) {
int result = compare_0(o1, o2);
if (isDesc) result = -result;
return result;
public int compare_0(Map<String, Object> o1, Map<String, Object> o2) {
Object v1 = o1.get(orderByKey);
Object v2 = o2.get(orderByKey);
if (v1 == null && v2 == null) return 0;
if (v1 == null) return -1;
if (v2 == null) return 1;
if (v1 instanceof Number) return compare((Number) v1, (Number) v2);
if (v1 instanceof String) return compare((String) v1, (String) v2);
if (v1 instanceof Date) return compare((Date) v1, (Date) v2);
private final AtomicLong        connectErrorCount       = new AtomicLong();
private long                    discardCount            = 0;
public long getDiscardCount() {
} catch (SQLException e) {
LOG.error("dataSource init error", e);
long getDiscardCount();
public List<Map<String, Object>> getPoolingConnectionInfo() {
List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
lock.lock();
for (int i = 0; i < poolingCount; ++i) {
ConnectionHolder connHolder = connections[i];
Connection conn = connHolder.getConnection();
Map<String, Object> map = new LinkedHashMap<String, Object>();
map.put("id", System.identityHashCode(conn));
map.put("useCount", connHolder.getUseCount());
if (connHolder.getLastActiveTimeMillis() > 0) {
map.put("lastActiveTime", new Date(connHolder.getLastActiveTimeMillis()));
map.put("connectTime", new Date(connHolder.getTimeMillis()));
map.put("holdability", connHolder.getUnderlyingHoldability());
map.put("transactionIsolation", connHolder.getUnderlyingTransactionIsolation());
map.put("autoCommit", connHolder.isUnderlyingAutoCommit());
map.put("readoOnly", connHolder.isUnderlyingReadOnly());
if (connHolder.isPoolPreparedStatements()) {
List<Map<String, Object>> stmtCache = new ArrayList<Map<String, Object>>();
PreparedStatementPool stmtPool = connHolder.getStatementPool();
for (PreparedStatementHolder stmtHolder : stmtPool.getMap().values()) {
Map<String, Object> stmtInfo = new LinkedHashMap<String, Object>();
stmtInfo.put("sql", stmtHolder.getKey().getSql());
stmtInfo.put("defaultRowPretch", stmtHolder.getDefaultRowPretch());
stmtInfo.put("rowPrefetch", stmtHolder.getRowPrefetch());
stmtInfo.put("hitCount", stmtHolder.getHitCount());
stmtCache.add(stmtInfo);
map.put("pscache", stmtCache);
list.add(map);
} finally {
lock.unlock();
return list;
public class DBCPTest extends TestCase {
public void test_max() throws Exception {
Class.forName("com.alibaba.druid.mock.MockDriver");
final BasicDataSource dataSource = new BasicDataSource();
dataSource.setInitialSize(3);
dataSource.setMaxActive(20);
dataSource.setMaxIdle(20);
dataSource.setDriverClassName("com.alibaba.druid.mock.MockDriver");
dataSource.setUrl("jdbc:mock:xxx");
final int THREAD_COUNT = 200;
final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);
final CountDownLatch startLatch = new CountDownLatch(1);
Thread[] threads = new Thread[THREAD_COUNT];
for (int i = 0; i < THREAD_COUNT; ++i) {
threads[i] = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < 1000; ++i) {
Connection conn = dataSource.getConnection();
Thread.sleep(1);
conn.close();
} catch (Exception e) {
} finally {
endLatch.countDown();
threads[i].start();
startLatch.countDown();
endLatch.await();
System.out.println(MockDriver.instance.getConnections().size());
System.out.println(MockDriver.instance.getConnectionCloseCount());
private final static Log                                                                    LOG                                       = LogFactory.getLog(DruidAbstractDataSource.class);
protected final Date                                                                        createdTime                               = new Date();
protected Date                                                                              initedTime;
protected final ReentrantLock                                                               lock                                      = new ReentrantLock(
LOG.error("load validConnectionCheckerClass error : " + validConnectionCheckerClass);
LOG.error("load passwordCallback error : " + passwordCallbackClassName);
LOG.error("load exceptionSorter error : " + exceptionSorter);
this.exceptionSorter = (ExceptionSorter) clazz.newInstance();
initedTime = new Date();
private boolean                                                                             dupCloseLogEnable                         = false;
final long nanos = unit.toNanos(timeout);
long estimate = nanos;
throw new GetConnectionTimeoutException("loopWaitCount " + i + ", wait millis " + (nanos - estimate)/(1000 * 1000));
if (holder == null) {
if (dupCloseLogEnable) {
LOG.error("dup close");
if (path.startsWith("/connectionInfo-")) {
Integer id = StringUtils.subStringToInteger(path, "connectionInfo-", ".");
DruidDataSource datasource = getDruidDataSourceById(id);
if (path.endsWith(".json")) {
if (datasource == null) returnJSONResult(request, response, RESULT_CODE_ERROR, null);
else returnJSONResult(request, response, RESULT_CODE_SUCCESS, datasource.getPoolingConnectionInfo());
if (path.endsWith(".html")) {
returnViewConnectionInfo(datasource, request, response);
private void returnViewConnectionInfo(DruidDataSource datasource, HttpServletRequest request,
HttpServletResponse response) throws IOException {
if (datasource == null) return;
String text = IOUtils.readFromResource(RESOURCE_PATH + "/connectionInfo.html");
text = text.replaceAll("\{datasourceId\}", String.valueOf(System.identityHashCode(datasource)));
response.getWriter().print(text);
dataMap.put("ConnectionHoldHistogram", dataSource.getDataSourceStat().getConnectionHoldHistogram().toArray());
dataMap.put("TransactionHistogram", dataSource.getTransactionHistogramValues());
dataMap.put("ConnectionHoldTimeHistogram", dataSource.getDataSourceStat().getConnectionHoldHistogram().toArray());
Class implClass = Resources.classForName("com.alibaba.druid.support.logging.Log4jImpl");
Class implClass = Resources.classForName("com.alibaba.druid.support.logging.Jdk14LoggingImpl");
InputStreamReader reader;
reader = new InputStreamReader(in, "UTF-8");
} catch (UnsupportedEncodingException e) {
throw new IllegalStateException(e.getMessage(), e);
public final static int RevisionVersion = 6;
public String getExceptionSorterClassName() {
if (exceptionSorter == null) {
return null;
return exceptionSorter.getClass().getName();
String getExceptionSorterClassName();
dataMap.put("QueryTimeout", dataSource.getQueryTimeout());
dataMap.put("ValidConnectionCheckerClassName", dataSource.getValidConnectionCheckerClassName());
dataMap.put("ExceptionSorterClassName", dataSource.getExceptionSorterClassName());
dataMap.put("TestOnReturn", dataSource.isTestOnReturn());
dataMap.put("DefaultAutoCommit", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultReadOnly", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultTransactionIsolation", dataSource.getDefaultTransactionIsolation());
dataMap.put("ConnectionHoldTimeHistogram",
dataSource.getDataSourceStat().getConnectionHoldHistogram().toArray());
dataMap.put("TransactionQueryTimeout", dataSource.getTransactionQueryTimeout());
dataMap.put("LoginTimeout", dataSource.getLoginTimeout());
dataMap.put("ExecuteCount", dataSource.getExecuteCount());
dataMap.put("CommitCount", dataSource.getCommitCount());
dataMap.put("RollbackCount", dataSource.getRollbackCount());
dataMap.put("ErrorCount", dataSource.getErrorCount());
if (lexer.token() == Token.LBRACE || identifierEquals("CALL")) {
this(new SQLExprParser(sql));
if (lexer.token() == Token.LBRACE || identifierEquals("CALL")) {
boolean brace = false;
if (lexer.token() == Token.LBRACE) {
lexer.nextToken();
brace = true;
if (brace) {
accept(Token.RBRACE);
public class MergeTest extends TestCase {
public void test_mergeCall() throws Exception {
String sql = "{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}";
ParameterizedOutputVisitorUtils.parameterize(sql, null);
public void test_mergeCall_oracle() throws Exception {
String sql = "{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}";
ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.ORACLE);
public void test_mergeCall_mysql() throws Exception {
String sql = "{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}";
ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.MYSQL);
public class DruidStatService {
private ScheduledExecutorService scheduler;
private ScheduledFuture<?>       collectPlan;
private int                      collectPeriodSeconds = 60 * 5;
private DruidStatStore           store;
public synchronized void start() {
if (store != null) {
store = new DruidStatMemoryStore();
scheduler = Executors.newSingleThreadScheduledExecutor();
collectPlan = scheduler.scheduleAtFixedRate(new CollectTask(), collectPeriodSeconds, collectPeriodSeconds,
TimeUnit.SECONDS);
public synchronized void stop() {
if (collectPlan == null) {
collectPlan.cancel(true);
if (scheduler != null) {
scheduler.shutdown();
public void collect() {
final long timeMillis = System.currentTimeMillis();
List<DataSourceInfo> dataSourceStatList = new ArrayList<DataSourceInfo>();
for (DruidDataSource dataSource : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
DataSourceInfo dataSourceStat = new DataSourceInfo();
dataSourceStat.setUrl(dataSource.getUrl());
dataSourceStat.setDbType(dataSource.getDbType());
dataSourceStatList.add(dataSourceStat);
Collection<JdbcSqlStat> sqlStats = dataSource.getDataSourceStat().getSqlStatMap().values();
List<SqlInfo> sqlStatInfoList = new ArrayList<SqlInfo>(sqlStats.size());
for (JdbcSqlStat sqlStat : dataSource.getDataSourceStat().getSqlStatMap().values()) {
SqlInfo sqlStatInfo = new SqlInfo();
sqlStatInfo.setSql(sqlStat.getSql());
sqlStatInfoList.add(sqlStatInfo);
store.saveDataSource(timeMillis, dataSourceStatList);
private final class CollectTask implements Runnable {
public void run() {
collect();
public interface DruidStatStore {
void saveSql(long timeMillis, List<SqlInfo> sqlList);
void saveDataSource(long timeMillis, List<DataSourceInfo> dataSourceList);
public class DataSourceInfo {
private String        url;
private String        dbType;
private List<SqlInfo> sqlList;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public String getUrl() {
return url;
public void setUrl(String url) {
this.url = url;
public List<SqlInfo> getSqlList() {
return sqlList;
public void setSqlList(List<SqlInfo> sqlList) {
this.sqlList = sqlList;
public class SqlInfo {
private String sql;
private int    executeCount;
private int    runningCount;
private int    concurrentMax;
private int    executeErrorCount;
private int    inTransactionCount;
private long   fetchRowCount;
private long   updateCount;
public SqlInfo(){
public String getSql() {
return sql;
public void setSql(String sql) {
this.sql = sql;
public int getExecuteCount() {
return executeCount;
public void setExecuteCount(int executeCount) {
this.executeCount = executeCount;
public int getRunningCount() {
return runningCount;
public void setRunningCount(int runningCount) {
this.runningCount = runningCount;
public int getConcurrentMax() {
return concurrentMax;
public void setConcurrentMax(int concurrentMax) {
this.concurrentMax = concurrentMax;
public int getExecuteErrorCount() {
return executeErrorCount;
public void setExecuteErrorCount(int executeErrorCount) {
this.executeErrorCount = executeErrorCount;
public int getInTransactionCount() {
return inTransactionCount;
public void setInTransactionCount(int inTransactionCount) {
this.inTransactionCount = inTransactionCount;
public long getFetchRowCount() {
return fetchRowCount;
public void setFetchRowCount(long fetchRowCount) {
this.fetchRowCount = fetchRowCount;
public long getUpdateCount() {
return updateCount;
public void setUpdateCount(long updateCount) {
this.updateCount = updateCount;
public class DruidStatMemoryStore implements DruidStatStore {
public void saveSql(long timeMillis, List<SqlInfo> sqlList) {
public void saveDataSource(long timeMillis, List<DataSourceInfo> dataSourceList) {
private boolean             callAllow                  = true;
public boolean isCallAllow() {
return callAllow;
public void setCallAllow(boolean callAllow) {
this.callAllow = callAllow;
} else if (x instanceof SQLCallStatement) {
} else if (x instanceof SQLCallStatement) {
} else if (x instanceof SQLCallStatement) {
public class WallCallTest extends TestCase {
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql("{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}"));
public void testOracle() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle("{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}"));
public void testSqlServer() throws Exception {
Assert.assertTrue(WallUtils.isValidateSqlServer("{ call INTERFACE_DATA_EXTRACTION.INVOICE_INFO(?,?,?)}"));
if (sqlStat.getExecuteCount() == 0 && sqlStat.getRunningCount() == 0) {
sqlStatInfo.setExecuteCount((int) sqlStat.getExecuteCount());
sqlStatInfo.setRunningCount((int) sqlStat.getRunningCount());
sqlStatInfo.setConcurrentMax((int) sqlStat.getConcurrentMax());
sqlStatInfo.setErrorCount((int) sqlStat.getErrorCount());
sqlStatInfo.setInTransactionCount((int) sqlStat.getInTransactionCount());
sqlStatInfo.setFetchRowCount(sqlStat.getFetchRowCount());
sqlStatInfo.setUpdateCount(sqlStat.getUpdateCount());
dataSourceStat.setSqlList(sqlStatInfoList);
dataSourceStatList.add(dataSourceStat);
private int    errorCount;
public int getErrorCount() {
return errorCount;
public void setErrorCount(int errorCount) {
this.errorCount = errorCount;
dataSourceStat.setId(dataSource.getID());
dataSourceStat.setActiveCount(dataSource.getActiveCount());
dataSourceStat.setActivePeak(dataSource.getActivePeak());
dataSourceStat.setCloseCount((int) dataSource.getCloseCount());
dataSourceStat.setConnectCount((int) dataSource.getConnectCount());
dataSourceStat.setConnectErrorCount((int) dataSource.getConnectErrorCount());
dataSourceStat.setCreateCount((int) dataSource.getCreateCount());
dataSourceStat.setCreateErrorCount((int) dataSource.getCreateErrorCount());
dataSourceStat.setDestoryCount((int) dataSource.getDestroyCount());
dataSourceStat.setExecuteCount((int) dataSource.getExecuteCount());
dataSourceStat.setPoolingCount(dataSource.getPoolingCount());
private long          id;
private int           activeCount;
private int           activePeak;
private int           poolingCount;
private int           connectCount;
private int           connectErrorCount;
private int           createCount;
private int           createErrorCount;
private int           executeCount;
private int           closeCount;
private int           destoryCount;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public int getActiveCount() {
return activeCount;
public void setActiveCount(int activeCount) {
this.activeCount = activeCount;
public int getActivePeak() {
return activePeak;
public void setActivePeak(int activePeak) {
this.activePeak = activePeak;
public int getPoolingCount() {
return poolingCount;
public void setPoolingCount(int poolingCount) {
this.poolingCount = poolingCount;
public int getConnectCount() {
return connectCount;
public void setConnectCount(int connectCount) {
this.connectCount = connectCount;
public int getConnectErrorCount() {
return connectErrorCount;
public void setConnectErrorCount(int connectErrorCount) {
this.connectErrorCount = connectErrorCount;
public int getCreateCount() {
return createCount;
public void setCreateCount(int createCount) {
this.createCount = createCount;
public int getCreateErrorCount() {
return createErrorCount;
public void setCreateErrorCount(int createErrorCount) {
this.createErrorCount = createErrorCount;
public int getExecuteCount() {
return executeCount;
public void setExecuteCount(int executeCount) {
this.executeCount = executeCount;
public int getCloseCount() {
return closeCount;
public void setCloseCount(int closeCount) {
this.closeCount = closeCount;
public int getDestoryCount() {
return destoryCount;
public void setDestoryCount(int destoryCount) {
this.destoryCount = destoryCount;
private ConcurrentHashMap<Long, DataSourceData> dataSourceDataMap = new ConcurrentHashMap<Long, DataSourceData>();
for (DataSourceInfo dataSourceInfo : dataSourceList) {
DataSourceData data = dataSourceDataMap.get(dataSourceInfo.getId());
if (data == null) {
dataSourceDataMap.putIfAbsent(dataSourceInfo.getId(), new DataSourceData());
data = dataSourceDataMap.get(dataSourceInfo.getId());
data.add(timeMillis, dataSourceInfo);
public static class DataSourceData {
private ConcurrentSkipListMap<Long, DataSourceInfo> data = new ConcurrentSkipListMap<Long, DataSourceInfo>();
public void add(long timeMillis, DataSourceInfo dataSourceInfo) {
data.put(timeMillis, dataSourceInfo);
Map<String, SqlInfo> sqlStatInfoMap = new HashMap<String, SqlInfo>(sqlStats.size());
SqlInfo sqlStatInfo = DruidStatServiceUtils.createSqlInfo(sqlStat);
SqlInfo oldsqlStatInfo = sqlStatInfoMap.get(sqlStatInfo.getSql());
if (oldsqlStatInfo != null) {
oldsqlStatInfo.merge(sqlStatInfo);
sqlStatInfoMap.put(sqlStatInfo.getSql(), sqlStatInfo);
dataSourceStat.setSqlList(new ArrayList<SqlInfo>(sqlStatInfoMap.values()));
public class DruidStatServiceUtils {
private final static Log LOG = LogFactory.getLog(DruidStatServiceUtils.class);
public static SqlInfo createSqlInfo(JdbcSqlStat sqlStat) {
SqlInfo info = new SqlInfo();
String sql = sqlStat.getSql();
sql = ParameterizedOutputVisitorUtils.parameterize(sql, sqlStat.getDbType());
} catch (Exception e) {
LOG.error("merge sql error", e);
info.setSql(sql);
info.setExecuteCount((int) sqlStat.getExecuteCount());
info.setRunningCount((int) sqlStat.getRunningCount());
info.setConcurrentMax((int) sqlStat.getConcurrentMax());
info.setErrorCount((int) sqlStat.getErrorCount());
info.setInTransactionCount((int) sqlStat.getInTransactionCount());
info.setFetchRowCount(sqlStat.getFetchRowCount());
info.setUpdateCount(sqlStat.getUpdateCount());
info.setResultSetHoldTimeMilis(sqlStat.getResultSetHoldTimeMilis());
info.setHisogram(sqlStat.getHistogram().toArray());
info.setExecuteAndResultHoldTimeHistogram(sqlStat.getExecuteAndResultHoldTimeHistogram().toArray());
info.setFetchRowCountHistogram(sqlStat.getFetchRowCountHistogram().toArray());
info.setUpdateCountHistogram(sqlStat.getUpdateCountHistogram().toArray());
return info;
private long   resultSetHoldTimeMilis;
private int    histogram_0;
private int    histogram_1;
private int    histogram_2;
private int    histogram_3;
private int    histogram_4;
private int    histogram_5;
private int    histogram_6;
private int    histogram_7;
private int    executeAndResultHoldTimeHistogram_0;
private int    executeAndResultHoldTimeHistogram_1;
private int    executeAndResultHoldTimeHistogram_2;
private int    executeAndResultHoldTimeHistogram_3;
private int    executeAndResultHoldTimeHistogram_4;
private int    executeAndResultHoldTimeHistogram_5;
private int    executeAndResultHoldTimeHistogram_6;
private int    executeAndResultHoldTimeHistogram_7;
private int    updateCountHistogram_0;
private int    updateCountHistogram_1;
private int    updateCountHistogram_2;
private int    updateCountHistogram_3;
private int    updateCountHistogram_4;
private int    updateCountHistogram_5;
private int    fetchRowCountHistogram_0;
private int    fetchRowCountHistogram_1;
private int    fetchRowCountHistogram_2;
private int    fetchRowCountHistogram_3;
private int    fetchRowCountHistogram_4;
private int    fetchRowCountHistogram_5;
public void setExecuteAndResultHoldTimeHistogram(long[] values) {
executeAndResultHoldTimeHistogram_0 = (int) values[0];
executeAndResultHoldTimeHistogram_1 = (int) values[1];
executeAndResultHoldTimeHistogram_2 = (int) values[2];
executeAndResultHoldTimeHistogram_3 = (int) values[3];
executeAndResultHoldTimeHistogram_4 = (int) values[4];
executeAndResultHoldTimeHistogram_5 = (int) values[5];
executeAndResultHoldTimeHistogram_6 = (int) values[6];
executeAndResultHoldTimeHistogram_7 = (int) values[7];
public int[] getExecuteAndResultHoldTimeHistogram() {
return new int[] { executeAndResultHoldTimeHistogram_0, 
executeAndResultHoldTimeHistogram_1, 
executeAndResultHoldTimeHistogram_2, 
executeAndResultHoldTimeHistogram_3, 
executeAndResultHoldTimeHistogram_4, 
executeAndResultHoldTimeHistogram_5, 
executeAndResultHoldTimeHistogram_6, 
executeAndResultHoldTimeHistogram_7, 
public void setFetchRowCountHistogram(long[] values) {
fetchRowCountHistogram_0 = (int) values[0];
fetchRowCountHistogram_1 = (int) values[1];
fetchRowCountHistogram_2 = (int) values[2];
fetchRowCountHistogram_3 = (int) values[3];
fetchRowCountHistogram_4 = (int) values[4];
fetchRowCountHistogram_5 = (int) values[5];
public int[] getFetchRowCountHistogram() {
return new int[] { fetchRowCountHistogram_0, 
fetchRowCountHistogram_1, 
fetchRowCountHistogram_2, 
fetchRowCountHistogram_3, 
fetchRowCountHistogram_4, 
fetchRowCountHistogram_5, 
public void setUpdateCountHistogram(long[] values) {
updateCountHistogram_0 = (int) values[0];
updateCountHistogram_1 = (int) values[1];
updateCountHistogram_2 = (int) values[2];
updateCountHistogram_3 = (int) values[3];
updateCountHistogram_4 = (int) values[4];
updateCountHistogram_5 = (int) values[5];
public int[] getUpdateCountHistogram() {
return new int[] { updateCountHistogram_0, 
updateCountHistogram_1, 
updateCountHistogram_2, 
updateCountHistogram_3, 
updateCountHistogram_4, 
updateCountHistogram_5, 
public void setHisogram(long[] values) {
histogram_0 = (int) values[0];
histogram_1 = (int) values[1];
histogram_2 = (int) values[2];
histogram_3 = (int) values[3];
histogram_4 = (int) values[4];
histogram_5 = (int) values[5];
histogram_6 = (int) values[6];
histogram_7 = (int) values[7];
public int[] getHistogram() {
return new int[] { histogram_0, 
histogram_1, 
histogram_2, 
histogram_3, 
histogram_4, 
histogram_5, 
histogram_6, 
histogram_7, 
public long getResultSetHoldTimeMilis() {
return resultSetHoldTimeMilis;
public void setResultSetHoldTimeMilis(long resultSetHoldTimeMilis) {
this.resultSetHoldTimeMilis = resultSetHoldTimeMilis;
public void merge(SqlInfo sqlInfo) {
public class SqlInfoTest extends TestCase {
public void test_0 () throws Exception {
JdbcSqlStat sqlStat = new JdbcSqlStat("select 1");
DruidStatServiceUtils.createSqlInfo(sqlStat);
private int[]  histogram;
private int[]  executeAndResultHoldTimeHistogram;
private int[]  updateCountHistogram;
private int[]  fetchRowCountHistogram;
executeAndResultHoldTimeHistogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
executeAndResultHoldTimeHistogram[i] = (int) values[i];
return executeAndResultHoldTimeHistogram;
fetchRowCountHistogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
fetchRowCountHistogram[i] = (int) values[i];
return fetchRowCountHistogram;
updateCountHistogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
updateCountHistogram[i] = (int) values[i];
return updateCountHistogram;
histogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
histogram[i] = (int) values[i];
return histogram;
public void merge(SqlInfo o) {
executeCount += o.executeCount;
runningCount += o.runningCount;
if (o.concurrentMax > concurrentMax) {
concurrentMax = o.concurrentMax;
errorCount += o.errorCount;
inTransactionCount += o.inTransactionCount;
fetchRowCount += o.fetchRowCount;
updateCount += o.updateCount;
resultSetHoldTimeMilis += o.resultSetHoldTimeMilis;
for (int i = 0; i < histogram.length; ++i) {
this.histogram[i] += o.histogram[i];
for (int i = 0; i < executeAndResultHoldTimeHistogram.length; ++i) {
this.executeAndResultHoldTimeHistogram[i] += o.executeAndResultHoldTimeHistogram[i];
for (int i = 0; i < updateCountHistogram.length; ++i) {
this.updateCountHistogram[i] += o.updateCountHistogram[i];
for (int i = 0; i < fetchRowCountHistogram.length; ++i) {
this.fetchRowCountHistogram[i] += o.fetchRowCountHistogram[i];
public void test_0() throws Exception {
sqlStat.incrementRunningCount();
sqlStat.incrementExecuteSuccessCount();
SqlInfo info = DruidStatServiceUtils.createSqlInfo(sqlStat);
Assert.assertEquals(1, info.getRunningCount());
Assert.assertEquals(1, info.getExecuteCount());
JdbcSqlStat sqlStat1 = new JdbcSqlStat("select 2");
sqlStat1.incrementRunningCount();
sqlStat1.incrementExecuteSuccessCount();
SqlInfo info1 = DruidStatServiceUtils.createSqlInfo(sqlStat);
info.merge(info1);
Assert.assertEquals(2, info.getRunningCount());
Assert.assertEquals(2, info.getExecuteCount());
public int getCollectPeriodSeconds() {
return collectPeriodSeconds;
public void setCollectPeriodSeconds(int collectPeriodSeconds) {
this.collectPeriodSeconds = collectPeriodSeconds;
dataSourceStat.setCollectTimeMillis(System.currentTimeMillis());
dataSourceStat.setConnectionHoldHistogram(dataSource.getDataSourceStat().getConnectionHistogramValues());
dataSourceStat.setTransactionHistogram(dataSource.getTransactionHistogramValues());
store.saveDataSource(dataSourceStatList);
void saveDataSource(List<DataSourceInfo> dataSourceList);
private long          collectTimeMillis;
private int[]         transactionHistogram;
private int[]         connectionHoldHistogram;
public int[] getTransactionHistogram() {
return transactionHistogram;
public void setTransactionHistogram(long[] values) {
this.transactionHistogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
transactionHistogram[i] = (int) values[i];
public void setTransactionHistogram(int[] values) {
this.transactionHistogram = values;
public int[] getConnectionHoldHistogram() {
return connectionHoldHistogram;
public void setConnectionHoldHistogram(int[] values) {
this.connectionHoldHistogram = values;
public void setConnectionHoldHistogram(long[] values) {
this.connectionHoldHistogram = new int[values.length];
for (int i = 0; i < values.length; ++i) {
connectionHoldHistogram[i] = (int) values[i];
public long getCollectTimeMillis() {
return collectTimeMillis;
public void setCollectTimeMillis(long collectTimeMillis) {
this.collectTimeMillis = collectTimeMillis;
public void saveDataSource(List<DataSourceInfo> dataSourceList) {
dataSourceDataMap.putIfAbsent(dataSourceInfo.getId(), new DataSourceData(dataSourceInfo.getId(),
dataSourceInfo.getUrl(),
dataSourceInfo.getDbType()));
data.add(dataSourceInfo);
public Collection<DataSourceInfo> scan(long dataSourceId, Long startTimeMillis, Long endTimeMillis) {
DataSourceData data = dataSourceDataMap.get(dataSourceId);
if (data == null) {
return Collections.emptyList();
return data.scan(startTimeMillis, endTimeMillis);
private final Long                                  id;
private final String                                url;
private final String                                dbType;
public DataSourceData(Long id, String url, String dbType){
this.id = id;
this.url = url;
this.dbType = dbType;
public Long getId() {
return id;
public String getUrl() {
return url;
public String getDbType() {
return dbType;
public void add(DataSourceInfo dataSourceInfo) {
data.put(dataSourceInfo.getCollectTimeMillis(), dataSourceInfo);
public Collection<DataSourceInfo> scan(Long startTimeMillis, Long endTimeMillis) {
if (data.size() == 0) {
return Collections.emptyList();
if (startTimeMillis == null) {
startTimeMillis = data.keySet().iterator().next();
if (endTimeMillis == null) {
endTimeMillis = data.descendingKeySet().iterator().next();
return data.subMap(startTimeMillis, endTimeMillis).values();
stat.reset();
if (stat.getExecuteCount() == 0 && stat.getRunningCount() == 0) {
iter.remove();
stat.reset();
public final static String        ATTR_NAME_CONNECTION_STAT  = "stat.conn";
public final static String        ATTR_NAME_STATEMENT_STAT   = "stat.stmt";
if (connection.getCloseCount() == 0) {
long nowNano = System.nanoTime();
dataSourceStat.getConnectionStat().incrementConnectionCloseCount();
JdbcConnectionStat.Entry connectionInfo = getConnectionInfo(connection);
long aliveNanoSpan = nowNano - connectionInfo.getEstablishNano();
JdbcConnectionStat.Entry existsConnection = dataSourceStat.getConnections().remove(connection.getId());
if (existsConnection != null) {
dataSourceStat.getConnectionStat().afterClose(aliveNanoSpan);
private int                   closeCount       = 0;
if (closeCount > 0) {
closeCount++;
this.closeCount++;
return closeCount > 0;
@Override
public int getCloseCount() {
return closeCount;
int getCloseCount();
private int                   closeCount;
closeCount++;
@Override
public int getCloseCount() {
return closeCount;
final ConnectionHolder holder = this.holder;
if (holder != null && holder.getDataSource().isRemoveAbandoned()) {
holder.setLastActiveTimeMillis(System.currentTimeMillis());
boolean isRunning() {
final ConnectionHolder holder = this.holder;
if (holder != null && holder.getDataSource().isRemoveAbandoned()) {
running = true;
running = false;
Histogram histogram = sqlStat.getExecuteAndResultHoldTimeHistogram();
Assert.assertEquals(0, histogram.getValue(0) + histogram.getValue(1) + histogram.getValue(2));
sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Histogram histogram = sqlStat.getExecuteAndResultHoldTimeHistogram();
Assert.assertEquals(1, histogram.getValue(0) + histogram.getValue(1) + histogram.getValue(2));
if (sqlStat == null || sqlStat.isRemoved()) {
if (sqlStat == null || sqlStat.isRemoved()) {
public class ConfigErrorTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_connect() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
internalAfterStatementExecute(statement, false, updateCount);
internalAfterStatementExecute(statement, true);
protected void statementExecuteAfter(StatementProxy statement, String sql, boolean firstResult) {
internalAfterStatementExecute(statement, firstResult);
internalAfterStatementExecute(statement, false, result);
private final void internalAfterStatementExecute(StatementProxy statement, boolean firstResult, int... updateCountArray) {
sqlStat.addExecuteTime(statement.getLastExecuteType(), firstResult, nanoSpan);
sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanoSpan);
public ResultSet executeQuery(MockStatementBase stmt, String sql) throws SQLException {
MockConnection conn = stmt.getConnection();
public class MockPreparedStatement extends PreparedStatementBase implements MockStatementBase, PreparedStatement {
public class MockStatement extends StatementBase implements MockStatementBase, Statement {
public MockConnection getConnection() {
ResultSet executeQuery(MockStatementBase statement, String sql) throws SQLException;
public ResultSet executeQuery(MockStatementBase statement, String sql) throws SQLException {
public ResultSet executeQuery(MockStatementBase statement, SQLSelectQueryBlock query) throws SQLException {
public ResultSet showStatus(MockStatementBase statement) throws SQLException {
public ResultSet executeQueryFromDual(MockStatementBase statement, SQLSelectQueryBlock query) throws SQLException {
String errorMessage = "";
if (isTestOnBorrow()) {
errorMessage += "testOnBorrow is true, ";
if (isTestOnReturn()) {
errorMessage += "testOnReturn is true, ";
if (isTestWhileIdle()) {
errorMessage += "testWhileIdle is true, ";
LOG.error(errorMessage + "validationQuery not set");
firstResultSet = this.statement.execute();
firstResultSet = chain.preparedStatement_execute(this);
firstResultSet = true;
firstResultSet = false;
firstResultSet = false;
firstResultSet = true;
firstResultSet = false;
firstResultSet = false;
firstResultSet = false;
firstResultSet = false;
public void addExecuteTime(StatementExecuteType executeType, boolean firstResultSet, long nanoSpan) {
if (StatementExecuteType.ExecuteQuery != executeType && !firstResultSet) {
public interface MockStatementBase extends Statement {
MockConnection getConnection() throws SQLException;
public class StatFilterExecuteFirstResultSetTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
MockDriver driver = new MockDriver() {
public MockPreparedStatement createMockPreparedStatement(MockConnection conn, String sql) {
return new MyMockPreparedStatement(conn, sql);
dataSource.setDriver(driver);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Assert.assertTrue(dataSource.isInited());
final String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
boolean firstResult = stmt.execute();
Assert.assertTrue(firstResult);
ResultSet rs = stmt.getResultSet();
rs.next();
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Histogram histogram = sqlStat.getHistogram();
Assert.assertEquals(1,
histogram.getValue(0) + histogram.getValue(1) + histogram.getValue(2)
+ histogram.getValue(3));
Histogram rsHoldHistogram = sqlStat.getExecuteAndResultHoldTimeHistogram();
Assert.assertEquals(1, rsHoldHistogram.getValue(0) + rsHoldHistogram.getValue(1) + rsHoldHistogram.getValue(2)
+ rsHoldHistogram.getValue(3));
static class MyMockPreparedStatement extends MockPreparedStatement {
public MyMockPreparedStatement(MockConnection conn, String sql){
super(conn, sql);
public boolean execute() throws SQLException {
return true;
public ResultSet getResultSet() throws SQLException {
return getConnection().getDriver().executeQuery(this, getSql());
public class DruidDataSourcePanel extends DruidPanel {
private static final long serialVersionUID = 1L;
public class DruidDriverPanel extends DruidPanel {
private static final long serialVersionUID = 1L;
public class DruidPanel extends JPanel {
private static final long serialVersionUID = 1L;
protected Object doInBackground(JConsoleContext context) throws Exception {
doInBackground(context.getMBeanServerConnection());
return null;
protected void doInBackground(MBeanServerConnection conn) throws Exception {
System.out.println("doInBackground");
public class DruidPlugin extends JConsolePlugin {
private final Map<String, JPanel> tabs = new LinkedHashMap<String, JPanel>();
public DruidPlugin(){
tabs.put("Druid-Driver", new DruidDriverPanel());
tabs.put("Druid-DataSource", new DruidDataSourcePanel());
tabs.put("Druid-SQL", new DruidSQLPanel());
public Map<String, JPanel> getTabs() {
return tabs;
public SwingWorker<?, ?> newSwingWorker() {
SwingWorker<?, ?> worer = new SwingWorker<Object, Object>() {
protected Object doInBackground() throws Exception {
return DruidPlugin.this.doInBackground();
return worer;
protected Object doInBackground() throws Exception {
for (JPanel panel : tabs.values()) {
((DruidPanel) panel).doInBackground(this.getContext());
return null;
public class DruidSQLPanel extends DruidPanel {
private static final long serialVersionUID = 1L;
connectionLog("connect committed. id " + connection.getId());
connectionLog("connect setAutoCommit " + autoCommit + ". id " + connection.getId());
private Object                              druidDataSourceStatManager;
private Object                              jdbcStatManager;
private Set<DruidDataSource> getDruidDataSourceInstances() {
ReflectionUtils.callObjectMethod(druidDataSourceStatManager, "reset");
ReflectionUtils.callObjectMethod(jdbcStatManager, "reset");
private JdbcSqlStat getSqlStatById(Integer id) {
private DruidDataSource getDruidDataSourceById(Integer identity) {
private Map<String, Object> getSqlStatData(JdbcSqlStat sqlStat) {
public static Object callObjectMethod(Object obj, String methodName) {
System.out.println(callObjectMethod(new ReflectionUtils(), "getTest"));
public class DataSourceClosedException extends SQLException {
private static final long serialVersionUID = 1L;
public DataSourceClosedException(){
public DataSourceClosedException(String reason){
super(reason);
public DataSourceClosedException(Throwable cause){
super(cause);
public final static Log         LOG                     = LogFactory.getLog(DruidDataSource.class);
private long                    closeTimeMillis         = -1L;
if (closed) {
connectErrorCount.incrementAndGet();
throw new DataSourceClosedException("dataSource already closed at " + new Date(closeTimeMillis));
this.closeTimeMillis = System.currentTimeMillis();
LOG.warn("dataSource " + this.getID() + " closed");
throw new GetConnectionTimeoutException("loopWaitCount " + i + ", wait millis "
+ (nanos - estimate) / (1000 * 1000));
public class ClosedTest extends TestCase {
public void test_close() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
Connection conn = dataSource.getConnection();
conn.close();
dataSource.close();
DataSourceClosedException error = null;
dataSource.getConnection();
} catch (DataSourceClosedException ex) {
error = ex;
Assert.assertNotNull(error);
public class DruidDataSourceStatDefaultStrategy implements DruidDataSourceStatStrategy {
private Set<DruidDataSource> getDruidDataSourceInstances() {
return DruidDataSourceStatManager.getDruidDataSourceInstances();
public void resetDataSourceStat() {
DruidDataSourceStatManager.getInstance().reset();
public void resetSqlStat() {
JdbcStatManager.getInstance().reset();
public void resetAll() {
resetSqlStat();
resetDataSourceStat();
private JdbcSqlStat getSqlStatById(Integer id) {
for (DruidDataSource ds : getDruidDataSourceInstances()) {
JdbcSqlStat sqlStat = ds.getDataSourceStat().getSqlStat(id);
if (sqlStat != null)
return sqlStat;
return null;
public Map<String, Object> getDataSourceStatData(Integer id) {
if (id == null) {
return null;
DruidDataSource datasource = getDruidDataSourceById(id);
return datasource == null ? null : dataSourceToMapData(datasource);
private DruidDataSource getDruidDataSourceById(Integer identity) {
if (identity == null) {
return null;
for (DruidDataSource datasource : getDruidDataSourceInstances()) {
if (System.identityHashCode(datasource) == identity) {
return datasource;
return null;
public List<Map<String, Object>> getSqlStatDataList() {
List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
for (DruidDataSource datasource : getDruidDataSourceInstances()) {
for (JdbcSqlStat sqlStat : datasource.getDataSourceStat().getSqlStatMap().values()) {
if (sqlStat.getExecuteCount() == 0 && sqlStat.getRunningCount() == 0) {
result.add(getSqlStatData(sqlStat));
return result;
public Map<String, Object> getSqlStatData(Integer id) {
if (id == null) {
return null;
JdbcSqlStat sqlStat = getSqlStatById(id);
return sqlStat == null ? null : getSqlStatData(sqlStat);
private Map<String, Object> getSqlStatData(JdbcSqlStat sqlStat) {
return sqlStat.getData();
} catch (JMException e) {
return null;
public List<Object> getDataSourceStatList() {
List<Object> datasourceList = new ArrayList<Object>();
for (DruidDataSource dataSource : getDruidDataSourceInstances()) {
datasourceList.add(dataSourceToMapData(dataSource));
return datasourceList;
public Map<String, Object> returnJSONBasicStat() {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Version", VERSION.getVersionNumber());
dataMap.put("Drivers", getDriversData());
return dataMap;
private List<String> getDriversData() {
List<String> drivers = new ArrayList<String>();
for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
Driver driver = e.nextElement();
drivers.add(driver.getClass().getName());
return drivers;
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
DruidDataSource datasource = getDruidDataSourceById(id);
if (datasource == null)
return null;
return datasource.getPoolingConnectionInfo();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
DruidDataSource datasource = getDruidDataSourceById(id);
if (datasource == null || !datasource.isRemoveAbandoned())
return null;
return datasource.getActiveConnectionStackTrace();
private Map<String, Object> dataSourceToMapData(DruidDataSource dataSource) {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Identity", System.identityHashCode(dataSource));
dataMap.put("Name", dataSource.getName());
dataMap.put("DbType", dataSource.getDbType());
dataMap.put("DriverClassName", dataSource.getDriverClassName());
dataMap.put("URL", dataSource.getUrl());
dataMap.put("UserName", dataSource.getUsername());
dataMap.put("FilterClassNames", dataSource.getFilterClassNames());
dataMap.put("WaitThreadCount", dataSource.getWaitThreadCount());
dataMap.put("NotEmptyWaitCount", dataSource.getNotEmptyWaitCount());
dataMap.put("NotEmptyWaitMillis", dataSource.getNotEmptyWaitMillis());
dataMap.put("PoolingCount", dataSource.getPoolingCount());
dataMap.put("PoolingPeak", dataSource.getPoolingPeak());
dataMap.put("PoolingPeakTime", dataSource.getPoolingPeakTime() == null ? null : dataSource.getPoolingPeakTime().toString());
dataMap.put("ActiveCount", dataSource.getActiveCount());
dataMap.put("ActivePeak", dataSource.getActivePeak());
dataMap.put("ActivePeakTime", dataSource.getActivePeakTime() == null ? null : dataSource.getActivePeakTime().toString());
dataMap.put("InitialSize", dataSource.getInitialSize());
dataMap.put("MinIdle", dataSource.getMinIdle());
dataMap.put("MaxActive", dataSource.getMaxActive());
dataMap.put("QueryTimeout", dataSource.getQueryTimeout());
dataMap.put("TransactionQueryTimeout", dataSource.getTransactionQueryTimeout());
dataMap.put("LoginTimeout", dataSource.getLoginTimeout());
dataMap.put("ValidConnectionCheckerClassName", dataSource.getValidConnectionCheckerClassName());
dataMap.put("ExceptionSorterClassName", dataSource.getExceptionSorterClassName());
dataMap.put("TestOnBorrow", dataSource.isTestOnBorrow());
dataMap.put("TestOnReturn", dataSource.isTestOnReturn());
dataMap.put("TestWhileIdle", dataSource.isTestWhileIdle());
dataMap.put("DefaultAutoCommit", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultReadOnly", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultTransactionIsolation", dataSource.getDefaultTransactionIsolation());
dataMap.put("LogicConnectCount", dataSource.getConnectCount());
dataMap.put("LogicCloseCount", dataSource.getCloseCount());
dataMap.put("LogicConnectErrorCount", dataSource.getConnectErrorCount());
dataMap.put("PhysicalConnectCount", dataSource.getCreateCount());
dataMap.put("PhysicalCloseCount", dataSource.getDestroyCount());
dataMap.put("PhysicalConnectErrorCount", dataSource.getCreateErrorCount());
dataMap.put("ExecuteCount", dataSource.getExecuteCount());
dataMap.put("ErrorCount", dataSource.getErrorCount());
dataMap.put("CommitCount", dataSource.getCommitCount());
dataMap.put("RollbackCount", dataSource.getRollbackCount());
dataMap.put("PSCacheAccessCount", dataSource.getCachedPreparedStatementAccessCount());
dataMap.put("PSCacheHitCount", dataSource.getCachedPreparedStatementHitCount());
dataMap.put("PSCacheMissCount", dataSource.getCachedPreparedStatementMissCount());
dataMap.put("StartTransactionCount", dataSource.getStartTransactionCount());
dataMap.put("TransactionHistogram", dataSource.getTransactionHistogramValues());
dataMap.put("ConnectionHoldTimeHistogram", dataSource.getDataSourceStat().getConnectionHoldHistogram().toArray());
dataMap.put("RemoveAbandoned", dataSource.isRemoveAbandoned());
return dataMap;
public class DruidDataSourceStatJNDIStatStrategy implements DruidDataSourceStatStrategy{
private Object getStrategyB() {
return ReflectionUtils.getClassFromWebContainerOrCurrentClassLoader("com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy");
@SuppressWarnings("unchecked")
public Map<String, Object> getSqlStatData(Integer id) {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStrategyB(), "getSqlStatData", id);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getSqlStatDataList() {
return (List<Map<String, Object>>) ReflectionUtils.callObjectMethod(getStrategyB(), "getSqlStatDataList");
@SuppressWarnings("unchecked")
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return (List<String>) ReflectionUtils.callObjectMethod(getStrategyB(), "getActiveConnectionStackTraceByDataSourceId", id);
@SuppressWarnings("unchecked")
public Map<String, Object> returnJSONBasicStat() {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStrategyB(), "returnJSONBasicStat");
@SuppressWarnings("unchecked")
public List<Object> getDataSourceStatList() {
return (List<Object>) ReflectionUtils.callObjectMethod(getStrategyB(), "getDataSourceStatList");
@SuppressWarnings("unchecked")
public Map<String, Object> getDataSourceStatData(Integer id) {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStrategyB(), "getDataSourceStatData", id);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return (List<Map<String, Object>>) ReflectionUtils.callObjectMethod(getStrategyB(), "getPoolingConnectionInfoByDataSourceId", id);
public void resetAll() {
ReflectionUtils.callObjectMethod(getStrategyB(), "resetAll");
public interface DruidDataSourceStatStrategy {
public Map<String, Object> getSqlStatData(Integer id);
public List<Map<String, Object>> getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id);
public Map<String, Object> returnJSONBasicStat();
public List<Object> getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id);
public void resetAll();
public class DruidDataSourceStatStrategyContext {
private DruidDataSourceStatStrategy druidDataSourceStatStrategy;
public DruidDataSourceStatStrategyContext(DruidDataSourceStatStrategy druidDataSourceStatStrategy) {
this.druidDataSourceStatStrategy = druidDataSourceStatStrategy;
public Map<String, Object> getSqlStatData(Integer id) {
return druidDataSourceStatStrategy.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return druidDataSourceStatStrategy.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return druidDataSourceStatStrategy.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return druidDataSourceStatStrategy.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return druidDataSourceStatStrategy.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return druidDataSourceStatStrategy.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return druidDataSourceStatStrategy.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
druidDataSourceStatStrategy.resetAll();
private final static DruidStatManagerFacade instance = new DruidStatManagerFacade();
private static DruidDataSourceStatStrategyContext ctx = null;
private static DruidDataSourceStatStrategy strategy = null;
strategy = new DruidDataSourceStatJNDIStatStrategy();
ctx = new DruidDataSourceStatStrategyContext(strategy);
private DruidStatManagerFacade() {
public static DruidStatManagerFacade getInstance() {
return instance;
public Map<String, Object> getSqlStatData(Integer id) {
return ctx.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return ctx.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return ctx.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return ctx.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return ctx.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return ctx.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return ctx.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
ctx.resetAll();
public long getSlowSqlMillis() {
return slowSqlMillis;
private final void internalAfterStatementExecute(StatementProxy statement, boolean firstResult,
int... updateCountArray) {
public class SlowSqlMillisTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:wrap-jdbc:jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setTestOnReturn(false);
dataSource.setTestWhileIdle(false);
dataSource.setConnectionProperties("druid.stat.slowSqlMillis=500");
dataSource.setFilters("stat");
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_connect() throws Exception {
StatFilter filter = (StatFilter) dataSource.getProxyFilters().get(0);
Assert.assertEquals(500, filter.getSlowSqlMillis());
dataSource.setUrl("jdbc:mock:xxx");
public class SlowSqlMillisTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setTestOnReturn(false);
dataSource.setTestWhileIdle(false);
System.setProperty("druid.stat.slowSqlMillis", "500");
dataSource.setFilters("stat");
StatFilter filter = (StatFilter) dataSource.getProxyFilters().get(0);
Assert.assertEquals(3000, filter.getSlowSqlMillis());
dataSource.init();
protected void tearDown() throws Exception {
System.clearProperty("druid.stat.slowSqlMillis");
dataSource.close();
public void test_connect() throws Exception {
StatFilter filter = (StatFilter) dataSource.getProxyFilters().get(0);
Assert.assertEquals(500, filter.getSlowSqlMillis());
private final static Log         LOG                     = LogFactory.getLog(DruidDataSource.class);
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log LOG = (Log) field.get(null);
LOG.resetStat();
Assert.assertEquals(0, LOG.getErrorCount());
Assert.assertEquals(1, LOG.getErrorCount());
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log LOG = (Log) field.get(null);
LOG.resetStat();
Assert.assertEquals(0, LOG.getErrorCount());
Assert.assertEquals(1, LOG.getErrorCount());
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log LOG = (Log) field.get(null);
LOG.resetStat();
Assert.assertEquals(0, LOG.getErrorCount());
Assert.assertEquals(1, LOG.getErrorCount());
public class ReflectionUtils {
private final static Log LOG = LogFactory.getLog(ReflectionUtils.class);
public static Class<?> getClassFromWebContainerOrCurrentClassLoader(String className) {
} catch (ClassNotFoundException e) {
LOG.warn(e.getMessage(), e);
if (result == null) {
} catch (ClassNotFoundException e) {
LOG.warn(e.getMessage(), e);
public static Object callStaticMethod(Class<?> classObject, String methodName) {
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return null;
public static Object callObjectMethod(Object obj, String methodName) {
Constructor<?> ctor = ((Class<?>) obj).getConstructor();
Object instance = ctor.newInstance();
Method m = ((Class<?>) obj).getMethod(methodName); 
return m.invoke(instance);
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return null;
public static Object callObjectMethod(Object obj, String methodName, Object methodParam) {
Constructor<?> ctor = ((Class<?>) obj).getConstructor();
Object instance = ctor.newInstance();
Method m = ((Class<?>) obj).getMethod(methodName, methodParam.getClass()); 
return m.invoke(instance);
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return null;
public void getTest() {
public static void main(String args[]) {
if (LOG.isDebugEnabled()) LOG.debug("can'r find class in web container classLoader ", e);
"LastSlowParameters", 
"ResultSetHoldTime", 
"ExecuteAndResultSetHoldTime", 
"FetchRowCountHistogram", 
"EffectedRowCountHistogram", 
"ExecuteAndResultHoldTimeHistogram"
private static DateFormat format = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
if (sqlStat.getLastSlowParameters() != null && sqlStat.getLastSlowParameters().trim().length() > 0) {
content.append("<h2>LastSlow SQL View:</h2>");
content.append("<table cellpadding='5' cellspacing='1' width='99%'>");
content.append("<tr>");
content.append("<td class='td_lable' width='130'>MaxTimespanOccurTime</td>");
content.append("<td>" + format.format(sqlStat.getExecuteNanoSpanMaxOccurTime()) + "</td>");
content.append("</tr>");
content.append("<tr>");
content.append("<td class='td_lable' width='130'>LastSlowParameters</td>");
content.append("<td>" + sqlStat.getLastSlowParameters() + "</td>");
content.append("</tr>");
content.append("</table>");
content.append("<br />");
private final static Log LOG = LogFactory.getLog(DruidDataSourceStatJNDIStatStrategy.class);
Class<?> clazz = ReflectionUtils.getClassFromWebContainerOrCurrentClassLoader("com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy");
return clazz.newInstance();
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return null;
public static Object callObjectMethod(Object obj, String methodName) {
return m.invoke(obj);
} catch (Exception e) {
LOG.warn("callObjectMethod fail:class=" + obj.getClass().getName() + " method=" + methodName, e);
return null;
public static Object callObjectMethod(Object obj, String methodName, Integer id) {
Method m = obj.getClass().getMethod(methodName, Integer.class);
return m.invoke(obj, id);
private Set<DruidDataSource> getDruidDataSourceInstances() {
return DruidDataSourceStatManager.getDruidDataSourceInstances();
public void resetDataSourceStat() {
DruidDataSourceStatManager.getInstance().reset();
public void resetSqlStat() {
JdbcStatManager.getInstance().reset();
public void resetAll() {
resetSqlStat();
resetDataSourceStat();
public JdbcSqlStat getSqlStatById(Integer id) {
for (DruidDataSource ds : getDruidDataSourceInstances()) {
JdbcSqlStat sqlStat = ds.getDataSourceStat().getSqlStat(id);
if (sqlStat != null) return sqlStat;
return null;
public Map<String, Object> getDataSourceStatData(Integer id) {
if (id == null) {
return null;
DruidDataSource datasource = getDruidDataSourceById(id);
return datasource == null ? null : dataSourceToMapData(datasource);
public DruidDataSource getDruidDataSourceById(Integer identity) {
if (identity == null) {
return null;
for (DruidDataSource datasource : getDruidDataSourceInstances()) {
if (System.identityHashCode(datasource) == identity) {
return datasource;
return null;
public List<Map<String, Object>> getSqlStatDataList() {
List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
for (DruidDataSource datasource : getDruidDataSourceInstances()) {
for (JdbcSqlStat sqlStat : datasource.getDataSourceStat().getSqlStatMap().values()) {
if (sqlStat.getExecuteCount() == 0 && sqlStat.getRunningCount() == 0) {
result.add(getSqlStatData(sqlStat));
return result;
public Map<String, Object> getSqlStatData(Integer id) {
if (id == null) {
return null;
JdbcSqlStat sqlStat = getSqlStatById(id);
return sqlStat == null ? null : getSqlStatData(sqlStat);
private Map<String, Object> getSqlStatData(JdbcSqlStat sqlStat) {
return sqlStat.getData();
} catch (JMException e) {
return null;
public List<Object> getDataSourceStatList() {
List<Object> datasourceList = new ArrayList<Object>();
for (DruidDataSource dataSource : getDruidDataSourceInstances()) {
datasourceList.add(dataSourceToMapData(dataSource));
return datasourceList;
public Map<String, Object> returnJSONBasicStat() {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Version", VERSION.getVersionNumber());
dataMap.put("Drivers", getDriversData());
return dataMap;
private List<String> getDriversData() {
List<String> drivers = new ArrayList<String>();
for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
Driver driver = e.nextElement();
drivers.add(driver.getClass().getName());
return drivers;
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
DruidDataSource datasource = getDruidDataSourceById(id);
if (datasource == null) return null;
return datasource.getPoolingConnectionInfo();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
DruidDataSource datasource = getDruidDataSourceById(id);
if (datasource == null || !datasource.isRemoveAbandoned()) return null;
return datasource.getActiveConnectionStackTrace();
private Map<String, Object> dataSourceToMapData(DruidDataSource dataSource) {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Identity", System.identityHashCode(dataSource));
dataMap.put("Name", dataSource.getName());
dataMap.put("DbType", dataSource.getDbType());
dataMap.put("DriverClassName", dataSource.getDriverClassName());
dataMap.put("URL", dataSource.getUrl());
dataMap.put("UserName", dataSource.getUsername());
dataMap.put("FilterClassNames", dataSource.getFilterClassNames());
dataMap.put("WaitThreadCount", dataSource.getWaitThreadCount());
dataMap.put("NotEmptyWaitCount", dataSource.getNotEmptyWaitCount());
dataMap.put("NotEmptyWaitMillis", dataSource.getNotEmptyWaitMillis());
dataMap.put("PoolingCount", dataSource.getPoolingCount());
dataMap.put("PoolingPeak", dataSource.getPoolingPeak());
dataMap.put("PoolingPeakTime",
dataSource.getPoolingPeakTime() == null ? null : dataSource.getPoolingPeakTime().toString());
dataMap.put("ActiveCount", dataSource.getActiveCount());
dataMap.put("ActivePeak", dataSource.getActivePeak());
dataMap.put("ActivePeakTime",
dataSource.getActivePeakTime() == null ? null : dataSource.getActivePeakTime().toString());
dataMap.put("InitialSize", dataSource.getInitialSize());
dataMap.put("MinIdle", dataSource.getMinIdle());
dataMap.put("MaxActive", dataSource.getMaxActive());
dataMap.put("QueryTimeout", dataSource.getQueryTimeout());
dataMap.put("TransactionQueryTimeout", dataSource.getTransactionQueryTimeout());
dataMap.put("LoginTimeout", dataSource.getLoginTimeout());
dataMap.put("ValidConnectionCheckerClassName", dataSource.getValidConnectionCheckerClassName());
dataMap.put("ExceptionSorterClassName", dataSource.getExceptionSorterClassName());
dataMap.put("TestOnBorrow", dataSource.isTestOnBorrow());
dataMap.put("TestOnReturn", dataSource.isTestOnReturn());
dataMap.put("TestWhileIdle", dataSource.isTestWhileIdle());
dataMap.put("DefaultAutoCommit", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultReadOnly", dataSource.isDefaultAutoCommit());
dataMap.put("DefaultTransactionIsolation", dataSource.getDefaultTransactionIsolation());
dataMap.put("LogicConnectCount", dataSource.getConnectCount());
dataMap.put("LogicCloseCount", dataSource.getCloseCount());
dataMap.put("LogicConnectErrorCount", dataSource.getConnectErrorCount());
dataMap.put("PhysicalConnectCount", dataSource.getCreateCount());
dataMap.put("PhysicalCloseCount", dataSource.getDestroyCount());
dataMap.put("PhysicalConnectErrorCount", dataSource.getCreateErrorCount());
dataMap.put("ExecuteCount", dataSource.getExecuteCount());
dataMap.put("ErrorCount", dataSource.getErrorCount());
dataMap.put("CommitCount", dataSource.getCommitCount());
dataMap.put("RollbackCount", dataSource.getRollbackCount());
dataMap.put("PSCacheAccessCount", dataSource.getCachedPreparedStatementAccessCount());
dataMap.put("PSCacheHitCount", dataSource.getCachedPreparedStatementHitCount());
dataMap.put("PSCacheMissCount", dataSource.getCachedPreparedStatementMissCount());
dataMap.put("StartTransactionCount", dataSource.getStartTransactionCount());
dataMap.put("TransactionHistogram", dataSource.getTransactionHistogramValues());
dataMap.put("ConnectionHoldTimeHistogram",
dataSource.getDataSourceStat().getConnectionHoldHistogram().toArray());
dataMap.put("RemoveAbandoned", dataSource.isRemoveAbandoned());
return dataMap;
public class DruidDataSourceStatJNDIStatStrategy implements DruidDataSourceStatStrategy {
private final static Log LOG = LogFactory.getLog(DruidDataSourceStatJNDIStatStrategy.class);
private Object getStatDefaultStrategy() {
Class<?> clazz = ReflectionUtils.getClassFromWebContainerOrCurrentClassLoader("com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy");
return clazz.newInstance();
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return null;
@SuppressWarnings("unchecked")
public Map<String, Object> getSqlStatData(Integer id) {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getSqlStatData", id);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getSqlStatDataList() {
return (List<Map<String, Object>>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getSqlStatDataList");
@SuppressWarnings("unchecked")
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return (List<String>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(),
"getActiveConnectionStackTraceByDataSourceId", id);
@SuppressWarnings("unchecked")
public Map<String, Object> returnJSONBasicStat() {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "returnJSONBasicStat");
@SuppressWarnings("unchecked")
public List<Object> getDataSourceStatList() {
return (List<Object>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getDataSourceStatList");
@SuppressWarnings("unchecked")
public Map<String, Object> getDataSourceStatData(Integer id) {
return (Map<String, Object>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getDataSourceStatData", id);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return (List<Map<String, Object>>) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(),
"getPoolingConnectionInfoByDataSourceId",
public void resetAll() {
ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "resetAll");
public DruidDataSource getDruidDataSourceById(Integer id) {
return (DruidDataSource) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getDruidDataSourceById");
public JdbcSqlStat getSqlStatById(Integer id) {
return (JdbcSqlStat) ReflectionUtils.callObjectMethod(getStatDefaultStrategy(), "getSqlStatById", id);
public Map<String, Object> getSqlStatData(Integer id);
public List<Map<String, Object>> getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id);
public Map<String, Object> returnJSONBasicStat();
public List<Object> getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id);
public void resetAll();
public DruidDataSource getDruidDataSourceById(Integer id);
public JdbcSqlStat getSqlStatById(Integer id);
private DruidDataSourceStatStrategy druidDataSourceStatStrategy;
public DruidDataSourceStatStrategyContext(DruidDataSourceStatStrategy druidDataSourceStatStrategy){
this.druidDataSourceStatStrategy = druidDataSourceStatStrategy;
public Map<String, Object> getSqlStatData(Integer id) {
return druidDataSourceStatStrategy.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return druidDataSourceStatStrategy.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return druidDataSourceStatStrategy.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return druidDataSourceStatStrategy.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return druidDataSourceStatStrategy.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return druidDataSourceStatStrategy.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return druidDataSourceStatStrategy.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
druidDataSourceStatStrategy.resetAll();
public DruidDataSource getDruidDataSourceById(Integer id) {
return druidDataSourceStatStrategy.getDruidDataSourceById(id);
public JdbcSqlStat getSqlStatById(Integer id) {
return druidDataSourceStatStrategy.getSqlStatById(id);
private final static DruidStatManagerFacade       instance = new DruidStatManagerFacade();
private static DruidDataSourceStatStrategyContext ctx      = null;
private static DruidDataSourceStatStrategy        strategy = null;
strategy = new DruidDataSourceStatJNDIStatStrategy();
ctx = new DruidDataSourceStatStrategyContext(strategy);
private DruidStatManagerFacade(){
public static DruidStatManagerFacade getInstance() {
return instance;
public Map<String, Object> getSqlStatData(Integer id) {
return ctx.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return ctx.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return ctx.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return ctx.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return ctx.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return ctx.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return ctx.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
ctx.resetAll();
public DruidDataSource getDruidDataSourceById(Integer id) {
return ctx.getDruidDataSourceById(id);
public JdbcSqlStat getSqlStatById(Integer id) {
return ctx.getSqlStatById(id);
private static DateFormat             format                      = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
private final static Log LOG = LogFactory.getLog(DruidDataSourceStatJNDIStatStrategy.class);
Class<?> clazz = ReflectionUtils.getClassFromWebContainerOrCurrentClassLoader("com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy");
Object object = null;
object = clazz.newInstance();
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return object;
public static Object callObjectMethod(Object obj, String methodName) {
return m.invoke(obj);
} catch (Exception e) {
LOG.warn("callObjectMethod fail:class=" + obj.getClass().getName() + " method=" + methodName, e);
return null;
public static Object callObjectMethod(Object obj, String methodName, Integer id) {
Method m = obj.getClass().getMethod(methodName, Integer.class);
return m.invoke(obj, id);
content.append("<td class='td_lable' width='130'>SlowestSqlOccurTime</td>");
private final static Log LOG = LogFactory.getLog(SQLUtils.class);
List<SQLStatement> statementList = toStatementList(sql, dbType);
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor visitor = createFormatOutputVisitor(out, statementList, dbType);
for (SQLStatement stmt : statementList) {
stmt.accept(visitor);
return out.toString();
} catch (SQLParseException ex) {
LOG.warn("format error", ex);
return sql;
private final static Log                                      LOG           = LogFactory.getLog(DruidDataSourceStatJNDIStatStrategy.class);
private final static List<Object>                             strategyList  = new ArrayList<Object>();
private final static HashMap<Object, HashMap<String, Method>> classMethodHM = new HashMap<Object, HashMap<String, Method>>();
private final static String[]                                 methodNameArr = new String[] { "getSqlStatData",
"getSqlStatDataList", "getActiveConnectionStackTraceByDataSourceId", "returnJSONBasicStat",
"getDataSourceStatList", "getDataSourceStatData", "getPoolingConnectionInfoByDataSourceId", "resetAll",
"getDruidDataSourceById", "getSqlStatById"                         };
public DruidDataSourceStatJNDIStatStrategy(){
private void init() {
String className = "com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy";
Class<?> clazzFromWebContainer = ReflectionUtils.getClassFromWebContainer(className);
Class<?> clazzFromCurClassLoader = ReflectionUtils.getClassFromCurrentClassLoader(className);
if (clazzFromWebContainer != null) strategyList.add(clazzFromWebContainer.newInstance());
if (clazzFromCurClassLoader != null) strategyList.add(clazzFromCurClassLoader.newInstance());
Object obj = null;
for (int i = 0; i < strategyList.size(); i++) {
obj = strategyList.get(i);
HashMap<String, Method> methodHM = null;
String methodName = null;
for (int j = 0; j < methodNameArr.length; j++) {
methodHM = new HashMap<String, Method>();
methodName = methodNameArr[j];
methodHM.put(methodName, ReflectionUtils.getObjectMethod(obj, methodName));
classMethodHM.put(obj, methodHM);
private Object invoke(String methodName, Integer methodParam) {
Object result = null;
HashMap<String, Method> hm = null;
Object invokeRes = null;
Object obj = null;
for (int i = 0; i < strategyList.size(); i++) {
obj = strategyList.get(i);
hm = classMethodHM.get(obj);
if (hm.containsKey(methodName)) {
if (methodParam == null) {
invokeRes = hm.get(methodName).invoke(obj);
invokeRes = hm.get(methodName).invoke(obj, methodParam);
if (invokeRes instanceof Map) {
result = invokeMapResHandler(null, (Map<String, Object>) invokeRes);
} else if (invokeRes instanceof List) {
result = invokeListResHandler(null, (List<Map<String, Object>>) invokeRes);
} catch (Exception e) {
LOG.error(e.getMessage(), e);
return result;
private Map<String, Object> invokeMapResHandler(Map<String, Object> finalRs, Map<String, Object> invokeRes) {
Map<String, Object> res = null;
if (finalRs == null) {
res = finalRs;
finalRs.putAll(invokeRes);
res = finalRs;
return res;
private List<?> invokeListResHandler(List<Map<String, Object>> finalRs, List<Map<String, Object>> invokeRes) {
List<Map<String, Object>> res = null;
if (finalRs == null) {
res = finalRs;
finalRs.addAll(invokeRes);
res = finalRs;
return res;
public Map<String, Object> getSqlStatData(Integer id) {
return (Map<String, Object>) invoke("getSqlStatData", id);
public Map<String, Object> getDataSourceStatData(Integer id) {
return (Map<String, Object>) invoke("getDataSourceStatData", id);
return (Map<String, Object>) invoke("returnJSONBasicStat", null);
public List<Map<String, Object>> getSqlStatDataList() {
return (List<Map<String, Object>>) invoke("getSqlStatDataList", null);
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return (List<String>) invoke("getActiveConnectionStackTraceByDataSourceId", id);
@SuppressWarnings("unchecked")
public List<Object> getDataSourceStatList() {
return (List<Object>) invoke("getDataSourceStatList", null);
return (List<Map<String, Object>>) invoke("getPoolingConnectionInfoByDataSourceId", id);
invoke("resetAll", null);
return (DruidDataSource) invoke("getDruidDataSourceById", id);
return (JdbcSqlStat) invoke("getSqlStatById", id);
public static Class<?> getClassFromWebContainer(String className) {
return result;
public static Class<?> getClassFromCurrentClassLoader(String className) {
Class<?> result = null;
result = Thread.currentThread().getContextClassLoader().loadClass(className);
} catch (ClassNotFoundException e) {
LOG.error("can'r find class in current thread context classLoader ", e);
return result;
public static Class<?> getClassFromWebContainerOrCurrentClassLoader(String className) {
Class<?> result = getClassFromWebContainer(className);
result = getClassFromCurrentClassLoader(className);
public static Method getObjectMethod(Object obj, String methodName) {
return obj.getClass().getMethod(methodName);
} catch (Exception e) {
LOG.warn("getObjectMethod fail:class=" + obj.getClass().getName() + " method=" + methodName, e);
return null;
public static Method getObjectMethod(Object obj, String methodName, Integer id) {
return obj.getClass().getMethod(methodName, Integer.class);
} catch (Exception e) {
LOG.warn("getObjectMethod fail:class=" + obj.getClass().getName() + " method=" + methodName, e);
return null;
@Override
public void resultSet_close(FilterChain chain, ResultSetProxy resultSet) throws SQLException {
chain.resultSet_close(resultSet);
StringBuffer buf = new StringBuffer();
buf.append("{conn-");
buf.append(resultSet.getStatementProxy().getConnectionProxy().getId());
buf.append(", ");
buf.append(stmtId(resultSet));
buf.append(", rs-");
buf.append(resultSet.getId());
buf.append("} closed");
if (isResultSetCloseAfterLogEnabled()) {
resultSetLog(buf.toString());
public ResultSet createResultSet(MockPreparedStatement stmt) {
Object obj = stmt.getObject(parameterIndex);
return wrapObject(obj);
private Object wrapObject(Object obj) {
if (obj instanceof ResultSet) {
ResultSet rs = (ResultSet) obj;
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
resultSetTrace.add(poolableResultSet);
obj = poolableResultSet;
return obj;
Object obj = stmt.getObject(parameterIndex, map);
return wrapObject(obj);
Object obj = stmt.getObject(parameterName);
return wrapObject(obj);
Object obj = stmt.getObject(parameterName, map);
return wrapObject(obj);
lexer.nextToken();
lexer.nextToken();
if (lexer.token() == Token.OF) {
for (;;) {
SQLExpr expr = this.createExprParser().expr();
forClause.getOf().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
public ResultSet createResultSet(MockPreparedStatement stmt) {
public class PGSelectForUpdateTest extends PGTest {
public void test_0() throws Exception {
String sql = "select pkvalue from dbtpktable where tablename = 'taturvisit' for update";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public class CallableStatmentTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(100);
dataSource.setFilters("log4j");
dataSource.setDriver(new MockDriver() {
public MockCallableStatement createMockCallableStatement(MockConnection conn, String sql) {
return new MyMockCallableStatement(conn, sql);
protected void tearDown() throws Exception {
dataSource.close();
public void test_connect() throws Exception {
MockCallableStatement rawStmt = null;
MockResultSet rawRs = null;
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall("select 1");
stmt.execute();
rawStmt = stmt.unwrap(MockCallableStatement.class);
ResultSet rs = (ResultSet) stmt.getObject(0);
rawRs = rs.unwrap(MockResultSet.class);
rs.next();
rs.close();
stmt.close();
Assert.assertFalse(rawStmt.isClosed());
Assert.assertTrue(rawRs.isClosed());
rawRs = rs.unwrap(MockResultSet.class);
Assert.assertNotNull(rawRs);
conn.close();
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall("select 1");
stmt.execute();
Assert.assertSame(rawStmt, stmt.unwrap(MockCallableStatement.class));
Assert.assertFalse(rawStmt.isClosed());
stmt.getObject(0);
ResultSet rs = (ResultSet) stmt.getObject(0);
rs.next();
rs.close();
stmt.close();
conn.close();
public static class MyMockCallableStatement extends MockCallableStatement {
public MyMockCallableStatement(MockConnection conn, String sql){
super(conn, sql);
public Object getObject(int index) throws SQLException {
return this.getConnection().getDriver().createResultSet(this);
if (clazzFromCurClassLoader != null && clazzFromWebContainer != clazzFromCurClassLoader) {
public class EncodingConvertFilterTest extends TestCase {
private DruidDataSource dataSource;
private static String   CLIENT_ENCODING = "UTF-8";
private static String   SERVER_ENCODING = "ISO-8859-1";
private static String   text            = "";
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("encoding");
dataSource.setDriver(new MockDriver() {
public ResultSet createResultSet(MockPreparedStatement stmt) {
return new MyResultSet(stmt);
public ResultSet executeQuery(MockStatementBase stmt, String sql) throws SQLException {
return new MyResultSet(stmt);
dataSource.getConnectProperties().put("clientEncoding", CLIENT_ENCODING);
dataSource.getConnectProperties().put("serverEncoding", SERVER_ENCODING);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Assert.assertTrue(dataSource.isInited());
EncodingConvertFilter filter = (EncodingConvertFilter) dataSource.getProxyFilters().get(0);
DruidPooledConnection conn = dataSource.getConnection();
final String PARAM_VALUE = "";
PreparedStatement stmt = conn.prepareStatement("select ?");
stmt.setString(1, PARAM_VALUE);
MockPreparedStatement raw = stmt.unwrap(MockPreparedStatement.class);
String param1 = (String) raw.getParameters().get(0);
Assert.assertEquals(PARAM_VALUE, new String(param1.getBytes(SERVER_ENCODING), CLIENT_ENCODING));
Assert.assertFalse(param1.equals(PARAM_VALUE));
ResultSet rs = stmt.executeQuery();
MyResultSet rawRs = rs.unwrap(MyResultSet.class);
rawRs.setValue(filter.encode((ConnectionProxy) conn.getConnection(), text));
rs.next();
Assert.assertEquals(text, rs.getString(1));
rs.close();
stmt.close();
conn.close();
public static class MyResultSet extends MockResultSet {
private String value;
public MyResultSet(Statement statement){
super(statement);
public String getObject(int index) throws SQLException {
return getString(index);
public String getString(int columnIndex) throws SQLException {
return value;
public String getValue() {
return value;
public void setValue(String value) {
this.value = value;
public class EncodingConvertFilterTest2 extends TestCase {
private DruidDataSource dataSource;
private static String   CLIENT_ENCODING = "UTF-8";
private static String   SERVER_ENCODING = "ISO-8859-1";
private static String   text            = "";
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("encoding");
dataSource.setDriver(new MockDriver() {
public ResultSet createResultSet(MockPreparedStatement stmt) {
return new MyResultSet(stmt);
public ResultSet executeQuery(MockStatementBase stmt, String sql) throws SQLException {
return new MyResultSet(stmt);
dataSource.getConnectProperties().put("clientEncoding", CLIENT_ENCODING);
dataSource.getConnectProperties().put("serverEncoding", SERVER_ENCODING);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Assert.assertTrue(dataSource.isInited());
EncodingConvertFilter filter = (EncodingConvertFilter) dataSource.getProxyFilters().get(0);
DruidPooledConnection conn = dataSource.getConnection();
final String PARAM_VALUE = "";
CallableStatement stmt = conn.prepareCall("select ?");
stmt.setString(1, PARAM_VALUE);
MockCallableStatement raw = stmt.unwrap(MockCallableStatement.class);
stmt.execute();
String param1 = (String) raw.getParameters().get(0);
Assert.assertEquals(PARAM_VALUE, new String(param1.getBytes(SERVER_ENCODING), CLIENT_ENCODING));
Assert.assertFalse(param1.equals(PARAM_VALUE));
MyResultSet rawRs = new MyResultSet(raw);
rawRs.setValue(filter.encode((ConnectionProxy) conn.getConnection(), text));
raw.getOutParameters().add(rawRs);
ResultSet rs = (ResultSet) stmt.getObject(1);
rs.next();
Assert.assertEquals(text, rs.getString(1));
rs.close();
stmt.close();
conn.close();
public static class MyResultSet extends MockResultSet {
private String value;
public MyResultSet(Statement statement){
super(statement);
public String getObject(int index) throws SQLException {
return getString(index);
public String getString(int columnIndex) throws SQLException {
return value;
public String getValue() {
return value;
public void setValue(String value) {
this.value = value;
private final List<Object> outParameters = new ArrayList<Object>();
public List<Object> getOutParameters() {
return outParameters;
if (outParameters.size() >= parameterIndex - 1) {
outParameters.add(null);
Object obj = outParameters.get(parameterIndex - 1);
public final static String   PROP_DEFAULTAUTOCOMMIT                   = "defaultAutoCommit";
public final static String   PROP_DEFAULTREADONLY                     = "defaultReadOnly";
public final static String   PROP_DEFAULTTRANSACTIONISOLATION         = "defaultTransactionIsolation";
public final static String   PROP_DEFAULTCATALOG                      = "defaultCatalog";
public final static String   PROP_DRIVERCLASSNAME                     = "driverClassName";
public final static String   PROP_MAXACTIVE                           = "maxActive";
public final static String   PROP_MAXIDLE                             = "maxIdle";
public final static String   PROP_MINIDLE                             = "minIdle";
public final static String   PROP_INITIALSIZE                         = "initialSize";
public final static String   PROP_MAXWAIT                             = "maxWait";
public final static String   PROP_TESTONBORROW                        = "testOnBorrow";
public final static String   PROP_TESTONRETURN                        = "testOnReturn";
public final static String   PROP_TIMEBETWEENEVICTIONRUNSMILLIS       = "timeBetweenEvictionRunsMillis";
public final static String   PROP_NUMTESTSPEREVICTIONRUN              = "numTestsPerEvictionRun";
public final static String   PROP_MINEVICTABLEIDLETIMEMILLIS          = "minEvictableIdleTimeMillis";
public final static String   PROP_TESTWHILEIDLE                       = "testWhileIdle";
public final static String   PROP_PASSWORD                            = "password";
public final static String   PROP_URL                                 = "url";
public final static String   PROP_USERNAME                            = "username";
public final static String   PROP_VALIDATIONQUERY                     = "validationQuery";
public final static String   PROP_VALIDATIONQUERY_TIMEOUT             = "validationQueryTimeout";
public final static String   PROP_INITCONNECTIONSQLS                  = "initConnectionSqls";
public final static String   PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
public final static String   PROP_REMOVEABANDONED                     = "removeAbandoned";
public final static String   PROP_REMOVEABANDONEDTIMEOUT              = "removeAbandonedTimeout";
public final static String   PROP_LOGABANDONED                        = "logAbandoned";
public final static String   PROP_POOLPREPAREDSTATEMENTS              = "poolPreparedStatements";
public final static String   PROP_MAXOPENPREPAREDSTATEMENTS           = "maxOpenPreparedStatements";
public final static String   PROP_CONNECTIONPROPERTIES                = "connectionProperties";
public final static String   PROP_FILTERS                             = "filters";
public final static String   PROP_EXCEPTION_SORTER                    = "exceptionSorter";
public final static String   PROP_EXCEPTION_SORTER_CLASS_NAME         = "exception-sorter-class-name";
Assert.assertEquals(0, raw.getOutParameters().size());
Assert.assertEquals(1, raw.getOutParameters().size());
Assert.assertEquals(2, raw.getOutParameters().size());
public class StatViewServletTest {
private final static String contextPath = "/";
private final static String servletPatternPrefix   = "/druid";
private Server              server;
private int                 port;
@BeforeClass
public static void setUpBeforeClass() throws Exception {}
@AfterClass
public static void tearDownAfterClass() throws Exception {}
public void setUp() throws Exception {
ServerSocket s = new ServerSocket(0);
port = s.getLocalPort();
s.close();
server = new Server();
SelectChannelConnector connector = new SelectChannelConnector();
connector.setPort(port);
server.addConnector(connector);
ResourceHandler resourceHandler = new ResourceHandler();
resourceHandler.setWelcomeFiles(new String[] { "index.html" });
resourceHandler.setResourceBase(".");
ServletContextHandler contextHandler = new ServletContextHandler();
contextHandler.setContextPath(contextPath);
contextHandler.addServlet(new ServletHolder(new StatViewServlet()), servletPatternPrefix + "");
HandlerList handlers = new HandlerList();
handlers.setHandlers(new Handler[] { resourceHandler, contextHandler, new DefaultHandler() });
server.setHandler(handlers);
server.start();
public void tearDown() throws Exception {
server.stop();
public void test_basic() throws Exception {
WebConversation wc = new WebConversation();
String url = "http:
WebResponse wr = wc.getResponse(url);
String jsonString = wr.getText();
JSONObject json = JSON.parseObject(jsonString);
int resultCode = json.getInteger("ResultCode");
assertThat(1, equalTo(resultCode));
Map<String, Object> dataMap = json.getJSONObject("Content");
assertThat(VERSION.getVersionNumber(), equalTo(dataMap.get("Version")));
public static void main(String[] args) throws Exception {
Resource statViewServerXml = Resource.newSystemResource("jetty/StatViewServer.xml");
XmlConfiguration configuration = new XmlConfiguration(statViewServerXml.getInputStream());
Server server = (Server) configuration.configure();
server.start();
server.join();
public static Class<?> loadClass(ClassLoader classLoader, String className) {
return classLoader.loadClass(className);
return null;
public static Class<?> getClassFromWebContainer(String className) {
return loadClass(HttpServletRequest.class.getClassLoader(), className);
Class<?> result = loadClass(Thread.currentThread().getContextClassLoader(), className);
public final static String    PROP_DEFAULTAUTOCOMMIT                   = "defaultAutoCommit";
public final static String    PROP_DEFAULTREADONLY                     = "defaultReadOnly";
public final static String    PROP_DEFAULTTRANSACTIONISOLATION         = "defaultTransactionIsolation";
public final static String    PROP_DEFAULTCATALOG                      = "defaultCatalog";
public final static String    PROP_DRIVERCLASSNAME                     = "driverClassName";
public final static String    PROP_MAXACTIVE                           = "maxActive";
public final static String    PROP_MAXIDLE                             = "maxIdle";
public final static String    PROP_MINIDLE                             = "minIdle";
public final static String    PROP_INITIALSIZE                         = "initialSize";
public final static String    PROP_MAXWAIT                             = "maxWait";
public final static String    PROP_TESTONBORROW                        = "testOnBorrow";
public final static String    PROP_TESTONRETURN                        = "testOnReturn";
public final static String    PROP_TIMEBETWEENEVICTIONRUNSMILLIS       = "timeBetweenEvictionRunsMillis";
public final static String    PROP_NUMTESTSPEREVICTIONRUN              = "numTestsPerEvictionRun";
public final static String    PROP_MINEVICTABLEIDLETIMEMILLIS          = "minEvictableIdleTimeMillis";
public final static String    PROP_TESTWHILEIDLE                       = "testWhileIdle";
public final static String    PROP_PASSWORD                            = "password";
public final static String    PROP_URL                                 = "url";
public final static String    PROP_USERNAME                            = "username";
public final static String    PROP_VALIDATIONQUERY                     = "validationQuery";
public final static String    PROP_VALIDATIONQUERY_TIMEOUT             = "validationQueryTimeout";
public final static String    PROP_INITCONNECTIONSQLS                  = "initConnectionSqls";
public final static String    PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
public final static String    PROP_REMOVEABANDONED                     = "removeAbandoned";
public final static String    PROP_REMOVEABANDONEDTIMEOUT              = "removeAbandonedTimeout";
public final static String    PROP_LOGABANDONED                        = "logAbandoned";
public final static String    PROP_POOLPREPAREDSTATEMENTS              = "poolPreparedStatements";
public final static String    PROP_MAXOPENPREPAREDSTATEMENTS           = "maxOpenPreparedStatements";
public final static String    PROP_CONNECTIONPROPERTIES                = "connectionProperties";
public final static String    PROP_FILTERS                             = "filters";
public final static String    PROP_EXCEPTION_SORTER                    = "exceptionSorter";
public final static String    PROP_EXCEPTION_SORTER_CLASS_NAME         = "exception-sorter-class-name";
public final static String    PROP_INIT                                = "init";
PROP_FILTERS, PROP_EXCEPTION_SORTER, PROP_EXCEPTION_SORTER_CLASS_NAME, PROP_INIT };
value = (String) properties.get(PROP_INIT);
if ("true".equals(value)) {
dataSource.init();
public class DruidDataSourceFactoryTest extends TestCase {
private DruidDataSource dataSource;
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_factory() throws Exception {
DruidDataSourceFactory factory = new DruidDataSourceFactory();
Reference ref = new Reference(DataSource.class.getName());
ref.add(new StringRefAddr(DruidDataSourceFactory.PROP_REMOVEABANDONED, "true"));
ref.add(new StringRefAddr(DruidDataSourceFactory.PROP_MAXACTIVE, "20"));
Hashtable<String, String> env = new Hashtable<String, String>();
dataSource = (DruidDataSource) factory.getObjectInstance(ref, null, null, env);
Assert.assertTrue(dataSource.isRemoveAbandoned());
Assert.assertEquals(20, dataSource.getMaxActive());
public class DBCPTest extends TestCase {
public void test_dbcp() throws Exception {
BasicDataSource dataSource = new BasicDataSource();
dataSource.setDriverClassName(MockDriver.class.getName());
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxOpenPreparedStatements(100);
dataSource.setPoolPreparedStatements(true);
final String sql = "selelct 1";
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall(sql);
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall(sql);
stmt.close();
conn.close();
@SuppressWarnings("rawtypes")
public final static String                      SYS_PROP_INSTANCES = "druid.dataSources";
private final static Log                        LOG                = LogFactory.getLog(DruidDataSourceStatManager.class);
private final static DruidDataSourceStatManager instance           = new DruidDataSourceStatManager();
private final AtomicLong                        resetCount         = new AtomicLong();
private static IdentityHashMap                  dataSources;
private final static String                     MBEAN_NAME         = "com.alibaba.druid:type=DruidDataSourceStat";
IdentityHashMap<Object, ObjectName> dataSources = getInstances();
synchronized (dataSources) {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
for (Object item : dataSources.entrySet()) {
Map.Entry entry = (Map.Entry) item;
ObjectName objectName = (ObjectName) entry.getValue();
if (objectName == null) {
continue;
mbeanServer.unregisterMBean(objectName);
} catch (JMException e) {
LOG.error(e.getMessage(), e);
dataSources.clear();
@SuppressWarnings("unchecked")
public static IdentityHashMap<Object, ObjectName> getInstances() {
if (dataSources == null) {
dataSources = getInstances0();
return dataSources;
@SuppressWarnings("unchecked")
static IdentityHashMap<Object, ObjectName> getInstances0() {
Properties properties = System.getProperties();
IdentityHashMap<Object, ObjectName> instances = (IdentityHashMap<Object, ObjectName>) properties.get(SYS_PROP_INSTANCES);
if (instances == null) {
synchronized (properties) {
instances = (IdentityHashMap<Object, ObjectName>) properties.get(SYS_PROP_INSTANCES);
if (instances == null) {
instances = new IdentityHashMap<Object, ObjectName>();
properties.put(SYS_PROP_INSTANCES, instances);
return instances;
public synchronized static ObjectName add(Object dataSource, String name) {
final IdentityHashMap<Object, ObjectName> dataSources = getInstances();
synchronized (dataSources) {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
if (dataSources.size() == 0) {
ObjectName objectName = new ObjectName(MBEAN_NAME);
if (!mbeanServer.isRegistered(objectName)) {
mbeanServer.registerMBean(instance, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
ObjectName objectName = null;
if (name != null) {
objectName = new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + name);
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
if (objectName == null) {
int id = System.identityHashCode(dataSource);
objectName = new ObjectName("com.alibaba.druid:type=DruidDataSource,id=" + id);
mbeanServer.registerMBean(dataSource, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
objectName = null;
dataSources.put(dataSource, objectName);
return objectName;
IdentityHashMap<Object, ObjectName> dataSources = getInstances();
synchronized (dataSources) {
ObjectName objectName = (ObjectName) dataSources.remove(dataSource);
if (objectName == null) {
objectName = dataSource.getObjectName();
if (objectName == null) {
LOG.error("unregister mbean failed. url " + dataSource.getUrl());
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
if (objectName != null) {
mbeanServer.unregisterMBean(objectName);
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
if (dataSources.size() == 0) {
mbeanServer.unregisterMBean(new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
@SuppressWarnings("unchecked")
IdentityHashMap<Object, ObjectName> dataSources = getInstances();
synchronized (dataSources) {
for (Object item : dataSources.keySet()) {
Method method = item.getClass().getMethod("resetStat");
method.invoke(item);
} catch (Exception e) {
LOG.error("resetStat error", e);
resetCount.incrementAndGet();
ObjectName objectName = DruidDataSourceStatManager.addDataSource(this, this.name);
DruidDataSourceStatManager.removeDataSource(this);
public synchronized static ObjectName addDataSource(Object dataSource, String name) {
final IdentityHashMap<Object, ObjectName> instances = getInstances();
synchronized (instances) {
if (instances.size() == 0) {
instances.put(dataSource, objectName);
public synchronized static void removeDataSource(Object dataSource) {
IdentityHashMap<Object, ObjectName> instances = getInstances();
synchronized (instances) {
ObjectName objectName = (ObjectName) instances.remove(dataSource);
if (instances.size() == 0) {
public class JdbcSqlStatUtils {
private final static Log LOG = LogFactory.getLog(JdbcSqlStatUtils.class);
@SuppressWarnings("unchecked")
public static Map<String, Object> getData(Object jdbcSqlStat) {
Method method = jdbcSqlStat.getClass().getMethod("getData");
Object obj = method.invoke(jdbcSqlStat);
return (Map<String, Object>) obj;
} catch (Exception e) {
LOG.error("getData error", e);
return null;
strategy = new DruidDataSourceStatReflectStatStrategy();
public class DruidDataSourceStatReflectStatStrategy implements DruidDataSourceStatStrategy {
private final static Log LOG                              = LogFactory.getLog(DruidDataSourceStatReflectStatStrategy.class);
private static Object    clazzFromWebContainer_instacne   = null;
private static Object    clazzFromCurClassLoader_instacne = null;
public DruidDataSourceStatReflectStatStrategy(){
private void init() {
String className = "com.alibaba.druid.stat.DruidDataSourceStatDefaultStrategy";
Class<?> clazzFromWebContainer = ReflectionUtils.getClassFromWebContainer(className);
Class<?> clazzFromCurClassLoader = ReflectionUtils.getClassFromCurrentClassLoader(className);
if (clazzFromWebContainer != null) clazzFromWebContainer_instacne = clazzFromCurClassLoader.newInstance();
if (clazzFromCurClassLoader != null && clazzFromCurClassLoader != clazzFromWebContainer) {
clazzFromCurClassLoader_instacne = clazzFromCurClassLoader.newInstance();
} catch (Exception e) {
LOG.error(e.getMessage(), e);
@SuppressWarnings("unchecked")
private Object invokeMapResHandler(Object finalRs, Object invokeRes) {
Object res = null;
if (finalRs == null) {
if (invokeRes instanceof Map) {
res = (Map<String, Object>) invokeRes;
} else if (invokeRes instanceof List) {
res = (List<Map<String, Object>>) invokeRes;
res = invokeRes;
if (invokeRes instanceof Map) {
Map<String, Object> finalRs_ = (Map<String, Object>) finalRs;
Map<String, Object> invokeRes_ = (Map<String, Object>) invokeRes;
if (invokeRes != null) finalRs_.putAll(invokeRes_);
res = finalRs_;
} else if (invokeRes instanceof List) {
List<Map<String, Object>> finalRs_ = (List<Map<String, Object>>) finalRs;
List<Map<String, Object>> invokeRes_ = (List<Map<String, Object>>) invokeRes;
if (invokeRes != null) finalRs_.addAll(invokeRes_);
res = finalRs_;
final List list = new ArrayList();
list.add(finalRs);
list.add(invokeRes);
res = list;
return res;
private Object mergeStatData(String methodName, Integer methodParam) {
Object result = null;
if (clazzFromWebContainer_instacne != null) {
result = invokeMapResHandler(result, strategy.invoke(clazzFromWebContainer_instacne, methodName,
methodParam));
result = invokeMapResHandler(result, ReflectHelper.getInstance().invoke(clazzFromWebContainer_instacne,
methodName, methodParam));
if (clazzFromCurClassLoader_instacne != null) {
result = invokeMapResHandler(result, strategy.invoke(clazzFromWebContainer_instacne, methodName,
result = invokeMapResHandler(result, ReflectHelper.getInstance().invoke(clazzFromCurClassLoader_instacne,
methodName, methodParam));
return result;
@SuppressWarnings("unchecked")
public Map<String, Object> getSqlStatData(Integer id) {
return (Map<String, Object>) mergeStatData("getSqlStatData", id);
@SuppressWarnings("unchecked")
public Map<String, Object> getDataSourceStatData(Integer id) {
return (Map<String, Object>) mergeStatData("getDataSourceStatData", id);
@SuppressWarnings("unchecked")
public Map<String, Object> returnJSONBasicStat() {
return (Map<String, Object>) mergeStatData("returnJSONBasicStat", null);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getSqlStatDataList() {
return (List<Map<String, Object>>) mergeStatData("getSqlStatDataList", null);
@SuppressWarnings("unchecked")
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return (List<String>) mergeStatData("getActiveConnectionStackTraceByDataSourceId", id);
@SuppressWarnings("unchecked")
public List<Object> getDataSourceStatList() {
return (List<Object>) mergeStatData("getDataSourceStatList", null);
@SuppressWarnings("unchecked")
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return (List<Map<String, Object>>) mergeStatData("getPoolingConnectionInfoByDataSourceId", id);
public Object getDruidDataSourceById(Integer id) {
return mergeStatData("getDruidDataSourceById", id);
public Object getSqlStatById(Integer id) {
return mergeStatData("getSqlStatById", id);
public void resetAll() {
mergeStatData("resetAll", null);
public class ReflectHelper {
private final static List<Object>                             list     = new ArrayList<Object>();
private final static HashMap<Object, HashMap<String, Method>> methodHM = new HashMap<Object, HashMap<String, Method>>();
private ReflectHelper(){
private static ReflectHelper instance = new ReflectHelper();
public static ReflectHelper getInstance() {
return instance;
public Object invoke(Object obj, String methodName, Integer id) {
Object target = null;
int objIndex = list.indexOf(obj);
if (objIndex != -1) {
target = list.get(objIndex);
target = obj;
HashMap<String, Method> h = methodHM.get(target);
boolean existsMethod = h.containsKey(methodName);
Method method = null;
if (existsMethod) {
method = h.get(methodName);
return ReflectionUtils.callObjectMethod(target, method, id);
method = ReflectionUtils.getObjectMethod(target, methodName, id);
final HashMap<String, Method> hm = new HashMap<String, Method>();
hm.put(methodName, method);
methodHM.put(target, hm);
return ReflectionUtils.callObjectMethod(target, method, id);
public abstract class ReflectStatStrategy {
public final static HashMap<Object, HashMap<String, Method>> methodHM = new HashMap<Object, HashMap<String, Method>>();
public abstract Object invoke(Object obj, String methodName, Integer id);
public class WebAppReflectStatStrategy extends ReflectStatStrategy {
public Object invoke(Object target, String methodName, Integer id) {
HashMap<String, Method> h = methodHM.get(target);
boolean existsMethod = h.containsKey(methodName);
Method method = null;
if (existsMethod) {
method = h.get(methodName);
return ReflectionUtils.callObjectMethod(target, method, id);
method = ReflectionUtils.getObjectMethod(target, methodName, id);
final HashMap<String, Method> hm = new HashMap<String, Method>();
hm.put(methodName, method);
methodHM.put(target, hm);
return ReflectionUtils.callObjectMethod(target, method, id);
public class WebContainerReflectStatStrategy extends ReflectStatStrategy {
public Object invoke(Object target, String methodName, Integer id) {
HashMap<String, Method> h = methodHM.get(target);
boolean existsMethod = h.containsKey(methodName);
Method method = null;
if (existsMethod) {
method = h.get(methodName);
return ReflectionUtils.callObjectMethod(target, method, id);
method = ReflectionUtils.getObjectMethod(target, methodName, id);
final HashMap<String, Method> hm = new HashMap<String, Method>();
hm.put(methodName, method);
methodHM.put(target, hm);
return ReflectionUtils.callObjectMethod(target, method, id);
public class DruidStatManagerFacade {
private final static DruidStatManagerFacade       instance = new DruidStatManagerFacade();
private static DruidDataSourceStatStrategyContext ctx      = null;
private static DruidDataSourceStatStrategy        strategy = null;
strategy = new DruidDataSourceStatJNDIStatStrategy();
ctx = new DruidDataSourceStatStrategyContext(strategy);
private DruidStatManagerFacade(){
public static DruidStatManagerFacade getInstance() {
return instance;
public Map<String, Object> getSqlStatData(Integer id) {
return ctx.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return ctx.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return ctx.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return ctx.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return ctx.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return ctx.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return ctx.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
ctx.resetAll();
public Object getDruidDataSourceById(Integer id) {
return ctx.getDruidDataSourceById(id);
public Object getSqlStatById(Integer id) {
return ctx.getSqlStatById(id);
public class DruidStatManagerFacade {
private final static DruidStatManagerFacade       instance = new DruidStatManagerFacade();
private static DruidDataSourceStatStrategyContext ctx      = null;
private static DruidDataSourceStatStrategy        strategy = null;
strategy = new DruidDataSourceStatReflectStatStrategy();
ctx = new DruidDataSourceStatStrategyContext(strategy);
private DruidStatManagerFacade(){
public static DruidStatManagerFacade getInstance() {
return instance;
public Map<String, Object> getSqlStatData(Integer id) {
return ctx.getSqlStatData(id);
public List<Map<String, Object>> getSqlStatDataList() {
return ctx.getSqlStatDataList();
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
return ctx.getActiveConnectionStackTraceByDataSourceId(id);
public Map<String, Object> returnJSONBasicStat() {
return ctx.returnJSONBasicStat();
public List<Object> getDataSourceStatList() {
return ctx.getDataSourceStatList();
public Map<String, Object> getDataSourceStatData(Integer id) {
return ctx.getDataSourceStatData(id);
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
return ctx.getPoolingConnectionInfoByDataSourceId(id);
public void resetAll() {
ctx.resetAll();
public Object getDruidDataSourceById(Integer id) {
return ctx.getDruidDataSourceById(id);
public Object getSqlStatById(Integer id) {
return ctx.getSqlStatById(id);
public class DruidStatManagerFacade {
private final static DruidStatManagerFacade instance = new DruidStatManagerFacade();
private DruidStatManagerFacade(){
public static DruidStatManagerFacade getInstance() {
return instance;
private Set<Object> getDruidDataSourceInstances() {
return DruidDataSourceStatManager.getInstances().keySet();
public void resetDataSourceStat() {
DruidDataSourceStatManager.getInstance().reset();
public void resetSqlStat() {
JdbcStatManager.getInstance().reset();
public void resetAll() {
resetSqlStat();
resetDataSourceStat();
public Object getSqlStatById(Integer id) {
for (Object ds : getDruidDataSourceInstances()) {
Object sqlStat = DruidDataSourceUtils.getSqlStat(ds, id);
if (sqlStat != null) {
return sqlStat;
return null;
public Map<String, Object> getDataSourceStatData(Integer id) {
if (id == null) {
return null;
Object datasource = getDruidDataSourceById(id);
return datasource == null ? null : dataSourceToMapData(datasource);
public Object getDruidDataSourceById(Integer identity) {
if (identity == null) {
return null;
for (Object datasource : getDruidDataSourceInstances()) {
if (System.identityHashCode(datasource) == identity) {
return datasource;
return null;
public List<Map<String, Object>> getSqlStatDataList() {
List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
for (Object datasource : getDruidDataSourceInstances()) {
for (Object sqlStat : DruidDataSourceUtils.getSqlStatMap(datasource).values()) {
Map<String, Object> data = JdbcSqlStatUtils.getData(sqlStat);
long executeCount = (Long) data.get("ExecuteCount");
long runningCount = (Long) data.get("RunningCount");
if (executeCount == 0 && runningCount == 0) {
result.add(data);
return result;
public Map<String, Object> getSqlStatData(Integer id) {
if (id == null) {
return null;
Object sqlStat = getSqlStatById(id);
if (sqlStat == null) {
return null;
return JdbcSqlStatUtils.getData(sqlStat);
public List<Object> getDataSourceStatList() {
List<Object> datasourceList = new ArrayList<Object>();
for (Object dataSource : getDruidDataSourceInstances()) {
datasourceList.add(dataSourceToMapData(dataSource));
return datasourceList;
public Map<String, Object> returnJSONBasicStat() {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("Version", VERSION.getVersionNumber());
dataMap.put("Drivers", getDriversData());
return dataMap;
private List<String> getDriversData() {
List<String> drivers = new ArrayList<String>();
for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
Driver driver = e.nextElement();
drivers.add(driver.getClass().getName());
return drivers;
public List<Map<String, Object>> getPoolingConnectionInfoByDataSourceId(Integer id) {
Object datasource = getDruidDataSourceById(id);
if (datasource == null) {
return null;
return DruidDataSourceUtils.getPoolingConnectionInfo(datasource);
public List<String> getActiveConnectionStackTraceByDataSourceId(Integer id) {
Object datasource = getDruidDataSourceById(id);
if (datasource == null || DruidDataSourceUtils.isRemoveAbandoned(datasource)) {
return null;
return DruidDataSourceUtils.getActiveConnectionStackTrace(datasource);
private Map<String, Object> dataSourceToMapData(Object dataSource) {
return DruidDataSourceUtils.getStatData(dataSource);
final long startNano = System.nanoTime();
statementStat.setLastExecuteStartNano(startNano);
boolean inTransaction = false;
inTransaction = !statement.getConnectionProxy().getAutoCommit();
} catch (SQLException e) {
LOG.error("getAutoCommit error", e);
if (inTransaction) {
sqlStat.incrementInTransactionCount();
StatFilterContext.getInstance().executeBefore(sql, inTransaction);
final long nowNano = System.nanoTime();
final long nanoSpan = nowNano - entry.getLastExecuteStartNano();
StringBuilder buf = buildSlowParameters(statement);
String sql = statement.getLastExecuteSql();
StatFilterContext.getInstance().executeAfter(sql, nanoSpan, null);
StatFilterContext.getInstance().executeAfter(sql, nanoSpan, error);
private StringBuilder buildSlowParameters(StatementProxy statement) {
StringBuilder buf = new StringBuilder();
buf.append('[');
int index = 0;
for (JdbcParameter parameter : statement.getParameters().values()) {
if (index != 0) {
buf.append(',');
Object value = parameter.getValue();
if (value == null) {
buf.append("null");
} else if (value instanceof String) {
buf.append('"');
String text = (String) value;
if (text.length() > 100) {
for (int i = 0; i < 97; ++i) {
char ch = text.charAt(i);
if (ch == ''') {
buf.append('\');
buf.append(ch);
buf.append(ch);
buf.append("...");
for (int i = 0; i < text.length(); ++i) {
char ch = text.charAt(i);
if (ch == ''') {
buf.append('\');
buf.append(ch);
buf.append(ch);
buf.append('"');
} else if (value instanceof Number) {
buf.append(value.toString());
} else if (value instanceof java.util.Date) {
java.util.Date date = (java.util.Date) value;
buf.append(date.getClass().getSimpleName());
buf.append('(');
buf.append(date.getTime());
buf.append(')');
} else if (value instanceof Boolean) {
buf.append(value.toString());
} else if (value instanceof InputStream) {
buf.append("<InputStream>");
} else if (value instanceof Clob) {
buf.append("<Clob>");
} else if (value instanceof NClob) {
buf.append("<NClob>");
} else if (value instanceof Blob) {
buf.append("<Blob>");
buf.append('<');
buf.append(value.getClass().getName());
buf.append('>');
buf.append(']');
return buf;
private List<StatFilterContextListener> listeners = new CopyOnWriteArrayList<StatFilterContextListener>();
private static final StatFilterContext  instance  = new StatFilterContext();
public void addUpdateCount(int updateCount) {
public void addFetchRowCount(int fetchRowCount) {
public void executeBefore(String sql, boolean inTransaction) {
public void executeAfter(String sql, long nanoSpan, Throwable error) {
public void commit() {
public void rollback() {
void executeBefore(String sql, boolean inTransaction);
void executeAfter(String sql, long nanoSpan, Throwable error);
void commit();
void rollback();
public class StatFilterContextListenerAdapter implements StatFilterContextListener {
public void addUpdateCount(int updateCount) {
public void addFetchRowCount(int fetchRowCount) {
public void executeBefore(String sql, boolean inTransaction) {
public void executeAfter(String sql, long nanoSpan, Throwable error) {
public void commit() {
public void rollback() {
WebAppStatManager.getInstance().addWebAppStatSet(webAppStat);
if (webAppStat != null) {
WebAppStatManager.getInstance().remove(webAppStat);
class WebStatFilterContextListener extends StatFilterContextListenerAdapter {
public void executeBefore(String sql, boolean inTransaction) {
WebURIStat stat = WebURIStat.current();
if (stat != null) {
stat.incrementJdbcExecuteCount();
public void executeAfter(String sql, long nanoSpan, Throwable error) {
public void commit() {
WebURIStat stat = WebURIStat.current();
if (stat != null) {
stat.incrementJdbcCommitCount();
public void rollback() {
WebURIStat stat = WebURIStat.current();
if (stat != null) {
stat.incrementJdbcRollbackCount();
private final AtomicLong                        requestCount               = new AtomicLong(0);
private String                                  contextPath;
public WebAppStat(){
public WebAppStat(String contextPath){
this.contextPath = contextPath;
public String getContextPath() {
return contextPath;
requestCount.incrementAndGet();
public int getRunningCount() {
return this.runningCount.get();
public long getConcurrentMax() {
return concurrentMax.get();
public long getRequestCount() {
return requestCount.get();
public Map<String, Object> getStatData() {
Map<String, Object> data = new LinkedHashMap<String, Object>();
data.put("ContextPath", this.getContextPath());
data.put("RunningCount", this.getRunningCount());
data.put("ConcurrentMax", this.getConcurrentMax());
data.put("RequestCount", this.getRequestCount());
List<Map<String, Object>> uriStatDataList = new ArrayList<Map<String, Object>>(this.uriStatMap.size());
for (WebURIStat uriStat : this.uriStatMap.values()) {
Map<String, Object> uriStatData = uriStat.getStatData();
long runningCount = (Long) uriStatData.get("RunningCount");
long requestCount = (Long) uriStatData.get("RequestCount");
if (runningCount == 0 && requestCount == 0) {
uriStatDataList.add(uriStatData);
data.put("URIList", uriStatDataList);
return data;
public class WebAppStatManager {
public final static String             SYS_PROP_INSTANCES = "druid.web.webAppStat";
private final static WebAppStatManager instance           = new WebAppStatManager();
private Set<Object>                    webAppStatSet      = null;
public static WebAppStatManager getInstance() {
return instance;
public Set<Object> getWebAppStatSet() {
if (webAppStatSet == null) {
webAppStatSet = getWebAppStatSet0();
return webAppStatSet;
public void addWebAppStatSet(Object webAppStat) {
getWebAppStatSet().add(webAppStat);
public boolean remove(Object webAppStat) {
return getWebAppStatSet().remove(webAppStat);
@SuppressWarnings("unchecked")
static Set<Object> getWebAppStatSet0() {
Properties properties = System.getProperties();
Set<Object> webAppStats = (Set<Object>) properties.get(SYS_PROP_INSTANCES);
if (webAppStats == null) {
synchronized (properties) {
webAppStats = (Set<Object>) properties.get(SYS_PROP_INSTANCES);
if (webAppStats == null) {
webAppStats = new CopyOnWriteArraySet<Object>();
properties.put(SYS_PROP_INSTANCES, webAppStats);
return webAppStats;
static class RequestStat {
long jdbcExecuteCount;
long jdbcUpdateCount;
long jdbcFetchRowCount;
private final AtomicLong                     requestCount      = new AtomicLong(0);
private final AtomicLong                     jdbcFetchRowPeak  = new AtomicLong();              
private final AtomicLong                     jdbcUpdatePeak    = new AtomicLong();              
private final AtomicLong                     jdbcExecutePeak   = new AtomicLong();              
private static ThreadLocal<RequestStat>      localRequestStat  = new ThreadLocal<RequestStat>();
localRequestStat.set(new RequestStat());
requestCount.incrementAndGet();
RequestStat localStat = localRequestStat.get();
if (localStat != null) {
long fetchRowCount = localStat.jdbcFetchRowCount;
for (;;) {
long peak = jdbcFetchRowPeak.get();
if (fetchRowCount <= peak) {
if (jdbcFetchRowPeak.compareAndSet(peak, fetchRowCount)) {
long executeCount = localStat.jdbcExecuteCount;
for (;;) {
long peak = jdbcExecutePeak.get();
if (executeCount <= peak) {
if (jdbcExecutePeak.compareAndSet(peak, executeCount)) {
long updateCount = localStat.jdbcUpdateCount;
for (;;) {
long peak = jdbcUpdatePeak.get();
if (updateCount <= peak) {
if (jdbcUpdatePeak.compareAndSet(peak, updateCount)) {
localRequestStat.set(null);
public int getRunningCount() {
return this.runningCount.get();
public long getConcurrentMax() {
return concurrentMax.get();
public long getRequestCount() {
return requestCount.get();
RequestStat localStat = localRequestStat.get();
if (localStat != null) {
localStat.jdbcFetchRowCount += delta;
RequestStat localStat = localRequestStat.get();
if (localStat != null) {
localStat.jdbcExecuteCount += updateCount;
public long getJdbcUpdatePeak() {
return jdbcUpdatePeak.get();
RequestStat localStat = localRequestStat.get();
if (localStat != null) {
localStat.jdbcExecuteCount++;
public long getJdbcExecutePeak() {
return jdbcExecutePeak.get();
public Map<String, Object> getStatData() {
Map<String, Object> data = new LinkedHashMap<String, Object>();
data.put("URI", this.getUri());
data.put("RunningCount", this.getRunningCount());
data.put("ConcurrentMax", this.getConcurrentMax());
data.put("RequestCount", this.getRequestCount());
data.put("JdbcCommitCount", this.getJdbcCommitCount());
data.put("JdbcRollbackCount", this.getJdbcRollbackCount());
data.put("JdbcExecuteCount", this.getJdbcExecuteCount());
data.put("JdbcExecutePeak", this.getJdbcExecutePeak());
data.put("JdbcFetchRowCount", this.getJdbcFetchRowCount());
data.put("JdbcFetchRowPeak", this.getJdbcFetchRowPeak());
data.put("JdbcUpdateCount", this.getJdbcUpdateCount());
data.put("JdbcUpdatePeak", this.getJdbcUpdatePeak());
return data;
public List<Map<String, Object>> getWebAppStatData() {
Set<Object> stats = getWebAppStatSet();
List<Map<String, Object>> statDataList = new ArrayList<Map<String, Object>>(stats.size());
for (Object stat : stats) {
Map<String, Object> statData = WebAppStatUtils.getStatData(stat);
statDataList.add(statData);
return statDataList;
public class WebAppStatUtils {
private final static Log LOG = LogFactory.getLog(WebAppStatUtils.class);
@SuppressWarnings("unchecked")
public static Map<String, Object> getStatData(Object webStat) {
Method method = webStat.getClass().getMethod("getStatData");
Object obj = method.invoke(webStat);
return (Map<String, Object>) obj;
} catch (Exception e) {
LOG.error("getStatData error", e);
return null;
List<Map<String, Object>> array = WebAppStatManager.getInstance().getURIStatData();
List<Map<String, Object>> uriStatDataList = getURIStatDataList();
data.put("URIList", uriStatDataList);
return data;
public List<Map<String, Object>> getURIStatDataList() {
return uriStatDataList;
public List<Map<String, Object>> getURIStatData() {
Set<Object> stats = getWebAppStatSet();
List<Map<String, Object>> allAppUriStatDataList = new ArrayList<Map<String, Object>>();
for (Object stat : stats) {
List<Map<String, Object>> uriStatDataList = WebAppStatUtils.getURIStatDataList(stat);
allAppUriStatDataList.addAll(uriStatDataList);
return allAppUriStatDataList;
@SuppressWarnings("unchecked")
public static List<Map<String, Object>> getURIStatDataList(Object webStat) {
Method method = webStat.getClass().getMethod("getURIStatDataList");
Object obj = method.invoke(webStat);
return (List<Map<String, Object>>) obj;
} catch (Exception e) {
LOG.error("getURIStatDataList error", e);
return null;
currentLocal.set(null);
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.executeBefore(sql, inTransaction);
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.executeAfter(sql, nanoSpan, error);
public class DruidWebUtils {
public static String getRemoteAddr(HttpServletRequest request) {
String ip = request.getHeader("x-forwarded-for");
if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
ip = request.getHeader("Proxy-Client-IP");
if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
ip = request.getHeader("WL-Proxy-Client-IP");
if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
ip = request.getRemoteAddr();
return ip;
public class AntPathMatcher implements PatternMatcher {
public static final String DEFAULT_PATH_SEPARATOR = "/";
private String             pathSeparator          = DEFAULT_PATH_SEPARATOR;
public void setPathSeparator(String pathSeparator) {
this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);
public boolean isPattern(String path) {
return (path.indexOf('*') != -1 || path.indexOf('?') != -1);
public boolean matches(String pattern, String source) {
return match(pattern, source);
public boolean match(String pattern, String path) {
return doMatch(pattern, path, true);
public boolean matchStart(String pattern, String path) {
return doMatch(pattern, path, false);
protected boolean doMatch(String pattern, String path, boolean fullMatch) {
if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {
return false;
String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);
String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);
int pattIdxStart = 0;
int pattIdxEnd = pattDirs.length - 1;
int pathIdxStart = 0;
int pathIdxEnd = pathDirs.length - 1;
while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {
String patDir = pattDirs[pattIdxStart];
if ("**".equals(patDir)) {
if (!matchStrings(patDir, pathDirs[pathIdxStart])) {
return false;
pattIdxStart++;
pathIdxStart++;
if (pathIdxStart > pathIdxEnd) {
if (pattIdxStart > pattIdxEnd) {
return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));
if (!fullMatch) {
return true;
if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {
return true;
for (int i = pattIdxStart; i <= pattIdxEnd; i++) {
if (!pattDirs[i].equals("**")) {
return false;
return true;
} else if (pattIdxStart > pattIdxEnd) {
return false;
} else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {
return true;
while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {
String patDir = pattDirs[pattIdxEnd];
if (patDir.equals("**")) {
if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {
return false;
pattIdxEnd--;
pathIdxEnd--;
if (pathIdxStart > pathIdxEnd) {
for (int i = pattIdxStart; i <= pattIdxEnd; i++) {
if (!pattDirs[i].equals("**")) {
return false;
return true;
while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {
int patIdxTmp = -1;
for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {
if (pattDirs[i].equals("**")) {
patIdxTmp = i;
if (patIdxTmp == pattIdxStart + 1) {
pattIdxStart++;
continue;
int patLength = (patIdxTmp - pattIdxStart - 1);
int strLength = (pathIdxEnd - pathIdxStart + 1);
int foundIdx = -1;
strLoop: for (int i = 0; i <= strLength - patLength; i++) {
for (int j = 0; j < patLength; j++) {
String subPat = (String) pattDirs[pattIdxStart + j + 1];
String subStr = (String) pathDirs[pathIdxStart + i + j];
if (!matchStrings(subPat, subStr)) {
continue strLoop;
foundIdx = pathIdxStart + i;
if (foundIdx == -1) {
return false;
pattIdxStart = patIdxTmp;
pathIdxStart = foundIdx + patLength;
for (int i = pattIdxStart; i <= pattIdxEnd; i++) {
if (!pattDirs[i].equals("**")) {
return false;
return true;
private boolean matchStrings(String pattern, String str) {
char[] patArr = pattern.toCharArray();
char[] strArr = str.toCharArray();
int patIdxStart = 0;
int patIdxEnd = patArr.length - 1;
int strIdxStart = 0;
int strIdxEnd = strArr.length - 1;
boolean containsStar = false;
for (char aPatArr : patArr) {
if (aPatArr == '*') {
containsStar = true;
if (!containsStar) {
if (patIdxEnd != strIdxEnd) {
return false; 
for (int i = 0; i <= patIdxEnd; i++) {
ch = patArr[i];
if (ch != '?') {
if (ch != strArr[i]) {
return false;
return true; 
if (patIdxEnd == 0) {
return true; 
while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {
if (ch != '?') {
if (ch != strArr[strIdxStart]) {
return false;
patIdxStart++;
strIdxStart++;
if (strIdxStart > strIdxEnd) {
for (int i = patIdxStart; i <= patIdxEnd; i++) {
if (patArr[i] != '*') {
return false;
return true;
while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {
if (ch != '?') {
if (ch != strArr[strIdxEnd]) {
return false;
patIdxEnd--;
strIdxEnd--;
if (strIdxStart > strIdxEnd) {
for (int i = patIdxStart; i <= patIdxEnd; i++) {
if (patArr[i] != '*') {
return false;
return true;
while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
int patIdxTmp = -1;
for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {
if (patArr[i] == '*') {
patIdxTmp = i;
if (patIdxTmp == patIdxStart + 1) {
patIdxStart++;
continue;
int patLength = (patIdxTmp - patIdxStart - 1);
int strLength = (strIdxEnd - strIdxStart + 1);
int foundIdx = -1;
strLoop: for (int i = 0; i <= strLength - patLength; i++) {
for (int j = 0; j < patLength; j++) {
ch = patArr[patIdxStart + j + 1];
if (ch != '?') {
if (ch != strArr[strIdxStart + i + j]) {
continue strLoop;
foundIdx = strIdxStart + i;
if (foundIdx == -1) {
return false;
patIdxStart = patIdxTmp;
strIdxStart = foundIdx + patLength;
for (int i = patIdxStart; i <= patIdxEnd; i++) {
if (patArr[i] != '*') {
return false;
return true;
public String extractPathWithinPattern(String pattern, String path) {
String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);
String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);
StringBuilder buffer = new StringBuilder();
int puts = 0;
for (int i = 0; i < patternParts.length; i++) {
String patternPart = patternParts[i];
if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {
if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {
buffer.append(this.pathSeparator);
buffer.append(pathParts[i]);
for (int i = patternParts.length; i < pathParts.length; i++) {
if (puts > 0 || i > 0) {
buffer.append(this.pathSeparator);
buffer.append(pathParts[i]);
return buffer.toString();
public interface PatternMatcher {
boolean matches(String pattern, String source);
public class ServletPathMatcher implements PatternMatcher {
@Override
public boolean matches(String pattern, String source) {
if (pattern == null || source == null) {
return false;
pattern = pattern.trim();
source = source.trim();
if (pattern.endsWith("*")) {
int length = pattern.length() - 1;
if (source.length() >= length) {
if (pattern.substring(0, length).equals(source.substring(0, length))) {
return true;
} else if (pattern.startsWith("*")) {
int length = pattern.length() - 1;
if (source.length() >= length && source.endsWith(pattern.substring(1))) {
return true;
if (pattern.equals(source)) {
return true;
return false;
public static String[] tokenizeToStringArray(String str, String delimiters) {
return tokenizeToStringArray(str, delimiters, true, true);
@SuppressWarnings({ "unchecked", "rawtypes" })
public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens,
boolean ignoreEmptyTokens) {
if (str == null) {
return null;
StringTokenizer st = new StringTokenizer(str, delimiters);
List tokens = new ArrayList();
while (st.hasMoreTokens()) {
String token = st.nextToken();
if (trimTokens) {
token = token.trim();
if (!ignoreEmptyTokens || token.length() > 0) {
tokens.add(token);
return toStringArray(tokens);
@SuppressWarnings({ "unchecked", "rawtypes" })
public static String[] toStringArray(Collection collection) {
if (collection == null) {
return null;
return (String[]) collection.toArray(new String[collection.size()]);
public class ServletPathMathcherTest {
protected PatternMatcher pathMatcher = new ServletPathMatcher();
public void testStartsWithPattern() {
String[] bogusPatterns = { "/druid*", "/druid*/what*", "*/druid*" };
String[] bogusSources = { "/druid", "/druid/index.html", "/druid*/what/xyu" };
boolean result = false;
for (int i = 0; i < bogusSources.length; i++) {
for (int j = 0; j < bogusPatterns.length; j++) {
String bogusSource = bogusSources[i];
String bogusPattern = bogusPatterns[j];
if (pathMatcher.matches(bogusPattern, bogusSource)) {
result = true;
if (result == true) {
assertThat(true, equalTo(result));
result = false;
public void testEndsWithPattern() {
String[] bogusPatterns = { "*.html", "*.ico", "*.css" };
String[] bogusSources = { "/index.html", "/favicon.ico", "/druid.css" };
boolean result = false;
for (int i = 0; i < bogusSources.length; i++) {
for (int j = 0; j < bogusPatterns.length; j++) {
String bogusSource = bogusSources[i];
String bogusPattern = bogusPatterns[j];
if (pathMatcher.matches(bogusPattern, bogusSource)) {
result = true;
if (result == true) {
assertThat(true, equalTo(result));
result = false;
public void testEqualsPattern() {
String[] bogusPatterns = { "/index.html", "/favicon.ico", "/xyz" };
String[] bogusSources = { "/index.html", "/favicon.ico", "/xyz" };
boolean result = false;
for (int i = 0; i < bogusSources.length; i++) {
for (int j = 0; j < bogusPatterns.length; j++) {
String bogusSource = bogusSources[i];
String bogusPattern = bogusPatterns[j];
if (pathMatcher.matches(bogusPattern, bogusSource)) {
result = true;
if (result == true) {
assertThat(true, equalTo(result));
result = false;
public void testPatternPriority() {
String[] bogusPatterns = { "*html*", "/favicon.ico*", "*html" };
String[] bogusSources = { "*html/ok?", "/favicon.ico/ok?", "/index.html" };
boolean result = false;
for (int i = 0; i < bogusSources.length; i++) {
for (int j = 0; j < bogusPatterns.length; j++) {
String bogusSource = bogusSources[i];
String bogusPattern = bogusPatterns[j];
if (pathMatcher.matches(bogusPattern, bogusSource)) {
result = true;
if (result == true) {
assertThat(true, equalTo(result));
result = false;
protected PatternMatcher             pathMatcher               = new ServletPathMatcher();
private final String                 EXCLUSIONS                = "exclusions";
private Set<String>                  excludesPattern;
if (excludesPattern != null) {
for (String pattern : excludesPattern) {
if (pathMatcher.matches(pattern, requestURI)) {
chain.doFilter(request, response);
String exclusions = config.getInitParameter(EXCLUSIONS);
if (exclusions != null && exclusions.trim().length() != 0) {
excludesPattern = new HashSet<String>(Arrays.asList(exclusions.split("\s*,\s*")));
private String                       contextPath;
if (isExclusion(requestURI)) {
chain.doFilter(request, response);
public boolean isExclusion(String requestURI) {
if (excludesPattern == null) {
return false;
if (contextPath != null && requestURI.startsWith(contextPath)) {
requestURI = requestURI.substring(contextPath.length());
for (String pattern : excludesPattern) {
if (pathMatcher.matches(pattern, requestURI)) {
return true;
this.contextPath = DruidWebUtils.getContextPath(config.getServletContext());
webAppStat = new WebAppStat(contextPath);
private static String getContextPath_2_5(ServletContext context) {
String contextPath = context.getContextPath();
if (contextPath == null || contextPath.length() == 0) {
contextPath = "/";
return contextPath;
public static String getContextPath(ServletContext context) {
if (context.getMajorVersion() == 2 && context.getMinorVersion() < 5) {
return null;
return getContextPath_2_5(context);
} catch (NoSuchMethodError error) {
return null;
if(!requestURI.startsWith("/")) {
requestURI = "/" + requestURI;
if ("".equals(path)) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/index.html");
response.sendRedirect("druid/index.html");
if ("/".equals(path)) {
response.sendRedirect("index.html");
return comparatorOrderBy(array, parameters);
private List<Map<String,Object>> comparatorOrderBy(List<Map<String, Object>> array,Map<String, String> parameters){
private List<Map<String, Object>> getSqlStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = druidStatManager.getSqlStatDataList();
return comparatorOrderBy(array, parameters);
Throwable error = null;
} catch (IOException e) {
error = e;
} catch (ServletException e) {
error = e;
} catch (RuntimeException e) {
error = e;
} catch (Error e) {
error = e;
webAppStat.afterInvoke(error, nanoSpan);
sessionStat.afterInvoke(error, nanoSpan);
WebRequestStat localStat = WebRequestStat.current();
if (localStat != null) {
localStat.addJdbcUpdateCount(updateCount);
WebRequestStat localStat = WebRequestStat.current();
if (localStat != null) {
localStat.addJdbcFetchRowCount(fetchRowCount);
WebRequestStat localStat = WebRequestStat.current();
if (localStat != null) {
localStat.incrementJdbcExecuteCount();
WebRequestStat localStat = WebRequestStat.current();
if (localStat != null) {
localStat.incrementJdbcCommitCount();
WebRequestStat localStat = WebRequestStat.current();
if (localStat != null) {
localStat.incrementJdbcRollbackCount();
public void afterInvoke(Throwable error, long nanoSpan) {
uriStat.afterInvoke(error, nanoSpan);
private final AtomicLong    requestErrorCount    = new AtomicLong(0);
public void afterInvoke(Throwable error, long nanoSpan) {
public long getRequestErrorCount() {
return requestErrorCount.get();
private final AtomicInteger                  runningCount        = new AtomicInteger();
private final AtomicInteger                  concurrentMax       = new AtomicInteger();
private final AtomicLong                     requestCount        = new AtomicLong(0);
private final AtomicLong                     requestTimeNano     = new AtomicLong();
private final AtomicLong                     jdbcFetchRowCount   = new AtomicLong();
private final AtomicLong                     jdbcFetchRowPeak    = new AtomicLong();             
private final AtomicLong                     jdbcUpdateCount     = new AtomicLong();
private final AtomicLong                     jdbcUpdatePeak      = new AtomicLong();             
private final AtomicLong                     jdbcExecuteCount    = new AtomicLong();
private final AtomicLong                     jdbcExecutePeak     = new AtomicLong();             
private final AtomicLong                     jdbcExecuteTimeNano = new AtomicLong();
private final AtomicLong                     jdbcCommitCount     = new AtomicLong();
private final AtomicLong                     jdbcRollbackCount   = new AtomicLong();
private final static ThreadLocal<WebURIStat> currentLocal        = new ThreadLocal<WebURIStat>();
public void afterInvoke(Throwable error, long nanoSpan) {
requestTimeNano.addAndGet(nanoSpan);
this.addJdbcFetchRowCount(fetchRowCount);
this.addJdbcExecuteCount(executeCount);
this.addJdbcUpdateCount(updateCount);
public long getRequestTimeNano() {
return requestTimeNano.get();
public long getRequestTimeMillis() {
return getRequestTimeNano() / (1000 * 1000);
public void addJdbcUpdateCount(long updateCount) {
public void addJdbcExecuteCount(long executeCount) {
jdbcExecuteCount.addAndGet(executeCount);
public long getJdbcExecuteTimeMillis() {
return getJdbcExecuteTimeNano() / (1000 * 1000);
public long getJdbcExecuteTimeNano() {
return jdbcExecuteTimeNano.get();
data.put("RequestTimeMillis", this.getRequestTimeMillis());
data.put("JdbcExecuteTimeMillis", this.getJdbcExecuteTimeMillis());
WebAppStatUtils.reset(stat);
public static void reset(Object webStat) {
Method method = webStat.getClass().getMethod("reset");
SpringStatUtils.reset(stat);
public static void reset(Object webStat) {
Method method = webStat.getClass().getMethod("reset");
private String       className;
private String       methodName;
private final String signature;
this.className = instanceClass.getName();
this.methodName = method.getName();
signature = getMethodSignature(method);
public String getClassName() {
return className;
public void setClassName(String className) {
this.className = className;
public String getMethodName() {
return methodName;
public void setMethodName(String methodName) {
this.methodName = methodName;
result = prime * result + ((className == null) ? 0 : className.hashCode());
result = prime * result + ((signature == null) ? 0 : signature.hashCode());
if (className == null) {
if (other.className != null) {
return false;
} else if (!className.equals(other.className)) {
if (signature == null) {
if (other.signature != null) {
return false;
} else if (!signature.equals(other.signature)) {
data.put("Class", this.getMethodInfo().getClassName());
private boolean                    pooling                  = false;
public boolean isPooling() {
return pooling;
public void setPooling(boolean pooling) {
this.pooling = pooling;
oldHolder.setPooling(false);
holder.setPooling(true);
holder.setPooling(false);
public int size() {
return this.map.size();
public class PSCacheTest3 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:x1");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(3);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_pscache() throws Exception {
DruidPooledConnection conn = dataSource.getConnection();
ConnectionHolder holder = conn.getConnectionHolder();
PreparedStatementPool stmtPool = holder.getStatementPool();
final String sql_0 = "select 0";
final String sql_1 = "select 1";
final String sql_2 = "select 2";
final String sql_3 = "select 3";
final String sql_4 = "select 4";
Assert.assertEquals(0, stmtPool.size());
PreparedStatementHolder stmtHoler_0;
PreparedStatementHolder stmtHoler_1;
PreparedStatementHolder stmtHoler_2;
PreparedStatementHolder stmtHoler_3;
PreparedStatementHolder stmtHoler_4;
DruidPooledPreparedStatement stmt_0 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_0);
Assert.assertFalse(stmt_0.getPreparedStatementHolder().isPooling());
stmt_0.close();
Assert.assertEquals(1, stmtPool.size());
Assert.assertTrue(stmt_0.getPreparedStatementHolder().isPooling());
DruidPooledPreparedStatement stmt_0 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_0);
Assert.assertEquals(1, stmtPool.size());
Assert.assertTrue(stmt_0.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_0.getPreparedStatementHolder().isPooling());
stmt_0.close();
Assert.assertFalse(stmt_0.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_0.getPreparedStatementHolder().isPooling());
Assert.assertEquals(1, stmtPool.size());
DruidPooledPreparedStatement stmt_0 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_0);
stmtHoler_0 = stmt_0.getPreparedStatementHolder();
Assert.assertTrue(stmtHoler_0.isInUse());
Assert.assertTrue(stmtHoler_0.isPooling());
stmt_0.execute();
DruidPooledPreparedStatement stmt_1 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_1);
Assert.assertEquals(1, stmtPool.size());
stmtHoler_1 = stmt_1.getPreparedStatementHolder();
Assert.assertTrue(stmt_1.getPreparedStatementHolder().isInUse());
Assert.assertFalse(stmt_1.getPreparedStatementHolder().isPooling());
stmt_1.close();
Assert.assertFalse(stmt_1.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_1.getPreparedStatementHolder().isPooling());
Assert.assertTrue(stmt_1.getPreparedStatementHolder().isPooling());
Assert.assertEquals(2, stmtPool.size());
Assert.assertTrue(stmtHoler_0.isPooling());
Assert.assertTrue(stmtHoler_1.isPooling());
DruidPooledPreparedStatement stmt_2 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_2);
Assert.assertEquals(2, stmtPool.size());
stmtHoler_2 = stmt_2.getPreparedStatementHolder();
Assert.assertTrue(stmt_2.getPreparedStatementHolder().isInUse());
Assert.assertFalse(stmt_2.getPreparedStatementHolder().isPooling());
stmt_2.close();
Assert.assertFalse(stmt_2.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_2.getPreparedStatementHolder().isPooling());
Assert.assertTrue(stmt_2.getPreparedStatementHolder().isPooling());
Assert.assertEquals(3, stmtPool.size());
Assert.assertTrue(stmtHoler_0.isPooling());
Assert.assertTrue(stmtHoler_1.isPooling());
Assert.assertTrue(stmtHoler_2.isPooling());
DruidPooledPreparedStatement stmt_3 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_3);
Assert.assertEquals(3, stmtPool.size());
stmtHoler_3 = stmt_3.getPreparedStatementHolder();
Assert.assertTrue(stmt_3.getPreparedStatementHolder().isInUse());
Assert.assertFalse(stmt_3.getPreparedStatementHolder().isPooling());
stmt_3.close();
Assert.assertFalse(stmt_3.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_3.getPreparedStatementHolder().isPooling());
Assert.assertTrue(stmt_3.getPreparedStatementHolder().isPooling());
Assert.assertEquals(3, stmtPool.size());
Assert.assertFalse(stmtHoler_0.isPooling());
Assert.assertTrue(stmtHoler_1.isPooling());
Assert.assertTrue(stmtHoler_2.isPooling());
Assert.assertTrue(stmtHoler_3.isPooling());
DruidPooledPreparedStatement stmt_4 = (DruidPooledPreparedStatement) conn.prepareStatement(sql_4);
Assert.assertEquals(3, stmtPool.size());
stmtHoler_4 = stmt_4.getPreparedStatementHolder();
Assert.assertTrue(stmt_4.getPreparedStatementHolder().isInUse());
Assert.assertFalse(stmt_4.getPreparedStatementHolder().isPooling());
stmt_4.close();
Assert.assertFalse(stmt_4.getPreparedStatementHolder().isInUse());
Assert.assertTrue(stmt_4.getPreparedStatementHolder().isPooling());
Assert.assertTrue(stmt_4.getPreparedStatementHolder().isPooling());
Assert.assertEquals(3, stmtPool.size());
Assert.assertFalse(stmtHoler_0.isPooling());
Assert.assertFalse(stmtHoler_1.isPooling());
Assert.assertTrue(stmtHoler_2.isPooling());
Assert.assertTrue(stmtHoler_3.isPooling());
Assert.assertTrue(stmtHoler_4.isPooling());
stmt_0.close();
Assert.assertTrue(stmtHoler_0.isPooling());
Assert.assertFalse(stmtHoler_1.isPooling());
Assert.assertFalse(stmtHoler_2.isPooling());
Assert.assertTrue(stmtHoler_3.isPooling());
Assert.assertTrue(stmtHoler_4.isPooling());
conn.close();
public final static int                         DEFAULT_MAX_STAT_SESSION_COUNT = 1000;
private final LRUCache<String, WebSessionStat>  sessionStatMap;
sessionStatLock.readLock().lock();
Iterator<Map.Entry<String, WebSessionStat>> iter = sessionStatMap.entrySet().iterator();
while (iter.hasNext()) {
Map.Entry<String, WebSessionStat> entry = iter.next();
entry.getValue().reset();
sessionStatLock.readLock().unlock();
private final AtomicLong    requestTimeNano      = new AtomicLong();
private String              principal            = null;
public void reset() {
concurrentMax.set(0);
requestCount.set(0);
requestErrorCount.set(0);
requestTimeNano.set(0);
jdbcFetchRowCount.set(0);
jdbcUpdateCount.set(0);
jdbcExecuteCount.set(0);
jdbcExecuteTimeNano.set(0);
jdbcCommitCount.set(0);
jdbcRollbackCount.set(0);
remoteAddresses.clear();
principal = null;
public String getPrincipal() {
return principal;
public void setPrincipal(String principal) {
this.principal = principal;
data.put("Principal", this.getPrincipal());
if (responseWrapper.getStatus() == HttpServletResponse.SC_NOT_FOUND) {
public static final String           PARAM_NAME_PRINCIPAL_SESSION_NAME = "principalSessionName";
public static final String           PARAM_NAME_PRINCIPAL_COOKIE_NAME  = "principalCookieName";
buf.append(";");
data.put("Principal", this.getPrincipal());
private String                        permittedIp;
private Pattern                       ipCheckPattern;
permittedIp = getServletConfig().getInitParameter("permittedIp");
if (permittedIp != null ) {
this.ipCheckPattern = IpUtils.buildIpCheckPattern(permittedIp);
private boolean isPermittedRequest(HttpServletRequest request) {
if (permittedIp == null || permittedIp.trim().equals("")) {
return true;
String remoteIp = request.getRemoteAddr();
Matcher matcher =  ipCheckPattern.matcher(remoteIp);
return matcher.matches();
if (!isPermittedRequest(request)) {
path = "/nopermit.html";
returnResourceFile(path, uri, response);
public class IpUtils {
public static Pattern buildIpCheckPattern(String permittedIP) {
String[] addrs = permittedIP.split(",");
StringBuilder sb = new StringBuilder();
for (String addr : addrs ) {
addr = addr.trim();
addr = addr.replace("*", "\d{1,3}");
sb.append(addr.trim()).append("|");
return Pattern.compile(sb.toString());
public class IpUtilsTest {
public void testBuildIpCheckPattern() {
Pattern pat = IpUtils.buildIpCheckPattern("192.168.0.*");
String[] validIps = {"192.168.0.1", "192.168.0.2","192.168.0.15","192.168.0.250"};
String[] inValidIps = {"192.168.15.1", "192.168.7.1","10.8.9.25","168.2.3.10"};
checkIp(pat, validIps, inValidIps);
pat = IpUtils.buildIpCheckPattern("192.168.0.1");
validIps = new String[] {"192.168.0.1"};
inValidIps = new String[] {"192.168.0.2", "192.168.1.0","10.15.255.3"};
checkIp(pat, validIps, inValidIps);
pat = IpUtils.buildIpCheckPattern("192.168.0.1,192.168.0.2,192.168.1.*");
validIps = new String[] {"192.168.0.1","192.168.0.2","192.168.1.15"};
inValidIps = new String[] {"192.168.0.3", "192.168.10.2","10.15.255.3","16.8.155.3"};
checkIp(pat, validIps, inValidIps);
private void  checkIp(Pattern pat, String[] validIps, String[] inValidIps) {
Matcher matcher = null;
for (String validIp : validIps) {
matcher = pat.matcher(validIp);
Assert.assertTrue(matcher.matches());
for (String inValidIp : inValidIps) {
matcher = pat.matcher(inValidIp);
Assert.assertFalse(matcher.matches());
public void insert(Connection conn, String sql, Object... parameters) throws SQLException {
insert(conn, sql, Arrays.asList(parameters));
public List<Map<String, Object>> select(String sql, Object... parameters) throws SQLException {
return select(sql, Arrays.asList(parameters));
public int delete(String sql, Object... parameters) throws SQLException {
return delete(sql, Arrays.asList(parameters));
public void insert(String sql, Object... parameters) throws SQLException {
insert(sql, Arrays.asList(parameters));
public static void execute(DataSource dataSource, String sql, Object... parameters) throws SQLException {
execute(dataSource, sql, Arrays.asList(parameters));
public class MySqlMappingEngineTest extends TestCase {
private DruidDataSource dataSource;
private MappingEngine   mapping = new MappingEngine();
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setMinIdle(1);
dataSource.setUrl("jdbc:h2:mem:test;");
dataSource.setTestOnBorrow(false);
JdbcUtils.execute(dataSource, "CREATE TABLE user (id INT, name VARCHAR(40))");
mapping.setDataSource(dataSource);
protected void tearDown() throws Exception {
JdbcUtils.execute(dataSource, "DROP TABLE user");
JdbcUtils.close(dataSource);
public void test_curd() throws Exception {
List<Map<String, Object>> list = mapping.select("select * from user");
Assert.assertEquals(0, list.size());
mapping.insert("insert into user (id, name) values (?, ?)", 123, "wenshao");
List<Map<String, Object>> list = mapping.select("select * from user");
Assert.assertEquals(1, list.size());
Map<String, Object> data = list.get(0);
Assert.assertEquals(123, data.get("ID"));
Assert.assertEquals("wenshao", data.get("NAME"));
List<Map<String, Object>> list = mapping.select("select id "id", name "name" from user");
Assert.assertEquals(1, list.size());
Map<String, Object> data = list.get(0);
Assert.assertEquals(123, data.get("id"));
Assert.assertEquals("wenshao", data.get("name"));
mapping.delete("delete from user");
List<Map<String, Object>> list = mapping.select("select * from user");
Assert.assertEquals(0, list.size());
public void insertToTable(String tableName, Map<String, Object> map) throws SQLException {
StringBuilder sql = new StringBuilder() 
.append("insert into ") 
.append(tableName) 
.append("("); 
int nameCount = 0;
for (String name : map.keySet()) {
if (nameCount > 0) {
sql.append(",");
sql.append(name);
nameCount++;
sql.append(") values (");
for (int i = 0; i < nameCount; ++i) {
if (i != 0) {
sql.append(",");
sql.append("?");
sql.append(")");
List<Object> parameters = new ArrayList<Object>(map.values());
insert(sql.toString(), parameters);
public static int executeUpdate(DataSource dataSource, String sql, Object... parameters) throws SQLException {
return executeUpdate(dataSource, sql, Arrays.asList(parameters));
public static List<Map<String, Object>> executeQuery(DataSource dataSource, String sql, Object... parameters)
throws SQLException {
return executeQuery(dataSource, sql, Arrays.asList(parameters));
public static void insertToTable(DataSource dataSource, String tableName, Map<String, Object> data)
throws SQLException {
Connection conn = null;
conn = dataSource.getConnection();
insertToTable(conn, tableName, data);
} finally {
close(conn);
public static void insertToTable(Connection conn, String tableName, Map<String, Object> data) throws SQLException {
String sql = makeInsertToTableSql(tableName, data.keySet());
List<Object> parameters = new ArrayList<Object>(data.values());
execute(conn, sql, parameters);
public static String makeInsertToTableSql(String tableName, Collection<String> names) {
StringBuilder sql = new StringBuilder() 
.append("insert into ") 
.append(tableName) 
.append("("); 
int nameCount = 0;
for (String name : names) {
if (nameCount > 0) {
sql.append(",");
sql.append(name);
nameCount++;
sql.append(") values (");
for (int i = 0; i < nameCount; ++i) {
if (i != 0) {
sql.append(",");
sql.append("?");
sql.append(")");
return sql.toString();
public class JdbcUtilsTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setMinIdle(1);
dataSource.setUrl("jdbc:h2:mem:test;");
dataSource.setTestOnBorrow(false);
JdbcUtils.execute(dataSource, "CREATE TABLE user (id INT, name VARCHAR(40))");
protected void tearDown() throws Exception {
JdbcUtils.execute(dataSource, "DROP TABLE user");
JdbcUtils.close(dataSource);
public void test_curd() throws Exception {
List<Map<String, Object>> list = JdbcUtils.executeQuery(dataSource, "select * from user");
Assert.assertEquals(0, list.size());
Map<String, Object> data = new HashMap<String, Object>();
data.put("id", 123);
data.put("name", "");
JdbcUtils.insertToTable(dataSource, "user", data);
List<Map<String, Object>> list = JdbcUtils.executeQuery(dataSource, "select * from user");
Assert.assertEquals(1, list.size());
Map<String, Object> data = list.get(0);
Assert.assertEquals(123, data.get("ID"));
Assert.assertEquals("", data.get("NAME"));
List<Map<String, Object>> list = JdbcUtils.executeQuery(dataSource, "select id "id", name "name" from user");
Assert.assertEquals(1, list.size());
Map<String, Object> data = list.get(0);
Assert.assertEquals(123, data.get("id"));
Assert.assertEquals("", data.get("name"));
JdbcUtils.executeUpdate(dataSource, "delete from user");
List<Map<String, Object>> list = JdbcUtils.executeQuery(dataSource, "select * from user");
Assert.assertEquals(0, list.size());
return sql;
} catch (ParserException ex) {
LOG.warn("format error", ex);
return returnJSONSqlInfo(id);
private String returnJSONSqlInfo(Integer id) {
Map<String,Object> map = druidStatManager.getSqlStatData(id);
map.put("formattedSql",SQLUtils.format((String) map.get("SQL"),(String) map.get("DbType")));
List<SQLStatement> statementList = SQLUtils.parseStatements((String) map.get("SQL"), (String) map.get("DbType"));
if (!statementList.isEmpty()) {
SQLStatement statemen = statementList.get(0);
SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, (String) map.get("DbType"));
statemen.accept(visitor);
map.put("parsedTable", visitor.getTables().toString());
map.put("parsedFields", visitor.getColumns().toString());
map.put("parsedConditions", visitor.getConditions().toString());
map.put("parsedRelationships", visitor.getRelationships().toString());
map.put("parsedOrderbycolumns", visitor.getOrderByColumns().toString());
DateFormat format = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
map.put("MaxTimespanOccurTime", format.format(map.get("MaxTimespanOccurTime")));
return returnJSONResult(map == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, map);
returnViewSqlStat(id, request,response);
private void returnViewSqlStat(Integer id, HttpServletRequest request, HttpServletResponse response) throws IOException {
String text = IOUtils.readFromResource(RESOURCE_PATH + "/sqlDetail.html");
text = text.replaceAll("\{sqlId\}", id.toString());
response.getWriter().print(text);
public class ConfigTool {
public final static int DEFAULT_KEY_SIZE = 1024;
public static void main(String[] args) throws Exception {
if (args.length == 0) {
String command = args[0];
if ("-gen".equals(command)) {
int keySize = DEFAULT_KEY_SIZE;
if (args.length > 1) {
keySize = Integer.parseInt(args[1]);
Map<String, String> result = gen(keySize);
print(result);
if ("-encrypt".equals(command)) {
String privateKey = args[1];
String text = args[2];
Map<String, String> result = encrypt(privateKey, text);
print(result);
if ("-decrypt".equals(command)) {
String publicKey = args[1];
String text = args[2];
Map<String, String> result = decrypt(publicKey, text);
print(result);
public static void print(Map<String, String> map) {
for (Map.Entry<String, String> entry : map.entrySet()) {
System.out.print(entry.getKey());
System.out.print(" : ");
System.out.println();
System.out.print(entry.getValue());
System.out.println();
System.out.println();
public static Map<String, String> decrypt(String publicKeyString, String cipherText) throws Exception {
Map<String, String> map = new LinkedHashMap<String, String>();
byte[] publicKeyBytes = Base64.base64ToByteArray(publicKeyString);
X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyBytes);
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
PublicKey publicKey = keyFactory.generatePublic(x509KeySpec);
Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.DECRYPT_MODE, publicKey);
byte[] cipherBytes = Base64.base64ToByteArray(cipherText);
byte[] plainBytes = cipher.doFinal(cipherBytes);
String plainText = new String(plainBytes);
map.put("result", plainText);
return map;
public static Map<String, String> encrypt(String privateKeyString, String plain) throws Exception {
Map<String, String> map = new LinkedHashMap<String, String>();
byte[] privateKeyBytes = Base64.base64ToByteArray(privateKeyString);
PKCS8EncodedKeySpec x509KeySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
PrivateKey privateKey = keyFactory.generatePrivate(x509KeySpec);
Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.ENCRYPT_MODE, privateKey);
byte[] plainBytes = plain.getBytes();
byte[] cipherBytes = cipher.doFinal(plainBytes);
String cipherText = Base64.byteArrayToBase64(cipherBytes);
map.put("result", cipherText);
return map;
public static Map<String, String> gen(int keySize) throws Exception {
Map<String, String> map = new LinkedHashMap<String, String>();
KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
keyPairGen.initialize(512, new SecureRandom());
KeyPair keyPair = keyPairGen.generateKeyPair();
RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
map.put("privateKey", Base64.byteArrayToBase64(privateKey.getEncoded()));
map.put("publicKey", Base64.byteArrayToBase64(publicKey.getEncoded()));
return map;
public class ConfigToolTest extends TestCase {
public void test_configTool() throws Exception {
Map<String, String> result = ConfigTool.gen(1024);
String publicKey = result.get("publicKey");
String privateKey = result.get("privateKey");
System.out.println("publicKey : " + publicKey);
System.out.println("privateKey : " + privateKey);
String cipher = ConfigTool.encrypt(privateKey, "abcdef").get("result");
System.out.println("cipher : " + cipher);
String plain = ConfigTool.decrypt(publicKey, cipher).get("result");
System.out.println("plain : " + plain);
Assert.assertEquals("abcdef", plain);
public final static String URL_PREFIX           = "druid-configFile=";
public final static String SYS_PROP_CONFIG_FILE = "druid.configFile";
public final static String SYS_PROP_CONFIG_KEY  = "druid.configKey";
public final static String DEFAULT_ALGORITHM    = "RSA";
private final static Log   LOG                  = LogFactory.getLog(ConfigFilter.class);
String property = System.getProperty(SYS_PROP_CONFIG_KEY);
if (property != null && property.length() != 0) {
this.setKey(property);
filePath = System.getProperty(SYS_PROP_CONFIG_FILE);
if (this.encryptedPassword == null) {
public final static String URL_PREFIX                         = "druid-configFile=";
public final static String SYS_PROP_CONFIG_FILE               = "druid.config.file";
public final static String SYS_PROP_CONFIG_KEY                = "druid.config.key";
public final static String SYS_PROP_CONFIG_ENCRYPTED_PASSWORD = "druid.config.encryptedPassword";
public final static String DEFAULT_ALGORITHM                  = "RSA";
private final static Log   LOG                                = LogFactory.getLog(ConfigFilter.class);
String property = System.getProperty(SYS_PROP_CONFIG_KEY);
if (property != null && property.length() != 0) {
this.setKey(property);
String property = System.getProperty(SYS_PROP_CONFIG_ENCRYPTED_PASSWORD);
if (property != null && property.length() != 0) {
this.setEncryptedPassword(property);
public class ConfigLoadFilterTest4 extends TestCase {
private DruidDataSource dataSource;
private ConfigFilter    configFilter;
protected void setUp() throws Exception {
System.setProperty(ConfigFilter.SYS_PROP_CONFIG_KEY,
"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMmVkLy+Cy/3rQ1OyH7nz1tT8Bu2KEU+z5LbeZ1yue/RN4KlcOEalj/K9Ev05Lpfu9cOdYnYM8ka1MiQdHLyJP0CAwEAAQ==");
configFilter = new ConfigFilter();
configFilter.setEncryptedPassword("TFxB6eJcgxE1hxOgiwOC/L7zWR/9vnSIfpggI2PTfcvvRhSnCGCPwI9n03fiJiLmRdnDU2/KaVTJYwz8zzkBqg==");
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:config-3");
dataSource.setMaxActive(13);
dataSource.getProxyFilters().add(configFilter);
dataSource.setTestOnBorrow(false);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
System.clearProperty(ConfigFilter.SYS_PROP_CONFIG_KEY);
public void test_config() throws Exception {
dataSource.init();
Assert.assertEquals(13, dataSource.getMaxActive());
Assert.assertEquals("jdbc:mock:config-3", dataSource.getUrl());
Assert.assertEquals(MockDriver.instance, dataSource.getDriver());
Assert.assertEquals("abc", dataSource.getPassword());
Connection conn = dataSource.getConnection();
conn.close();
public class ConfigLoadFilterTest5 extends TestCase {
private DruidDataSource dataSource;
private ConfigFilter    configFilter;
protected void setUp() throws Exception {
System.setProperty(ConfigFilter.SYS_PROP_CONFIG_KEY,
"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMmVkLy+Cy/3rQ1OyH7nz1tT8Bu2KEU+z5LbeZ1yue/RN4KlcOEalj/K9Ev05Lpfu9cOdYnYM8ka1MiQdHLyJP0CAwEAAQ==");
System.setProperty(ConfigFilter.SYS_PROP_CONFIG_ENCRYPTED_PASSWORD,
"TFxB6eJcgxE1hxOgiwOC/L7zWR/9vnSIfpggI2PTfcvvRhSnCGCPwI9n03fiJiLmRdnDU2/KaVTJYwz8zzkBqg==");
configFilter = new ConfigFilter();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:config-3");
dataSource.setMaxActive(13);
dataSource.getProxyFilters().add(configFilter);
dataSource.setTestOnBorrow(false);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
System.clearProperty(ConfigFilter.SYS_PROP_CONFIG_KEY);
System.clearProperty(ConfigFilter.SYS_PROP_CONFIG_ENCRYPTED_PASSWORD);
public void test_config() throws Exception {
dataSource.init();
Assert.assertEquals(13, dataSource.getMaxActive());
Assert.assertEquals("jdbc:mock:config-3", dataSource.getUrl());
Assert.assertEquals(MockDriver.instance, dataSource.getDriver());
Assert.assertEquals("abc", dataSource.getPassword());
Connection conn = dataSource.getConnection();
conn.close();
dataSource.setFilters("config");
if (maxActive < this.minIdle) {
throw new IllegalArgumentException("maxActive less than minIdle, " + maxActive + " < " + this.minIdle);
if (maxActive == 0) {
throw new IllegalArgumentException("maxActive can't not set zero");
LOG.info("maxActive modified : " + this.maxActive + " -> " + maxActive);
dataSource.setMaxActive(2);
dataSource.shrink();
Assert.assertEquals(1, dataSource.getPoolingCount());
for (int i = 0; i < 10; ++i) {
Assert.assertEquals(2, connect(3));
Assert.assertEquals(2, dataSource.getPoolingCount());
dataSource.setMaxActive(1);
dataSource.shrink();
Assert.assertEquals(1, dataSource.getPoolingCount());
for (int i = 0; i < 10; ++i) {
Assert.assertEquals(1, connect(2));
Assert.assertEquals(1, dataSource.getPoolingCount());
Exception error = null;
dataSource.setMaxActive(0);
} catch (IllegalArgumentException e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getMaxActive());
void setMaxActive(int maxActive);
if (maxWaitMillis == this.maxWait) {
LOG.error("maxWait modified : " + this.maxWait + " -> " + maxWaitMillis);
public void setMinIdle(int value) {
if (value == this.minIdle) {
if (value > this.maxActive) {
throw new IllegalArgumentException("minIdle greater than maxActive, " + maxActive + " < " + this.minIdle);
LOG.error("minIdle modified : " + this.minIdle + " -> " + value);
this.minIdle = value;
if (maxActive < this.minIdle) {
throw new IllegalArgumentException("maxActive less than minIdle, " + maxActive + " < " + this.minIdle);
JdbcDataSourceStat stat = dataSource.getDataSourceStat();
Exception error = null;
dataSource.setMaxActive(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
error = null;
JdbcDataSourceStat stat = dataSource.getDataSourceStat();
public void test_change_maxWait() throws Exception {
dataSource.setMaxWait(1);
public void test_change_minIdle() throws Exception {
dataSource.setMinIdle(1);
if (map == null) {
return returnJSONResult(RESULT_CODE_ERROR , null);
Date maxTimespanOccurTime = (Date)map.get("MaxTimespanOccurTime");
if (maxTimespanOccurTime != null) {
map.put("MaxTimespanOccurTime", format.format(maxTimespanOccurTime));
public static boolean equals(String a, String b) {
if (a == null) {
return b == null;
return a.equals(b);
public void put(PreparedStatementHolder stmtHolder) throws SQLException {
PreparedStatement stmt = stmtHolder.getStatement();
stmtHolder.setEnterOracleImplicitCache(true);
stmtHolder.setEnterOracleImplicitCache(false);
PreparedStatementKey key = stmtHolder.getKey();
PreparedStatementHolder oldStmtHolder = map.put(key, stmtHolder);
if (oldStmtHolder == stmtHolder) {
if (oldStmtHolder != null) {
oldStmtHolder.setPooling(false);
closeRemovedStatement(oldStmtHolder);
if (stmtHolder.getHitCount() == 0) {
stmtHolder.setPooling(true);
if (stmtHolder.getStatement() instanceof PreparedStatementProxy) {
PreparedStatementProxy stmtProxy = (PreparedStatementProxy) stmtHolder.getStatement();
Assert.assertEquals(1, dataSource.getCachedPreparedStatementCount());
private final static Log             LOG                               = LogFactory.getLog(WebStatFilter.class);
for (int updateCount : updateCountArray) {
sqlStat.addUpdateCount(updateCount);
sqlStat.addFetchRowCount(0);
StatFilterContext.getInstance().addUpdateCount(updateCount);
@Deprecated
return this.mergeSql(sql, dbType);
public String mergeSql(String sql, String dbType) {
LOG.error("merge sql error, dbType " + dbType + ", sql : n" + sql, e);
DataSourceProxy dataSource = statement.getConnectionProxy().getDirectDataSource();
JdbcDataSourceStat dataSourceStat = dataSource.getDataSourceStat();
String dbType = this.dbType;
if (dbType == null) {
dbType = dataSource.getDbType();
sql = mergeSql(sql, dbType);
String errorUrl = contextPath + "error_" + status;
SimpleType.LONG, 
SimpleType.LONG, 
"ExecuteAndResultHoldTimeHistogram", 
"EffectedRowCountMax", 
"FetchRowCountMax"
map.put("EffectedRowCountMax", getUpdateCountMax());
map.put("FetchRowCountMax", getFetchRowCountMax());
if (!method.getParameterTypes()[i].getName().equals(other.method.getParameterTypes()[i].getName())) {
public class SpringMethodInfoTest extends TestCase {
public void test_equals() throws Exception {
SpringMethodInfo b1 = new SpringMethodInfo(B.class, B.class.getMethod("f", int.class));
SpringMethodInfo c = new SpringMethodInfo(C.class, C.class.getMethod("f", int.class));
SpringMethodInfo b2 = new SpringMethodInfo(B.class, B.class.getMethod("f", int.class));
Assert.assertFalse(b1.equals(c));
Assert.assertTrue(b1.equals(b1));
Assert.assertTrue(b1.equals(b2));
Assert.assertEquals(B.class.getName(), b1.getClassName());
Assert.assertEquals(C.class.getName(), c.getClassName());
public void test_get() throws Exception {
SpringStat springStat = new SpringStat();
SpringMethodInfo b1 = new SpringMethodInfo(B.class, B.class.getMethod("f", int.class));
SpringMethodInfo b2 = new SpringMethodInfo(B.class, B.class.getMethod("f", int.class));
SpringMethodStat methodStat1 = springStat.getMethodStat(b1, true);
SpringMethodStat methodStat2 = springStat.getMethodStat(b2, true);
Assert.assertSame(methodStat1, methodStat2);
public static class A {
public void f(int i) {
public static class B extends A {
public static class C extends A {
private final static DruidStatManagerFacade instance    = new DruidStatManagerFacade();
private boolean                             resetEnable = true;
private final AtomicLong                    resetCount  = new AtomicLong();
resetCount.incrementAndGet();
public boolean isResetEnable() {
return resetEnable;
public void setResetEnable(boolean resetEnable) {
this.resetEnable = resetEnable;
dataMap.put("ResetEnable", isResetEnable());
dataMap.put("ResetCount", getResetCount());
public long getResetCount() {
return resetCount.get();
private static DruidStatManagerFacade     statManagerFacade       = DruidStatManagerFacade.getInstance();
public boolean isResetEnable() {
return statManagerFacade.isResetEnable();
public void setResetEnable(boolean value) {
statManagerFacade.setResetEnable(value);
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.returnJSONBasicStat());
statManagerFacade.resetAll();
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.getDataSourceStatList());
Object result = statManagerFacade.getDataSourceStatData(id);
List<?> connectionInfoList = statManagerFacade.getPoolingConnectionInfoByDataSourceId(id);
return comparatorOrderBy(array, parameters);
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> comparatorOrderBy(List<Map<String, Object>> array, Map<String, String> parameters) {
List<Map<String, Object>> array = statManagerFacade.getSqlStatDataList();
Map<String, Object> map = statManagerFacade.getSqlStatData(id);
return returnJSONResult(RESULT_CODE_ERROR, null);
map.put("formattedSql", SQLUtils.format((String) map.get("SQL"), (String) map.get("DbType")));
DateFormat format = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
Date maxTimespanOccurTime = (Date) map.get("MaxTimespanOccurTime");
if (maxTimespanOccurTime != null) {
map.put("MaxTimespanOccurTime", format.format(maxTimespanOccurTime));
List<String> result = statManagerFacade.getActiveConnectionStackTraceByDataSourceId(id);
private final static Log     LOG                         = LogFactory.getLog(StatViewServlet.class);
private static final long    serialVersionUID            = 1L;
public static final String   PARAM_NAME_RESET_ENABLE     = "resetEnable";
public static final String   PARAM_NAME_ALLOW            = "allow";
public static final String   PARAM_NAME_DENY             = "deny";
private final static String  RESOURCE_PATH               = "support/http/resources";
private final static String  TEMPLATE_PAGE_RESOURCE_PATH = RESOURCE_PATH + "/template.html";
private JSONDruidStatService statService                 = JSONDruidStatService.getInstance();
public String                templatePage;
private List<IPRange>        allowList                   = new ArrayList<IPRange>();
private List<IPRange>        denyList                    = new ArrayList<IPRange>();
String param = getInitParameter(PARAM_NAME_RESET_ENABLE);
if (param != null && param.trim().length() != 0) {
param = param.trim();
boolean resetEnable = Boolean.parseBoolean(param);
statService.setResetEnable(resetEnable);
} catch (Exception e) {
String msg = "initParameter config error, resetEnable : " + getInitParameter(PARAM_NAME_RESET_ENABLE);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_ALLOW);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
IPRange ipRange = new IPRange(item);
allowList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, allow : " + getInitParameter(PARAM_NAME_ALLOW);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_DENY);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
IPRange ipRange = new IPRange(item);
denyList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, deny : " + getInitParameter(PARAM_NAME_DENY);
LOG.error(msg, e);
public boolean isPermittedRequest(HttpServletRequest request) {
String remoteAddress = request.getRemoteAddr();
return isPermittedRequest(remoteAddress);
public boolean isPermittedRequest(String remoteAddress) {
IPAddress ipAddress = new IPAddress(remoteAddress);
for (IPRange range : denyList) {
if (range.isIPAddressInRange(ipAddress)) {
return false;
if (allowList.size() > 0) {
for (IPRange range : allowList) {
if (range.isIPAddressInRange(ipAddress)) {
return true;
return false;
return true;
response.getWriter().print(statService.service(fullUrl));
private void returnResourceFile(String fileName, String uri, HttpServletResponse response) throws ServletException,
IOException {
if (text == null) {
public class StatViewServletTest_resetEnable extends TestCase {
protected void setUp() throws Exception {
JSONDruidStatService.getInstance().setResetEnable(true);
protected void tearDown() throws Exception {
JSONDruidStatService.getInstance().setResetEnable(true);
public void test_resetEnable_none() throws Exception {
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
MockServletConfig servletConfig = new MockServletConfig();
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
public void test_resetEnable_true() throws Exception {
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_RESET_ENABLE, "true");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
public void test_resetEnable_empty() throws Exception {
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_RESET_ENABLE, "");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
public void test_resetEnable_false() throws Exception {
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_RESET_ENABLE, "false");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertFalse(JSONDruidStatService.getInstance().isResetEnable());
public void test_resetEnable_error() throws Exception {
Assert.assertTrue(JSONDruidStatService.getInstance().isResetEnable());
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_RESET_ENABLE, "xxx");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertFalse(JSONDruidStatService.getInstance().isResetEnable());
public class StatViewSerlvetTest_allow extends TestCase {
public void test_allow() throws Exception {
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_ALLOW, "128.242.127.2");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
MockHttpServletRequest request = new MockHttpServletRequest();
request.setRemoteAddr("128.242.127.2");
Assert.assertTrue(servlet.isPermittedRequest(request));
Assert.assertFalse(servlet.isPermittedRequest("128.242.127.3"));
public void test_allow_1() throws Exception {
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_ALLOW, "128.242.127.2,xx");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
MockHttpServletRequest request = new MockHttpServletRequest();
request.setRemoteAddr("128.242.127.2");
Assert.assertTrue(servlet.isPermittedRequest(request));
Assert.assertFalse(servlet.isPermittedRequest("128.242.127.3"));
public void test_allow_2() throws Exception {
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_ALLOW, "128.242.127.2,,, ");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
MockHttpServletRequest request = new MockHttpServletRequest();
request.setRemoteAddr("128.242.127.2");
Assert.assertTrue(servlet.isPermittedRequest(request));
Assert.assertFalse(servlet.isPermittedRequest("128.242.127.3"));
public void test_allow_3() throws Exception {
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_ALLOW, "128.242.127.2/24");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
for (int i = 1; i <= 255; ++i) {
MockHttpServletRequest request = new MockHttpServletRequest();
request.setRemoteAddr("128.242.127." + i);
Assert.assertTrue(servlet.isPermittedRequest(request));
Assert.assertFalse(servlet.isPermittedRequest("128.242.128.1"));
public void test_allow_4() throws Exception {
MockServletConfig servletConfig = new MockServletConfig();
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_ALLOW, "128.242.127.2/24");
servletConfig.addInitParameter(StatViewServlet.PARAM_NAME_DENY, "128.242.127.4");
StatViewServlet servlet = new StatViewServlet();
servlet.init(servletConfig);
Assert.assertTrue(servlet.isPermittedRequest("128.242.127.1"));
Assert.assertTrue(servlet.isPermittedRequest("128.242.127.2"));
Assert.assertTrue(servlet.isPermittedRequest("128.242.127.3"));
Assert.assertFalse(servlet.isPermittedRequest("128.242.127.4"));
Assert.assertTrue(servlet.isPermittedRequest("128.242.127.5"));
if (!isResetEnable()) {
SpringStatManager.getInstance().resetStat();
WebAppStatManager.getInstance().resetStat();
boolean ipV6 = remoteAddress != null && remoteAddress.indexOf(':') != -1;
if (ipV6) {
if (denyList.size() == 0 && allowList.size() == 0) {
return true;
WebRequestStat requestStat = new WebRequestStat(startNano, startMillis);
if (sessionStat != null) {
sessionStat.beforeInvoke();
long currentMillis = System.currentTimeMillis();
sessionStat.setCreateTimeMillis(currentMillis);
String userAgent = request.getHeader("user-agent");
sessionStat.setUserAgent(userAgent);
private long startMillis;
public WebRequestStat(long startNano, long startMillis){
this.startNano = startNano;
this.startMillis = startMillis;
public long getStartMillis() {
return startMillis;
public void setStartMillis(long startMillis) {
this.startMillis = startMillis;
private String              userAgent;
public String getUserAgent() {
return userAgent;
public void setUserAgent(String userAgent) {
this.userAgent = userAgent;
WebRequestStat requestStat = WebRequestStat.current();
if (requestStat != null) {
this.setLastAccessTimeMillis(requestStat.getStartMillis());
data.put("UserAgent", this.getUserAgent());
Assert.assertNull(appStat.getSessionStat(session_0.getId()));
Assert.assertTrue(appStat.getSessionStat(session_0.getId()).getLastAccessTimeMillis() > 0);
private static DruidStatManagerFacade     statManagerFacade      = DruidStatManagerFacade.getInstance();
if (url.startsWith("/websession-") && url.indexOf(".json") > 0) {
String id = StringUtils.subString(url, "websession-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionDetail(id));
private Map<String, Object> getWebSessionDetail(String sessionId) {
return WebAppStatManager.getInstance().getSessionStat(sessionId);
public Map<String, Object> getSessionStatData(String sessionId) {
WebSessionStat uriStat = sessionStatMap.get(sessionId);
if (uriStat == null) {
return null;
return uriStat.getStatData();
public Map<String, Object> getSessionStat(String sessionId) {
Set<Object> stats = getWebAppStatSet();
for (Object stat : stats) {
Map<String, Object> statData = WebAppStatUtils.getSessionStatData(stat, sessionId);
if (statData != null) {
return statData;
return null;
@SuppressWarnings("unchecked")
public static Map<String, Object> getSessionStatData(Object webStat, String sessionId) {
if (webStat.getClass() == WebAppStat.class) {
return ((WebAppStat) webStat).getSessionStatData(sessionId);
Method method = webStat.getClass().getMethod("getSessionStatData", String.class);
Object obj = method.invoke(webStat);
return (Map<String, Object>) obj;
} catch (Exception e) {
LOG.error("getSessionStatData error", e);
return null;
private final AtomicInteger runningCount             = new AtomicInteger();
private final AtomicInteger concurrentMax            = new AtomicInteger();
private final AtomicLong    requestCount             = new AtomicLong(0);
private final AtomicLong    requestErrorCount        = new AtomicLong(0);
private final AtomicLong    requestTimeNano          = new AtomicLong();
private final AtomicLong    jdbcFetchRowCount        = new AtomicLong();
private final AtomicLong    jdbcUpdateCount          = new AtomicLong();
private final AtomicLong    jdbcExecuteCount         = new AtomicLong();
private final AtomicLong    jdbcExecuteTimeNano      = new AtomicLong();
private final AtomicLong    jdbcCommitCount          = new AtomicLong();
private final AtomicLong    jdbcRollbackCount        = new AtomicLong();
private long                createTimeMillis         = -1L;
private volatile long       lastAccessTimeMillis     = -1L;
private Set<String>         remoteAddresses          = new HashSet<String>();
private String     principal                = null;
private Histogram           requestIntervalHistogram = Histogram.makeHistogram(8);
requestIntervalHistogram.reset();
if (this.lastAccessTimeMillis > 0) {
long interval = lastAccessTimeMillis - this.lastAccessTimeMillis;
requestIntervalHistogram.record(interval);
public void afterInvoke(Throwable error, long nanos) {
reacord(nanos);
public long[] getRequestInterval() {
return requestIntervalHistogram.toArray();
data.put("RequestInterval", this.getRequestInterval());
public static Histogram makeHistogram(int rangeCount) {
long[] rangeValues = new long[rangeCount];
for (int i = 0; i < rangeValues.length; ++i) {
rangeValues[i] = (long) Math.pow(10, i);
return new Histogram(rangeValues);
if (url.startsWith("/weburi-") && url.indexOf(".json") > 0) {
String uri = StringUtils.subString(url, "weburi-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatData(uri));
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionStatData(id));
private Map<String, Object> getWebURIStatData(String uri) {
return WebAppStatManager.getInstance().getURIStatData(uri);
private Map<String, Object> getWebSessionStatData(String sessionId) {
WebSessionStat sessionStat = sessionStatMap.get(sessionId);
if (sessionStat == null) {
return null;
return sessionStat.getStatData();
public Map<String, Object> getURIStatData(String uri) {
WebURIStat uriStat = getURIStat(uri);
public Map<String, Object> getURIStatData(String uri) {
Set<Object> stats = getWebAppStatSet();
for (Object stat : stats) {
Map<String, Object> statData = WebAppStatUtils.getURIStatData(stat, uri);
if (statData != null) {
return statData;
return null;
@SuppressWarnings("unchecked")
public static Map<String, Object> getURIStatData(Object webStat, String uri) {
if (webStat.getClass() == WebAppStat.class) {
return ((WebAppStat) webStat).getURIStatData(uri);
Method method = webStat.getClass().getMethod("getURIStatData", String.class);
Object obj = method.invoke(webStat);
return (Map<String, Object>) obj;
} catch (Exception e) {
LOG.error("getURIStatData error", e);
return null;
if (error != null) {
reqStat.incrementJdbcExecuteErrorCount();
private long jdbcExecuteErrorCount;
public long getJdbcExecuteErrorCount() {
return jdbcExecuteErrorCount;
public void incrementJdbcExecuteErrorCount() {
jdbcExecuteErrorCount++;
if (lastAccessTimeMillis < 0L) {
private final AtomicInteger                  runningCount          = new AtomicInteger();
private final AtomicInteger                  concurrentMax         = new AtomicInteger();
private final AtomicLong                     requestCount          = new AtomicLong(0);
private final AtomicLong                     requestTimeNano       = new AtomicLong();
private final AtomicLong                     jdbcFetchRowCount     = new AtomicLong();
private final AtomicLong                     jdbcFetchRowPeak      = new AtomicLong();             
private final AtomicLong                     jdbcUpdateCount       = new AtomicLong();
private final AtomicLong                     jdbcUpdatePeak        = new AtomicLong();             
private final AtomicLong                     jdbcExecuteCount      = new AtomicLong();
private final AtomicLong                     jdbcExecuteErrorCount = new AtomicLong();
private final AtomicLong                     jdbcExecutePeak       = new AtomicLong();             
private final AtomicLong                     jdbcExecuteTimeNano   = new AtomicLong();
private final AtomicLong                     jdbcCommitCount       = new AtomicLong();
private final AtomicLong                     jdbcRollbackCount     = new AtomicLong();
private final AtomicLong                     errorCount            = new AtomicLong();
private volatile long                        lastAccessTimeMillis  = -1L;
private final static ThreadLocal<WebURIStat> currentLocal          = new ThreadLocal<WebURIStat>();
WebRequestStat requestStat = WebRequestStat.current();
if (requestStat != null) {
this.setLastAccessTimeMillis(requestStat.getStartMillis());
if (error != null) {
errorCount.incrementAndGet();
long jdbcExecuteErrorCount = localStat.getJdbcExecuteErrorCount();
if (jdbcExecuteErrorCount > 0) {
this.jdbcExecuteErrorCount.addAndGet(jdbcExecuteErrorCount);
public AtomicLong getJdbcExecuteErrorCount() {
return jdbcExecuteErrorCount;
public void setLastAccessTimeMillis(long lastAccessTimeMillis) {
this.lastAccessTimeMillis = lastAccessTimeMillis;
public Date getLastAccessTime() {
if (lastAccessTimeMillis < 0L) {
return null;
return new Date(lastAccessTimeMillis);
public long getLastAccessTimeMillis() {
return lastAccessTimeMillis;
public long getErrorCount() {
return errorCount.get();
data.put("ErrorCount", this.getErrorCount());
data.put("LastAccessTime", this.getLastAccessTime());
data.put("JdbcExecuteErrorCount", this.getJdbcExecuteErrorCount());
if (JdbcUtils.H2.equals(dbType)) {
return toMySqlString(sqlObject);
if (JdbcUtils.H2.equals(dbType)) {
return new MySqlExprParser(sql);
return new MySqlParameterizedOutputVisitor(out);
if (JdbcUtils.H2.equals(dbType)) {
if (JdbcUtils.H2.equals(dbType)) {
return new MySqlEvalVisitorImpl();
if (filePath.startsWith("http:
public class ConfigLoadFilterTest6 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("druid-configFile=https:
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_http_config() throws Exception {
Assert.assertEquals(true, dataSource.isTestOnBorrow()); 
Assert.assertEquals(8, dataSource.getMaxActive());
dataSource.init();
Assert.assertEquals(false, dataSource.isTestOnBorrow());
Assert.assertEquals(10, dataSource.getMaxActive());
Assert.assertEquals("jdbc:mock:config-0", dataSource.getUrl());
Assert.assertEquals(MockDriver.instance, dataSource.getDriver());
Connection conn = dataSource.getConnection();
conn.close();
if (url.startsWith("/spring-detail.json")) {
String clazz = parameters.get("class");
String method = parameters.get("method");
return returnJSONResult(RESULT_CODE_SUCCESS, getSpringMethodStatData(clazz, method));
private Map<String, Object> getSpringMethodStatData(String clazz, String method) {
return SpringStatManager.getInstance().getMethodStatData(clazz, method);
if (error != null) {
springMethodStat.incrementJdbcExecuteErrorCount();
private final static ThreadLocal<SpringMethodStat> currentLocal          = new ThreadLocal<SpringMethodStat>();
private final SpringMethodInfo                     methodInfo;
private final AtomicInteger                        runningCount          = new AtomicInteger();
private final AtomicInteger                        concurrentMax         = new AtomicInteger();
private final AtomicLong                           executeCount          = new AtomicLong(0);
private final AtomicLong                           executeErrorCount     = new AtomicLong(0);
private final AtomicLong                           executeTimeNano       = new AtomicLong();
private final AtomicLong                           jdbcFetchRowCount     = new AtomicLong();
private final AtomicLong                           jdbcUpdateCount       = new AtomicLong();
private final AtomicLong                           jdbcExecuteCount      = new AtomicLong();
private final AtomicLong                           jdbcExecuteErrorCount = new AtomicLong();
private final AtomicLong                           jdbcExecuteTimeNano   = new AtomicLong();
private final AtomicLong                           jdbcCommitCount       = new AtomicLong();
private final AtomicLong                           jdbcRollbackCount     = new AtomicLong();
public long getJdbcExecuteErrorCount() {
return jdbcExecuteErrorCount.get();
public void addJdbcExecuteErrorCount(long executeCount) {
jdbcExecuteErrorCount.addAndGet(executeCount);
public void incrementJdbcExecuteErrorCount() {
jdbcExecuteErrorCount.incrementAndGet();
data.put("JdbcExecuteErrorCount", this.getJdbcExecuteErrorCount());
public Map<String, Object> getMethodStatData(String clazz, String method) {
for (SpringMethodStat methodStat : this.methodStats.values()) {
SpringMethodInfo methodInfo = methodStat.getMethodInfo();
if (methodInfo.getClassName().equals(clazz) && methodInfo.getSignature().equals(method)) {
return methodStat.getStatData();
return null;
public Map<String, Object> getMethodStatData(String clazz, String method) {
Set<Object> stats = getSpringStatSet();
for (Object stat : stats) {
Map<String, Object> statData = SpringStatUtils.getMethodStatData(stat, clazz, method);
if (statData != null) {
return statData;
return null;
@SuppressWarnings("unchecked")
public static Map<String, Object> getMethodStatData(Object methodStat, String clazz, String methodSignature) {
if (methodStat.getClass() == SpringStat.class) {
return ((SpringStat) methodStat).getMethodStatData(clazz, methodSignature);
Method method = methodStat.getClass().getMethod("getMethodStatData", String.class, String.class);
Object obj = method.invoke(methodStat, clazz, methodSignature);
return (Map<String, Object>) obj;
} catch (Exception e) {
LOG.error("getMethodStatDataList error", e);
return null;
private int    threadCount     = 2;
final int      LOOP_COUNT      = 1000 * 1000;
public void test_2() throws Exception {
String dbType = (String) map.get("DbType");
String sql = (String) map.get("SQL");
map.put("formattedSql", SQLUtils.format(sql, dbType));
List<SQLStatement> statementList = SQLUtils.parseStatements(sql, dbType);
SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, dbType);
StatFilterContext.getInstance().resultSet_open();
long nanos = System.nanoTime() - resultSet.getConstructNano();
dataSourceStat.getResultSetStat().afterClose(nanos);
sqlStat.addResultSetHoldTimeNano(stmtExecuteNano, nanos);
StatFilterContext.getInstance().resultSet_close(nanos);
StatFilterContext.getInstance().pool_connection_close(nanos);
StatFilterContext.getInstance().pool_connection_open();
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.commit();
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.rollback();
public void pool_connection_open() {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.pool_connect();
public void pool_connection_close(long nanos) {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.pool_close(nanos);
public void physical_connection_connect() {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.physical_connection_connect();
public void physical_connection_close(long nanos) {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.physical_connection_close(nanos);
public void resultSet_open() {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.resultSet_open();
public void resultSet_close(long nanos) {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.resultSet_close(nanos);
void pool_connect();
void pool_close(long nanos);
void physical_connection_connect();
void physical_connection_close(long nanos);
void resultSet_open();
void resultSet_close(long nanos);
public void pool_connect() {
public void pool_close(long nanos) {
public void physical_connection_connect() {
public void physical_connection_close(long nanos) {
public void resultSet_open() {
public void resultSet_close(long nanos) {
public void pool_connect() {
WebRequestStat reqStat = WebRequestStat.current();
if (reqStat != null) {
reqStat.incrementJdbcPoolConnectCount();
SpringMethodStat springMethodStat = SpringMethodStat.current();
if (springMethodStat != null) {
springMethodStat.incrementJdbcPoolConnectionOpenCount();
public void pool_close(long nanos) {
WebRequestStat reqStat = WebRequestStat.current();
if (reqStat != null) {
reqStat.incrementJdbcPoolCloseCount();
SpringMethodStat springMethodStat = SpringMethodStat.current();
if (springMethodStat != null) {
springMethodStat.incrementJdbcPoolConnectionOpenCount();
public void resultSet_open() {
WebRequestStat reqStat = WebRequestStat.current();
if (reqStat != null) {
reqStat.incrementJdbcResultSetOpenCount();
public void resultSet_close(long nanos) {
WebRequestStat reqStat = WebRequestStat.current();
if (reqStat != null) {
reqStat.incrementJdbcResultSetCloseCount();
private long jdbcPoolConnectCount;
private long jdbcPoolCloseCount;
private long jdbcResultSetOpenCount;
private long jdbcResultSetCloseCount;
public long getJdbcPoolConnectionOpenCount() {
return jdbcPoolConnectCount;
public void incrementJdbcPoolConnectCount() {
this.jdbcPoolConnectCount++;
public long getJdbcPoolConnectionCloseCount() {
return jdbcPoolCloseCount;
public void incrementJdbcPoolCloseCount() {
this.jdbcPoolCloseCount++;
public long getJdbcResultSetOpenCount() {
return jdbcResultSetOpenCount;
public void incrementJdbcResultSetOpenCount() {
this.jdbcResultSetOpenCount++;
public long getJdbcResultSetCloseCount() {
return jdbcResultSetCloseCount;
public void incrementJdbcResultSetCloseCount() {
this.jdbcResultSetCloseCount++;
private final AtomicInteger                  runningCount                 = new AtomicInteger();
private final AtomicInteger                  concurrentMax                = new AtomicInteger();
private final AtomicLong                     requestCount                 = new AtomicLong(0);
private final AtomicLong                     requestTimeNano              = new AtomicLong();
private final AtomicLong                     jdbcFetchRowCount            = new AtomicLong();
private final AtomicLong                     jdbcFetchRowPeak             = new AtomicLong();             
private final AtomicLong                     jdbcUpdateCount              = new AtomicLong();
private final AtomicLong                     jdbcUpdatePeak               = new AtomicLong();             
private final AtomicLong                     jdbcExecuteCount             = new AtomicLong();
private final AtomicLong                     jdbcExecuteErrorCount        = new AtomicLong();
private final AtomicLong                     jdbcExecutePeak              = new AtomicLong();             
private final AtomicLong                     jdbcExecuteTimeNano          = new AtomicLong();
private final AtomicLong                     jdbcCommitCount              = new AtomicLong();
private final AtomicLong                     jdbcRollbackCount            = new AtomicLong();
private final AtomicLong                     jdbcPoolConnectionOpenCount  = new AtomicLong();
private final AtomicLong                     jdbcPoolConnectionCloseCount = new AtomicLong();
private final AtomicLong                     jdbcResultSetOpenCount       = new AtomicLong();
private final AtomicLong                     jdbcResultSetCloseCount      = new AtomicLong();
private final AtomicLong                     errorCount                   = new AtomicLong();
private volatile long                        lastAccessTimeMillis         = -1L;
private final static ThreadLocal<WebURIStat> currentLocal                 = new ThreadLocal<WebURIStat>();
this.jdbcExecuteErrorCount.addAndGet(localStat.getJdbcExecuteErrorCount());
this.addJdbcPoolConnectionOpenCount(localStat.getJdbcPoolConnectionOpenCount());
this.addJdbcPoolConnectionCloseCount(localStat.getJdbcPoolConnectionCloseCount());
this.addJdbcResultSetOpenCount(localStat.getJdbcResultSetOpenCount());
this.addJdbcResultSetCloseCount(localStat.getJdbcResultSetCloseCount());
public long getJdbcPoolConnectionOpenCount() {
return jdbcPoolConnectionOpenCount.get();
public void addJdbcPoolConnectionOpenCount(long delta) {
jdbcPoolConnectionOpenCount.addAndGet(delta);
public void incrementJdbcPoolConnectionOpenCount() {
jdbcPoolConnectionOpenCount.incrementAndGet();
public long getJdbcPoolConnectionCloseCount() {
return jdbcPoolConnectionCloseCount.get();
public void addJdbcPoolConnectionCloseCount(long delta) {
jdbcPoolConnectionCloseCount.addAndGet(delta);
public void incrementJdbcPoolConnectionCloseCount() {
jdbcPoolConnectionCloseCount.incrementAndGet();
public long getJdbcResultSetOpenCount() {
return jdbcResultSetOpenCount.get();
public void addJdbcResultSetOpenCount(long delta) {
jdbcResultSetOpenCount.addAndGet(delta);
public long getJdbcResultSetCloseCount() {
return jdbcResultSetCloseCount.get();
public void addJdbcResultSetCloseCount(long delta) {
jdbcResultSetCloseCount.addAndGet(delta);
data.put("JdbcPoolConnectionOpenCount", this.getJdbcPoolConnectionOpenCount());
data.put("JdbcPoolConnectionCloseCount", this.getJdbcPoolConnectionCloseCount());
data.put("JdbcResultSetOpenCount", this.getJdbcResultSetOpenCount());
data.put("JdbcResultSetCloseCount", this.getJdbcResultSetCloseCount());
private final AtomicLong                           jdbcPoolConnectionOpenCount      = new AtomicLong();
private final AtomicLong                           jdbcPoolConnectionCloseCount        = new AtomicLong();
private volatile Throwable                         lastError;
private volatile long                              lastErrorTimeMillis;
jdbcExecuteErrorCount.set(0);
jdbcPoolConnectionOpenCount.set(0);
jdbcPoolConnectionCloseCount.set(0);
lastError = null;
lastErrorTimeMillis = 0;
lastError = error;
lastErrorTimeMillis = System.currentTimeMillis();
public Throwable getLastError() {
return lastError;
public Date getLastErrorTime() {
if (lastErrorTimeMillis <= 0) {
return null;
return new Date(lastErrorTimeMillis);
public long getLastErrorTimeMillis() {
return lastErrorTimeMillis;
public long getJdbcPoolConnectionOpenCount() {
return jdbcPoolConnectionOpenCount.get();
public void addJdbcPoolConnectionOpenCount(long delta) {
jdbcPoolConnectionOpenCount.addAndGet(delta);
public void incrementJdbcPoolConnectionOpenCount() {
jdbcPoolConnectionOpenCount.incrementAndGet();
public long getJdbcPoolConnectionCloseCount() {
return jdbcPoolConnectionCloseCount.get();
public void addJdbcPoolConnectionCloseCount(long delta) {
jdbcPoolConnectionCloseCount.addAndGet(delta);
public void incrementJdbcPoolConnectionCloseCount() {
jdbcPoolConnectionCloseCount.incrementAndGet();
data.put("JdbcPoolConnectionOpenCount", this.getJdbcPoolConnectionOpenCount());
data.put("JdbcPoolConnectionCloseCount", this.getJdbcPoolConnectionCloseCount());
data.put("LastError", this.getLastError());
data.put("LastErrorTime", this.getLastErrorTime());
springMethodStat.incrementJdbcPoolConnectionCloseCount();
public class DruidStatJSONService {
private final static DruidStatJSONService instance               = new DruidStatJSONService();
private DruidStatJSONService(){
public static DruidStatJSONService getInstance() {
private DruidStatJSONService statService                 = DruidStatJSONService.getInstance();
DruidStatJSONService.getInstance().setResetEnable(true);
DruidStatJSONService.getInstance().setResetEnable(true);
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertFalse(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertTrue(DruidStatJSONService.getInstance().isResetEnable());
Assert.assertFalse(DruidStatJSONService.getInstance().isResetEnable());
String requestURI = getRequestURI(httpRequest);
if (uriStat == null) {
int index = requestURI.indexOf(";jsessionid=");
if (index != -1) {
requestURI = requestURI.substring(0, index);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), (ClobProxy) obj);
private void clobOpenAfter(JdbcDataSourceStat dataSourceStat, ClobProxy clob) {
public void clob_open() {
public void clobFree() {
if (clob instanceof NClob) {
return wrap(connection, (NClob) clob);
public class FilterChainTest_Clob extends TestCase {
private DruidDataSource dataSource;
private StatementProxy  statement;
private MockResultSet   mockResultSet;
private int             invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
statement = new StatementProxyImpl(null, null, 1);
mockResultSet = new MockResultSet(null) {
public Object getObject(int columnIndex) throws SQLException {
invokeCount++;
return new MockClob();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_resultSet_getClob() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.resultSet_getClob(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1);
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getClob_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.resultSet_getClob(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1");
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1);
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1");
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1, Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1", Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public class FilterChainTest_NClob extends TestCase {
private DruidDataSource dataSource;
private StatementProxy  statement;
private MockResultSet   mockResultSet;
private int             invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
statement = new StatementProxyImpl(null, null, 1);
mockResultSet = new MockResultSet(null) {
public Object getObject(int columnIndex) throws SQLException {
invokeCount++;
return new MockNClob();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_resultSet_getClob() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.resultSet_getClob(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1);
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getClob_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.resultSet_getClob(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1");
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1);
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1");
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1, Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1", Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public class FilterChainTest_Clob_2 extends TestCase {
private DruidDataSource        dataSource;
private CallableStatementProxy statement;
private int                    invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
MockCallableStatement mockStmt = new MockCallableStatement(null, "") {
public Object getObject(int parameterIndex) throws SQLException {
invokeCount++;
return new MockClob();
statement = new CallableStatementProxyImpl(null, mockStmt, "", 1);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_getClob() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.callableStatement_getClob(statement, 1);
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getClob_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.callableStatement_getClob(statement, "1");
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, 1);
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, "1");
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, 1, Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, "1", Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ClobProxy);
Assert.assertEquals(1, invokeCount);
public class FilterChainTest_NClob_2 extends TestCase {
private DruidDataSource        dataSource;
private CallableStatementProxy statement;
private int                    invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
MockCallableStatement mockStmt = new MockCallableStatement(null, "") {
public Object getObject(int parameterIndex) throws SQLException {
invokeCount++;
return new MockNClob();
statement = new CallableStatementProxyImpl(null, mockStmt, "", 1);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_getClob() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.callableStatement_getClob(statement, 1);
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getClob_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = chain.callableStatement_getClob(statement, "1");
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, 1);
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, "1");
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, 1, Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
Clob clob = (Clob) chain.callableStatement_getObject(statement, "1", Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof NClobProxy);
Assert.assertEquals(1, invokeCount);
if (obj instanceof ResultSet) {
return wrap(resultSet.getStatementProxy(), (ResultSet) obj);
if (obj instanceof ResultSet) {
return wrap(resultSet.getStatementProxy(), (ResultSet) obj);
if (obj instanceof ResultSet) {
return wrap(resultSet.getStatementProxy(), (ResultSet) obj);
if (obj instanceof ResultSet) {
return wrap(resultSet.getStatementProxy(), (ResultSet) obj);
public class FilterChainTest_ResultSet extends TestCase {
private DruidDataSource dataSource;
private StatementProxy  statement;
private MockResultSet   mockResultSet;
private int             invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
statement = new StatementProxyImpl(null, null, 1);
mockResultSet = new MockResultSet(null) {
public Object getObject(int columnIndex) throws SQLException {
invokeCount++;
return new MockResultSet(null);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_resultSet_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1);
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1");
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), 1, Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_resultSet_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.resultSet_getObject(new ResultSetProxyImpl(statement, mockResultSet, 1, null), "1", Collections.<String, Class<?>>emptyMap());
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public class FilterChainTest_ResultSet_2 extends TestCase {
private DruidDataSource        dataSource;
private CallableStatementProxy statement;
private int                    invokeCount = 0;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
MockCallableStatement mockStmt = new MockCallableStatement(null, "") {
public Object getObject(int parameterIndex) throws SQLException {
invokeCount++;
return new MockResultSet(null);
statement = new CallableStatementProxyImpl(null, mockStmt, "", 1);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
invokeCount = 0;
public void test_getObject() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.callableStatement_getObject(statement, 1);
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_1() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.callableStatement_getObject(statement, "1");
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_2() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.callableStatement_getObject(statement, 1, Collections.<String, Class<?>> emptyMap());
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
public void test_getObject_3() throws Exception {
FilterChainImpl chain = new FilterChainImpl(dataSource);
ResultSet clob = (ResultSet) chain.callableStatement_getObject(statement, "1", Collections.<String, Class<?>> emptyMap());
Assert.assertTrue(clob instanceof ResultSetProxy);
Assert.assertEquals(1, invokeCount);
StatFilterContext.getInstance().clob_open();
StatFilterContext.getInstance().clob_free();
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.clob_open();
public void clob_free() {
for (int i = 0; i < listeners.size(); ++i) {
StatFilterContextListener listener = listeners.get(i);
listener.clob_free();
void clob_open();
void clob_free();
public void clob_open() {
public void clob_free() {
return comparatorOrderBy(array, parameters);
Assert.assertEquals(0, dataSource.getDestroyCount());
Assert.assertEquals("actveCount != 0", 0, dataSource.getActiveCount());
dataSource.setMinEvictableIdleTimeMillis(10 * 1000);
this.jdbcExecuteTimeNano.addAndGet(localStat.getJdbcExecuteTimeNano());
if (holder == null) {
LOG.warn("connectionHolder is null");
public class DruidAXDataSource extends DruidDataSource implements XADataSource {
private static final long serialVersionUID = 1L;
public XAConnection getXAConnection() throws SQLException {
return null;
public XAConnection getXAConnection(String user, String password) throws SQLException {
throw new UnsupportedOperationException("Not supported by DruidDataSource");
public class DruidXAPoolableConnection extends DruidPooledConnection implements XAResource {
private final static Log     LOG       = LogFactory.getLog(DruidXAPoolableConnection.class);
public DruidXAPoolableConnection(DruidConnectionHolder holder, XAConnection xaConnection) throws SQLException{
public class DruidXAOracleException extends XAException {
private int xaError   = 0;
private int primary   = 0;
private int secondary = 0;
public DruidXAOracleException(){
public DruidXAOracleException(int error){
super(errorConvert(error));
this.xaError = errorConvert(error);
this.primary = (error & 0xFFFF);
this.secondary = (error >> 16);
public static XAException newXAException(OracleConnection conn, int error) {
DruidXAOracleException xaexc = new DruidXAOracleException(error);
int xacode = xaexc.getXAError();
if (xacode == -7) {
if (conn != null) {
return xaexc;
public int getXAError() {
return this.xaError;
public static int errorConvert(int err) {
return errorConvert(err, -3);
public static int errorConvert(int err, int defaultErrorCode) {
switch (err & 0xFFFF) {
case 24756
return -4;
case 25351
case 30006
case 24764
case 24765
case 24766
case 24767
case 12571
case 17002
case 17008
case 17410
case 24796
case 25400
case 25401
case 25402
case 25403
case 25404
case 25405
case 25406
case 25407
case 25408
case 25409
return -7;
case 17448
case 24763
case 24768
case 24769
case 24770
case 24775
case 24776
return -6;
case 24761
return 100;
return defaultErrorCode;
public class DruidXAOracleResource extends DruidXAResource {
private static String xa_start_post_816                    = "begin ? := JAVA_XA.xa_start_new(?,?,?,?,?); end;";
private static String xa_forget_post_816                   = "begin ? := JAVA_XA.xa_forget_new (?,?,?); end;";
private static String xa_prepare_post_816                  = "begin ? := JAVA_XA.xa_prepare_new (?,?,?); end;";
private static String xa_rollback_post_816                 = "begin ? := JAVA_XA.xa_rollback_new (?,?,?); end;";
private static String xa_commit_post_816                   = "begin ? := JAVA_XA.xa_commit_new (?,?,?,?); end;";
private static String xa_end_post_816                      = "begin ? := JAVA_XA.xa_end_new(?,?,?,?); end;";
private String        synchronizeBeforeRecoverNewCall      = "BEGIN sys.dbms_xa.dist_txn_sync n; END;";
private String        synchronizeBeforeRecoverOldCall      = "BEGIN sys.dbms_system.dist_txn_sync(0) n; END;";
private String        recoverySqlRows                      = "SELECT formatid, globalid, branchid FROM SYS.DBA_PENDING_TRANSACTIONS";
private int           version;
private boolean       needStackingForCommitRollbackPrepare = false;
boolean               isTransLoose                         = false;
public DruidXAOracleResource(DruidXAPooledConnection conn) throws SQLException, XAException{
this.version = OracleUtils.getVersionNumber(conn);
this.needStackingForCommitRollbackPrepare = (this.version < 9000);
if (this.version < 8170) {
throw new XAException(XAException.XAER_PROTO);
public void commit(Xid xid, boolean onePhase) throws XAException {
synchronized (this.connection) {
if (xid == null) {
throw new XAException(-5);
Xid stackedXid = null;
if (this.needStackingForCommitRollbackPrepare) {
stackedXid = super.suspendStacked(xid);
removeXidFromList(xid);
if (this.activeXid == null) {
exitGlobalTxnMode();
doCommit(xid, onePhase);
} catch (SQLException sqle) {
checkError(sqle, -3);
} catch (XAException xae) {
if (xae.errorCode == -7) {
this.connection.close();
} catch (SQLException ea) {
} else if (this.needStackingForCommitRollbackPrepare) {
super.resumeStacked(stackedXid);
throw xae;
if (this.needStackingForCommitRollbackPrepare) {
super.resumeStacked(stackedXid);
protected void doCommit(Xid xid, boolean onePhase) throws XAException, SQLException {
CallableStatement cstmt = null;
cstmt = this.connection.prepareCall(xa_commit_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.setInt(5, onePhase ? 1 : 0);
cstmt.execute();
int returnVal = cstmt.getInt(1);
checkError(returnVal, -7);
} catch (SQLException s) {
int returnVal = s.getErrorCode();
if (returnVal == 0) {
throw new XAException(-6);
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
public void end(Xid xid, int flag) throws XAException {
synchronized (this.connection) {
int returnVal = -1;
boolean isTMSUCCESS = false;
boolean isTMFAIL = false;
if (xid == null) {
throw new XAException(-5);
int validFlags = 638582786;
if ((flag & validFlags) != flag) {
throw new XAException(-5);
Xid stackedXid = null;
isTMSUCCESS = (flag & 0x4000000) != 0;
isTMFAIL = (flag & 0x20000000) != 0;
if ((isTMSUCCESS) || (isTMFAIL)) {
stackedXid = super.suspendStacked(xid);
boolean isLocallySuspended = false;
boolean i = false;
if ((isTMSUCCESS) || (isTMFAIL)) {
isLocallySuspended = isXidSuspended(xid);
if (isLocallySuspended) {
super.resumeStacked(xid);
removeXidFromList(xid);
} else if (flag == 33554432) {
boolean[] flags = { false };
super.createOrUpdateXid(xid, true, flags);
i = flags[0];
returnVal = doEnd(xid, flag, i);
} catch (SQLException sqle) {
checkError(sqle, -3);
if (stackedXid != null) {
super.resumeStacked(stackedXid);
} else if (isXidListEmpty()) {
exitGlobalTxnMode();
this.activeXid = null;
checkError(returnVal);
if (((isTMSUCCESS) && (flag != 67108864)) || ((isTMFAIL) && (flag != 536870912))) {
throw new XAException(-5);
} finally {
restoreAutoCommitModeForGlobalTransaction();
protected int doEnd(Xid xid, int flag, boolean isLocallySuspended) throws XAException, SQLException {
CallableStatement cstmt = null;
int returnVal = -1;
cstmt = this.connection.prepareCall(xa_end_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.setInt(5, flag);
cstmt.execute();
returnVal = cstmt.getInt(1);
} catch (SQLException s) {
returnVal = s.getErrorCode();
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
return returnVal;
public void forget(Xid xid) throws XAException {
synchronized (this.connection) {
int returnVal = 0;
if (xid == null) {
throw new XAException(-5);
removeXidFromList(xid);
returnVal = doForget(xid);
} catch (SQLException sqle) {
checkError(sqle, -3);
checkError(returnVal);
protected int doForget(Xid xid) throws XAException, SQLException {
int returnVal = 0;
CallableStatement cstmt = null;
cstmt = this.connection.prepareCall(xa_forget_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.execute();
returnVal = cstmt.getInt(1);
} catch (SQLException s) {
returnVal = s.getErrorCode();
if (returnVal == 0) {
throw new XAException(-6);
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
return returnVal;
public boolean isSameRM(XAResource xares) throws XAException {
Connection conn1 = null;
if ((xares instanceof OracleXAResource)) {
conn1 = ((OracleXAResource) xares).getConnection();
return false;
if ((this.connection == null) || (((OracleConnection) this.connection).isClosed())) {
return false;
String l_url = ((OracleConnection) this.connection).getURL();
String l_prt = ((OracleConnection) this.connection).getProtocolType();
if (conn1 != null) {
return (conn1.equals(this.connection)) || (((OracleConnection) conn1).getURL().equals(l_url))
|| ((((OracleConnection) conn1).getProtocolType().equals(l_prt)) && (l_prt.equals("kprb")));
} catch (SQLException sqe) {
throw new XAException(-3);
return false;
public int prepare(Xid xid) throws XAException {
synchronized (this.connection) {
int returnVal = 0;
if (xid == null) {
throw new XAException(-5);
Xid stackedXid = null;
if (this.needStackingForCommitRollbackPrepare) {
stackedXid = super.suspendStacked(xid);
returnVal = doPrepare(xid);
if ((returnVal != 0) && (returnVal != 3)) {
int x_e = OracleXAException.errorConvert(returnVal);
if ((x_e != 0) && (x_e != 3)) {
XAException ex = DruidXAOracleException.newXAException(getConnectionDuringExceptionHandling(),
returnVal);
ex.fillInStackTrace();
returnVal = x_e;
} catch (SQLException sqle) {
checkError(sqle, -3);
} catch (XAException xaex) {
if (xaex.errorCode == -7) {
this.connection.close();
} catch (SQLException ea) {
} else if (this.needStackingForCommitRollbackPrepare) {
super.resumeStacked(stackedXid);
throw xaex;
if (this.needStackingForCommitRollbackPrepare) {
super.resumeStacked(stackedXid);
return returnVal;
protected int doPrepare(Xid xid) throws XAException, SQLException {
int returnVal = 0;
CallableStatement cstmt = null;
cstmt = this.connection.prepareCall(xa_prepare_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.execute();
returnVal = cstmt.getInt(1);
} catch (SQLException s) {
int errorCode = s.getErrorCode();
if (errorCode == 0) {
throw new XAException(-6);
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
return returnVal;
protected OracleConnection getConnectionDuringExceptionHandling() {
return (OracleConnection) this.connection;
public Xid[] recover(int flag) throws XAException {
synchronized (this.connection) {
if ((flag & 0x1800000) != flag) {
throw new XAException(-5);
if (flag == 16777216) {
this.isTMRScanStarted = true;
Xid[] arrayOfXid1;
if ((this.isTMRScanStarted) && (flag == 8388608)) {
this.isTMRScanStarted = false;
arrayOfXid1 = NO_XID;
return arrayOfXid1;
if ((this.isTMRScanStarted) && (flag == 0)) {
arrayOfXid1 = NO_XID;
return arrayOfXid1;
Statement stmt = null;
ResultSet rset = null;
ArrayList xidCollection = new ArrayList(50);
stmt = this.connection.createStatement();
stmt.execute(this.synchronizeBeforeRecoverNewCall);
} catch (Exception exc) {
stmt.execute(this.synchronizeBeforeRecoverOldCall);
rset = stmt.executeQuery(this.recoverySqlRows);
while (rset.next()) {
xidCollection.add(new OracleXid(rset.getInt(1), rset.getBytes(2), rset.getBytes(3)));
} catch (SQLException sqe) {
throw new XAException(-3);
} finally {
if (stmt != null) {
stmt.close();
if (rset != null) rset.close();
} catch (Exception ignore) {
int xidSize = xidCollection.size();
Xid[] xids = new Xid[xidSize];
System.arraycopy(xidCollection.toArray(), 0, xids, 0, xidSize);
Xid[] arrayOfXid2 = xids;
return arrayOfXid2;
public void rollback(Xid xid) throws XAException {
synchronized (this.connection) {
int returnVal = 0;
if (xid == null) {
throw new XAException(-5);
Xid stackedXid = null;
if (this.needStackingForCommitRollbackPrepare) {
stackedXid = super.suspendStacked(xid);
removeXidFromList(xid);
if (this.activeXid == null) exitGlobalTxnMode();
doRollback(xid);
} catch (SQLException sqle) {
checkError(sqle, -3);
if (this.needStackingForCommitRollbackPrepare) {
super.resumeStacked(stackedXid);
checkError(returnVal);
protected void doRollback(Xid xid) throws XAException, SQLException {
CallableStatement cstmt = null;
cstmt = this.connection.prepareCall(xa_rollback_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.execute();
int returnVal = cstmt.getInt(1);
checkError(returnVal, -7);
} catch (SQLException s) {
int errorCode = s.getErrorCode();
if (errorCode == 0) {
throw new XAException(-6);
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
public void start(Xid xid, int flag) throws XAException {
synchronized (this.connection) {
int returnVal = -1;
if (xid == null) {
throw new XAException(-5);
int isolFlag = flag & 0xFF00;
flag &= -65281;
int otherFlag = flag & 0x10000 | (this.isTransLoose ? 65536 : 0);
flag &= -65537;
if (((flag & 0x8200002) != flag) || ((otherFlag != 0) && ((otherFlag & 0x10000) != 65536))) {
throw new XAException(-5);
if (((isolFlag & 0xFF00) != 0) && (isolFlag != 256) && (isolFlag != 512) && (isolFlag != 1024)) {
throw new XAException(-5);
if (((flag & 0x8200000) != 0) && (((isolFlag & 0xFF00) != 0) || ((otherFlag & 0x10000) != 0))) {
throw new XAException(-5);
flag |= isolFlag | otherFlag;
saveAndAlterAutoCommitModeForGlobalTransaction();
returnVal = doStart(xid, flag);
} catch (SQLException sqle) {
checkError(sqle, -3);
checkError(returnVal);
boolean[] isLocallySuspended = { false };
createOrUpdateXid(xid, false, isLocallySuspended);
} catch (XAException ea) {
restoreAutoCommitModeForGlobalTransaction();
protected void enterGlobalTxnMode() {
((OracleConnection) this.connection).setTxnMode(1);
protected void exitGlobalTxnMode() {
((OracleConnection) this.connection).setTxnMode(0);
protected int doStart(Xid xid, int flag) throws XAException, SQLException {
int returnVal = -1;
CallableStatement cstmt = null;
cstmt = this.connection.prepareCall(xa_start_post_816);
cstmt.registerOutParameter(1, 2);
cstmt.setInt(2, xid.getFormatId());
cstmt.setBytes(3, xid.getGlobalTransactionId());
cstmt.setBytes(4, xid.getBranchQualifier());
cstmt.setInt(5, this.timeout);
cstmt.setInt(6, flag);
cstmt.execute();
returnVal = cstmt.getInt(1);
} catch (SQLException s) {
returnVal = s.getErrorCode();
if (returnVal == 0) {
throw new XAException(-6);
} finally {
if (cstmt != null) cstmt.close();
} catch (SQLException s) {
cstmt = null;
return returnVal;
public class DruidXAPooledConnection extends DruidPooledConnection implements XAConnection {
protected XAResource xaResource = null;
public DruidXAPooledConnection(DruidConnectionHolder holder){
super(holder);
@Override
public XAResource getXAResource() throws SQLException {
return null;
public abstract class DruidXAResource implements XAResource {
public final static Log                LOG                         = LogFactory.getLog(DruidXAResource.class);
public static final int                XA_OK                       = 0;
public static final short              DEFAULT_XA_TIMEOUT          = 60;
protected boolean                      savedConnectionAutoCommit   = false;
protected boolean                      savedXAConnectionAutoCommit = false;
public static final int                TMNOFLAGS                   = 0;
public static final int                TMNOMIGRATE                 = 2;
public static final int                TMENDRSCAN                  = 8388608;
public static final int                TMFAIL                      = 536870912;
public static final int                TMMIGRATE                   = 1048576;
public static final int                TMJOIN                      = 2097152;
public static final int                TMONEPHASE                  = 1073741824;
public static final int                TMRESUME                    = 134217728;
public static final int                TMSTARTRSCAN                = 16777216;
public static final int                TMSUCCESS                   = 67108864;
public static final int                TMSUSPEND                   = 33554432;
public static final int                ORATMREADONLY               = 256;
public static final int                ORATMREADWRITE              = 512;
public static final int                ORATMSERIALIZABLE           = 1024;
public static final int                ORAISOLATIONMASK            = 65280;
public static final int                ORATRANSLOOSE               = 65536;
protected Connection                   connection                  = null;
protected DruidXAPooledConnection      xaconnection                = null;
protected int                          timeout                     = 60;
protected String                       dblink                      = null;
protected Hashtable<Xid, XidListEntry> xidHash                     = new Hashtable<Xid, XidListEntry>(50);
Xid                                    lastActiveXid               = null;
protected Xid                          activeXid                   = null;
protected boolean                      canBeMigratablySuspended    = false;
protected boolean                      isTMRScanStarted            = false;
protected static final Xid[]           NO_XID                      = new Xid[0];
public int getTransactionTimeout() throws XAException {
return this.timeout;
public boolean setTransactionTimeout(int seconds) throws XAException {
if (seconds < 0) {
throw new XAException(-5);
this.timeout = seconds;
return true;
protected void saveAndAlterAutoCommitModeForGlobalTransaction() throws XAException {
this.savedConnectionAutoCommit = this.connection.getAutoCommit();
this.connection.setAutoCommit(false);
this.savedXAConnectionAutoCommit = this.connection.getAutoCommit();
this.xaconnection.setAutoCommit(false); 
} catch (SQLException ex) {
LOG.error(ex.getMessage(), ex);
protected final synchronized boolean removeXidFromList(Xid xid) {
if (isSameXid(this.activeXid, xid)) {
this.activeXid = null;
return this.xidHash.remove(xid) != null;
protected void resumeStacked(Xid xid) throws XAException {
if (xid != null) {
start(xid, 134217728);
this.activeXid = xid;
protected Xid suspendStacked(Xid xid) throws XAException {
Xid stackedXid = null;
if ((this.activeXid != null) && (!isSameXid(this.activeXid, xid))) {
stackedXid = this.activeXid;
if (!isXidSuspended(this.activeXid)) {
end(this.activeXid, 33554432);
this.lastActiveXid = this.activeXid;
this.activeXid = null;
Xid localXid1 = stackedXid;
return localXid1;
protected boolean isXidSuspended(Xid xid) throws XAException {
boolean returnValue = false;
XidListEntry x = getMatchingXidListEntry(xid);
if (x != null) {
returnValue = x.isSuspended;
return returnValue;
protected void checkError(int error) throws XAException {
protected void checkError(int error, int defaultXAError) throws XAException {
protected void checkError(SQLException sqlex, int defaultXAError) throws XAException {
final boolean isSameXid(Xid xid1, Xid xid2) {
return xid1 == xid2;
protected synchronized void createOrUpdateXid(Xid xid, boolean isSuspended, boolean[] isLocallySuspended) {
XidListEntry x = getMatchingXidListEntry(xid);
if (x != null) {
isLocallySuspended[0] = true;
x.isSuspended = isSuspended;
x = new XidListEntry(xid, isSuspended);
this.xidHash.put(xid, x);
if (isSuspended) {
this.lastActiveXid = this.activeXid;
this.activeXid = null;
enterGlobalTxnMode();
if ((this.lastActiveXid != null) && (isSameXid(xid, this.lastActiveXid))) {
this.lastActiveXid = null;
this.activeXid = x.xid;
protected void restoreAutoCommitModeForGlobalTransaction() throws XAException {
if (this.savedConnectionAutoCommit) {
this.connection.setAutoCommit(this.savedConnectionAutoCommit);
this.xaconnection.setAutoCommit(this.savedXAConnectionAutoCommit); 
} catch (SQLException ignoreException) {
abstract void enterGlobalTxnMode();
final synchronized XidListEntry getMatchingXidListEntry(Xid xid) {
return (XidListEntry) this.xidHash.get(xid);
protected final synchronized boolean isXidListEmpty() {
return this.xidHash.isEmpty();
class XidListEntry {
Xid     xid;
boolean isSuspended;
XidListEntry(Xid x, boolean s){
this.xid = x;
this.isSuspended = s;
public static short getVersionNumber(DruidPooledConnection conn) throws SQLException {
oracle.jdbc.internal.OracleConnection oracleConn = (oracle.jdbc.internal.OracleConnection) unwrap(conn);
return oracleConn.getVersionNumber();
private static final long serialVersionUID = 1L;
private int               xaError          = 0;
private int               primary          = 0;
private int               secondary        = 0;
public int getOracleError() {
return this.primary;
public int getOracleSQLError() {
return this.secondary;
ArrayList<DruidXid> xidCollection = new ArrayList<DruidXid>(50);
xidCollection.add(new DruidXid(rset.getInt(1), rset.getBytes(2), rset.getBytes(3)));
public class DruidXid implements Xid {
private int             formatId;
private byte[]          gtrid        = null;
private byte[]          bqual        = null;
private byte[]          txctx        = null;
public static final int MAXGTRIDSIZE = 64;
public static final int MAXBQUALSIZE = 64;
private int             state;
public DruidXid(int fId, byte[] gId, byte[] bId) throws XAException{
this(fId, gId, bId, null);
public DruidXid(int fId, byte[] gId, byte[] bId, byte[] context) throws XAException{
this.formatId = fId;
if ((gId != null) && (gId.length > 64)) {
throw new XAException(-4);
this.gtrid = gId;
if ((bId != null) && (bId.length > 64)) {
throw new XAException(-4);
this.bqual = bId;
this.txctx = context;
this.state = 0;
public void setState(int k) {
this.state = k;
public int getState() {
return this.state;
public int getFormatId() {
return this.formatId;
public byte[] getGlobalTransactionId() {
return this.gtrid;
public byte[] getBranchQualifier() {
return this.bqual;
public byte[] getTxContext() {
return this.txctx;
public void setTxContext(byte[] context) {
this.txctx = context;
public static final boolean isLocalTransaction(Xid xid) {
byte[] gtrid = xid.getGlobalTransactionId();
if (gtrid == null) {
return true;
for (int i = 0; i < gtrid.length; i++) {
if (gtrid[i] == 0) {
return false;
return true;
if ((xares instanceof DruidXAOracleResource)) {
conn1 = ((DruidXAOracleResource) xares).getConnection();
int x_e = DruidXAOracleException.errorConvert(returnVal);
public Connection getConnection() {
return this.connection;
protected void initOracle() throws SQLException {
private final static Log  LOG              = LogFactory.getLog(DruidAXDataSource.class);
DruidPooledConnection conn = this.getConnection();
Connection physicalConn = conn.unwrap(Connection.class);
if (JdbcUtils.ORACLE.equals(dbType)) {
return OracleUtils.OracleXAConnection(physicalConn);
} catch (XAException xae) {
LOG.error("create xaConnection error", xae);
return null;
if (JdbcUtils.MYSQL.equals(dbType)) {
return MySqlUtils.createXAConnection(physicalConn);
if (JdbcUtils.POSTGRESQL.equals(dbType)) {
return PGUtils.createXAConnection(physicalConn);
throw new SQLException("xa not support dbType : " + this.dbType);
public class MySqlUtils {
public static MysqlXAConnection createXAConnection(Connection physicalConn) throws SQLException {
return new MysqlXAConnection((com.mysql.jdbc.ConnectionImpl) physicalConn, false);
public static OracleXAConnection OracleXAConnection(Connection oracleConnection) throws XAException {
return new OracleXAConnection(oracleConnection);
public class PGUtils {
public static PGXAConnection createXAConnection(Connection physicalConn) throws SQLException {
return new PGXAConnection((BaseConnection) physicalConn);
public class JtdsXAConnection implements XAConnection {
private Connection       connection;
private final XAResource resource;
private final int        xaConnectionId;
public JtdsXAConnection(Connection connection) throws SQLException{
this.resource = new JtdsXAResource(this, connection);
this.connection = connection;
this.xaConnectionId = XASupport.xa_open(connection);
int getXAConnectionID() {
return this.xaConnectionId;
public Connection getConnection() throws SQLException {
return connection;
public void close() throws SQLException {
XASupport.xa_close(connection, xaConnectionId);
} catch (SQLException e) {
JdbcUtils.close(connection);
public void addConnectionEventListener(ConnectionEventListener listener) {
public void removeConnectionEventListener(ConnectionEventListener listener) {
public void addStatementEventListener(StatementEventListener listener) {
public void removeStatementEventListener(StatementEventListener listener) {
public XAResource getXAResource() throws SQLException {
return resource;
public class JtdsXAResource implements XAResource {
private final Connection       connection;
private final JtdsXAConnection xaConnection;
private final String           rmHost;
public JtdsXAResource(JtdsXAConnection xaConnection, Connection connection){
this.xaConnection = xaConnection;
this.connection = connection;
rmHost = ((ConnectionJDBC2) connection).getRmHost();
protected JtdsXAConnection getResourceManager() {
return xaConnection;
protected String getRmHost() {
return this.rmHost;
public void commit(Xid xid, boolean commit) throws XAException {
XASupport.xa_commit(connection, xaConnection.getXAConnectionID(), xid, commit);
public void end(Xid xid, int flags) throws XAException {
XASupport.xa_end(connection, xaConnection.getXAConnectionID(), xid, flags);
public void forget(Xid xid) throws XAException {
XASupport.xa_forget(connection, xaConnection.getXAConnectionID(), xid);
public int getTransactionTimeout() throws XAException {
public boolean isSameRM(XAResource xares) throws XAException {
if (xares instanceof JtdsXAResource) {
if (((JtdsXAResource) xares).getRmHost().equals(this.rmHost)) {
return true;
return false;
public int prepare(Xid xid) throws XAException {
return XASupport.xa_prepare(connection, xaConnection.getXAConnectionID(), xid);
public Xid[] recover(int flags) throws XAException {
return XASupport.xa_recover(connection, xaConnection.getXAConnectionID(), flags);
public void rollback(Xid xid) throws XAException {
XASupport.xa_rollback(connection, xaConnection.getXAConnectionID(), xid);
public boolean setTransactionTimeout(int seconds) throws XAException {
return false;
public void start(Xid xid, int flags) throws XAException {
XASupport.xa_start(connection, xaConnection.getXAConnectionID(), xid, flags);
XAConnection rawXAConnection;
rawXAConnection = OracleUtils.OracleXAConnection(physicalConn);
} else if (JdbcUtils.MYSQL.equals(dbType)) {
rawXAConnection = MySqlUtils.createXAConnection(physicalConn);
} else if (JdbcUtils.POSTGRESQL.equals(dbType)) {
rawXAConnection = PGUtils.createXAConnection(physicalConn);
throw new SQLException("xa not support dbType : " + this.dbType);
return new DruidPooledXAConnection(conn, rawXAConnection);
public class DruidPooledXAConnection implements XAConnection {
private DruidPooledConnection pooledConnection;
private XAConnection          xaConnection;
public DruidPooledXAConnection(DruidPooledConnection pooledConnection, XAConnection xaConnection){
this.pooledConnection = pooledConnection;
this.xaConnection = xaConnection;
public Connection getConnection() throws SQLException {
return pooledConnection;
public void close() throws SQLException {
pooledConnection.close();
public void addConnectionEventListener(ConnectionEventListener listener) {
pooledConnection.addConnectionEventListener(listener);
public void removeConnectionEventListener(ConnectionEventListener listener) {
pooledConnection.removeConnectionEventListener(listener);
public void addStatementEventListener(StatementEventListener listener) {
pooledConnection.addStatementEventListener(listener);
public void removeStatementEventListener(StatementEventListener listener) {
pooledConnection.removeStatementEventListener(listener);
public XAResource getXAResource() throws SQLException {
return xaConnection.getXAResource();
return JSON.toJSONStringWithDateFormat(dataMap, "yyyy-MM-dd HH:mm:ss");
if (JdbcUtils.JTDS.equals(dbType)) {
return new JtdsXAConnection(physicalConn);
public static final String      JTDS             = "jtds";
return JTDS;
constructor = JdbcXAConnection.class.getDeclaredConstructor(JdbcDataSourceFactory.class, int.class,
method = TraceObject.class.getDeclaredMethod("getNextId", int.class);
public class H2XATest extends TestCase {
private DruidXADataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidXADataSource();
dataSource.setMinIdle(1);
dataSource.setUrl("jdbc:h2:mem:test;");
dataSource.setTestOnBorrow(false);
JdbcUtils.execute(dataSource, "CREATE TABLE user (id INT, name VARCHAR(40))");
protected void tearDown() throws Exception {
JdbcUtils.execute(dataSource, "DROP TABLE user");
JdbcUtils.close(dataSource);
public void test_0() throws Exception {
XAConnection conn = dataSource.getXAConnection();
conn.close();
private Logger dataSourceLogger = Logger.getLogger(dataSourceLoggerName);
private Logger connectionLogger = Logger.getLogger(connectionLoggerName);
private Logger statementLogger  = Logger.getLogger(statementLoggerName);
private Logger resultSetLogger  = Logger.getLogger(resultSetLoggerName);
protected String          dataSourceLoggerName                 = "druid.sql.DataSource";
protected String          connectionLoggerName                 = "druid.sql.Connection";
protected String          statementLoggerName                  = "druid.sql.Statement";
protected String          resultSetLoggerName                  = "druid.sql.ResultSet";
private Logger dataSourceLogger = LoggerFactory.getLogger(dataSourceLoggerName);
private Logger connectionLogger = LoggerFactory.getLogger(connectionLoggerName);
private Logger statementLogger  = LoggerFactory.getLogger(statementLoggerName);
private Logger resultSetLogger  = LoggerFactory.getLogger(resultSetLoggerName);
public class DruidStatJSONService implements DruidStatJSONServiceMBean {
public interface DruidStatJSONServiceMBean {
String service(String url);
protected void doInBackground(MBeanServerConnection conn) throws Exception {
ObjectName name = new ObjectName(DruidStatService.MBEAN_NAME);
String url = "/sql.json";
String result = (String) conn.invoke(name, "service", new String[] { url }, new String[] { String.class.getName() });
System.out.println("doInBackground");
Object o = JSONUtils.parse(result);
System.out.println(o);
public class MySqlSelectTest_7 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select * from tb order by id asc,name desc";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNotNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(2, visitor.getOrderByColumns().size());
if (token == Token.NULL) {
nextToken();
return null;
if (text.startsWith("null", index)) {
token = Token.NULL;
index += 3;
nextChar();
SQLBinaryOperator op = SQLBinaryOperator.GreaterThan;
if (lexer.token() == Token.EQ) {
lexer.nextToken();
op = SQLBinaryOperator.GreaterThanOrEqual;
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, op, rightExp);
throw new SQLParseException("syntax error, expect " + token + ", actual " + lexer.token() + " "
+ lexer.stringVal());
public class OracleSelectTest37 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select resource_value,count(resource_value) nums,http_method "
+ "from ( "
+ "       select * from audit_url_log "
+ "       where project_id = ? and to_char(begin_time,'yyyy-MM-dd') >= ? and to_char(begin_time,'yyyy-MM-dd') <= ? ) "
+ "       group by resource_value,http_method having count(resource_value) > = ?"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("audit_url_log")));
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("audit_url_log", "project_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("audit_url_log", "begin_time")));
SQLBinaryOperator op = SQLBinaryOperator.LessThan;
if (lexer.token() == Token.EQ) {
lexer.nextToken();
op = SQLBinaryOperator.LessThanOrEqual;
expr = new SQLBinaryOpExpr(expr, op, rightExp);
+ "       where project_id = ? and to_char(begin_time,'yyyy-MM-dd') > = ? and to_char(begin_time,'yyyy-MM-dd') < = ? ) "
return wrap(resultSet.getStatementProxy(), (Clob) obj);
return wrap(resultSet.getStatementProxy(), (Clob) obj);
return wrap(resultSet.getStatementProxy(), (Clob) obj);
return wrap(resultSet.getStatementProxy(), clob);
return wrap(resultSet.getStatementProxy(), (Clob) obj);
return wrap(resultSet.getStatementProxy(), clob);
return wrap(statement, (Clob) obj);
return wrap(statement, (Clob) obj);
return wrap(statement, (Clob) obj);
return wrap(statement, (Clob) obj);
return wrap(statement, clob);
return wrap(statement, clob);
public ClobProxy wrap(ConnectionProxy conn, Clob clob) {
if (clob == null) {
return null;
if (clob instanceof NClob) {
return wrap(conn, (NClob) clob);
return new ClobProxyImpl(dataSource, conn, clob);
public NClobProxy wrap(ConnectionProxy conn, NClob clob) {
if (clob == null) {
return null;
return new NClobProxyImpl(dataSource, conn, clob);
public ClobProxy wrap(StatementProxy stmt, Clob clob) {
return wrap(stmt, (NClob) clob);
return new ClobProxyImpl(dataSource, stmt.getConnectionProxy(), clob);
public NClobProxy wrap(StatementProxy stmt, NClob nclob) {
return new NClobProxyImpl(dataSource, stmt.getConnectionProxy(), nclob);
private final AtomicLong clobOpenCount                     = new AtomicLong();
clobOpenCount.set(0);
public long getUpdateCountMax() {
public long getFetchRowCountMax() {
public long getClobOpenCount() {
return clobOpenCount.get();
public void incrementClobOpenCount() {
clobOpenCount.incrementAndGet();
this.fetchRowCount.addAndGet(delta);
"LastSlowParameters", 
"ResultSetHoldTime", 
"ExecuteAndResultSetHoldTime", 
"EffectedRowCountHistogram", 
"FetchRowCountMax"
clobOpenAfter(chain.getDataSource().getDataSourceStat(), resultSet, (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), resultSet, (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) clob);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
private void clobOpenAfter(JdbcDataSourceStat dataSourceStat, ResultSetProxy rs, ClobProxy clob) {
clobOpenAfter(dataSourceStat, rs.getStatementProxy(), clob);
private void clobOpenAfter(JdbcDataSourceStat dataSourceStat, StatementProxy stmt, ClobProxy clob) {
dataSourceStat.incrementClobOpenCount();
if (stmt != null) {
JdbcSqlStat sqlStat = stmt.getSqlStat();
if (sqlStat != null) {
sqlStat.incrementClobOpenCount();
StatFilterContext.getInstance().clob_open();
SimpleType.LONG, 
"FetchRowCountMax", 
"ClobOpenCount",
map.put("ExecuteAndResultHoldTimeHistogram", this.getExecuteAndResultHoldTimeHistogram().toArray()); 
map.put("EffectedRowCountMax", getUpdateCountMax()); 
map.put("FetchRowCountMax", getFetchRowCountMax()); 
map.put("ClobOpenCount", getClobOpenCount()); 
String slowParameters = buildSlowParameters(statement);
sqlStat.setLastSlowParameters(slowParameters);
+ slowParameters);
private String buildSlowParameters(StatementProxy statement) {
JSONWriter out = new JSONWriter();
out.writeArrayStart();
out.writeComma();
out.writeNull();
out.writeString(text.substring(0, 97) + "...");
out.writeString(text);
out.writeObject(value);
out.writeObject(value);
out.writeObject(value);
out.writeString("<InputStream>");
out.writeString("<Clob>");
out.writeString("<NClob>");
out.writeString("<Blob>");
out.writeString('<' + value.getClass().getName() + '>');
out.writeArrayEnd();
return out.toString();
if (clob == null) {
throw new IllegalArgumentException("clob is null");
public void writeArrayStart() {
write('[');
public void writeComma() {
write(',');
public void writeArrayEnd() {
write(']');
public void writeNull() {
write("null");
writeNull();
writeNull();
writeNull();
writeNull();
writeNull();
writeNull();
writeNull();
writeNull();
ResultSetProxy resultSet = chain.preparedStatement_executeQuery(statement);
} else if (value instanceof Clob) {
out.writeString("<Clob>");
return conn.getDriver().executeQuery(this, sql);
} else if (expr instanceof SQLVariantRefExpr) {
SQLVariantRefExpr varExpr = (SQLVariantRefExpr) expr;
int varIndex = varExpr.getIndex();
if (statement instanceof MockPreparedStatement) {
MockPreparedStatement mockPstmt = (MockPreparedStatement) statement;
row[i] = mockPstmt.getParameters().get(varIndex);
row[i] = null;
row[i] = null;
public class StatFilterBuildSlowParameterTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.setConnectionProperties("druid.stat.slowSqlMillis=1");
MockDriver driver = new MockDriver() {
public ResultSet executeQuery(MockStatementBase stmt, String sql) throws SQLException {
Thread.sleep(2);
} catch (InterruptedException e) {
e.printStackTrace();
return super.executeQuery(stmt, sql);
dataSource.setDriver(driver);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_buildSlowSql() throws Exception {
long currentMillis = System.currentTimeMillis();
String sql = "select ?, ?, ?, ?, ?";
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date date = new Date(System.currentTimeMillis());
String dateText = dateFormat.format(date);
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setBoolean(1, true);
stmt.setInt(2, 123);
stmt.setLong(3, 10001);
stmt.setTimestamp(4, new java.sql.Timestamp(currentMillis));
stmt.setDate(5, new java.sql.Date(currentMillis));
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertNotNull(sqlStat);
String slowParameters = sqlStat.getLastSlowParameters();
Assert.assertNotNull(slowParameters);
List<Object> parameters = (List<Object>) JSONUtils.parse(slowParameters);
Assert.assertEquals(5, parameters.size());
Assert.assertEquals(true, parameters.get(0));
Assert.assertEquals(123, parameters.get(1));
Assert.assertEquals(10001, parameters.get(2));
Assert.assertEquals(dateText, parameters.get(3));
Assert.assertEquals(dateText, parameters.get(4));
currentMillis = System.currentTimeMillis();
date = new Date(System.currentTimeMillis());
dateText = dateFormat.format(date);
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setBoolean(1, false);
stmt.setInt(2, 234);
stmt.setLong(3, 10002);
stmt.setTimestamp(4, new java.sql.Timestamp(currentMillis));
stmt.setDate(5, new java.sql.Date(currentMillis));
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertNotNull(sqlStat);
String slowParameters = sqlStat.getLastSlowParameters();
Assert.assertNotNull(slowParameters);
List<Object> parameters = (List<Object>) JSONUtils.parse(slowParameters);
Assert.assertEquals(5, parameters.size());
Assert.assertEquals(false, parameters.get(0));
Assert.assertEquals(234, parameters.get(1));
Assert.assertEquals(10002, parameters.get(2));
Assert.assertEquals(dateText, parameters.get(3));
Assert.assertEquals(dateText, parameters.get(4));
StringBuilder buf = new StringBuilder();
for (int i = 0; i < 10; ++i) {
buf.append("abcdefghijklmnABCDEFGHIJKLMN1234567890!@#$%^&*(");
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setNull(1, Types.VARCHAR);
stmt.setString(2, buf.toString());
stmt.setClob(3, new MockClob());
stmt.setNClob(4, new MockNClob());
stmt.setBlob(5, new MockBlob());
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertNotNull(sqlStat);
String slowParameters = sqlStat.getLastSlowParameters();
Assert.assertNotNull(slowParameters);
List<Object> parameters = (List<Object>) JSONUtils.parse(slowParameters);
Assert.assertEquals(5, parameters.size());
Assert.assertEquals(null, parameters.get(0));
Assert.assertEquals(buf.substring(0, 97) + "...", parameters.get(1));
Assert.assertEquals("<Clob>", parameters.get(2));
Assert.assertEquals("<NClob>", parameters.get(3));
Assert.assertEquals("<Blob>", parameters.get(4));
StringBuilder buf = new StringBuilder();
for (int i = 0; i < 10; ++i) {
buf.append("abcdefghijklmnABCDEFGHIJKLMN1234567890!@#$%^&*(");
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setBinaryStream(1, new ByteInputStream(new byte[0]));
stmt.setString(2, buf.toString());
stmt.setTime(3, new Time(currentMillis));
stmt.setBigDecimal(4, new BigDecimal("56789.123"));
stmt.setRowId(5, new MockRowId());
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertNotNull(sqlStat);
String slowParameters = sqlStat.getLastSlowParameters();
Assert.assertNotNull(slowParameters);
List<Object> parameters = (List<Object>) JSONUtils.parse(slowParameters);
Assert.assertEquals(5, parameters.size());
Assert.assertEquals("<InputStream>", parameters.get(0));
Assert.assertEquals(buf.substring(0, 97) + "...", parameters.get(1));
Assert.assertEquals(dateText, parameters.get(2));
Assert.assertEquals(56789.123, parameters.get(3));
Assert.assertEquals("<com.alibaba.druid.mock.MockRowId>", parameters.get(4));
public class StatFilterClobTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_clob() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
MockClob clob = new MockClob();
stmt.setClob(1, clob);
ResultSet rs = stmt.executeQuery();
rs.next();
Assert.assertTrue(rs.getObject(1) instanceof ClobProxy);
rs.close();
stmt.close();
conn.close();
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertNotNull(sqlStat);
Assert.assertEquals(1, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
dataMap.put("ClobOpenCount", this.getDataSourceStat().getClobOpenCount());
PreparedStatement stmt = conn.prepareStatement("SELECT 1");
PreparedStatement stmt = conn.prepareStatement("SELECT 1");
if (poolingCount > 0) {
poolingPeak = poolingCount;
poolingPeakTime = System.currentTimeMillis();
if (poolingCount > poolingPeak) {
poolingPeak = poolingCount;
poolingPeakTime = System.currentTimeMillis();
lock.lock();
return poolingPeak;
} finally {
lock.unlock();
public long getOSMacOSXCount() {
public long getOSWindowsCount() {
public long getOSLinuxCount() {
public long getOSSymbianCount() {
public long getOSFreeBSDCount() {
public long getOSOpenBSDCount() {
public long getOSAndroidCount() {
public long getOSWindows98Count() {
public long getOSWindowsXPCount() {
public long getOSWindows2000Count() {
public long getOSWindowsVistaCount() {
public long getOSWindows7Count() {
public long getOSAndroid15Count() {
public long getOSAndroid16Count() {
public long getOSAndroid20Count() {
public long getOSAndroid21Count() {
public long getOSAndroid22Count() {
public long getOSAndroid23Count() {
public long getOSAndroid30Count() {
public long getOSAndroid31Count() {
public long getOSAndroid32Count() {
public long getOSAndroid40Count() {
public long getOSLinuxUbuntuCount() {
public class UserAgentBotStat extends TestCase {
public void test_youdao() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; YoudaoBot/1.0; http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotYoudaoCount());
public void test_bing() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; bingbot/2.0; +http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotBingCount());
public void test_google() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Googlebot/2.1; +http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotGoogleCount());
public void test_baidu() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Baiduspider/2.0; +http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotBaiduCount());
public void test_soso() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Sosospider+(+http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotSosoCount());
public void test_msn() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("msnbot/2.0b (+http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotMsnCount());
public void test_sogou() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Sogou web spider/4.0(+http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotSogouCount());
public void test_yahoo() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Yahoo! Slurp; http:
Assert.assertEquals(1, stat.getBotCount());
Assert.assertEquals(1, stat.getBotYahooCount());
public void test_unkownBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 ()");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Mail.RU/2.0)");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot2() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MJ12bot/v1.4.2; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot3() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("-");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot4() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent(""Mozilla/5.0");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot5() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) Speedy Spider (http:
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot6() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot7() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Crawl/0.01 libcrawl/0.3");
Assert.assertEquals(1, stat.getBotCount());
public void test_unkownBot8() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("SkimBot/1.0 (www.skimlinks.com <dev@skimlinks.com>)");
Assert.assertEquals(1, stat.getBotCount());
public void test_huawei() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("HuaweiSymantecSpider/1.0+DSE-support@huaweisymantec.com+(compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR ; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_Yeti() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Yeti/1.0 (NHN Corp.; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_KaloogaBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; KaloogaBot; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_YandexBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; YandexBot/3.0; +http:
Assert.assertEquals(1, stat.getBotCount());
public void test_Ezooms() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Ezooms/1.0; ezooms.bot@gmail.com)");
Assert.assertEquals(1, stat.getBotCount());
public void test_Exabot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; Exabot/3.0; +http:
Assert.assertEquals(1, stat.getBotCount());
public void test_mahonie() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("mahonie, neofonie search:robot/search:robot/0.0.1 (This is the MIA Bot - crawling for mia research project. If you feel unhappy and do not want to be visited by our crawler send an email to spider@neofonie.de; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_AhrefsBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; AhrefsBot/3.0; +http:
Assert.assertEquals(1, stat.getBotCount());
public void test_Crawler() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; SISTRIX Crawler; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_yodao() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; YodaoBot/1.0; http:
Assert.assertEquals(1, stat.getBotCount());
public void test_BeetleBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; BeetleBot; )");
Assert.assertEquals(1, stat.getBotCount());
public void test_findlinks() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("findlinks/2.1.5 (+http:
Assert.assertEquals(1, stat.getBotCount());
public void test_Updownerbot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Updownerbot (+http:
Assert.assertEquals(1, stat.getBotCount());
public void test_archiveOrgBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; archive.org_bot +http:
Assert.assertEquals(1, stat.getBotCount());
public void test_aiHitBot() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; aiHitBot/1.1; +http:
Assert.assertEquals(1, stat.getBotCount());
public void test_DoCoMo() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("DoCoMo/2.0 P900i(c100;TB;W24H11) (compatible; ichiro/mobile goo; +http:
Assert.assertEquals(1, stat.getBotCount());
public class UserAgentMacTest extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2) Gecko/20100115 Firefox/3.6");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentTest extends TestCase {
public void test_agent_ie10() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie9() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE9Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie9_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; 360SE)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE9Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie9_x86() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE9Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie8() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; chromeframe; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; MAXTHON 2.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie8_x1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie8_x2() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; GoogleToolbar 7.2.2427.2330; Windows XP 5.1; MSIE 8.0.6001.18702)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie8_x3() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; GoogleToolbar 7.3.2710.138; Windows 6.1; MSIE 8.0.7601.17514)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie7() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0; MAXTHON 2.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE7Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie7_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3; SE 2.X MetaSr 1.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE7Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie6() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 6.0; MAXTHON 2.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie6_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie6_2() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("User-Agent: Mozilla/5.0 (compatible; MSIE 6.0;Windows XP)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ie5() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 5.00; Windows 98)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_ipad() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) ");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getDeviceIpadCount());
public void test_agent_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
public void test_agent_chrome() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
public void test_agent_opera() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Opera/9.64 (Windows NT 5.1; U; en) Presto/2.1.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(1, stat.getBrowserOperaCount());
public void test_agent_android22() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
public void test_agent_other() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("SEC-schx199 UP.Browser/4.1.26l UP.Link/5.1.2.9");
Assert.assertEquals(0, stat.getBrowserIECount());
public void test_agent_other_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mitsu/1.2.B (MT560) MMP/1.1");
Assert.assertEquals(0, stat.getBrowserIECount());
public void test_0() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Science Traveller International 1X/1.0");
stat.computeUserAgent("Mozilla/3.0 (compatible)");
stat.computeUserAgent("amaya/9.52 libwww/5.4.0");
stat.computeUserAgent("amaya/9.51 libwww/5.4.0");
stat.computeUserAgent("amaya/9.1 libwww/5.4.0");
stat.computeUserAgent("amaya/6.2 libwww/5.3.1");
stat.computeUserAgent("AmigaVoyager/3.4.4 (MorphOS/PPC native)");
stat.computeUserAgent("xChaos_Arachne/5.1.89;GPL,386+");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Ubuntu APT-HTTP/1.3 (0.7.23.1ubuntu2)");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_2() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Ubuntu APT-HTTP/1.3");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_3() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(1, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_firefox_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.14) Gecko/20080409 Camino/1.6 (like Firefox/2.0.0.14)");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_firefox_2() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (X11; U; Linux i686; en; rv:1.9.0.11) Gecko/20080528 Epiphany/2.22 Firefox/3.0");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_firefox_3() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (X11; U; OpenBSD i386; en-US; rv:1.8.1.14) Gecko/20080821 Firefox/2.0.0.14");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(1, stat.getOSOpenBSDCount());
public void test_firefox_4() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.3) Gecko/20041002 Firefox/0.10.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_firefox_5() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_firefox_6() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.16) Gecko/20110319 Firefox/3.6.16");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public void test_android_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 2.2.1; fr-ch; A43 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid22Count());
public void test_android_15() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 1.5; zh-cn; ME600 Build/CUPCAKE) AppleWebKit/528.5+ (KHTML, like Gecko) Version/3.1.2 Mobile Safari/525.20.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid15Count());
public void test_android_16() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 1.6; en-gb; Dell Streak Build/Donut AppleWebKit/528.5+ (KHTML, like Gecko) Version/3.1.2 Mobile Safari/ 525.20.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid16Count());
public void test_android_21() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 2.1-update1; de-de; HTC Desire 1.19.161.5 Build/ERE27) AppleWebKit/530.17 (KHTML, like Gecko) Version/4.0 Mobile Safari/530.17");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid21Count());
public void test_android_23() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 2.3.3; zh-cn; HTC Incredible S Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid23Count());
public void test_android_4() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 4.0.4; zh-cn; Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid40Count());
public void test_safari() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSAndroidCount());
Assert.assertEquals(0, stat.getOSAndroid21Count());
public void test_iphone() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_1 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8B117 Safari/6531.22.7 (compatible; Googlebot-Mobile/2.1; +http:
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(1, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(1, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSAndroidCount());
Assert.assertEquals(0, stat.getOSAndroid21Count());
public void test_ipad() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (iPad; CPU OS 5_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A405 Safari/7534.48.3");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(1, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(1, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSAndroidCount());
Assert.assertEquals(0, stat.getOSAndroid21Count());
public void test_opera() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Opera/9.00 (Windows NT 4.0; U; en)");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(1, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSAndroidCount());
Assert.assertEquals(0, stat.getOSAndroid21Count());
public void test_opera_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Opera/9.80 (Macintosh; Intel Mac OS X; U; en) Presto/2.2.15 Version/10.00");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(1, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(1, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSAndroidCount());
Assert.assertEquals(0, stat.getOSAndroid21Count());
public class UserAgentWindows extends TestCase {
public void test_windows98() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 5.00; Windows 98)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSWindows98Count());
public void test_windows98_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Win 9x 4.90; AT&T CSM6.0; FunWebProducts)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(1, stat.getOSWindows98Count());
public void test_windowsXP() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows XP)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_IE6() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("User-Agent: Mozilla/5.0 (compatible; MSIE 6.0;Windows XP)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_IE6_1() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_IE7() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; User-agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; http:
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_IE8() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_IE9() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 5.1; WOW64; Trident/4.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windowsXP_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsXPCount());
public void test_windows2000_IE5() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_IE6() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 2.0.50727)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(1, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_IE7() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_IE8() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0; Trident/4.0; 360SE)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_IE9() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 5.0; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; 360SE)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(1, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.0; zh-CN; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8 (.NET CLR 3.5.30729)");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_firefox11() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows NT 5.0; rv:11.0) Gecko/20100101 Firefox/11.0");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windows2000_chrome() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows2000Count());
public void test_windowsVista() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022; .NET4.0C; .NET4.0E)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(1, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindowsVistaCount());
public void test_windows7() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3; SE 2.X MetaSr 1.0)");
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(1, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows7Count());
public void test_windows7_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows NT 6.1; rv:11.0) Gecko/20100101 Firefox/11.0");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(1, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows7Count());
public void test_windows7_chrome() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.162 Safari/535.19");
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getBrowserIE5Count());
Assert.assertEquals(0, stat.getBrowserIE6Count());
Assert.assertEquals(0, stat.getBrowserIE7Count());
Assert.assertEquals(0, stat.getBrowserIE8Count());
Assert.assertEquals(0, stat.getBrowserIE9Count());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
Assert.assertEquals(0, stat.getOSWindows98Count());
Assert.assertEquals(1, stat.getOSWindows7Count());
public static final String   PARAM_NAME_USERNAME     	 = "login_username";
public static final String   PARAM_NAME_PASSWORD         = "login_password";
public static final String 	 SESSION_USER_KEY 			 = "druid-user";
private DruidStatService statService                 	 = DruidStatService.getInstance();
private String username 								 = "admin";
private String password 								 = "admin";
String _username = getInitParameter(PARAM_NAME_USERNAME);
String _password = getInitParameter(PARAM_NAME_PASSWORD);
if (_username != null && _username.trim().length() != 0 &&
_password != null && _password.trim().length() != 0) {
username = _username;
password = _password;
HttpSession session = request.getSession();
String contextPath = request.getContextPath();
String servletPath = request.getServletPath();
if ("/submitLogin".equals(path)) {
String _username = request.getParameter(PARAM_NAME_USERNAME);
String _password = request.getParameter(PARAM_NAME_PASSWORD);
if(username.equals(_username) && password.equals(_password)) {
request.getSession().setAttribute(SESSION_USER_KEY, username);
response.getWriter().print("success");
response.getWriter().print("error");
} else if (session.getAttribute(SESSION_USER_KEY) == null && !("/login.html".equals(path) || path.startsWith("/css") || path.startsWith("/js"))) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/login.html");
response.sendRedirect("login.html");
if ("".equals(path)) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/index.html");
response.sendRedirect("druid/index.html");
if ("/".equals(path)) {
response.sendRedirect("index.html");
if (path.indexOf(".json") >= 0) {
String fullUrl = path;
if (request.getQueryString() != null && request.getQueryString().length() > 0) {
fullUrl += "?" + request.getQueryString();
response.getWriter().print(statService.service(fullUrl));
returnResourceFile(path, uri, response);
response.getWriter().print("error");
if (isRequireAuth() && session.getAttribute(SESSION_USER_KEY) == null
&& !("/login.html".equals(path) || path.startsWith("/css") || path.startsWith("/js"))) {
if ("".equals(path)) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/index.html");
response.sendRedirect("druid/index.html");
if ("/".equals(path)) {
response.sendRedirect("index.html");
if (path.indexOf(".json") >= 0) {
String fullUrl = path;
if (request.getQueryString() != null && request.getQueryString().length() > 0) {
fullUrl += "?" + request.getQueryString();
response.getWriter().print(statService.service(fullUrl));
returnResourceFile(path, uri, response);
@SuppressWarnings("unchecked")
} else if (JdbcUtils.MYSQL.equals(this.dbType)) {
LOG.warn("Your dbType is mysql, recommend set testWhileIdle is true and validationQuery shoud not be null");
&& !("/login.html".equals(path) || path.startsWith("/css") || path.startsWith("/js") || path.startsWith("/img"))) {
this.items.get(i).output(buf);
@SuppressWarnings("unchecked")
Map<String, Object> sqlStat = sqlList.get(0);
Assert.assertEquals(0, sqlStat.get("RunningCount"));
Assert.assertEquals(1, sqlStat.get("ExecuteCount"));
Assert.assertEquals(1, sqlStat.get("FetchRowCount"));
Assert.assertEquals(0, sqlStat.get("EffectedRowCount"));
public void test_statService_getSqlList() throws Exception {
public void test_statService_getDataSourceList() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String result = DruidStatService.getInstance().service("/datasource.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> dataSourceList = (List<Map<String, Object>>) resultMap.get("Content");
Assert.assertEquals(1, dataSourceList.size());
Map<String, Object> dataSourceStat = dataSourceList.get(0);
Assert.assertEquals(1, dataSourceStat.get("PoolingCount"));
Assert.assertEquals(0, dataSourceStat.get("ActiveCount"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC master.dbo.sp_addsrvrolemember user, sysadmin"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_droplogin user;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("EXEC sp_addlogin user, pass; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(dbcreator);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(bulkadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(diskadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(processadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(serveradmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(setupadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(securityadmin);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT is_srvrolemember(sysadmin, sa); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, DATABASE); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(null, SERVER); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(master..syslogins, OBJECT);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT permission_name FROM master..fn_my_permissions(sa, USER);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=sometable; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..sysobjects WHERE xtype = U;  use xtype = V for views SELECT name FROM someotherdb..sysobjects WHERE xtype = U; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM master..syslogins WHERE sysadmin = 1 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name + - + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins"));
private String clazzName;
clazzName = clazz.getName();
log = Logger.getLogger(clazzName);
log.logp(Level.SEVERE,clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s, e);
log.logp(Level.SEVERE,clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s);
log.logp(Level.FINE, clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s);
log.logp(Level.FINE, clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s, e);
log.logp(Level.WARNING, clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s);
log.logp(Level.WARNING, clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), s, e);
log.logp(Level.INFO, clazzName, Thread.currentThread().getStackTrace()[1].getMethodName(), msg);
private static final String callerFQCN = Log4jImpl.class.getName();
log.log(callerFQCN, Level.ERROR, s, e);
log.log(callerFQCN, Level.ERROR, s, null);
log.log(callerFQCN, Level.DEBUG, s, null);
log.log(callerFQCN, Level.DEBUG, s, e);
log.log(callerFQCN, Level.WARN, s, null);
log.log(callerFQCN, Level.WARN, s, e);
log.log(callerFQCN, Level.INFO, msg, null);
public String toString() {
return log.toString();
tryImplementation("org.apache.commons.logging.LogFactory",
"com.alibaba.druid.support.logging.JakartaCommonsLoggingImpl");
decrementCachedPreparedStatementCount();
incrementCachedPreparedStatementDeleteCount();
this.poolPreparedStatements = value;
if (!value) {
lock.lock();
} finally {
lock.unlock();
public JdbcSqlStat getSqlStat(long sqlId) {
return this.getDataSourceStat().getSqlStat(sqlId);
public class DruidPooledResultSetTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
public void testWrap() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
ResultSet rs = stmt.executeQuery();
ResultSet raw = rs.unwrap(ResultSet.class);
Assert.assertTrue(raw instanceof MockResultSet);
rs.close();
conn.close();
public void test_notSupport() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
DruidPooledResultSet rs = (DruidPooledResultSet) stmt.executeQuery();
Exception error = null;
rs.getObject(1, String.class);
} catch (SQLFeatureNotSupportedException e) {
error = e;
Assert.assertNotNull(error);
rs.close();
conn.close();
public void test_notSupport_1() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
DruidPooledResultSet rs = (DruidPooledResultSet) stmt.executeQuery();
Exception error = null;
rs.getObject("1", String.class);
} catch (SQLFeatureNotSupportedException e) {
error = e;
Assert.assertNotNull(error);
rs.close();
conn.close();
public class DumpTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
public void testWrap() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
conn.close();
dataSource.dump();
public void testToString() throws Exception {
String sql = "select ?, ?";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
stmt.setInt(2, 33);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
conn.close();
dataSource.toString();
public void test_getPoolingConnectionInfo() throws Exception {
String sql = "select ?, ?";
Connection conn = dataSource.getConnection();
Connection conn1 = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
stmt.setInt(2, 33);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
conn.close();
conn1.close();
List<Map<String, Object>> poolingList = dataSource.getPoolingConnectionInfo();
Assert.assertEquals(2, poolingList.size());
public void test_getStatData() throws Exception {
String sql = "select ?, ?";
Connection conn = dataSource.getConnection();
Connection conn1 = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
stmt.setInt(2, 33);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
conn.close();
conn1.close();
Map<String, Object> statData = dataSource.getStatData();
Assert.assertEquals(2, statData.get("PoolingCount"));
Assert.assertEquals(2, statData.get("PoolingPeak"));
Assert.assertEquals(2L, statData.get("LogicConnectCount"));
Assert.assertEquals(2L, statData.get("LogicCloseCount"));
Assert.assertEquals(0L, statData.get("LogicConnectErrorCount"));
Assert.assertEquals(1, dataSource.getSqlStatMap().size());
JdbcSqlStat sqlStat = dataSource.getSqlStatMap().get(sql);
Assert.assertNotNull(sqlStat);
Assert.assertNotNull(dataSource.getSqlStat(sqlStat.getId()));
Assert.assertNotNull(dataSource.getSqlStat((int) sqlStat.getId()));
public class PoolPreparedStatementsChangeTest extends TestCase {
private DruidDataSource dataSource;
private Log             dataSourceLog;
protected void setUp() throws Exception {
Field logField = DruidDataSource.class.getDeclaredField("LOG");
logField.setAccessible(true);
dataSourceLog = (Log) logField.get(null);
dataSourceLog.resetStat();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.init();
Assert.assertEquals(1, dataSourceLog.getInfoCount());
protected void tearDown() throws Exception {
dataSource.close();
public void test_connectPropertiesChange() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
Assert.assertEquals(false, dataSource.isPoolPreparedStatements());
dataSource.setPoolPreparedStatements(true);
Assert.assertEquals(true, dataSource.isPoolPreparedStatements());
String sql = "select ?";
Assert.assertEquals(0, dataSource.getCachedPreparedStatementCount());
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
ResultSet rs = stmt.executeQuery();
rs.close();
conn.close();
Assert.assertEquals(1, dataSource.getCachedPreparedStatementCount());
Assert.assertEquals(1, dataSource.getCachedPreparedStatementAccessCount());
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
ResultSet rs = stmt.executeQuery();
rs.close();
conn.close();
Assert.assertEquals(1, dataSource.getCachedPreparedStatementCount());
Assert.assertEquals(2, dataSource.getCachedPreparedStatementAccessCount());
dataSource.setPoolPreparedStatements(false);
Assert.assertEquals(0, dataSource.getCachedPreparedStatementCount());
Assert.assertEquals(2, dataSource.getCachedPreparedStatementAccessCount());
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "xxx");
ResultSet rs = stmt.executeQuery();
rs.close();
conn.close();
Assert.assertEquals(0, dataSource.getCachedPreparedStatementCount());
Assert.assertEquals(2, dataSource.getCachedPreparedStatementAccessCount());
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT sysobjects.name as tablename, syscolumns.name as columnname FROM sysobjects JOIN syscolumns ON sysobjects.id = syscolumns.id WHERE sysobjects.xtype = U AND syscolumns.name LIKE %PASSWORD% "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = mytable);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT 1  comment"));
Assert.assertFalse(WallUtils.isValidateSqlServer("WAITFOR DELAY 0:0:5 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("BULK INSERT mydata FROM c:boot.ini;"));
ds.setInitialSize(initialSize); 
Toolkit kit = Toolkit.getDefaultToolkit(); 
Dimension screenSize = kit.getScreenSize(); 
errorCount++;
errorCount++;
histogram.getSum());
histogram.getSum());
Assert.assertEquals(1, histogram.getSum());
public class DruidPooledPreparedStatementTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_hitCount() throws Exception {
String sql = "select ?";
Connection conn = dataSource.getConnection();
DruidPooledPreparedStatement stmt = (DruidPooledPreparedStatement) conn.prepareStatement(sql);
Assert.assertEquals(0, stmt.getFetchSize());
Assert.assertEquals(0, stmt.getFetchDirection());
Assert.assertEquals(0, stmt.getMaxRows());
Assert.assertEquals(0, stmt.getMaxFieldSize());
Assert.assertEquals(0, stmt.getQueryTimeout());
Assert.assertEquals(sql, stmt.getSql());
stmt.setFetchSize(1);
stmt.setFetchDirection(2);
stmt.setMaxRows(3);
stmt.setMaxFieldSize(4);
stmt.setQueryTimeout(5);
Assert.assertEquals(1, stmt.getFetchSize());
Assert.assertEquals(2, stmt.getFetchDirection());
Assert.assertEquals(3, stmt.getMaxRows());
Assert.assertEquals(4, stmt.getMaxFieldSize());
Assert.assertEquals(5, stmt.getQueryTimeout());
stmt.setString(1, "xx");
ResultSet rs = stmt.executeQuery();
Assert.assertTrue(rs.next());
Assert.assertFalse(rs.next());
rs.close();
conn.close();
Assert.assertEquals(0, stmt.getHitCount());
Connection conn = dataSource.getConnection();
DruidPooledPreparedStatement stmt = (DruidPooledPreparedStatement) conn.prepareStatement(sql);
Assert.assertEquals(0, stmt.getFetchSize());
Assert.assertEquals(0, stmt.getFetchDirection());
Assert.assertEquals(0, stmt.getMaxRows());
Assert.assertEquals(0, stmt.getMaxFieldSize());
Assert.assertEquals(0, stmt.getQueryTimeout());
stmt.setString(1, "xx");
ResultSet rs = stmt.executeQuery();
Assert.assertTrue(rs.next());
Assert.assertFalse(rs.next());
rs.close();
conn.close();
Assert.assertEquals(1, stmt.getHitCount());
Assert.assertNotNull(stmt.getKey());
if (!enable) {
connectErrorCount.incrementAndGet();
throw new DataSourceDisableException();
if (!enable) {
connectErrorCount.incrementAndGet();
throw new DataSourceDisableException();
Assert.assertTrue(endLatch.await(60, TimeUnit.SECONDS));
Thread.sleep(10);
return getManifestInfo("Implementation-Version");
public static String getBuildTime() {
return getManifestInfo("Implementation-Build");
@SuppressWarnings("rawtypes")
private static String getManifestInfo(String key) {
URL res = VERSION.class.getResource(VERSION.class.getSimpleName() + ".class");
JarURLConnection conn = (JarURLConnection) res.openConnection();
Manifest manifest = conn.getManifest();
Iterator entries = manifest.getMainAttributes().entrySet().iterator();
while (entries.hasNext()) {
Map.Entry entry = (Map.Entry) entries.next();
String manifestKey = entry.getKey().toString();
if (key.equals(manifestKey)) {
return (String) entry.getValue();
return null;
} catch (IOException e) {
return "n/a";
public class DruidDataSourceTest_closeError extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setInitialSize(1);
dataSource.getProxyFilters().add(new FilterAdapter() {
public void connection_close(FilterChain chain, ConnectionProxy connection) throws SQLException {
throw new SQLException();
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_closeError() throws Exception {
public class DruidDataSourceTest_getProperties extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.getConnectProperties().put("user", "jobs");
dataSource.getConnectProperties().put("password", "xxx");
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_error() throws Exception {
Assert.assertEquals(-1, dataSource.getProperties().indexOf("xxx"));
Assert.assertEquals(true, dataSource.getProperties().indexOf("******") != -1);
public class DruidDataSourceTest_maxWait extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setMaxActive(1);
dataSource.setMaxWait(30);
dataSource.setInitialSize(1);
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_maxWait() throws Exception {
Connection conn = dataSource.getConnection();
final AtomicInteger errorCount = new AtomicInteger();
final CountDownLatch endLatch = new CountDownLatch(2);
Thread t1 = new Thread("t-1") {
public void run() {
dataSource.getConnection();
} catch (Exception e) {
errorCount.incrementAndGet();
} finally {
endLatch.countDown();
Thread t2 = new Thread("t-2") {
public void run() {
dataSource.getConnection();
} catch (Exception e) {
errorCount.incrementAndGet();
} finally {
endLatch.countDown();
t1.start();
t2.start();
Thread.sleep(10);
t1.interrupt();
endLatch.await();
Assert.assertEquals(2, errorCount.get());
conn.close();
public void closePoolableStatement(DruidPooledPreparedStatement stmt) throws SQLException {
public class DruidPooledConnectionTest1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_conn() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
conn.close();
Exception error = null;
conn.handleException(new RuntimeException());
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getRecycleCount());
Assert.assertEquals(1, dataSource.getCloseCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_handleException_1() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
Exception error = null;
conn.handleException(new RuntimeException());
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
conn.close();
Assert.assertEquals(1, dataSource.getRecycleCount());
Assert.assertEquals(1, dataSource.getCloseCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_closePoolableStatement() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
DruidPooledPreparedStatement stmt = (DruidPooledPreparedStatement) conn.prepareStatement("select 1");
conn.close();
conn.closePoolableStatement(stmt);
public void test_dup_close() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
conn.close();
conn.close();
Assert.assertEquals(1, dataSource.getRecycleCount());
Assert.assertEquals(1, dataSource.getCloseCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_recycle() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
conn.close();
conn.recycle();
Assert.assertEquals(1, dataSource.getRecycleCount());
Assert.assertEquals(1, dataSource.getCloseCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_recycle_2() throws Exception {
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
conn.recycle();
conn.recycle();
conn.close();
Assert.assertEquals(1, dataSource.getRecycleCount());
Assert.assertEquals(1, dataSource.getCloseCount());
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public class DruidPooledConnectionTest_prepareError extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setPoolPreparedStatements(true);
dataSource.getProxyFilters().add(new FilterAdapter() {
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql) throws SQLException {
throw new SQLException();
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int autoGeneratedKeys)
throws SQLException {
throw new SQLException();
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType,
int resultSetConcurrency) throws SQLException {
throw new SQLException();
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType,
int resultSetConcurrency, int resultSetHoldability)
throws SQLException {
throw new SQLException();
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, int[] columnIndexes)
throws SQLException {
throw new SQLException();
public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection,
String sql, String[] columnNames)
throws SQLException {
throw new SQLException();
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection,
String sql) throws SQLException {
throw new SQLException();
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType, int resultSetConcurrency)
throws SQLException {
throw new SQLException();
public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection,
String sql, int resultSetType,
int resultSetConcurrency, int resultSetHoldability)
throws SQLException {
throw new SQLException();
protected void tearDown() throws Exception {
dataSource.close();
public void test_prepare_error() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepare_error_1() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1", 0, 0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepare_error_2() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1", 0, 0, 0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepare_error_3() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1", 0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepare_error_4() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1", new int[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepare_error_5() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareStatement("select 1", new String[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepareCall_error_1() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareCall("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepareCall_error_2() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareCall("select 1", 0, 0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
public void test_prepareCall_error_3() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
conn.prepareCall("select 1", 0, 0, 0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
} else if (c == 't') {
write("\t");
public final static int MajorVersion    = 0;
public final static int MinorVersion    = 2;
public final static int RevisionVersion = 6;
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion;
private static final long serialVersionUID = 1L;
pooledConnection.abandond();
public class ConcurrentIdentityHashMapTest extends TestCase {
public void test_0() throws Exception {
ConcurrentIdentityHashMap<Integer, String> map = new ConcurrentIdentityHashMap<Integer, String>();
Integer v1 = new Integer(3);
map.put(v1, "3");
Assert.assertTrue(map.contains("3"));
Assert.assertTrue(map.containsKey(v1));
Assert.assertFalse(map.contains("4"));
Assert.assertFalse(map.containsKey(new Integer(3)));
map.put(v1, "33");
Assert.assertFalse(map.contains("3"));
Assert.assertTrue(map.contains("33"));
Assert.assertEquals(1, map.size());
map.clear();
Assert.assertEquals(0, map.size());
public class DruidWebUtilsTest extends TestCase {
public void test_getContextPath_2_5() throws Exception {
new DruidWebUtils(); 
MockServletContext context = new MockServletContext() {
public int getMajorVersion() {
public int getMinorVersion() {
public String getContextPath() {
throw new NoSuchMethodError();
Assert.assertNull(DruidWebUtils.getContextPath(context));
public class HistogramTest extends TestCase {
public void test_histo() throws Exception {
Histogram histo = Histogram.makeHistogram(4);
Assert.assertEquals(4, histo.getRanges().length);
histo.record(0);
histo.record(1);
histo.record(2);
histo.record(11);
histo.record(12);
histo.record(13);
histo.record(101);
histo.record(102);
histo.record(103);
histo.record(104);
histo.record(1001);
histo.record(1002);
histo.record(1003);
histo.record(1004);
histo.record(1005);
histo.record(10001);
Assert.assertEquals(1, histo.get(0));
Assert.assertEquals(2, histo.get(1));
Assert.assertEquals(3, histo.get(2));
Assert.assertEquals(4, histo.get(3));
Assert.assertEquals(6, histo.get(4));
histo.toString();
public class DruidDataSourceTest1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
protected void tearDown() throws Exception {
dataSource.close();
public void test_oracle() throws Exception {
dataSource.setOracle(true);
dataSource.init();
Exception error = null;
dataSource.setOracle(false);
} catch (IllegalStateException e) {
error = e;
Assert.assertNotNull(error);
public void test_transactionQueryTimeout() throws Exception {
dataSource.setTransactionQueryTimeout(123456);
Assert.assertEquals(123456, dataSource.getTransactionQueryTimeout());
public void test_dupCloseLogEnable() throws Exception {
Assert.assertFalse(dataSource.isDupCloseLogEnable());
dataSource.setDupCloseLogEnable(true);
Assert.assertTrue(dataSource.isDupCloseLogEnable());
public void test_getClosedPreparedStatementCount() throws Exception {
Assert.assertEquals(0, dataSource.getClosedPreparedStatementCount());
Assert.assertEquals(0, dataSource.getPreparedStatementCount());
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("select 1");
stmt.close();
Assert.assertEquals(1, dataSource.getPreparedStatementCount());
Assert.assertEquals(1, dataSource.getClosedPreparedStatementCount());
public void test_getDriverMajorVersion() throws Exception {
Assert.assertEquals(-1, dataSource.getDriverMajorVersion());
dataSource.init();
Assert.assertEquals(0, dataSource.getDriverMajorVersion());
public void test_getDriverMinorVersion() throws Exception {
Assert.assertEquals(-1, dataSource.getDriverMinorVersion());
dataSource.init();
Assert.assertEquals(0, dataSource.getDriverMinorVersion());
public void test_getExceptionSorterClassName() throws Exception {
Assert.assertNull(dataSource.getExceptionSorterClassName());
@Override
public void statement_setQueryTimeout(FilterChain chain, StatementProxy statement, int seconds) throws SQLException {
chain.statement_setQueryTimeout(statement, seconds);
@Override
public void statement_clearWarnings(FilterChain chain, StatementProxy statement) throws SQLException {
chain.statement_clearWarnings(statement);
throw new SQLFeatureNotSupportedException();
throw new SQLFeatureNotSupportedException();
public class DruidPooledStatementTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new ErrorFilter());
protected void tearDown() throws Exception {
dataSource.close();
public void test_executeQuery_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeQuery("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_executeUpdate_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeUpdate("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_executeUpdate_error_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeUpdate("select 1", Statement.RETURN_GENERATED_KEYS);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_executeUpdate_error_2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeUpdate("select 1", new int[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_executeUpdate_error_3() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeUpdate("select 1", new String[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_execute_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.execute("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_execute_error_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.execute("select 1", Statement.RETURN_GENERATED_KEYS);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_execute_error_2() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.execute("select 1", new int[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_execute_error_3() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.execute("select 1", new String[0]);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getMaxFieldSize_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getMaxFieldSize();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setMaxFieldSize_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setMaxFieldSize(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getMaxRows_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getMaxRows();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setMaxRows_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setMaxRows(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setEscapeProcessing_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setEscapeProcessing(true);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getQueryTimeout_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getQueryTimeout();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setQueryTimeout_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setQueryTimeout(-1);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_cancel_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.cancel();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getWarnings_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getWarnings();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_clearWarnings_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.clearWarnings();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setCursorName_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setCursorName(null);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getResultSet_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getResultSet();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getDataSourceStat().getResultSetStat().getOpenCount());
public void test_getUpdateCount_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getUpdateCount();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getMoreResults_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getMoreResults();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setFetchDirection_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setFetchDirection(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getFetchDirection_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getFetchDirection();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_setFetchSize_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.setFetchSize(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getFetchSize_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getFetchSize();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getResultSetConcurrency_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getResultSetConcurrency();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getResultSetType_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getResultSetType();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_addBatch_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.addBatch("select 1");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_clearBatch_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.clearBatch();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_executeBatch_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.executeBatch();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getMoreResults_error_1() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getMoreResults(0);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getGeneratedKeys_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getGeneratedKeys();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_getResultSetHoldability_error() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.getResultSetHoldability();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(1, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_closeOnCompletion_error() throws Exception {
Connection conn = dataSource.getConnection();
DruidPooledStatement stmt = (DruidPooledStatement) conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.closeOnCompletion();
} catch (SQLFeatureNotSupportedException e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(0, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
public void test_isCloseOnCompletion_error() throws Exception {
Connection conn = dataSource.getConnection();
DruidPooledStatement stmt = (DruidPooledStatement) conn.createStatement();
Assert.assertEquals(0, dataSource.getPoolingCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getErrorCount());
Exception error = null;
stmt.isCloseOnCompletion();
} catch (SQLFeatureNotSupportedException e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(0, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertEquals(0, dataSource.getActiveCount());
private final class ErrorFilter extends FilterAdapter {
public ResultSetProxy statement_executeQuery(FilterChain chain, StatementProxy statement, String sql)
throws SQLException {
throw new SQLException();
public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
throw new SQLException();
public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql,
int autoGeneratedKeys) throws SQLException {
throw new SQLException();
public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, int columnIndexes[])
throws SQLException {
throw new SQLException();
public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql,
String columnNames[]) throws SQLException {
throw new SQLException();
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
throw new SQLException();
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int autoGeneratedKeys)
throws SQLException {
throw new SQLException();
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int columnIndexes[])
throws SQLException {
throw new SQLException();
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, String columnNames[])
throws SQLException {
throw new SQLException();
public int statement_getMaxFieldSize(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int statement_getMaxRows(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_setMaxFieldSize(FilterChain chain, StatementProxy statement, int max) throws SQLException {
throw new SQLException();
public void statement_setMaxRows(FilterChain chain, StatementProxy statement, int max) throws SQLException {
throw new SQLException();
public void statement_setEscapeProcessing(FilterChain chain, StatementProxy statement, boolean enable)
throws SQLException {
throw new SQLException();
public int statement_getQueryTimeout(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_setQueryTimeout(FilterChain chain, StatementProxy statement, int seconds)
throws SQLException {
throw new SQLException();
public void statement_cancel(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public SQLWarning statement_getWarnings(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_clearWarnings(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_setCursorName(FilterChain chain, StatementProxy statement, String name)
throws SQLException {
throw new SQLException();
public ResultSetProxy statement_getResultSet(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int statement_getUpdateCount(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public boolean statement_getMoreResults(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_setFetchDirection(FilterChain chain, StatementProxy statement, int value)
throws SQLException {
throw new SQLException();
public int statement_getFetchDirection(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int statement_getFetchSize(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_setFetchSize(FilterChain chain, StatementProxy statement, int value) throws SQLException {
throw new SQLException();
public int statement_getResultSetConcurrency(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int statement_getResultSetType(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public void statement_addBatch(FilterChain chain, StatementProxy statement, String sql) throws SQLException {
throw new SQLException();
public void statement_clearBatch(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int[] statement_executeBatch(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public boolean statement_getMoreResults(FilterChain chain, StatementProxy statement, int current)
throws SQLException {
throw new SQLException();
public ResultSetProxy statement_getGeneratedKeys(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public int statement_getResultSetHoldability(FilterChain chain, StatementProxy statement) throws SQLException {
throw new SQLException();
public class DruidDataSourceTest4 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setInitialSize(1);
protected void tearDown() throws Exception {
dataSource.close();
public void test_getTransactionThresholdMillis() {
Assert.assertEquals(0, dataSource.getTransactionThresholdMillis());
dataSource.setTransactionThresholdMillis(100);
Assert.assertEquals(100, dataSource.getTransactionThresholdMillis());
public void test_getTransactionHistogramRanges() {
Assert.assertNotNull(dataSource.getTransactionHistogramRanges());
public void test_getTransactionHistogramRanges_1() {
Assert.assertEquals(5, dataSource.getTransactionHistogramRanges().length);
public void test_setValidConnectionCheckerClassName() throws Exception {
Assert.assertNull(dataSource.getValidConnectionChecker());
dataSource.setValidConnectionCheckerClassName(MySqlValidConnectionChecker.class.getName());
Assert.assertNotNull(dataSource.getValidConnectionChecker());
public void test_setMinIdle() throws Exception {
Assert.assertEquals(0, dataSource.getMinIdle());
dataSource.init();
dataSource.setMinIdle(1);
Assert.assertEquals(1, dataSource.getMinIdle());
public void test_setMinIdle_error() throws Exception {
Assert.assertEquals(0, dataSource.getMinIdle());
dataSource.init();
Exception error = null;
dataSource.setMinIdle(100);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
Assert.assertEquals(0, dataSource.getMinIdle());
public void test_setExceptionSorter_error() throws Exception {
dataSource.setExceptionSorter("xx");
public void test_setExceptionSorter_error2() throws Exception {
Exception error = null;
dataSource.setExceptionSorter(MyExceptionSorter.class.getName());
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_getParentLogger() throws Exception {
Exception error = null;
dataSource.getParentLogger();
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
private class MyExceptionSorter implements ExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
return false;
private boolean         throwError = true;
if (throwError) {
return chain.callableStatement_wasNull(statement);
public void test_wasNull_noerror() throws Exception {
throwError = false;
stmt.wasNull();
Assert.assertEquals(0, dataSource.getErrorCount());
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getPoolingCount());
public void test_wasNull_error() throws Exception {
Connection conn = dataSource.getConnection();
CallableStatement stmt = conn.prepareCall("select 1");
stmt.execute();
Thread.sleep(10);
for (int i = 0; i < 100; ++i) {
if (conn.isAbandonded()) {
Thread.sleep(10);
startLatch.await(10, TimeUnit.MILLISECONDS);
for (int i = 0; i < 100; ++i) {
if (dataSource.getNotEmptyWaitThreadCount() == 10) {
Thread.sleep(10);
private final static Log      LOG                                      = LogFactory.getLog(DruidDataSourceFactory.class);
LOG.error("Could not parse defaultTransactionIsolation: " + value);
LOG.error("WARNING: defaultTransactionIsolation not set");
LOG.error("using default value of database driver");
public class DruidDataSourceC3P0AdapterTest extends TestCase {
private DruidDataSourceC3P0Adapter dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSourceC3P0Adapter();
dataSource.setJdbcUrl("jdbc:mock:xxx");
dataSource.setInitialPoolSize(1);
protected void tearDown() throws Exception {
dataSource.close();
public void test_conn_err() throws Exception {
Exception error = null;
dataSource.getConnection(null, null);
} catch (UnsupportedOperationException e) {
error = e;
Assert.assertNotNull(error);
public void test_getDriverClass() throws Exception {
Assert.assertNull(dataSource.getDriverClass());
Connection conn = dataSource.getConnection();
conn.close();
Assert.assertEquals(MockDriver.class.getName(), dataSource.getDriverClass());
Assert.assertEquals(MockDriver.instance, dataSource.getDriver());
public void test_getJdbcUrl() throws Exception {
Assert.assertEquals("jdbc:mock:xxx", dataSource.getJdbcUrl());
public class DruidDataSourceFactoryTest1 extends TestCase {
public void test_NONE() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "NONE");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_NONE, dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_READ_COMMITTED() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "READ_COMMITTED");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_READ_COMMITTED,
dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_READ_UNCOMMITTED() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "READ_UNCOMMITTED");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_READ_UNCOMMITTED,
dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_REPEATABLE_READ() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "REPEATABLE_READ");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_REPEATABLE_READ,
dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_SERIALIZABLE() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "SERIALIZABLE");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_SERIALIZABLE,
dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_other() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION, "xxx");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(-1, dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_integer() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_DEFAULTTRANSACTIONISOLATION,
Integer.toString(Connection.TRANSACTION_SERIALIZABLE));
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertEquals(Connection.TRANSACTION_SERIALIZABLE,
dataSource.getDefaultTransactionIsolation().intValue());
} finally {
JdbcUtils.close(dataSource);
public void test_init() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_INIT, "true");
DruidDataSource dataSource = null;
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertEquals("jdbc:mock:xxx", dataSource.getUrl());
Assert.assertTrue(dataSource.isInited());
} finally {
JdbcUtils.close(dataSource);
@SuppressWarnings("unchecked")
public void test_statService_getSqlById() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String result = DruidStatService.getInstance().service("/sql-" + dataSource.getSqlStatMap().values().iterator().next().getId() + ".json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
Map<String, Object> sqlStat = (Map<String, Object>) resultMap.get("Content");
Assert.assertEquals(0, sqlStat.get("RunningCount"));
Assert.assertEquals(1, sqlStat.get("ExecuteCount"));
Assert.assertEquals(1, sqlStat.get("FetchRowCount"));
Assert.assertEquals(0, sqlStat.get("EffectedRowCount"));
String result2 = DruidStatService.getInstance().service("/sql-" + Integer.MAX_VALUE + ".json");
resultMap = (Map<String, Object>) JSONUtils.parse(result2);
Assert.assertNull(resultMap.get("Content"));
if (url.startsWith("/webapp.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebAppStatDataList(parameters));
private List<Map<String, Object>> getWebAppStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getWebAppStatData();
return comparatorOrderBy(array, parameters);
private final static ThreadLocal<WebAppStat>    currentLocal                   = new ThreadLocal<WebAppStat>();
private final AtomicLong                        jdbcFetchRowCount              = new AtomicLong();
private final AtomicLong                        jdbcUpdateCount                = new AtomicLong();
private final AtomicLong                        jdbcExecuteCount               = new AtomicLong();
private final AtomicLong                        jdbcExecuteTimeNano            = new AtomicLong();
private final AtomicLong                        jdbcCommitCount                = new AtomicLong();
private final AtomicLong                        jdbcRollbackCount              = new AtomicLong();
private final AtomicLong                        osWindows98Count               = new AtomicLong();
private final AtomicLong                        osWindowsXPCount               = new AtomicLong();
private final AtomicLong                        osWindows2000Count             = new AtomicLong();
private final AtomicLong                        osWindowsVistaCount            = new AtomicLong();
private final AtomicLong                        osWindows7Count                = new AtomicLong();
jdbcFetchRowCount.set(0);
jdbcUpdateCount.set(0);
jdbcExecuteCount.set(0);
jdbcExecuteTimeNano.set(0);
jdbcCommitCount.set(0);
jdbcRollbackCount.set(0);
WebRequestStat requestStat = WebRequestStat.current();
if (requestStat != null) {
this.addJdbcExecuteCount(requestStat.getJdbcExecuteCount());
this.addJdbcFetchRowCount(requestStat.getJdbcFetchRowCount());
this.addJdbcUpdateCount(requestStat.getJdbcUpdateCount());
this.addJdbcCommitCount(requestStat.getJdbcCommitCount());
this.addJdbcRollbackCount(requestStat.getJdbcRollbackCount());
this.addJdbcExecuteTimeNano(requestStat.getJdbcExecuteTimeNano());
public void addJdbcFetchRowCount(long delta) {
this.jdbcFetchRowCount.addAndGet(delta);
public long getJdbcFetchRowCount() {
return jdbcFetchRowCount.get();
public void addJdbcUpdateCount(long updateCount) {
this.jdbcUpdateCount.addAndGet(updateCount);
public long getJdbcUpdateCount() {
return jdbcUpdateCount.get();
public void incrementJdbcExecuteCount() {
jdbcExecuteCount.incrementAndGet();
public void addJdbcExecuteCount(long executeCount) {
jdbcExecuteCount.addAndGet(executeCount);
public long getJdbcExecuteCount() {
return jdbcExecuteCount.get();
public long getJdbcExecuteTimeMillis() {
return getJdbcExecuteTimeNano() / (1000 * 1000);
public long getJdbcExecuteTimeNano() {
return jdbcExecuteTimeNano.get();
public void addJdbcExecuteTimeNano(long nano) {
jdbcExecuteTimeNano.addAndGet(nano);
public void incrementJdbcCommitCount() {
jdbcCommitCount.incrementAndGet();
public long getJdbcCommitCount() {
return jdbcCommitCount.get();
public void addJdbcCommitCount(long commitCount) {
this.jdbcCommitCount.addAndGet(commitCount);
public void incrementJdbcRollbackCount() {
jdbcRollbackCount.incrementAndGet();
public long getJdbcRollbackCount() {
return jdbcRollbackCount.get();
public void addJdbcRollbackCount(long rollbackCount) {
this.jdbcRollbackCount.addAndGet(rollbackCount);
data.put("JdbcCommitCount", this.getJdbcCommitCount());
data.put("JdbcRollbackCount", this.getJdbcRollbackCount());
data.put("JdbcExecuteCount", this.getJdbcExecuteCount());
data.put("JdbcExecuteTimeMillis", this.getJdbcExecuteTimeMillis());
data.put("JdbcFetchRowCount", this.getJdbcFetchRowCount());
data.put("JdbcUpdateCount", this.getJdbcUpdateCount());
data.put("OSMacOSXCount", this.getOSMacOSXCount());
data.put("OSWindowsCount", this.getOSWindowsCount());
data.put("OSLinuxCount", this.getOSLinuxCount());
data.put("OSSymbianCount", this.getOSSymbianCount());
data.put("OSFreeBSDCount", this.getOSFreeBSDCount());
data.put("OSOpenBSDCount", this.getOSOpenBSDCount());
data.put("OSAndroidCount", this.getOSAndroidCount());
data.put("OSWindows98Count", this.getOSWindows98Count());
data.put("OSWindowsXPCount", this.getOSWindowsXPCount());
data.put("OSWindows2000Count", this.getOSWindows2000Count());
data.put("OSWindowsVistaCount", this.getOSWindowsVistaCount());
data.put("OSWindows7Count", this.getOSWindows7Count());
data.put("OSAndroid15Count", this.getOSAndroid15Count());
data.put("OSAndroid16Count", this.getOSAndroid16Count());
data.put("OSAndroid20Count", this.getOSAndroid20Count());
data.put("OSAndroid21Count", this.getOSAndroid21Count());
data.put("OSAndroid22Count", this.getOSAndroid22Count());
data.put("OSAndroid23Count", this.getOSAndroid23Count());
data.put("OSAndroid30Count", this.getOSAndroid30Count());
data.put("OSAndroid31Count", this.getOSAndroid31Count());
data.put("OSAndroid32Count", this.getOSAndroid32Count());
data.put("OSAndroid40Count", this.getOSAndroid40Count());
data.put("OSLinuxUbuntuCount", this.getOSLinuxUbuntuCount());
data.put("BrowserIECount", this.getBrowserIECount());
data.put("BrowserFirefoxCount", this.getBrowserFirefoxCount());
data.put("BrowserChromeCount", this.getBrowserChromeCount());
data.put("BrowserSafariCount", this.getBrowserSafariCount());
data.put("BrowserOperaCount", this.getBrowserOperaCount());
data.put("BrowserIE5Count", this.getBrowserIE5Count());
data.put("BrowserIE6Count", this.getBrowserIE6Count());
data.put("BrowserIE7Count", this.getBrowserIE7Count());
data.put("BrowserIE8Count", this.getBrowserIE8Count());
data.put("BrowserIE9Count", this.getBrowserIE9Count());
data.put("BrowserIE10Count", this.getBrowserIE10Count());
data.put("Browser360SECount", this.getBrowser360SECount());
data.put("DeviceAndroidCount", this.getDeviceAndroidCount());
data.put("DeviceIpadCount", this.getDeviceIpadCount());
data.put("DeviceIphoneCount", this.getDeviceIphoneCount());
data.put("DeviceWindowsPhoneCount", this.getDeviceWindowsPhoneCount());
data.put("BotCount", this.getBotCount());
data.put("BotBaiduCount", this.getBotBaiduCount());
data.put("BotYoudaoCount", this.getBotYoudaoCount());
data.put("BotGoogleCount", this.getBotGoogleCount());
data.put("BotMsnCount", this.getBotMsnCount());
data.put("BotBingCount", this.getBotBingCount());
data.put("BotSosoCount", this.getBotSosoCount());
data.put("BotSogouCount", this.getBotSogouCount());
data.put("BotYahooCount", this.getBotYahooCount());
Map<String, Object> statData = appStat.getStatData();
Assert.assertEquals(1L, statData.get("RequestCount"));
public class ThreadLocalRandomTest extends TestCase {
public void test_random() throws Exception {
ThreadLocalRandom.current().nextBoolean();
ThreadLocalRandom.current().nextDouble();
ThreadLocalRandom.current().nextFloat();
ThreadLocalRandom.current().nextInt();
ThreadLocalRandom.current().nextLong();
webAppStat.incrementSessionCount();
private final AtomicLong                        sessionCount                   = new AtomicLong(0);
sessionCount.set(0);
public void incrementSessionCount() {
sessionCount.incrementAndGet();
public long getSessionCount() {
return sessionCount.get();
data.put("SessionCount", this.getSessionCount());
protected Decrypter                          decrypter;
public Decrypter getDecrypter() {
return decrypter;
public void setDecrypter(Decrypter decrypter) {
this.decrypter = decrypter;
Decrypter decrypter1 = this.getDecrypter();
if (decrypter1 != null) {
SensitiveParameters parameters = decrypter1.decrypt(new SensitiveParameters(url, user, password));
url = parameters.getUrl();
user = parameters.getUsername();
password = parameters.getPassword();
} catch (DecryptException e) {
throw new SQLException("Failed to decrypt sensitive parameters.", e);
return Base64.byteArrayToBase64(encryptedBytes);
return Base64.byteArrayToBase64(encryptedBytes);
String encryptedString = Base64.byteArrayToBase64(encryptedBytes);;
@RunWith(Suite.class)
@Suite.SuiteClasses({
AesDecrypterTest.class,
DesDecrypterTest.class,
RsaDecrypterTest.class,
BlowfishDecrypterTest.class
String publicKeyContent = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2YdTlkEw7JfRNItCosRf4QO8vOL54ZEdj0LZm"
"tKhNFnNRTtHrLDFT44BPYqFSLVv3TOhLxJcEs31kyQhXEC5b9ozpZBvYrJDSt8QQMoYDAMLSojs+"
"K4vTJavgbRKKads0di+DuoMmJ5g5dcbDNd1Kb4kgWhrZtUwhfSjQklaiIwIDAQAB";
String keyFilePath;
public void setUp() throws IOException {
File tmp = File.createTempFile("druid_public_key", Long.toString(System.currentTimeMillis()));
byte[] keyContent = Base64.base64ToByteArray(this.publicKeyContent);
FileOutputStream out = null;
out = new FileOutputStream(tmp);
out.write(keyContent);
} finally {
if (out != null) {
out.close();
this.keyFilePath = tmp.getAbsolutePath();
public void tearDown() {
File tmp = new File(this.keyFilePath);
if (tmp.exists()) {
tmp.delete();
this.keyFilePath = null;
decrypter.setPublicKeyFile(this.keyFilePath);
dataMap.put("JavaVMName", System.getProperty("java.vm.name"));
dataMap.put("JavaVersion", System.getProperty("java.version"));
dataMap.put("JavaClassPath", System.getProperty("java.class.path"));
dataMap.put("StartTime", new Date(ManagementFactory.getRuntimeMXBean().getStartTime()));
dataSource.getConnection();
private volatile boolean                 enable                  = true;
private volatile boolean                 closed                  = false;
boolean init = false;
init = true;
if (init && LOG.isInfoEnabled()) {
if (closed) {
connectErrorCount.incrementAndGet();
throw new DataSourceClosedException("dataSource already closed at " + new Date(closeTimeMillis));
if (!enable) {
connectErrorCount.incrementAndGet();
throw new DataSourceDisableException();
final long nanos = TimeUnit.MILLISECONDS.toNanos(maxWait);
final int maxWaitThreadCount = getMaxWaitThreadCount();
DruidConnectionHolder holder;
holder = pollLast(nanos);
holder.incrementUseCount();
DruidPooledConnection poolalbeConnection = new DruidPooledConnection(holder);
final long lastActiveTimeMillis = System.currentTimeMillis();
putLast(holder, lastActiveTimeMillis);
void putLast(DruidConnectionHolder e, long lastActiveTimeMillis) throws SQLException {
e.setLastActiveTimeMillis(lastActiveTimeMillis);
poolingPeakTime = lastActiveTimeMillis;
DruidConnectionHolder pollLast(long nanos) throws InterruptedException, SQLException {
if (!enable) {
discardConnection(holder.getConnection());
System.out.println(": , PKCS#8, ");
System.out.println("openssl pkcs8 -topk8 -inform PEM -outform DER -in Key -nocrypt > ");
@Override
public Blob callableStatement_getBlob(FilterChain chain, CallableStatementProxy statement, int parameterIndex)
throws SQLException {
Blob blob = chain.callableStatement_getBlob(statement, parameterIndex);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, blob);
return blob;
@Override
public Blob callableStatement_getBlob(FilterChain chain, CallableStatementProxy statement, String parameterName)
throws SQLException {
Blob blob = chain.callableStatement_getBlob(statement, parameterName);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, blob);
return blob;
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
private void blobOpenAfter(JdbcDataSourceStat dataSourceStat, StatementProxy stmt, Blob blob) {
dataSourceStat.incrementBlobOpenCount();
dataMap.put("BlobOpenCount", this.getDataSourceStat().getBlobOpenCount());
private final AtomicLong                                    blobOpenCount           = new AtomicLong();
blobOpenCount.set(0);
public long getBlobOpenCount() {
return blobOpenCount.get();
public void incrementBlobOpenCount() {
blobOpenCount.incrementAndGet();
@Override
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
Blob blob = chain.resultSet_getBlob(result, columnIndex);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, blob);
return blob;
@Override
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
Blob blob = chain.resultSet_getBlob(result, columnLabel);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, blob);
return blob;
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
private void blobOpenAfter(JdbcDataSourceStat dataSourceStat, ResultSetProxy rs, Blob blob) {
blobOpenAfter(dataSourceStat, rs.getStatementProxy(), blob);
if (stmt != null) {
JdbcSqlStat sqlStat = stmt.getSqlStat();
if (sqlStat != null) {
sqlStat.incrementBlobOpenCount();
StatFilterContext.getInstance().blob_open();
public void blob_open() {
listener.blob_open();
void blob_open();
public void blob_open() {
private final AtomicLong blobOpenCount                     = new AtomicLong();
blobOpenCount.set(0);
public long getBlobOpenCount() {
return blobOpenCount.get();
public void incrementBlobOpenCount() {
blobOpenCount.incrementAndGet();
SimpleType.LONG, 
"BlobOpenCount",
map.put("BlobOpenCount", getBlobOpenCount()); 
sqlStat.addStringReadLength(resultSet.getReadStringLength());
} else if (obj instanceof Blob) {
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
} else if (obj instanceof Blob) {
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
} else if (obj instanceof Blob) {
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
} else if (obj instanceof Blob) {
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
@Override
public String resultSet_getString(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
String value = chain.resultSet_getString(result, columnIndex);
if (value != null) {
result.addReadStringLength(value.length());
return value;
@Override
public String resultSet_getString(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
String value = chain.resultSet_getString(result, columnLabel);
if (value != null) {
result.addReadStringLength(value.length());
return value;
void addReadStringLength(int length);
long getReadStringLength();
protected int                cursorIndex      = 0;
protected int                fetchRowCount    = 0;
private int                  closeCount       = 0;
private long                 readStringLength = 0;
@Override
public void addReadStringLength(int length) {
this.readStringLength += length;
@Override
public long getReadStringLength() {
return readStringLength;
private final AtomicLong stringReadLength                  = new AtomicLong();
stringReadLength.set(0);
public long getStringReadLength() {
return stringReadLength.get();
public void addStringReadLength(long length) {
this.stringReadLength.addAndGet(length);
SimpleType.LONG, 
"StringReadLength",
map.put("StringReadLength", getStringReadLength()); 
return value;
@Override
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
byte[] value = chain.resultSet_getBytes(result, columnIndex);
if (value != null) {
result.addReadBytesLength(value.length);
return value;
@Override
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
byte[] value = chain.resultSet_getBytes(result, columnLabel);
if (value != null) {
result.addReadBytesLength(value.length);
void addReadBytesLength(int length);
long getReadBytesLength();
private long                 readBytesLength  = 0;
@Override
public void addReadBytesLength(int length) {
this.readBytesLength += length;
@Override
public long getReadBytesLength() {
return readBytesLength;
private final AtomicLong readStringLength                  = new AtomicLong();
private final AtomicLong readBytesLength                   = new AtomicLong();
readStringLength.set(0);
readBytesLength.set(0);
public long getReadStringLength() {
return readStringLength.get();
this.readStringLength.addAndGet(length);
public long getReadBytesLength() {
return readBytesLength.get();
public void addReadBytesLength(int length) {
this.readBytesLength.addAndGet(length);
SimpleType.LONG, 
"BlobOpenCount", 
"ReadStringLength", 
"ReadBytesLength",
map.put("ReadStringLength", getReadStringLength()); 
map.put("ReadBytesLength", getReadBytesLength()); 
if (resultSet.getReadStringLength() > 0) {
sqlStat.addStringReadLength(resultSet.getReadStringLength());
if (resultSet.getReadBytesLength() > 0) {
sqlStat.addReadBytesLength(resultSet.getReadBytesLength());
if (resultSet.getOpenInputStreamCount() > 0) {
sqlStat.addInputStreamOpenCount(resultSet.getOpenInputStreamCount());
if (resultSet.getOpenReaderCount() > 0) {
sqlStat.addReaderOpenCount(resultSet.getOpenReaderCount());
@Override
public InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
InputStream input = chain.resultSet_getBinaryStream(result, columnIndex);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
@Override
public InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
InputStream input = chain.resultSet_getBinaryStream(result, columnLabel);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
@Override
public InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
InputStream input = chain.resultSet_getAsciiStream(result, columnIndex);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
@Override
public InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
InputStream input = chain.resultSet_getAsciiStream(result, columnLabel);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
@Override
public Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
Reader reader = chain.resultSet_getCharacterStream(result, columnIndex);
if (reader != null) {
result.incrementOpenReaderCount();
return reader;
@Override
public Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
Reader reader = chain.resultSet_getCharacterStream(result, columnLabel);
if (reader != null) {
result.incrementOpenReaderCount();
return reader;
void incrementOpenInputStreamCount();
int getOpenInputStreamCount();
void incrementOpenReaderCount();
int getOpenReaderCount();
protected int                cursorIndex          = 0;
protected int                fetchRowCount        = 0;
private int                  closeCount           = 0;
private long                 readStringLength     = 0;
private long                 readBytesLength      = 0;
private int                  openInputStreamCount = 0;
private int                  openReaderCount      = 0;
@Override
public void incrementOpenInputStreamCount() {
openInputStreamCount++;
@Override
public int getOpenInputStreamCount() {
return openInputStreamCount;
@Override
public void incrementOpenReaderCount() {
openReaderCount++;
@Override
public int getOpenReaderCount() {
return openReaderCount;
private final AtomicLong inputStreamOpenCount              = new AtomicLong();
private final AtomicLong readerOpenCount                   = new AtomicLong();
inputStreamOpenCount.set(0);
readerOpenCount.set(0);
public void addReadBytesLength(long length) {
public long getReaderOpenCount() {
return readerOpenCount.get();
public void addReaderOpenCount(int count) {
this.readerOpenCount.addAndGet(count);
public long getInputStreamOpenCount() {
return inputStreamOpenCount.get();
public void addInputStreamOpenCount(int count) {
this.inputStreamOpenCount.addAndGet(count);
SimpleType.LONG, 
SimpleType.LONG, 
"ReadBytesLength", 
"InputStreamOpenCount", 
"ReaderOpenCount", 
map.put("InputStreamOpenCount", getInputStreamOpenCount()); 
map.put("ReaderOpenCount", getReaderOpenCount()); 
public class StatFilterReadBytesLengthTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new byte[6];
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, String columnIndex)
throws SQLException {
return new byte[7];
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(0, sqlStat.getReadBytesLength());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBytes(1);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(6, sqlStat.getReadBytesLength());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(0, sqlStat.getReadBytesLength());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(0, sqlStat.getReadBytesLength());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBytes("1");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(7, sqlStat.getReadBytesLength());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReadStringLength());
Assert.assertEquals(0, sqlStat.getReadBytesLength());
public class StatFilterReadStringLengthTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public String resultSet_getString(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return "123456";
public String resultSet_getString(FilterChain chain, ResultSetProxy result, String columnIndex)
throws SQLException {
return "1234567";
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReadStringLength());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getString(1);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(6, sqlStat.getReadStringLength());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReadStringLength());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReadStringLength());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getString("1");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(7, sqlStat.getReadStringLength());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReadStringLength());
public class StatFilterOpenBlobCountTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new MockBlob();
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new MockBlob();
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBlob(1);
rs.getBlob(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBlob("1");
rs.getBlob("2");
rs.getBlob("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public class StatFilterOpenBlobCountTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new MockBlob();
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new MockBlob();
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
return new MockBlob();
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
return new MockBlob();
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject(1);
rs.getObject(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject("1");
rs.getObject("2");
rs.getObject("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public void test_stat_2() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject(1, Collections.<String, Class<?>> emptyMap());
rs.getObject(2, Collections.<String, Class<?>> emptyMap());
rs.getObject(3, Collections.<String, Class<?>> emptyMap());
rs.getObject(4, Collections.<String, Class<?>> emptyMap());
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(4, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public void test_stat_4() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject("1", Collections.<String, Class<?>> emptyMap());
rs.getObject("2", Collections.<String, Class<?>> emptyMap());
rs.getObject("3", Collections.<String, Class<?>> emptyMap());
rs.getObject("4", Collections.<String, Class<?>> emptyMap());
rs.getObject("5", Collections.<String, Class<?>> emptyMap());
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(5, sqlStat.getBlobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getBlobOpenCount());
public class StatFilterOpenClobCountTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public Clob resultSet_getClob(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
public Clob resultSet_getClob(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getClob(1);
rs.getClob(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getClob("1");
rs.getClob("2");
rs.getClob("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public class StatFilterOpenClobCountTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
return new ClobProxyImpl(result.getStatementProxy().getConnectionProxy().getDirectDataSource(),
result.getStatementProxy().getConnectionProxy(), new MockClob());
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject(1);
rs.getObject(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject("1");
rs.getObject("2");
rs.getObject("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public void test_stat_2() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject(1, Collections.<String,Class<?>>emptyMap());
rs.getObject(2, Collections.<String,Class<?>>emptyMap());
rs.getObject(3, Collections.<String,Class<?>>emptyMap());
rs.getObject(4, Collections.<String,Class<?>>emptyMap());
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(4, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public void test_stat_4() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getClobOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getObject("1", Collections.<String,Class<?>>emptyMap());
rs.getObject("2", Collections.<String,Class<?>>emptyMap());
rs.getObject("3", Collections.<String,Class<?>>emptyMap());
rs.getObject("4", Collections.<String,Class<?>>emptyMap());
rs.getObject("5", Collections.<String,Class<?>>emptyMap());
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(5, sqlStat.getClobOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getClobOpenCount());
public class StatFilterOpenInputStreamCountTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public java.io.InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new ByteArrayInputStream(new byte[0]);
public java.io.InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new ByteArrayInputStream(new byte[0]);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBinaryStream(1);
rs.getBinaryStream(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getInputStreamOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getBinaryStream("1");
rs.getBinaryStream("2");
rs.getBinaryStream("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getInputStreamOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
public class StatFilterOpenInputStreamCountTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public java.io.InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result,
int columnIndex) throws SQLException {
return new ByteArrayInputStream(new byte[0]);
public java.io.InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result,
String columnLabel) throws SQLException {
return new ByteArrayInputStream(new byte[0]);
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getAsciiStream(1);
rs.getAsciiStream(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getInputStreamOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getAsciiStream("1");
rs.getAsciiStream("2");
rs.getAsciiStream("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getInputStreamOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getInputStreamOpenCount());
public class StatFilterOpenReaderCountTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.getProxyFilters().add(new FilterAdapter() {
public java.io.Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
return new StringReader("");
public java.io.Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
return new StringReader("");
dataSource.init();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_stat() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReaderOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getCharacterStream(1);
rs.getCharacterStream(2);
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(2, sqlStat.getReaderOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReaderOpenCount());
public void test_stat_1() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select 'x'";
PreparedStatement stmt = conn.prepareStatement("select 'x'");
JdbcSqlStat sqlStat = dataSource.getDataSourceStat().getSqlStat(sql);
Assert.assertEquals(0, sqlStat.getReaderOpenCount());
ResultSet rs = stmt.executeQuery();
rs.next();
rs.getCharacterStream("1");
rs.getCharacterStream("2");
rs.getCharacterStream("3");
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(3, sqlStat.getReaderOpenCount());
sqlStat.reset();
Assert.assertEquals(0, sqlStat.getReaderOpenCount());
buf.append(", ntpoolStatements:[");
int entryIndex = 0;
for (Map.Entry<PreparedStatementKey, PreparedStatementHolder> entry : pool.getMap().entrySet()) {
if (entryIndex != 0) {
buf.append(",");
buf.append("ntt{hitCount:");
buf.append(entry.getValue().getHitCount());
buf.append(",sql:"");
buf.append(entry.getKey().getSql());
buf.append(""");
buf.append("t}");
entryIndex++;
} catch (ConcurrentModificationException e) {
buf.append("ntt]");
return dataSource.getParentLogger();
public void test_getParentLogger_err() throws Exception {
Exception error = null;
dataSource.getParentLogger();
} catch (SQLFeatureNotSupportedException e) {
error = e;
Assert.assertNotNull(error);
public void test_propertyCycle() throws Exception {
dataSource.setPropertyCycle(3);
Assert.assertEquals(3, dataSource.getPropertyCycle());
public void test_acquireIncrement() throws Exception {
dataSource.setAcquireIncrement(4);
Assert.assertEquals(4, dataSource.getAcquireIncrement());
public void test_overrideDefaultPassword() throws Exception {
dataSource.setOverrideDefaultPassword("x2");
Assert.assertEquals("x2", dataSource.getOverrideDefaultPassword());
public void test_overrideDefaultUser() throws Exception {
dataSource.setOverrideDefaultUser("x1");
Assert.assertEquals("x1", dataSource.getOverrideDefaultUser());
public void test_factoryClassLocation() throws Exception {
dataSource.setFactoryClassLocation("x3");
Assert.assertEquals("x3", dataSource.getFactoryClassLocation());
public void test_maxConnectionAge() throws Exception {
dataSource.setMaxConnectionAge(123);
Assert.assertEquals(123, dataSource.getMaxConnectionAge());
public void test_connectionCustomizerClassName() throws Exception {
dataSource.setConnectionCustomizerClassName("x4");
Assert.assertEquals("x4", dataSource.getConnectionCustomizerClassName());
public void test_maxIdleTimeExcessConnections() throws Exception {
dataSource.setMaxIdleTimeExcessConnections(101);
Assert.assertEquals(101, dataSource.getMaxIdleTimeExcessConnections());
public void test_maxAdministrativeTaskTime() throws Exception {
dataSource.setMaxAdministrativeTaskTime(102);
Assert.assertEquals(102, dataSource.getMaxAdministrativeTaskTime());
public void test_userOverridesAsString() throws Exception {
dataSource.setUserOverridesAsString("x5");
Assert.assertEquals("x5", dataSource.getUserOverridesAsString());
public void test_usesTraditionalReflectiveProxies() throws Exception {
dataSource.setUsesTraditionalReflectiveProxies(true);
Assert.assertEquals(true, dataSource.isUsesTraditionalReflectiveProxies());
public void test_forceIgnoreUnresolvedTransactions() throws Exception {
dataSource.setForceIgnoreUnresolvedTransactions(true);
Assert.assertEquals(true, dataSource.isForceIgnoreUnresolvedTransactions());
public void test_automaticTestTable() throws Exception {
dataSource.setAutomaticTestTable("x6");
Assert.assertEquals("x6", dataSource.getAutomaticTestTable());
public void test_connectionTesterClassName() throws Exception {
dataSource.setConnectionTesterClassName("x6");
Assert.assertEquals("x6", dataSource.getConnectionTesterClassName());
DruidConnectionHolder holder = null;
holder = new DruidConnectionHolder(DruidDataSource.this, connection);
} catch (SQLException ex) {
LOG.error("create connection holder error", ex);
public void test_getObjectInstance() throws Exception {
Assert.assertNull(new DruidDataSourceFactory().getObjectInstance(null, null, null, null));
public void test_getObjectInstance_1() throws Exception {
Assert.assertNull(new DruidDataSourceFactory().getObjectInstance(new Object(), null, null, null));
if (statementPool != null && statementPool.getMap().size() > 0) {
buf.append(statementPool.getMap().size());
public class DruidConnectionHolderTest4 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_toString() throws Exception {
DruidPooledConnection conn = dataSource.getConnection();
DruidConnectionHolder holder = conn.getConnectionHolder();
Field field = DruidConnectionHolder.class.getDeclaredField("statementPool");
field.setAccessible(true);
Assert.assertNull(field.get(holder));
holder.toString();
Assert.assertNull(field.get(holder));
holder.getStatementPool();
Assert.assertNotNull(field.get(holder));
holder.toString();
PreparedStatement stmt = conn.prepareStatement("select 1");
stmt.execute();
stmt.close();
conn.close();
Assert.assertEquals(1, holder.getStatementPool().size());
holder.toString();
map.put("StatementLastErrorTime", null);
map.put("StatementLastErrorMessage", null);
map.put("StatementLastErrorStackTrace", null);
map.put("ResultSetLastErrorMessage", null);
map.put("ResultSetLastErrorStackTrace", null);
dataSource.setUseOracleImplicitCache(true);
dataSource.setUseOracleImplicitCache(false);
Assert.assertNull(dataSource.getConnectProperties().get("oracle.jdbc.FreeMemoryOnEnterImplicitCache"));
dataSource.setDriver(null);
dataSource.setUseOracleImplicitCache(true);
Assert.assertNull(dataSource.getConnectProperties().get("oracle.jdbc.FreeMemoryOnEnterImplicitCache"));
dataSource.setFilters("stat,log4j,wall");
dataSource.getProxyFilters().add(new FilterAdapter() {} );
dataSource.setDbType("mysql");
public void test_unwrap_8() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertTrue(new FilterChainImpl(dataSource).wrap((ConnectionProxy) null, (Clob) new MockNClob()) instanceof NClob);
conn.close();
public void test_unwrap_9() throws Exception {
Assert.assertNull(new FilterChainImpl(dataSource).wrap((StatementProxy) null, (NClob) null));
dataSource.setFilters("stat,log4j,wall");
dataSource.getProxyFilters().add(new FilterAdapter() {} );
dataSource.setFilters("stat,log4j,wall");
dataSource.getProxyFilters().add(new FilterAdapter() {} );
dataSource.setDbType("mysql");
dataSource.getProxyFilters().add(new FilterAdapter() {
Assert.assertNull(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(Statement) null));
Assert.assertNull(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(PreparedStatement) null, ""));
Assert.assertNull(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(CallableStatement) null, ""));
Assert.assertNull(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(Clob) null));
Assert.assertTrue(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
new MockNClob()) instanceof NClob);
Assert.assertTrue(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(Clob) new MockNClob()) instanceof NClob);
Assert.assertNull(new FilterChainImpl(dataSource).wrap((ConnectionProxy) dataSource.getConnection().getConnection(),
(NClob) null));
dataSource.setDbType("mysql");
} else if (obj instanceof Blob) {
} else if (obj instanceof Blob) {
} else if (obj instanceof Blob) {
} else if (obj instanceof Blob) {
public class FilterManagerTest extends TestCase {
public void test_instance() throws Exception {
new FilterManager();
public void test_loadFilter() throws Exception {
Exception error = null;
FilterManager.loadFilter(new ArrayList<Filter>(), ErrorFilter.class.getName());
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
public void test_loadFilter_2() throws Exception {
Exception error = null;
FilterManager.loadFilter(new ArrayList<Filter>(), ErrorFilter.class.getName());
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
public static class ErrorFilter extends FilterAdapter {
public ErrorFilter(){
throw new RuntimeException();
public class StatFilterTest3 extends TestCase {
public void test_dbType() throws Exception {
StatFilter filter = new StatFilter();
Assert.assertFalse(filter.isMergeSql());
filter.setDbType("mysql");
filter.setMergeSql(true);
Assert.assertTrue(filter.isMergeSql());
Assert.assertEquals("mysql", filter.getDbType());
Assert.assertEquals("SELECT ?nLIMIT ?" , filter.mergeSql("select 'x' limit 1"));
public void test_dbType_error() throws Exception {
StatFilter filter = new StatFilter();
filter.setDbType("mysql");
filter.setMergeSql(true);
Assert.assertEquals("mysql", filter.getDbType());
Assert.assertEquals("sdafawer asf " , filter.mergeSql("sdafawer asf "));
public void test_merge() throws Exception {
StatFilter filter = new StatFilter();
filter.setDbType("mysql");
filter.setMergeSql(false);
Assert.assertEquals("mysql", filter.getDbType());
Assert.assertEquals("select 'x' limit 1" , filter.mergeSql("select 'x' limit 1"));
public class ConcurrentIdentityHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
public final void putAll(Map<? extends K, ? extends V> m) {
visitor.visit(this);
visitor.visit(this);
visitor.endVisit(this);
visitor.visit(this);
this.exprParser.name();
throw new ParserException("TODO");
boolean allow = false;
allow = true;
allow = true;
allow = true;
allow = true;
allow = true;
allow = config.isTruncateAllow();
if (!allow) {
boolean allow = false;
allow = true;
allow = true;
allow = true;
allow = true;
allow = true;
allow = true;
allow = true;
allow = config.isTruncateAllow();
if (!allow) {
public SQLServerWallVisitor(WallProvider provider){
boolean allow = false;
allow = true;
allow = true;
allow = true;
allow = true;
allow = true;
allow = config.isTruncateAllow();
if (!allow) {
if (opt.getInterval() == -1) {
if (opt.getInterval() == -1) {
if (value == null) {
value = "";
int index = tmp.indexOf('.');
int index = range.indexOf('/');
Object value = map.get(keyStr.substring(0, keyStr.indexOf('[')));
return s == null || "".equals(s);
return "on".equalsIgnoreCase(status);
for (SQLObject child : children) {
for (int i = 0; i < this.indentCount; ++i) {
public static final int MAX_SIZE           = 1024;
private final char[][]  symbolsChar;
private int             size               = 0;
this.symbolsChar = new char[tableSize][];
char[] characters = symbolsChar[bucket];
if (size >= MAX_SIZE) {
return new String(buffer, offset, len);
symbolsChar[bucket] = entry.characters;
public void reset(int mark, char markChar, Token token) {
this.ch = markChar;
sb.append(method.getName());
sb.append('(');
sb.append(',');
sb.append(')');
protected void checkOpen() throws SQLException {
public String hexString() {
public Number integerValue() {
public void setApplicationContext(ApplicationContext context) {
protected void checkOpen() throws SQLException {
if (lexer.token() == Token.SELECT || lexer.token() == Token.WITH) {
public class OracleSelectTest38 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select * from " +
"(with vw_kreis_statics_t as" +
"  (select substr(xzqh,1,6) xzqh,swrslx,sum(swrs_count) acd_totle from" +
"    (select xzqh,sglx,case when (swrs7 <  3) then '1'" +
"       when (swrs7 <  5) then '2' when (swrs7 <=  9) then '3' else '4' end  swrslx,1 swrs_count" +
"       from acduser.vw_acd_info where sglx='1' " +
"       " +
"                    and sgfssj  >=   ?" +
"                 " +
"                 " +
"        )" +
"   group by substr(xzqh,1,6),swrslx)" +
"   select e."XZQH",e."LESS3",e."F3TO5",e."F5TO9",e."MORE9",kreis_code, kreis_name,px1,py1,px2,py2 from" +
"    ( select" +
"     xzqh," +
"     nvl(max(decode(swrslx,'1',acd_totle)),0)  less3," +
"     nvl(max(decode(swrslx,'2',acd_totle)),0)  f3to5," +
"     nvl(max(decode(swrslx,'3',acd_totle)),0)  f5to9," +
"     nvl(max(decode(swrslx,'4',acd_totle)),0)  more9" +
"     from( select * from acduser.vw_kreis_statics_t) group by xzqh  " +
"     ) e" +
"  left join" +
" acduser.vw_sc_kreis_code_lv2 f on e.xzqh = f.short_kreis_code) " +
"   where kreis_code in" +
"(select * from " +
"  (select tbek_code from acduser.vw_kreis_code start with tbek_code = ? connect by prior tbek_pk=tbek_parent ) " +
"where  tbek_code != ?)"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(4, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("acduser.vw_acd_info")));
Assert.assertEquals(15, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("acduser.vw_acd_info", "xzqh")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("acduser.vw_acd_info", "sglx")));
dataSource.setFilters("stat,log4j,wall,encoding");
dataSource.setFilters("stat,log4j,wall,encoding");
dataSource.setFilters("stat,log4j,wall,encoding");
Object value = null;
switch (x.getOperator()) {
value = _add(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case Subtract
value = _sub(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case Multiply
value = _multi(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case Divide
value = _div(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case GreaterThan
value = _gt(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case GreaterThanOrEqual
value = _gteq(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case LessThan
value = _lt(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case LessThanOrEqual
value = _lteq(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
if (a instanceof Double || b instanceof Double) {
return _double(a) + _double(b);
if (a instanceof Float || b instanceof Float) {
return _float(a) + _float(b);
if (a instanceof Double || b instanceof Double) {
return _double(a) - _double(b);
if (a instanceof Float || b instanceof Float) {
return _float(a) - _float(b);
public class SQLEvalVisitorUtilsTest extends TestCase {
public void test_instance() throws Exception {
new SQLEvalVisitorUtils();
public void test_evalExpr() throws Exception {
Assert.assertEquals(5, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", 2, 3));
Assert.assertEquals(6, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? * ?", 2, 3));
Assert.assertEquals(-1, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", 2, 3));
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? / ?", 6, 3));
public void test_evalExpr_2() throws Exception {
Assert.assertEquals(5, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(6, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? * ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(-1, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? / ?", Arrays.<Object> asList(6, 3)));
public void test_add() throws Exception {
Assert.assertEquals(5, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(6, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(7, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(4, 3)));
public void test_add_1() throws Exception {
Assert.assertEquals(5.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2.0, 3)));
Assert.assertEquals(6.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(3.0, 3)));
Assert.assertEquals(7.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(4.0, 3)));
public void test_add_2() throws Exception {
Assert.assertEquals(5.1, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2.1, 3)));
Assert.assertEquals(6.2, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(3.2, 3)));
Assert.assertEquals(7.3, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(4.3, 3)));
public void test_add_3() throws Exception {
Assert.assertEquals(5.1D,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2.1D, 3)));
Assert.assertEquals(6.2D,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(3.2D, 3)));
Assert.assertEquals(7.3D,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(4.3D, 3)));
public void test_add_4() throws Exception {
Assert.assertEquals(5.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(2, 3.0)));
Assert.assertEquals(6.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(3, 3.0)));
Assert.assertEquals(7.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?", Arrays.<Object> asList(4, 3.0)));
public void test_add_5() throws Exception {
Assert.assertEquals(new BigInteger("5"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(2, new BigInteger("3"))));
Assert.assertEquals(new BigInteger("6"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(3, new BigInteger("3"))));
Assert.assertEquals(new BigInteger("7"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(4, new BigInteger("3"))));
public void test_add_6() throws Exception {
Assert.assertEquals(new BigDecimal("5"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(2, new BigDecimal("3"))));
Assert.assertEquals(new BigDecimal("6"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(3, new BigDecimal("3"))));
Assert.assertEquals(new BigDecimal("7"),
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? + ?",
Arrays.<Object> asList(4, new BigDecimal("3"))));
public void test_sub() throws Exception {
Assert.assertEquals(-1, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(1, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(4, 3)));
public void test_sub_1() throws Exception {
Assert.assertEquals(-1.0,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(2.0, 3)));
Assert.assertEquals(0.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(3.0, 3)));
Assert.assertEquals(1.0, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(4.0, 3)));
public void test_sub_2() throws Exception {
Assert.assertEquals(2.1 - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(2.1, 3)));
Assert.assertEquals(3.2 - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(3.2, 3)));
Assert.assertEquals(4.3 - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(4.3, 3)));
public void test_sub_3() throws Exception {
Assert.assertEquals(2.1D - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(2.1D, 3)));
Assert.assertEquals(3.2D - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(3.2D, 3)));
Assert.assertEquals(4.3D - 3,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? - ?", Arrays.<Object> asList(4.3D, 3)));
public void test_lt() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(4, 3)));
public void test_lt_1() throws Exception {
Assert.assertEquals(true,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(2.0, 3)));
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(3.0, 3)));
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? < ?", Arrays.<Object> asList(4.0, 3)));
public void test_ltEq() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(4, 3)));
public void test_ltEq_1() throws Exception {
Assert.assertEquals(true,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(2.0, 3)));
Assert.assertEquals(true,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(3.0, 3)));
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? <= ?", Arrays.<Object> asList(4.0, 3)));
public void test_gt() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? > ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? > ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? > ?", Arrays.<Object> asList(4, 3)));
public void test_gtEq() throws Exception {
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? >= ?", Arrays.<Object> asList(2, 3)));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? >= ?", Arrays.<Object> asList(3, 3)));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcUtils.MYSQL, "? >= ?", Arrays.<Object> asList(4, 3)));
if (stacks.size() > 0 ) {
traceList.add(stacks);
if (content == null ) {
System.out.println("SqlStat,SQL");
TabledDataPrinter.printSqlData(content, option);
if (content == null || content.size() == 0 ) {
System.out.println("");
TabledDataPrinter.printActiveConnStack(content, option);
System.out.println("  -sql,-ds,-act, ");
System.out.println("    ,  -sql -ds ");
System.out.println();
System.out.println(": ");
System.out.println("  3983sql .");
System.out.println("      >druidStat -sql 3983");
System.out.println("  3983ds.");
System.out.println("      >druidStat -ds 3983");
System.out.println("  3983sqlid10.");
System.out.println("      >druidStat -sql -id 10 -detail 3983");
System.out.println("  3983");
System.out.println("      >druidStat -act 3983");
System.out.println("  3983ds,sql,act");
System.out.println("      >druidStat -ds -sql -act 3983");
System.out.println("  5ds");
System.out.println("      >druidStat -ds 3983 5");
public class DruidStatNullDataTest extends TestCase {
private DruidDataSource dataSource;
private static String getSelfPid() {
String pid = ManagementFactory.getRuntimeMXBean().getName().split("@")[0];
return pid;
protected void createDs() throws Exception {
dataSource = new DruidDataSource();
dataSource.setMinIdle(1);
dataSource.setUrl("jdbc:h2:mem:test;");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setRemoveAbandoned(true);
dataSource.setRemoveAbandonedTimeout(600);
dataSource.init();
protected void dispose() throws Exception {
JdbcUtils.close(dataSource);
public void test_printDruidStat() throws Exception {
createDs();
String pid = getSelfPid();
String[] cmdArray = {"-sql", pid};
Option opt = Option.parseOptions(cmdArray);
DruidStat.printDruidStat(opt);
cmdArray = new String[] {"-act", pid};
opt = Option.parseOptions(cmdArray);
DruidStat.printDruidStat(opt);
dispose();
public static void main(String[] args) {
Result result = JUnitCore.runClasses(DruidStatNullDataTest.class);
for (Failure failure : result.getFailures()) {
System.out.println(failure.toString());
if (scheduler != null) {
scheduler.shutdownNow();
protected void setUp() throws Exception {
for (DruidDataSource item : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
JdbcUtils.close(item);
for (DruidDataSource item : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
JdbcUtils.close(item);
for (DruidDataSource item : DruidDataSourceStatManager.getDruidDataSourceInstances()) {
JdbcUtils.close(item);
multiDataSource.close();
Option.printHelp(e.getMessage());
PrintStream out = option.getPrintStream();
out.println("SqlStat,SQL");
out.println("");
private PrintStream printStream = System.out;
public static void printHelp(String errorMsg) {
printHelp(System.out, errorMsg);
printHelp(System.out, null);
public static void printHelp(PrintStream out, String errorMsg) {
if (errorMsg != null ) {
out.println(errorMsg);
out.println();
out.println("Usage: druidStat -help | -sql -ds -act [-detail] [-id id] <pid> [refresh-interval]");
out.println();
out.println(": ");
out.println("  -help             ");
out.println("  -sql              SQL");
out.println("  -ds               DataSource");
out.println("  -act              ");
out.println("  -detail           ");
out.println("  -id id            id" );
out.println("  pid               druidjvmid");
out.println("  refresh-interval  , " );
out.println();
out.println(": ");
out.println("  -sql,-ds,-act, ");
out.println("    ,  -sql -ds ");
out.println("  -id id -sql -ds,   -sql -id 5  -ds -id 1086752");
out.println("  pid, refresh-interval, ,");
out.println("  pidrefresh-interval, ");
out.println();
out.println(": ");
out.println("  3983sql .");
out.println("      >druidStat -sql 3983");
out.println("  3983ds.");
out.println("      >druidStat -ds 3983");
out.println("  3983sqlid10.");
out.println("      >druidStat -sql -id 10 -detail 3983");
out.println("  3983");
out.println("      >druidStat -act 3983");
out.println("  3983ds,sql,act");
out.println("      >druidStat -ds -sql -act 3983");
out.println("  5ds");
out.println("      >druidStat -ds 3983 5");
public void setPrintStream(PrintStream printStream) {
this.printStream=printStream;
public PrintStream getPrintStream() {
return this.printStream;
PrintStream out = opt.getPrintStream();
out.println(line);
out.println("===============================n");
PrintStream out = opt.getPrintStream();
out.println(getVerticalFormattedOutput(content, dsColField));
out.println(getFormattedOutput(content, dsRowTitle, dsRowField));
PrintStream out = opt.getPrintStream();
out.println("Formatted SQL:");
out.println(SQLUtils.format(sql, dbType));
out.println();
out.println(getVerticalFormattedOutput(content, sqlColField));
out.println(getFormattedOutput(content, sqlRowTitle, sqlRowField));
this.removeAbandonedTimeoutMillis = (long)removeAbandonedTimeout * 1000;
if (datasource == null || !DruidDataSourceUtils.isRemoveAbandoned(datasource)) {
public static final String     CONFIG_FILE                        = "config.file";
public static final String     CONFIG_DECRYPT                     = "config.decrypt";
public static final String     SYS_PROP_CONFIG_FILE               = "druid.config.file";
if (protocol == null) {
protocol = System.getProperty(SYS_PROP_CONFIG_FILE);
if (protocol != null && protocol.length() > 0) {
filePath = protocol.substring(PROTOCOL_PREFIX.length());
public void testInitRemoteConfigFileBySystemProperty() throws SQLException {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setFilters("config");
System.setProperty(ConfigFilter.SYS_PROP_CONFIG_FILE, FileConfigLoader.PROTOCOL_PREFIX + this.filePath);
dataSource.init();
Assert.assertEquals("The username is " + dataSource.getUsername(), "test1", dataSource.getUsername());
} finally {
System.clearProperty(ConfigFilter.SYS_PROP_CONFIG_FILE);
JdbcUtils.close(dataSource);
Class<?> clazz = classLoader.loadClass(clazzName);
private static final long serialVersionUID = 1L;
public String getFilePath(String protocol) {
public URL getUrl(String protocol) throws MalformedURLException {
private static Log         log                       = LogFactory.getLog(RsaDecrypter.class);
public static final String KEY                       = "config.decrypt.key";
public static final String KEY_FILE                  = "config.decrypt.keyFile";
public static final String X509_FILE                 = "config.decrypt.x509File";
public static final String DEFAULT_PUBLIC_KEY_STRING = "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKHGwq7q2RmwuRgKxBypQHw0mYu4BQZ3eMsTrdK8E6igRcxsobUC7uT0SoxIjl1WveWniCASejoQtn/BY6hVKWsCAwEAAQ==";
public PublicKey getPublicKey(Properties info) {
public PublicKey getPublicKeyByString(String publicKeyString) {
public PublicKey getPublicKeyByPublicKeyFile(String publicKeyFile) {
byte[] b = new byte[512 / 8];
public PublicKey getPublicKeyByX509(String x509File) {
private static Log         log                  = LogFactory.getLog(ConfigFilter.class);
public static final String CONFIG_FILE          = "config.file";
public static final String CONFIG_DECRYPT       = "config.decrypt";
public static final String SYS_PROP_CONFIG_FILE = "druid.config.file";
String configFile = connectinProperties.getProperty(CONFIG_FILE);
if (configFile == null) {
configFile = System.getProperty(SYS_PROP_CONFIG_FILE);
if (configFile != null && configFile.length() > 0) {
log.debug("Config file will be load from [" + configFile + "].");
info = loadConfig(configFile);
throw new IllegalArgumentException("Cannot load remote config file from the [config.file=" + configFile
throw new IllegalArgumentException("Druid doesn't support the decrypter [config.decrypt="
+ decrypterId + "].");
Properties securityInfo = isRemotedSecurityConfig ? info : connectinProperties;
public Properties loadConfig(String filePath) {
Properties properties = new Properties();
InputStream inStream = null;
boolean xml = false;
if (filePath.startsWith("http:
URL url = new URL(filePath);
inStream = url.openStream();
xml = url.getPath().endsWith(".xml");
File file = new File(filePath);
if (file.exists()) {
inStream = new FileInputStream(file);
inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(filePath);
xml = filePath.endsWith(".xml");
if (inStream == null) {
log.error("load config file error, file : " + filePath);
return null;
if (xml) {
properties.loadFromXML(inStream);
properties.load(inStream);
return properties;
} catch (Exception ex) {
log.error("load config file error, file : " + filePath, ex);
return null;
} finally {
JdbcUtils.close(inStream);
Exception error = null;
error = e;
Assert.assertNotNull(error);
Assert.assertEquals("The password is " + dataSource.getPassword() + ", is not xiaoyu", "xiaoyu",
dataSource.getPassword());
Exception error = null;
error = e;
Assert.assertNotNull(error);
dataSource.setConnectionProperties("config.decrypt=RSA;config.file=" + FileConfigLoader.PROTOCOL_PREFIX
+ this.filePath);
Exception error = null;
error = e;
Assert.assertNotNull(error);
dataSource.setConnectionProperties("config.file=file:
System.setProperty(ConfigFilter.SYS_PROP_CONFIG_FILE, "file:
dataSource.setConnectionProperties("config.decrypt=RSA;config.file=" + "file:
public class ConfigFilterTest1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("config");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_decrypt() throws Exception {
String plainPassword = "abcdefg1234567890";
dataSource.setPassword(ConfigTools.encrypt(plainPassword));
Assert.assertFalse(plainPassword.equals(dataSource.getPassword()));
dataSource.addConnectionProperty(ConfigFilter.CONFIG_DECRYPT, "true");
dataSource.init();
Assert.assertEquals(plainPassword, dataSource.getPassword());
public class ConfigFilterTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setFilters("config");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_decrypt() throws Exception {
dataSource.addConnectionProperty(ConfigFilter.CONFIG_FILE, "bvt/config/config-0.properties");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
dataSource.init();
Assert.assertEquals("jdbc:mock:config-0", dataSource.getUrl());
Assert.assertEquals(false, dataSource.isTestOnBorrow());
Assert.assertEquals(10, dataSource.getMaxActive());
public void test_decrypt1() throws Exception {
dataSource.addConnectionProperty(ConfigFilter.CONFIG_FILE, "bvt/config/config-1.properties");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
dataSource.init();
Assert.assertEquals("jdbc:mock:config-1", dataSource.getUrl());
Assert.assertEquals(false, dataSource.isTestOnBorrow());
Assert.assertEquals(11, dataSource.getMaxActive());
Assert.assertEquals(3, dataSource.getProxyFilters().size());
public void test_decrypt2() throws Exception {
dataSource.addConnectionProperty(ConfigFilter.CONFIG_FILE, "bvt/config/config-2.properties");
dataSource.addConnectionProperty(ConfigFilter.CONFIG_DECRYPT, "true");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
dataSource.init();
Assert.assertEquals("jdbc:mock:config-2", dataSource.getUrl());
Assert.assertEquals(false, dataSource.isTestOnBorrow());
Assert.assertEquals(12, dataSource.getMaxActive());
Assert.assertEquals("abcdefg1234567890", dataSource.getPassword());
public void test_decrypt3() throws Exception {
dataSource.addConnectionProperty(ConfigFilter.CONFIG_FILE, "bvt/config/config-3.properties");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
dataSource.init();
Assert.assertEquals("jdbc:mock:config-3", dataSource.getUrl());
Assert.assertEquals(false, dataSource.isTestOnBorrow());
Assert.assertEquals(13, dataSource.getMaxActive());
Assert.assertEquals("abcdefg1234567890", dataSource.getPassword());
public class ConfigToolsTest extends TestCase {
public void test_0() throws Exception {
String plainText = "abcdef";
String cipherText = ConfigTools.encrypt(plainText);
String decipherText = ConfigTools.decrypt(cipherText);
Assert.assertEquals(plainText, decipherText);
dataSource.setConnectionProperties("config.decrypt=true");
DruidStatService.getInstance().service("/reset-all.json");
String result = DruidStatService.getInstance().service("/sql-"
+ dataSource.getSqlStatMap().values().iterator().next().getId()
+ ".json");
DruidStatService.getInstance().service("/reset-all.json");
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getDataSourceIdList() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String result = DruidStatService.getInstance().service("/datasource.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> dataSourceList = (List<Map<String, Object>>) resultMap.get("Content");
Map<String, Object> dataSourceStat = dataSourceList.get(0);
assertThat(dataSourceStat, is(not(nullValue())));
int id = (Integer) dataSourceStat.get("Identity");
String resultId = DruidStatService.getInstance().service("/datasource-" + id + ".json");
Map<String, Object> resultIdMap = (Map<String, Object>) JSONUtils.parse(resultId);
Map<String, Object> dataSourceIdStat = (Map<String, Object>) resultIdMap.get("Content");
assertThat((Integer) dataSourceIdStat.get("PoolingCount"), equalTo(1));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getBasic() throws Exception {
String result = DruidStatService.getInstance().service("/basic.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
Map<String, Object> contentMap = (Map<String, Object>) resultMap.get("Content");
assertThat(contentMap.get("Version"), is(not(nullValue())));
assertThat(contentMap.get("Drivers"), is(not(nullValue())));
assertThat((Boolean) contentMap.get("ResetEnable"), is(true));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getActiveConnectionStackTrace() throws Exception {
String sql = "select 1";
dataSource.setRemoveAbandoned(true);
dataSource.setRemoveAbandonedTimeout(Integer.MAX_VALUE);
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
String result = DruidStatService.getInstance().service("/activeConnectionStackTrace.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<String> contentList = (List<String>) resultMap.get("Content");
assertThat(contentList.get(0), is(not(nullValue())));
stmt.close();
conn.close();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getActiveConnectionStackTraceId() throws Exception {
String sql = "select 1";
dataSource.setRemoveAbandoned(true);
dataSource.setRemoveAbandonedTimeout(Integer.MAX_VALUE);
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
String dsResult = DruidStatService.getInstance().service("/datasource.json");
Map<String, Object> dsResultMap = (Map<String, Object>) JSONUtils.parse(dsResult);
List<Map<String, Object>> dataSourceList = (List<Map<String, Object>>) dsResultMap.get("Content");
Map<String, Object> dataSourceStat = dataSourceList.get(0);
assertThat(dataSourceStat, is(not(nullValue())));
int id = (Integer) dataSourceStat.get("Identity");
String result = DruidStatService.getInstance().service("/activeConnectionStackTrace-" + id + ".json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<String> contentList = (List<String>) resultMap.get("Content");
assertThat(contentList.get(0), is(not(nullValue())));
stmt.close();
conn.close();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_returnJSONActiveConnectionStackTrace() throws Exception{
String result = DruidStatService.getInstance().service("/activeConnectionStackTrace-1.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
assertThat((Integer)resultMap.get("ResultCode"), equalTo(-1));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getWebURIList() throws Exception {
String uri = "/";
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
WebStatFilter filter = new WebStatFilter();
filter.init(filterConfig);
MockHttpServletRequest request = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
filter.doFilter(request, response, chain);
String result = DruidStatService.getInstance().service("/weburi.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> webURIList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(webURIList.size(), equalTo(1));
Map<String, Object> webURI = webURIList.get(0);
assertThat((String) webURI.get("URI"), equalTo(uri));
assertThat((Integer) webURI.get("RequestCount"), equalTo(1));
MockHttpServletRequest request2 = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response2 = new MockHttpServletResponse();
MockFilterChain chain2 = new MockFilterChain();
filter.doFilter(request2, response2, chain2);
result = DruidStatService.getInstance().service("/weburi.json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
webURIList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(webURIList.size(), equalTo(1));
webURI = webURIList.get(0);
assertThat((String) webURI.get("URI"), equalTo(uri));
assertThat((Integer) webURI.get("RequestCount"), equalTo(2));
filter.destroy();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getWebURIById() throws Exception {
String uri = "/";
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
WebStatFilter filter = new WebStatFilter();
filter.init(filterConfig);
MockHttpServletRequest request = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
filter.doFilter(request, response, chain);
String result = DruidStatService.getInstance().service("/weburi-" + uri + ".json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
Map<String, Object> contentMap = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) contentMap.get("RequestCount"), equalTo(1));
MockHttpServletRequest request2 = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response2 = new MockHttpServletResponse();
MockFilterChain chain2 = new MockFilterChain();
filter.doFilter(request2, response2, chain2);
result = DruidStatService.getInstance().service("/weburi-" + uri + ".json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
contentMap = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) contentMap.get("RequestCount"), equalTo(2));
filter.destroy();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getWebApp() throws Exception {
String uri = "/";
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
WebStatFilter filter = new WebStatFilter();
filter.init(filterConfig);
MockHttpServletRequest request = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
filter.doFilter(request, response, chain);
String result = DruidStatService.getInstance().service("/webapp.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(1));
Map<String, Object> contentMap = contentList.get(0);
assertThat((Integer) contentMap.get("RequestCount"), equalTo(1));
MockHttpServletRequest request2 = new MockHttpServletRequest("GET", uri);
MockHttpServletResponse response2 = new MockHttpServletResponse();
MockFilterChain chain2 = new MockFilterChain();
filter.doFilter(request2, response2, chain2);
result = DruidStatService.getInstance().service("/webapp.json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(1));
contentMap = contentList.get(0);
assertThat((Integer) contentMap.get("RequestCount"), equalTo(2));
filter.destroy();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getWebSession() throws Exception {
String uri = "/";
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
WebStatFilter filter = new WebStatFilter();
filter.init(filterConfig);
MockHttpServletRequest request = new MockHttpServletRequest("GET", uri);
MockHttpSession session = new MockHttpSession();
request.setSession(session);
String sessionId = session.getId();
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
filter.doFilter(request, response, chain);
String result = DruidStatService.getInstance().service("/websession.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(1));
Map<String, Object> contentMap = contentList.get(0);
assertThat((String) contentMap.get("SESSIONID"), equalTo(sessionId));
MockHttpServletRequest request2 = new MockHttpServletRequest("GET", uri);
MockHttpSession session2 = new MockHttpSession();
request2.setSession(session2);
String sessionId2 = session2.getId();
MockHttpServletResponse response2 = new MockHttpServletResponse();
MockFilterChain chain2 = new MockFilterChain();
filter.doFilter(request2, response2, chain2);
result = DruidStatService.getInstance().service("/websession.json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(2));
contentMap = contentList.get(1);
assertThat((String) contentMap.get("SESSIONID"), equalTo(sessionId2));
filter.destroy();
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getSpring() throws Exception {
ApplicationContext context = new ClassPathXmlApplicationContext(
"classpath:com/alibaba/druid/stat/spring-config-stat.xml");
UserService userService = (UserService) context.getBean("userService");
userService.save();
String result = DruidStatService.getInstance().service("/spring.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(1));
Map<String, Object> contentMap = contentList.get(0);
assertThat((String) contentMap.get("Class"), is(not(nullValue())));
assertThat((Integer) contentMap.get("ExecuteCount"), equalTo(1));
userService.save();
result = DruidStatService.getInstance().service("/spring.json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
contentList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(contentList.size(), equalTo(1));
contentMap = contentList.get(0);
assertThat((String) contentMap.get("Class"), is(not(nullValue())));
assertThat((Integer) contentMap.get("ExecuteCount"), equalTo(2));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getSpringDetail() throws Exception {
ApplicationContext context = new ClassPathXmlApplicationContext(
"classpath:com/alibaba/druid/stat/spring-config-stat.xml");
UserService userService = (UserService) context.getBean("userService");
userService.save();
String result = DruidStatService.getInstance().service("/spring-detail.json?class=com.alibaba.druid.stat.spring.UserService&method=save()");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
Map<String, Object> contentMap = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) contentMap.get("ExecuteCount"), equalTo(1));
userService.save();
result = DruidStatService.getInstance().service("/spring-detail.json?class=com.alibaba.druid.stat.spring.UserService&method=save()");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
contentMap = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) contentMap.get("ExecuteCount"), equalTo(2));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_getResetAll() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String resultSQL = DruidStatService.getInstance().service("/sql.json");
Map<String, Object> resultSQLMap = (Map<String, Object>) JSONUtils.parse(resultSQL);
List<Map<String, Object>> sqlList = (List<Map<String, Object>>) resultSQLMap.get("Content");
assertThat(sqlList.size(), equalTo(1));
Map<String, Object> sqlStat = sqlList.get(0);
assertThat((Integer) sqlStat.get("RunningCount"), equalTo(0));
String uri = "/";
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
WebStatFilter filter = new WebStatFilter();
filter.init(filterConfig);
MockHttpServletRequest request = new MockHttpServletRequest("GET", uri);
MockHttpSession session = new MockHttpSession();
request.setSession(session);
String sessionId = session.getId();
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
filter.doFilter(request, response, chain);
String resultWebSession = DruidStatService.getInstance().service("/websession.json");
Map<String, Object> resultWebSessionMap = (Map<String, Object>) JSONUtils.parse(resultWebSession);
List<Map<String, Object>> contentWebSessionList = (List<Map<String, Object>>) resultWebSessionMap.get("Content");
assertThat(contentWebSessionList.size(), equalTo(1));
Map<String, Object> contentWebSessionMap = contentWebSessionList.get(0);
assertThat((String) contentWebSessionMap.get("SESSIONID"), equalTo(sessionId));
ApplicationContext context = new ClassPathXmlApplicationContext(
"classpath:com/alibaba/druid/stat/spring-config-stat.xml");
UserService userService = (UserService) context.getBean("userService");
userService.save();
String resultSpring = DruidStatService.getInstance().service("/spring.json");
Map<String, Object> resultSpringMap = (Map<String, Object>) JSONUtils.parse(resultSpring);
List<Map<String, Object>> contentSpringList = (List<Map<String, Object>>) resultSpringMap.get("Content");
assertThat(contentSpringList.size(), equalTo(1));
Map<String, Object> contentMap = contentSpringList.get(0);
assertThat((String) contentMap.get("Class"), is(not(nullValue())));
assertThat((Integer) contentMap.get("ExecuteCount"), equalTo(1));
String result = DruidStatService.getInstance().service("/reset-all.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
assertThat(resultMap.get("content"), is(nullValue()));
resultSQL = DruidStatService.getInstance().service("/sql.json");
resultSQLMap = (Map<String, Object>) JSONUtils.parse(resultSQL);
sqlList = (List<Map<String, Object>>) resultSQLMap.get("Content");
assertThat(sqlList, is(nullValue()));
resultWebSession = DruidStatService.getInstance().service("/websession.json");
resultWebSessionMap = (Map<String, Object>) JSONUtils.parse(resultWebSession);
contentWebSessionList = (List<Map<String, Object>>) resultWebSessionMap.get("Content");
assertThat(contentWebSessionList, is(nullValue()));
resultSpring = DruidStatService.getInstance().service("/spring.json");
resultSpringMap = (Map<String, Object>) JSONUtils.parse(resultSpring);
contentSpringList = (List<Map<String, Object>>) resultSpringMap.get("Content");
assertThat(contentSpringList, is(nullValue()));
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService() throws Exception {
String result = DruidStatService.getInstance().service("/bad.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
assertThat((Integer)resultMap.get("ResultCode"), equalTo(-1));
public void test_statService_getParameters() throws Exception {
String url = "?x=a&y=b";
Map<String, String> parameters = DruidStatService.getParameters(url);
assertThat(parameters.get("x"), equalTo("a"));
assertThat(parameters.get("y"), equalTo("b"));
url = null;
parameters = DruidStatService.getParameters(url);
assertThat(parameters.isEmpty(), is(true));
url = "/%E4%B8%AD%E6%96%87";
parameters = DruidStatService.getParameters(url);
assertThat(parameters.isEmpty(), is(true));
public interface UserService {
public void save();
@Component("userService")
public class UserServiceImpl implements UserService {
@Override
public void save() {
DruidStatService.getInstance().service("/reset-all.json");
public void test_statService_returnJSONActiveConnectionStackTrace() throws Exception {
assertThat((Integer) resultMap.get("ResultCode"), equalTo(-1));
assertThat((Integer) resultMap.get("ResultCode"), equalTo(-1));
public class DruidStatServiceTest2 {
private DruidDataSource dataSource;
private DruidDataSource dataSource2;
public void setUp() throws Exception {
DruidStatService.getInstance().service("/reset-all.json");
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("stat");
dataSource.setTestOnBorrow(false);
dataSource.init();
dataSource2 = new DruidDataSource();
dataSource2.setUrl("jdbc:mock:xxx2");
dataSource2.setFilters("stat");
dataSource2.setTestOnBorrow(false);
dataSource2.init();
public void tearDown() throws Exception {
JdbcUtils.close(dataSource);
JdbcUtils.close(dataSource2);
public void test_statService_getSqlList() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String sql2 = "select 2";
conn = dataSource2.getConnection();
stmt = conn.prepareStatement(sql2);
rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String result = DruidStatService.getInstance().service("/sql.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> sqlList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(sqlList.size(), equalTo(2));
for (Map<String, Object> sqlStat : sqlList) {
assertThat((Integer) sqlStat.get("RunningCount"), equalTo(0));
assertThat((Integer) sqlStat.get("ExecuteCount"), equalTo(1));
assertThat((Integer) sqlStat.get("FetchRowCount"), equalTo(1));
assertThat((Integer) sqlStat.get("EffectedRowCount"), equalTo(0));
public void test_statService_getSqlById() throws Exception {
String sql = "select 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
String sql2 = "select 2";
conn = dataSource2.getConnection();
stmt = conn.prepareStatement(sql2);
rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
long id = dataSource.getSqlStatMap().values().iterator().next().getId();
String result = DruidStatService.getInstance().service("/sql-" + id + ".json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
Map<String, Object> sqlStat = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) sqlStat.get("RunningCount"), equalTo(0));
assertThat((Integer) sqlStat.get("ExecuteCount"), equalTo(1));
assertThat((Integer) sqlStat.get("FetchRowCount"), equalTo(1));
assertThat((Integer) sqlStat.get("EffectedRowCount"), equalTo(0));
assertThat((String) sqlStat.get("SQL"), equalTo(sql));
id = dataSource2.getSqlStatMap().values().iterator().next().getId();
result = DruidStatService.getInstance().service("/sql-" + id + ".json");
resultMap = (Map<String, Object>) JSONUtils.parse(result);
sqlStat = (Map<String, Object>) resultMap.get("Content");
assertThat((Integer) sqlStat.get("RunningCount"), equalTo(0));
assertThat((Integer) sqlStat.get("ExecuteCount"), equalTo(1));
assertThat((Integer) sqlStat.get("FetchRowCount"), equalTo(1));
assertThat((Integer) sqlStat.get("EffectedRowCount"), equalTo(0));
assertThat((String) sqlStat.get("SQL"), equalTo(sql2));
String result2 = DruidStatService.getInstance().service("/sql-" + Integer.MAX_VALUE + ".json");
resultMap = (Map<String, Object>) JSONUtils.parse(result2);
assertThat(resultMap.get("Content"), is(nullValue()));
public void test_statService_getDataSourceList() throws Exception {
String result = DruidStatService.getInstance().service("/datasource.json");
Map<String, Object> resultMap = (Map<String, Object>) JSONUtils.parse(result);
List<Map<String, Object>> dataSourceList = (List<Map<String, Object>>) resultMap.get("Content");
assertThat(dataSourceList.size(), equalTo(2));
Map<String, Object> dataSourceStat = dataSourceList.get(0);
assertThat((Integer) dataSourceStat.get("PoolingCount"), equalTo(0));
assertThat((Integer) dataSourceStat.get("ActiveCount"), equalTo(0));
WebAppStatManager.getInstance().getWebAppStatSet().clear();
if (filePath.startsWith("http:
public final static int RevisionVersion = 7;
private static final long                        serialVersionUID       = 1L;
private static final String                      BASE_URL               = "/sql";
private static final String                      KEY_FORMAT_SQL         = "formattedSql";
private static final String                      KEY_SQL                = "SQL";
private String                                   id;
private MBeanServerConnection                    conn;
private static final ArrayList<String>           PARESE_TITLE_LIST      = new ArrayList<String>() {
private static final long serialVersionUID = 1L;
add("parsedTable");
add("parsedFields");
add("parsedConditions");
add("parsedRelationships");
add("parsedOrderbycolumns");
private static final ArrayList<String>           LAST_SLOW_TITLE_LIST   = new ArrayList<String>() {
private static final long serialVersionUID = 1L;
add("MaxTimespan");
add("MaxTimespanOccurTime");
add("LastSlowParameters");
private static final ArrayList<String>           LAST_ERROR_TITLE_LIST  = new ArrayList<String>() {
private static final long serialVersionUID = 1L;
add("LastErrorMessage");
add("LastErrorClass");
add("LastErrorTime");
add("LastErrorStackTrace");
private static final ArrayList<String>           OTHER_ERROR_TITLE_LIST = new ArrayList<String>() {
private static final long serialVersionUID = 1L;
add("BatchSizeMax");
add("BatchSizeTotal");
add("BlobOpenCount");
add("ClobOpenCount");
add("ReaderOpenCount");
add("InputStreamOpenCount");
add("ReadStringLength");
add("ReadBytesLength");
private int                                      maxListLen;
private String                                   formatSql;
private String                                   sql;
private static final int                         WIDTH                  = 800;
private static final int                         HEIGHT                 = 600;
private final static Log                         LOG                    = LogFactory.getLog(DruidSqlDetailFrame.class);
public DruidSqlDetailFrame(String id, MBeanServerConnection conn){
ArrayList<LinkedHashMap<String, Object>> data = TableDataProcessor.parseData(TableDataProcessor.getData(url,
formatSql = (String) contentEle.remove(KEY_FORMAT_SQL);
sql = (String) contentEle.remove(KEY_SQL);
for (int i = 0; i < maxListLen; i++) {
slowDataEle.put(key, value);
LOG.warn("", e);
private void addTable(JPanel contentPanel, String title, ArrayList<LinkedHashMap<String, Object>> data) {
content1.setLayout(new BorderLayout());
content1.setBorder((TitledBorder) BorderFactory.createTitledBorder(title));
final JTableHeader header1 = table.getTableHeader();
content1.add(header1, BorderLayout.NORTH);
content1.add(table);
contentPanel.setLayout(new GridLayout(0, 1));
final JTextArea sqlField = new JTextArea(formatSql, 8, 20);
final JScrollPane content1 = new JScrollPane(sqlField);
content1.setBorder((TitledBorder) BorderFactory.createTitledBorder("SQL"));
contentPanel.add(content1);
addTable(contentPanel, "", parseData);
addTable(contentPanel, "", lastSlowData);
addTable(contentPanel, "", lastErrorData);
addTable(contentPanel, "", otherData);
pane.add(scrollPane, BorderLayout.CENTER);
setTitle("SQL:[" + sql + "]");
double width = Toolkit.getDefaultToolkit().getScreenSize().getWidth();
double height = Toolkit.getDefaultToolkit().getScreenSize().getHeight();
setLocation((int) (width - getWidth()) / 2, (int) (height - getHeight()) / 2);
defaultFetchDirection = stmt.getFetchDirection();
JTable table = new JTable();
protected final ReentrantLock                lock;
public DruidAbstractDataSource(boolean lockFair){
lock = new ReentrantLock(lockFair);
this.removeAbandonedTimeoutMillis = (long) removeAbandonedTimeout * 1000;
this(true);
public DruidDataSource(boolean fairLock){
super (fairLock);
void putLast(DruidConnectionHolder e, long lastActiveTimeMillis) {
private int    threadCount     = 5;
private int    loopCount       = 3;
public void test_0() throws Exception {
DruidDataSource dataSource = new DruidDataSource(false);
public void test_1() throws Exception {
final CountDownLatch dumpLatch = new CountDownLatch(1);
Thread[] threads = new Thread[threadCount];
dumpLatch.await();
} catch (InterruptedException e) {
e.printStackTrace();
threads[i] = thread;
long[] threadIdArray = new long[threads.length];
for (int i = 0; i < threads.length; ++i) {
threadIdArray[i] = threads[i].getId();
ThreadInfo[] threadInfoArray = ManagementFactory.getThreadMXBean().getThreadInfo(threadIdArray);
dumpLatch.countDown();
long blockedCount = 0;
long waitedCount = 0;
for (int i = 0; i < threadInfoArray.length; ++i) {
ThreadInfo threadInfo = threadInfoArray[i];
blockedCount += threadInfo.getBlockedCount();
waitedCount += threadInfo.getWaitedCount();
+ NumberFormat.getInstance().format(millis) + "; YGC " + ygc + " FGC " + fullGC
+ " blocked " + NumberFormat.getInstance().format(blockedCount) 
+ " waited " + NumberFormat.getInstance().format(waitedCount));
public void setSlowSqlMillis(long slowSqlMillis) {
this.slowSqlMillis = slowSqlMillis;
public boolean isLogSlowSql() {
return logSlowSql;
public void setLogSlowSql(boolean logSlowSql) {
this.logSlowSql = logSlowSql;
public class ProfileEntry {
private final Key    key;
private final String type;
public ProfileEntry(Key key, String type){
this.key = key;
this.type = type;
public Key getKey() {
return key;
public String getType() {
return type;
public static class Key {
private String parent;
private String name;
public Key(String parentName, String name){
this.parent = parentName;
this.name = name;
public String getParent() {
return parent;
public String getName() {
return name;
public class Profiler {
public static ThreadLocal<Boolean>                              enableLocal    = new ThreadLocal<Boolean>();
private static ThreadLocal<Map<ProfileEntry.Key, ProfileEntry>> entriesLocal = new ThreadLocal<Map<Key, ProfileEntry>>();
private final static ThreadLocal<ProfileEntry>                  currentLocal   = new ThreadLocal<ProfileEntry>();
public static void setThreadLocalEnable() {
enableLocal.set(true);
public static void setThreadLocalDisable() {
enableLocal.remove();
public static boolean isEnable() {
return Boolean.TRUE == enableLocal.get();
public static void enter(String name, String type, long startNano) {
ProfileEntry parent = currentLocal.get();
String parentName = null;
if (parent != null) {
parentName = parent.getKey().getName();
ProfileEntry.Key key = new ProfileEntry.Key(parentName, name);
Map<ProfileEntry.Key, ProfileEntry> entries = entriesLocal.get();
if (entries == null) {
entries = new HashMap<ProfileEntry.Key, ProfileEntry>();
entriesLocal.set(entries);
ProfileEntry entry = entries.get(key);
if (entry == null) {
entry = new ProfileEntry(key, type);
entries.put(key, entry);
currentLocal.set(entry);
public static ProfileEntry current() {
return currentLocal.get();
public static void release(long nanoSpan) {
ident = ident.replaceAll("`", "");
public class MySqlUpdateTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "UPDATE `z_code` SET `key`='INTRANT_NOTALLOWED_CATEGORY_C'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("z_code")));
Assert.assertTrue(visitor.getColumns().contains(new Column("z_code", "key")));
public class DruidPooledPreparedStatement extends DruidPooledStatement implements PreparedStatement {
private final PreparedStatementHolder holder;
private final PreparedStatement       stmt;
private final String                  sql;
private int                           defaultMaxFieldSize;
private int                           defaultMaxRows;
private int                           defaultQueryTimeout;
private int                           defaultFetchDirection;
private int                           defaultFetchSize;
private int                           currentMaxFieldSize;
private int                           currentMaxRows;
private int                           currentQueryTimeout;
private int                           currentFetchDirection;
private int                           currentFetchSize;
public DruidPooledPreparedStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
super(conn, holder.getStatement());
this.stmt = holder.getStatement();
this.holder = holder;
this.sql = holder.getKey().sql;
defaultMaxFieldSize = stmt.getMaxFieldSize();
defaultMaxRows = stmt.getMaxRows();
defaultQueryTimeout = stmt.getQueryTimeout();
defaultFetchDirection = stmt.getFetchDirection();
defaultFetchSize = stmt.getFetchSize();
currentMaxFieldSize = defaultMaxFieldSize;
currentMaxRows = defaultMaxRows;
currentQueryTimeout = defaultQueryTimeout;
currentFetchDirection = defaultFetchDirection;
currentFetchSize = defaultFetchSize;
public PreparedStatementHolder getPreparedStatementHolder() {
return holder;
public int getHitCount() {
return holder.getHitCount();
public void setFetchSize(int rows) throws SQLException {
currentFetchSize = rows;
super.setFetchSize(rows);
public void setFetchDirection(int direction) throws SQLException {
currentFetchDirection = direction;
super.setFetchDirection(direction);
public void setMaxFieldSize(int max) throws SQLException {
currentMaxFieldSize = max;
super.setMaxFieldSize(max);
public void setMaxRows(int max) throws SQLException {
currentMaxRows = max;
super.setMaxRows(max);
public void setQueryTimeout(int seconds) throws SQLException {
currentQueryTimeout = seconds;
super.setQueryTimeout(seconds);
public String getSql() {
return sql;
public PreparedStatementKey getKey() {
return holder.getKey();
public PreparedStatement getRawPreparedStatement() {
return stmt;
public PreparedStatement getRawStatement() {
return stmt;
@Override
public void close() throws SQLException {
if (isClosed()) {
if (defaultMaxFieldSize != currentMaxFieldSize) {
stmt.setMaxFieldSize(defaultMaxFieldSize);
currentMaxFieldSize = defaultMaxFieldSize;
if (defaultMaxRows != currentMaxRows) {
stmt.setMaxRows(defaultMaxRows);
currentMaxRows = defaultMaxRows;
if (defaultQueryTimeout != currentQueryTimeout) {
stmt.setQueryTimeout(defaultQueryTimeout);
currentQueryTimeout = defaultQueryTimeout;
if (defaultFetchDirection != currentFetchDirection) {
stmt.setFetchDirection(defaultFetchDirection);
currentFetchDirection = defaultFetchDirection;
if (defaultFetchSize != currentFetchSize) {
stmt.setFetchSize(defaultFetchSize);
currentFetchSize = defaultFetchSize;
conn.closePoolableStatement(this);
void closeInternal() throws SQLException {
super.close();
void setClosed(boolean value) {
this.closed = value;
@Override
public ResultSet executeQuery() throws SQLException {
checkOpen();
incrementExecuteCount();
transactionRecord(sql);
oracleSetRowPrefetch();
conn.beforeExecute();
ResultSet rs = stmt.executeQuery();
if (rs == null) {
return null;
DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
resultSetTrace.add(poolableResultSet);
return poolableResultSet;
} catch (Throwable t) {
throw checkException(t);
} finally {
conn.afterExecute();
@Override
public int executeUpdate() throws SQLException {
checkOpen();
incrementExecuteCount();
transactionRecord(sql);
conn.beforeExecute();
return stmt.executeUpdate();
} catch (Throwable t) {
throw checkException(t);
} finally {
conn.afterExecute();
@Override
public void setNull(int parameterIndex, int sqlType) throws SQLException {
checkOpen();
stmt.setNull(parameterIndex, sqlType);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBoolean(int parameterIndex, boolean x) throws SQLException {
checkOpen();
stmt.setBoolean(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setByte(int parameterIndex, byte x) throws SQLException {
checkOpen();
stmt.setByte(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setShort(int parameterIndex, short x) throws SQLException {
checkOpen();
stmt.setShort(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setInt(int parameterIndex, int x) throws SQLException {
checkOpen();
stmt.setInt(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setLong(int parameterIndex, long x) throws SQLException {
checkOpen();
stmt.setLong(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setFloat(int parameterIndex, float x) throws SQLException {
checkOpen();
stmt.setFloat(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setDouble(int parameterIndex, double x) throws SQLException {
checkOpen();
stmt.setDouble(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
checkOpen();
stmt.setBigDecimal(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setString(int parameterIndex, String x) throws SQLException {
checkOpen();
stmt.setString(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBytes(int parameterIndex, byte[] x) throws SQLException {
checkOpen();
stmt.setBytes(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setDate(int parameterIndex, Date x) throws SQLException {
checkOpen();
stmt.setDate(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setTime(int parameterIndex, Time x) throws SQLException {
checkOpen();
stmt.setTime(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
checkOpen();
stmt.setTimestamp(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
checkOpen();
stmt.setAsciiStream(parameterIndex, x, length);
} catch (Throwable t) {
throw checkException(t);
@Override
@Deprecated
public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
checkOpen();
stmt.setUnicodeStream(parameterIndex, x, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
checkOpen();
stmt.setBinaryStream(parameterIndex, x, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void clearParameters() throws SQLException {
checkOpen();
stmt.clearParameters();
} catch (Throwable t) {
throw checkException(t);
@Override
public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
checkOpen();
stmt.setObject(parameterIndex, x, targetSqlType);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setObject(int parameterIndex, Object x) throws SQLException {
checkOpen();
stmt.setObject(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public boolean execute() throws SQLException {
checkOpen();
incrementExecuteCount();
transactionRecord(sql);
conn.beforeExecute();
return stmt.execute();
} catch (Throwable t) {
throw checkException(t);
} finally {
conn.afterExecute();
protected void oracleSetRowPrefetch() throws SQLException {
if (!conn.isOracle()) {
if (holder.getHitCount() == 0) {
int fetchRowPeak = holder.getFetchRowPeak();
if (fetchRowPeak < 0) {
if (holder.getDefaultRowPretch() == -1) {
int defaultRowPretch = OracleUtils.getRowPrefetch(this);
holder.setDefaultRowPretch(defaultRowPretch);
holder.setRowPrefetch(defaultRowPretch);
int rowPrefetch;
if (fetchRowPeak <= 1) {
rowPrefetch = 2;
} else if (fetchRowPeak > holder.getDefaultRowPretch()) {
rowPrefetch = holder.getDefaultRowPretch();
rowPrefetch = fetchRowPeak + 1;
if (rowPrefetch != holder.getRowPrefetch()) {
OracleUtils.setRowPrefetch(this, rowPrefetch);
holder.setRowPrefetch(rowPrefetch);
@Override
public void addBatch() throws SQLException {
checkOpen();
stmt.addBatch();
} catch (Throwable t) {
throw checkException(t);
public int[] executeBatch() throws SQLException {
checkOpen();
incrementExecuteCount();
transactionRecord(sql);
conn.beforeExecute();
return stmt.executeBatch();
} catch (Throwable t) {
throw checkException(t);
} finally {
conn.afterExecute();
@Override
public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
checkOpen();
stmt.setCharacterStream(parameterIndex, reader, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setRef(int parameterIndex, Ref x) throws SQLException {
checkOpen();
stmt.setRef(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBlob(int parameterIndex, Blob x) throws SQLException {
checkOpen();
stmt.setBlob(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setClob(int parameterIndex, Clob x) throws SQLException {
checkOpen();
stmt.setClob(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setArray(int parameterIndex, Array x) throws SQLException {
checkOpen();
stmt.setArray(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public ResultSetMetaData getMetaData() throws SQLException {
checkOpen();
return stmt.getMetaData();
} catch (Throwable t) {
throw checkException(t);
@Override
public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
checkOpen();
stmt.setDate(parameterIndex, x, cal);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
checkOpen();
stmt.setTime(parameterIndex, x, cal);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
checkOpen();
stmt.setTimestamp(parameterIndex, x, cal);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
checkOpen();
stmt.setNull(parameterIndex, sqlType, typeName);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setURL(int parameterIndex, URL x) throws SQLException {
checkOpen();
stmt.setURL(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public ParameterMetaData getParameterMetaData() throws SQLException {
checkOpen();
return stmt.getParameterMetaData();
} catch (Throwable t) {
throw checkException(t);
@Override
public void setRowId(int parameterIndex, RowId x) throws SQLException {
checkOpen();
stmt.setRowId(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNString(int parameterIndex, String value) throws SQLException {
checkOpen();
stmt.setNString(parameterIndex, value);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
checkOpen();
stmt.setNCharacterStream(parameterIndex, value, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNClob(int parameterIndex, NClob value) throws SQLException {
checkOpen();
stmt.setNClob(parameterIndex, value);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
checkOpen();
stmt.setClob(parameterIndex, reader, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
checkOpen();
stmt.setBlob(parameterIndex, inputStream, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
checkOpen();
stmt.setNClob(parameterIndex, reader, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
checkOpen();
stmt.setSQLXML(parameterIndex, xmlObject);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
checkOpen();
stmt.setObject(parameterIndex, x, targetSqlType, scaleOrLength);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
checkOpen();
stmt.setAsciiStream(parameterIndex, x, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
checkOpen();
stmt.setBinaryStream(parameterIndex, x, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
checkOpen();
stmt.setCharacterStream(parameterIndex, reader, length);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
checkOpen();
stmt.setAsciiStream(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
checkOpen();
stmt.setBinaryStream(parameterIndex, x);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
checkOpen();
stmt.setCharacterStream(parameterIndex, reader);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
checkOpen();
stmt.setNCharacterStream(parameterIndex, value);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setClob(int parameterIndex, Reader reader) throws SQLException {
checkOpen();
stmt.setClob(parameterIndex, reader);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
checkOpen();
stmt.setBlob(parameterIndex, inputStream);
} catch (Throwable t) {
throw checkException(t);
@Override
public void setNClob(int parameterIndex, Reader reader) throws SQLException {
checkOpen();
stmt.setNClob(parameterIndex, reader);
} catch (Throwable t) {
throw checkException(t);
public static class PreparedStatementKey {
private final String       sql;
private final String       catalog;
protected final MethodType methodType;
private final int          resultSetType;
private final int          resultSetConcurrency;
private final int          resultSetHoldability;
private final int          autoGeneratedKeys;
private final int[]        columnIndexes;
private final String[]     columnNames;
public PreparedStatementKey(String sql, String catalog, MethodType methodType) throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency) throws SQLException{
this(sql, catalog, methodType, resultSetType, resultSetConcurrency, 0, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency, int resultSetHoldability) throws SQLException{
this(sql, catalog, methodType, resultSetType, resultSetConcurrency, resultSetHoldability, 0, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int autoGeneratedKeys)
throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, autoGeneratedKeys, null, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int[] columnIndexes)
throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, 0, columnIndexes, null);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, String[] columnNames)
throws SQLException{
this(sql, catalog, methodType, 0, 0, 0, 0, null, columnNames);
public PreparedStatementKey(String sql, String catalog, MethodType methodType, int resultSetType,
int resultSetConcurrency, int resultSetHoldability, int autoGeneratedKeys,
int[] columnIndexes, String[] columnNames) throws SQLException{
if (sql == null) {
throw new SQLException("sql is null");
this.sql = sql;
this.catalog = catalog;
this.methodType = methodType;
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
this.resultSetHoldability = resultSetHoldability;
this.autoGeneratedKeys = autoGeneratedKeys;
this.columnIndexes = columnIndexes;
this.columnNames = columnNames;
public int getResultSetType() {
return resultSetType;
public int getResultSetConcurrency() {
return resultSetConcurrency;
public int getResultSetHoldability() {
return resultSetHoldability;
public boolean equals(Object object) {
PreparedStatementKey that = (PreparedStatementKey) object;
if (!this.sql.equals(that.sql)) {
return false;
if (this.catalog == null) {
if (that.catalog != null) {
return false;
if (!this.catalog.equals(that.catalog)) {
return false;
if (this.methodType != that.methodType) {
return false;
if (this.resultSetType != that.resultSetType) {
return false;
if (this.resultSetConcurrency != that.resultSetConcurrency) {
return false;
if (this.resultSetHoldability != that.resultSetHoldability) {
return false;
if (this.autoGeneratedKeys != that.autoGeneratedKeys) {
return false;
if (!Arrays.equals(columnIndexes, that.columnIndexes)) {
return false;
if (!Arrays.equals(columnNames, that.columnNames)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((sql == null) ? 0 : sql.hashCode());
result = prime * result + ((catalog == null) ? 0 : catalog.hashCode());
result = prime * result + ((methodType == null) ? 0 : methodType.hashCode());
result = prime * result + resultSetConcurrency;
result = prime * result + resultSetHoldability;
result = prime * result + resultSetType;
result = prime * result + autoGeneratedKeys;
result = prime * result + Arrays.hashCode(columnIndexes);
result = prime * result + Arrays.hashCode(columnNames);
return result;
public String getSql() {
return sql;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatement.class) {
if (stmt instanceof PreparedStatementProxy) {
return stmt.unwrap(iface);
return (T) stmt;
if (iface == PreparedStatementHolder.class) {
return (T) this.holder;
return super.unwrap(iface);
} else if (rawUrl.startsWith("jdbc:wrap-jdbc:filters=default:name=com.alibaba.dragoon.master:jdbc:mysql:")) {
return MYSQL;
} else if (rawUrl.startsWith("jdbc:alibaba:oracle:")) {
return ORACLE;
} else if (rawUrl.startsWith("jdbc:wrap-jdbc:driver=com.alibaba.jdbc.AlibabaDriver")) {
return ORACLE;
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
public static final String      JTDS              = "jtds";
public static final String      MOCK              = "mock";
public static final String      HSQL              = "hsql";
public static final String      DB2               = "db2";
private static final String     DB2_DRIVER        = "COM.ibm.db2.jdbc.app.DB2Driver";
public static final String      POSTGRESQL        = "postgresql";
public static final String      SYBASE            = "sybase";
public static final String      SQL_SERVER        = "sqlserver";
public static final String      ORACLE            = "oracle";
public static final String      ALI_ORACLE        = "AliOracle";
private static final String     ORACLE_DRIVER     = "oracle.jdbc.driver.OracleDriver";
private static final String     ALI_ORACLE_DRIVER = "com.alibaba.jdbc.AlibabaDriver";
public static final String      MYSQL             = "mysql";
private static final String     MYSQL_DRIVER      = "com.mysql.jdbc.Driver";
public static final String      DERBY             = "derby";
public static final String      HBASE             = "hbase";
public static final String      HIVE              = "hive";
public static final String      H2                = "h2";
private static final String     H2_DRIVER         = "org.h2.Driver";
private final static Log        LOG               = LogFactory.getLog(JdbcUtils.class);
private static final Properties driverUrlMapping  = new Properties();
} else if (rawUrl.startsWith("jdbc:alibaba:oracle:")) {
return ALI_ORACLE_DRIVER;
return ALI_ORACLE;
} else if (JdbcUtils.ORACLE.equals(dbType) || JdbcUtils.ALI_ORACLE.equals(dbType)) {
Assert.assertEquals("SELECT COUNT(DISTINCT *)nFROM t", SQLUtils.format(sql, JdbcUtils.ALI_ORACLE));
Assert.assertEquals("SELECT COUNT(UNIQUE *)nFROM t",
SQLUtils.format("select count(unique *) from t", JdbcUtils.ORACLE));
Assert.assertEquals("SELECT COUNT(UNIQUE *)nFROM t",
SQLUtils.format("select count(unique *) from t", JdbcUtils.ALI_ORACLE));
Assert.assertEquals("SELECT *nFROM tnWHERE id = #{id}", SQLUtils.format(sql, JdbcUtils.ALI_ORACLE));
Assert.assertEquals("SELECT *nFROM tnWHERE id = ${id}", SQLUtils.format(sql, JdbcUtils.ALI_ORACLE));
ParameterizedOutputVisitorUtils.parameterize(sql, JdbcUtils.ALI_ORACLE);
String formatedText2 = SQLUtils.format(text, JdbcUtils.ALI_ORACLE);
System.out.println(formatedText2);
private final static Log              LOG = LogFactory.getLog(DruidPooledPreparedStatement.class);
defaultMaxFieldSize = stmt.getMaxFieldSize();
} catch (SQLException e) {
LOG.error("getMaxFieldSize error", e);
defaultMaxRows = stmt.getMaxRows();
} catch (SQLException e) {
LOG.error("getMaxRows error", e);
defaultQueryTimeout = stmt.getQueryTimeout();
} catch (SQLException e) {
LOG.error("getMaxRows error", e);
defaultFetchDirection = stmt.getFetchDirection();
} catch (SQLException e) {
LOG.error("getFetchDirection error", e);
defaultFetchSize = stmt.getFetchSize();
} catch (SQLException e) {
LOG.error("getFetchSize error", e);
return super.isFocusable() && isRequestFocusEnabled();
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface AutoLoad {
boolean value() default false;
super(fairLock);
initFromSPIServiceLoader();
private void initFromSPIServiceLoader() {
String property = System.getProperty("druid.load.spifilter.skip");
if (property != null) {
ServiceLoader<Filter> druidAutoFilterLoader = ServiceLoader.load(Filter.class);
for (Filter autoFilter : druidAutoFilterLoader) {
AutoLoad autoLoad = autoFilter.getClass().getAnnotation(AutoLoad.class);
if (autoLoad != null && autoLoad.value()) {
if (LOG.isInfoEnabled()) {
LOG.info("load filter from spi :" + autoFilter.getClass().getName());
addFilter(autoFilter);
addFilter(filter);
private void addFilter(Filter filter) {
boolean exists = false;
for (Filter initedFilter : this.filters) {
if (initedFilter.getClass() == filter.getClass()) {
exists = true;
if (!exists) {
protected AtomicLong                         createErrorCount                          = new AtomicLong();
protected volatile Throwable                 createError;
protected volatile Throwable                 lastError;
protected volatile long                      lastErrorTimeMillis;
protected volatile Throwable                 lastCreateError;
protected volatile long                      lastCreateErrorTimeMillis;
return createErrorCount.get();
createErrorCount.incrementAndGet();
createErrorCount.incrementAndGet();
createErrorCount.incrementAndGet();
super(fairLock);
private void discardConnection(Connection realConnection) {
final boolean isAutoCommit = holder.isUnderlyingAutoCommit();
final boolean isReadOnly = holder.isUnderlyingReadOnly();
final boolean testOnReturn = this.isTestOnReturn();
if (testOnReturn) {
final int activeCount;
final int activePeak;
final Date activePeakTime;
final int poolingCount;
final int poolingPeak;
final Date poolingPeakTime;
final long connectCount;
final long closeCount;
lock.lock();
poolingCount = this.poolingCount;
poolingPeak = this.poolingPeak;
poolingPeakTime = this.getPoolingPeakTime();
activeCount = this.activeCount;
activePeak = this.activePeak;
activePeakTime = this.getActivePeakTime();
connectCount = this.connectCount;
closeCount = this.closeCount;
} finally {
lock.unlock();
dataMap.put("PoolingCount", poolingCount);
dataMap.put("PoolingPeak", poolingPeak);
dataMap.put("PoolingPeakTime", poolingPeakTime);
dataMap.put("ActiveCount", activeCount);
dataMap.put("ActivePeak", activePeak);
dataMap.put("ActivePeakTime", activePeakTime);
dataMap.put("LogicConnectCount", connectCount);
dataMap.put("LogicCloseCount", closeCount);
map.put("ConnectionConnectCount", this.getConnectCount());
private final long[]          ranges;
private final AtomicLongArray rangeCounters;
this.rangeCounters = new AtomicLongArray(ranges.length + 1);
rangeCounters = new AtomicLongArray(ranges.length + 1);
for (int i = 0; i < rangeCounters.length(); i++) {
rangeCounters.set(i, 0);
int index = rangeCounters.length() - 1;
rangeCounters.incrementAndGet(index);
return rangeCounters.get(index);
long[] array = new long[rangeCounters.length()];
for (int i = 0; i < rangeCounters.length(); i++) {
array[i] = rangeCounters.get(i);
return rangeCounters.get(index);
for (int i = 0; i < rangeCounters.length(); ++i) {
sum += rangeCounters.get(i);
StringBuilder buf = new StringBuilder();
buf.append('[');
for (int i = 0; i < rangeCounters.length(); ++i) {
if (i != 0) {
buf.append(',');
buf.append(rangeCounters.get(i));
buf.append(']');
return buf.toString();
public class HistogramMemoryTest extends TestCase {
public void test_0() throws Exception {
long memoryStart = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
final int COUNT = 1024 * 1;
Object[] items = new Object[COUNT];
for (int i = 0; i < COUNT; ++i) {
items[i] = Histogram.makeHistogram(20);
long memoryEnd = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryEnd - memoryStart));
private final String                                   sessionId;
private volatile int                                   runningCount;
private volatile int                                   concurrentMax;
final static AtomicIntegerFieldUpdater<WebSessionStat> runningCountUpdater        = AtomicIntegerFieldUpdater.newUpdater(WebSessionStat.class,
"runningCount");
final static AtomicIntegerFieldUpdater<WebSessionStat> concurrentMaxUpdater       = AtomicIntegerFieldUpdater.newUpdater(WebSessionStat.class,
"concurrentMax");
private volatile long                                  requestCount;
private volatile long                                  requestErrorCount;
private volatile long                                  requestTimeNano;
final static AtomicLongFieldUpdater<WebSessionStat>    requestCountUpdater        = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"requestCount");
final static AtomicLongFieldUpdater<WebSessionStat>    requestErrorCountUpdater   = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"requestErrorCount");
final static AtomicLongFieldUpdater<WebSessionStat>    requestTimeNanoUpdater     = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"requestTimeNano");
private volatile long                                  jdbcFetchRowCount;
private volatile long                                  jdbcUpdateCount;
private volatile long                                  jdbcExecuteCount;
private volatile long                                  jdbcExecuteTimeNano;
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcFetchRowCountUpdater   = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcFetchRowCount");
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcUpdateCountUpdater     = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcUpdateCount");
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcExecuteCountUpdater    = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcExecuteCount");
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcExecuteTimeNanoUpdater = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcExecuteTimeNano");
private volatile long                                  jdbcCommitCount;
private volatile long                                  jdbcRollbackCount;
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcCommitCountUpdater     = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcCommitCount");
final static AtomicLongFieldUpdater<WebSessionStat>    jdbcRollbackCountUpdater   = AtomicLongFieldUpdater.newUpdater(WebSessionStat.class,
"jdbcRollbackCount");
private long                                           createTimeMillis           = -1L;
private volatile long                                  lastAccessTimeMillis       = -1L;
private Set<String>                                    remoteAddresses            = new HashSet<String>(2);
private String                                         principal                  = null;
private String                                         userAgent;
private Histogram                                      requestIntervalHistogram   = Histogram.makeHistogram(8);
concurrentMaxUpdater.set(this, 0);
requestCountUpdater.set(this, 0);
requestErrorCountUpdater.set(this, 0);
requestTimeNanoUpdater.set(this, 0);
jdbcFetchRowCountUpdater.set(this, 0);
jdbcUpdateCountUpdater.set(this, 0);
jdbcExecuteCountUpdater.set(this, 0);
jdbcExecuteTimeNanoUpdater.set(this, 0);
jdbcCommitCountUpdater.set(this, 0);
jdbcRollbackCountUpdater.set(this, 0);
int running = runningCountUpdater.incrementAndGet(this);
int max = concurrentMaxUpdater.get(this);
if (concurrentMaxUpdater.compareAndSet(this, max, running)) {
requestCountUpdater.incrementAndGet(this);
runningCountUpdater.decrementAndGet(this);
requestTimeNanoUpdater.addAndGet(this, nanos);
return this.runningCount;
return concurrentMax;
return requestCount;
return requestErrorCount;
return requestTimeNano;
jdbcFetchRowCountUpdater.addAndGet(this, delta);
return jdbcFetchRowCount;
jdbcUpdateCountUpdater.addAndGet(this, updateCount);
return jdbcUpdateCount;
jdbcExecuteCountUpdater.incrementAndGet(this);
jdbcExecuteCountUpdater.addAndGet(this, executeCount);
return jdbcExecuteCount;
return jdbcExecuteTimeNano;
jdbcExecuteTimeNanoUpdater.addAndGet(this, nano);
jdbcCommitCountUpdater.incrementAndGet(this);
return jdbcCommitCount;
jdbcCommitCountUpdater.addAndGet(this, commitCount);
jdbcRollbackCountUpdater.incrementAndGet(this);
return jdbcRollbackCount;
jdbcRollbackCountUpdater.addAndGet(this, rollbackCount);
private final String                                              uri;
private volatile int                                              runningCount;
private volatile int                                              concurrentMax;
private volatile long                                             requestCount;
private volatile long                                             requestTimeNano;
final static AtomicIntegerFieldUpdater<WebURIStat>                runningCountUpdater                 = AtomicIntegerFieldUpdater.newUpdater(WebURIStat.class,
"runningCount");
final static AtomicIntegerFieldUpdater<WebURIStat>                concurrentMaxUpdater                = AtomicIntegerFieldUpdater.newUpdater(WebURIStat.class,
"concurrentMax");
final static AtomicLongFieldUpdater<WebURIStat>                   requestCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"requestCount");
final static AtomicLongFieldUpdater<WebURIStat>                   requestTimeNanoUpdater              = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"requestTimeNano");
private volatile long                                             jdbcFetchRowCount;
private volatile long                                             jdbcFetchRowPeak;                                                                                       
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcFetchRowCountUpdater            = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcFetchRowCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcFetchRowPeakUpdater             = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcFetchRowPeak");
private volatile long                                             jdbcUpdateCount;
private volatile long                                             jdbcUpdatePeak;                                                                                         
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcUpdateCountUpdater              = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcUpdateCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcUpdatePeakUpdater               = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcUpdatePeak");
private volatile long                                             jdbcExecuteCount;
private volatile long                                             jdbcExecuteErrorCount;
private volatile long                                             jdbcExecutePeak;                                                                                        
private volatile long                                             jdbcExecuteTimeNano;
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcExecuteCountUpdater             = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcExecuteCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcExecuteErrorCountUpdater        = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcExecuteErrorCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcExecutePeakUpdater              = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcExecutePeak");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcExecuteTimeNanoUpdater          = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcExecuteTimeNano");
private volatile long                                             jdbcCommitCount;
private volatile long                                             jdbcRollbackCount;
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcCommitCountUpdater              = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcCommitCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcRollbackCountUpdater            = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcRollbackCount");
private volatile long                                             jdbcPoolConnectionOpenCount;
private volatile long                                             jdbcPoolConnectionCloseCount;
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcPoolConnectionOpenCountUpdater  = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcPoolConnectionOpenCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcPoolConnectionCloseCountUpdater = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcPoolConnectionCloseCount");
private volatile long                                             jdbcResultSetOpenCount;
private volatile long                                             jdbcResultSetCloseCount;
private volatile long                                             errorCount;
private volatile long                                             lastAccessTimeMillis                = -1L;
private volatile ProfileStat                                      profiletat;
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcResultSetOpenCountUpdater       = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcResultSetOpenCount");
final static AtomicLongFieldUpdater<WebURIStat>                   jdbcResultSetCloseCountUpdater      = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"jdbcResultSetCloseCount");
final static AtomicLongFieldUpdater<WebURIStat>                   errorCountUpdater                   = AtomicLongFieldUpdater.newUpdater(WebURIStat.class,
"errorCount");
final static AtomicReferenceFieldUpdater<WebURIStat, ProfileStat> profiletatUpdater;
profiletatUpdater = AtomicReferenceFieldUpdater.newUpdater(WebURIStat.class, ProfileStat.class, "profiletat");
private final static ThreadLocal<WebURIStat>                      currentLocal                        = new ThreadLocal<WebURIStat>();
int running = runningCountUpdater.incrementAndGet(this);
int max = concurrentMaxUpdater.get(this);
if (concurrentMaxUpdater.compareAndSet(this, max, running)) {
requestCountUpdater.incrementAndGet(this);
runningCountUpdater.decrementAndGet(this);
requestTimeNanoUpdater.addAndGet(this, nanos);
errorCountUpdater.incrementAndGet(this);
long peak = jdbcFetchRowPeakUpdater.get(this);
if (jdbcFetchRowPeakUpdater.compareAndSet(this, peak, fetchRowCount)) {
long peak = jdbcExecutePeakUpdater.get(this);
if (jdbcExecutePeakUpdater.compareAndSet(this, peak, executeCount)) {
long peak = jdbcUpdatePeakUpdater.get(this);
if (jdbcUpdatePeakUpdater.compareAndSet(this, peak, updateCount)) {
jdbcExecuteErrorCountUpdater.addAndGet(this, localStat.getJdbcExecuteErrorCount());
jdbcExecuteTimeNanoUpdater.addAndGet(this, localStat.getJdbcExecuteTimeNano());
return this.runningCount;
return concurrentMax;
return requestCount;
return requestTimeNano;
jdbcFetchRowCountUpdater.addAndGet(this, delta);
return jdbcFetchRowCount;
return jdbcFetchRowPeak;
jdbcUpdateCountUpdater.addAndGet(this, updateCount);
return jdbcUpdateCount;
return jdbcUpdatePeak;
jdbcExecuteCountUpdater.incrementAndGet(this);
jdbcExecuteCountUpdater.addAndGet(this, executeCount);
return jdbcExecuteCount;
public long getJdbcExecuteErrorCount() {
return jdbcExecutePeak;
return jdbcExecuteTimeNano;
jdbcCommitCountUpdater.incrementAndGet(this);
return jdbcCommitCount;
jdbcRollbackCountUpdater.incrementAndGet(this);
return jdbcRollbackCount;
return errorCount;
return jdbcPoolConnectionOpenCount;
jdbcPoolConnectionOpenCountUpdater.addAndGet(this, delta);
jdbcPoolConnectionOpenCountUpdater.incrementAndGet(this);
return jdbcPoolConnectionCloseCount;
jdbcPoolConnectionCloseCountUpdater.addAndGet(this, delta);
jdbcPoolConnectionCloseCountUpdater.incrementAndGet(this);
return jdbcResultSetOpenCount;
jdbcResultSetOpenCountUpdater.addAndGet(this, delta);
return jdbcResultSetCloseCount;
jdbcResultSetCloseCountUpdater.addAndGet(this, delta);
if (profiletat != null) {
return profiletat;
profiletatUpdater.compareAndSet(this, null, new ProfileStat());
private ConcurrentHashMap<ProfileEntryKey, ProfileEntryStat> entries = new ConcurrentHashMap<ProfileEntryKey, ProfileEntryStat>(
public class WebSessionStatTest extends TestCase {
public void test_0() throws Exception {
WebSessionStat item = new WebSessionStat("");
long memoryStart = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
final int COUNT = 1024 * 1024;
WebSessionStat[] items = new WebSessionStat[COUNT];
for (int i = 0; i < COUNT; ++i) {
items[i] = new WebSessionStat("");
long memoryEnd = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryEnd - memoryStart));
private void gc() {
for (int i = 0; i < 10; ++i) {
System.gc();
public class WebURIStatMemoryTest extends TestCase {
public void test_0() throws Exception {
WebURIStat item = new WebURIStat("");
long memoryStart = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
final int COUNT = 1024 * 1024;
WebURIStat[] items = new WebURIStat[COUNT];
for (int i = 0; i < COUNT; ++i) {
items[i] = new WebURIStat("");
long memoryEnd = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryEnd - memoryStart));
private void gc() {
for (int i = 0; i < 10; ++i) {
System.gc();
lock.lock();
return connectCount;
} finally {
lock.unlock();
boolean value() default true;
Profiler.enter(requestURI, Profiler.PROFILE_TYPE_WEB);
Profiler.release(nanos);
private Map<ProfileEntryKey, ProfileEntryStat> entries = new LinkedHashMap<ProfileEntryKey, ProfileEntryStat>(4);
private ReadWriteLock                          lock    = new ReentrantReadWriteLock();
ProfileEntryStat entryStat = getProfileEntry(entryKey);
private ProfileEntryStat getProfileEntry(ProfileEntryKey entryKey) {
lock.readLock().lock();
ProfileEntryStat entryStat = entries.get(entryKey);
if (entryStat != null) {
return entryStat;
} finally {
lock.readLock().unlock();
lock.writeLock().lock();
ProfileEntryStat entryStat = entries.get(entryKey);
if (entryStat == null) {
entries.put(entryKey, new ProfileEntryStat());
entryStat = entries.get(entryKey);
return entryStat;
} finally {
lock.writeLock().unlock();
public List<Map<String, Object>> getStatData() {
List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
lock.readLock().lock();
for (Map.Entry<ProfileEntryKey, ProfileEntryStat> entry : entries.entrySet()) {
Map<String, Object> entryData = new LinkedHashMap<String, Object>();
entryData.put("Name", entry.getKey().getName());
entryData.put("Parent", entry.getKey().getParentName());
entryData.put("Type", entry.getKey().getType());
entryData.put("ExecuteCount", entry.getValue().getExecuteCount());
entryData.put("ExecuteTimeMillis", entry.getValue().getExecuteTimeNanos() / 1000 / 1000);
list.add(entryData);
} finally {
lock.readLock().unlock();
Collections.reverse(list);
return list;
statsMapLocal.set(new LinkedHashMap<ProfileEntryKey, ProfileEntryReqStat>());
public final static int RevisionVersion = 8;
boolean isMergeSql();
void setMergeSql(boolean mergeSql);
boolean isLogSlowSql();
void setLogSlowSql(boolean logSlowSql);
String mergeSql(String sql, String dbType);
long getSlowSqlMillis();
void setSlowSqlMillis(long slowSqlMillis);
return datasource == null ? null : dataSourceToMapData(datasource, false);
return getSqlStatDataList(datasource);
return new ArrayList<Map<String, Object>>();
public List<Map<String, Object>> getSqlStatDataList(Object datasource) {
List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
for (Object sqlStat : DruidDataSourceUtils.getSqlStatMap(datasource).values()) {
Map<String, Object> data = JdbcSqlStatUtils.getData(sqlStat);
long executeCount = (Long) data.get("ExecuteCount");
long runningCount = (Long) data.get("RunningCount");
if (executeCount == 0 && runningCount == 0) {
result.add(data);
return getDataSourceStatDataList(false);
public List<Map<String, Object>> getDataSourceStatDataList(boolean includeSqlList) {
datasourceList.add(dataSourceToMapData(dataSource, includeSqlList));
if (stacks.size() > 0) {
traceList.add(stacks);
private Map<String, Object> dataSourceToMapData(Object dataSource, boolean includeSql) {
Map<String, Object> map = DruidDataSourceUtils.getStatData(dataSource);
if (includeSql) {
List<Map<String, Object>> sqlList = getSqlStatDataList(dataSource);
map.put("SQL", sqlList);
return map;
public class PushService {
private final DruidStatManagerFacade statManagerFacade = DruidStatManagerFacade.getInstance();
private String                       serverUrl;
private boolean                      includeSql        = true;
private boolean                      includeWebApp     = true;
private boolean                      includeWebUri     = true;
private boolean                      includeWebSession = true;
private boolean                      includeSpring     = true;
public void collect() {
Map<String, Object> data = new HashMap<String, Object>();
if (includeSql) {
List<Map<String, Object>> dataSources = statManagerFacade.getDataSourceStatDataList(true);
data.put("DataSources", dataSources);
if (includeWebApp) {
List<Map<String, Object>> list = WebAppStatManager.getInstance().getWebAppStatData();
data.put("WebApp", list);
if (includeWebUri) {
List<Map<String, Object>> list = WebAppStatManager.getInstance().getURIStatData();
data.put("WebURI", list);
if (includeWebSession) {
List<Map<String, Object>> list = WebAppStatManager.getInstance().getSessionStatData();
data.put("WebSession", list);
if (includeSpring) {
List<Map<String, Object>> list = SpringStatManager.getInstance().getMethodStatData();
data.put("Spring", list);
protected void push(Map<String, Object> data) {
String json = JSONUtils.toJSONString(data);
public class ConcurrentTest2 extends TestCase {
private String jdbcUrl;
private String user;
private String password;
private String driverClass;
private int    minPoolSize = 1;
private int    maxPoolSize = 8;
private int    maxActive   = 500;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:fake:dragoon_v25masterdb";
user = "dragoon25";
password = "dragoon25";
driverClass = "com.alibaba.druid.mock.MockDriver";
public void test_concurrent_2() throws Exception {
final DruidDataSource dataSource = new DruidDataSource();
Class.forName("com.alibaba.druid.mock.MockDriver");
dataSource.setInitialSize(10);
dataSource.setMaxActive(maxActive);
dataSource.setMinIdle(minPoolSize);
dataSource.setMaxIdle(maxPoolSize);
dataSource.setPoolPreparedStatements(true);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setPoolPreparedStatements(true);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setMaxWait(1000 * 60 * 1);
final int THREAD_COUNT = 50;
final int LOOP_COUNT = 1000 * 10;
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);
final CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
@Override
public void run() {
dataSource.shrink();
for (int threadIndex = 0; threadIndex < THREAD_COUNT; ++threadIndex) {
Thread thread = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < LOOP_COUNT; ++i) {
Connection conn = dataSource.getConnection();
conn.close();
barrier.await(10, TimeUnit.SECONDS);
} catch (Throwable e) {
e.printStackTrace();
} finally {
endLatch.countDown();
thread.start();
startLatch.countDown();
endLatch.await();
System.out.println("connectCount : " + dataSource.getConnectCount());
private final static PushService     instance             = new PushService();
private static final int             DEFAULT_CYCLE_TIME   = 5 * 60 * 1000;
private static final int             DEFAULT_PUSH_TIMEOUT = 60 * 1000;
private final DruidStatManagerFacade statManagerFacade    = DruidStatManagerFacade.getInstance();
private final WebAppStatManager      webAppStatManager    = WebAppStatManager.getInstance();
private final SpringStatManager      springStatManager    = SpringStatManager.getInstance();
private boolean                      includeSql           = true;
private boolean                      includeWebApp        = true;
private boolean                      includeWebUri        = true;
private boolean                      includeWebSession    = true;
private boolean                      includeSpring        = true;
private boolean                      autoReset            = true;
private long                         cycleTime            = DEFAULT_CYCLE_TIME;
private long                         pushTimeOut          = DEFAULT_PUSH_TIMEOUT;
private ScheduledExecutorService     scheduler            = Executors.newScheduledThreadPool(1,
new DaemonThreadFactory(
"DruidPullService-Scheduler"));
private ScheduledFuture<?>           executeFuture        = null;
private PushService(){
public static PushService getInstance() {
return instance;
public void start() {
executeFuture = scheduler.scheduleAtFixedRate(new Runnable() {
public void run() {
execute();
}, 0, cycleTime, TimeUnit.MILLISECONDS);
public void stop() {
if (executeFuture != null) {
if (executeFuture.cancel(true)) {
executeFuture = null;
protected void execute() {
Map<String, Object> data = collectAndReset();
String json = JSONUtils.toJSONString(data);
push(json);
protected Map<String, Object> collectAndReset() {
List<Map<String, Object>> list = webAppStatManager.getWebAppStatData();
List<Map<String, Object>> list = webAppStatManager.getURIStatData();
List<Map<String, Object>> list = webAppStatManager.getSessionStatData();
List<Map<String, Object>> list = springStatManager.getMethodStatData();
if (autoReset) {
statManagerFacade.resetAll();
return data;
protected void push(String data) {
HttpClientUtils.post(serverUrl, data, pushTimeOut);
public long getCycleTime() {
return cycleTime;
public void setCycleTime(long cycleTime) {
this.cycleTime = cycleTime;
public String getServerUrl() {
return serverUrl;
public void setServerUrl(String serverUrl) {
this.serverUrl = serverUrl;
public boolean isIncludeSql() {
return includeSql;
public void setIncludeSql(boolean includeSql) {
this.includeSql = includeSql;
public boolean isIncludeWebApp() {
return includeWebApp;
public void setIncludeWebApp(boolean includeWebApp) {
this.includeWebApp = includeWebApp;
public boolean isIncludeWebUri() {
return includeWebUri;
public void setIncludeWebUri(boolean includeWebUri) {
this.includeWebUri = includeWebUri;
public boolean isIncludeWebSession() {
return includeWebSession;
public void setIncludeWebSession(boolean includeWebSession) {
this.includeWebSession = includeWebSession;
public boolean isIncludeSpring() {
return includeSpring;
public void setIncludeSpring(boolean includeSpring) {
this.includeSpring = includeSpring;
public boolean isAutoReset() {
return autoReset;
public void setAutoReset(boolean autoReset) {
this.autoReset = autoReset;
public class DaemonThreadFactory implements ThreadFactory {
private AtomicInteger threadNo = new AtomicInteger(1);
private final String  nameStart;
private final String  nameEnd  = "]";
public DaemonThreadFactory(String poolName){
nameStart = "[" + poolName + "-";
public Thread newThread(Runnable r) {
Thread newThread = new Thread(r, nameStart + threadNo.getAndIncrement() + nameEnd);
newThread.setDaemon(true);
if (newThread.getPriority() != Thread.NORM_PRIORITY) {
newThread.setPriority(Thread.NORM_PRIORITY);
return newThread;
public class HttpClientUtils {
private final static Log LOG = LogFactory.getLog(HttpClientUtils.class);
public static boolean post(String serverUrl, String data, long timeout) {
StringBuilder responseBuilder = null;
BufferedReader reader = null;
OutputStreamWriter wr = null;
url = new URL(serverUrl);
URLConnection conn = url.openConnection();
conn.setDoOutput(true);
conn.setConnectTimeout(1000 * 5);
wr = new OutputStreamWriter(conn.getOutputStream());
wr.write("");
wr.flush();
reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
responseBuilder = new StringBuilder();
String line = null;
while ((line = reader.readLine()) != null) {
responseBuilder.append(line + "n");
wr.close();
reader.close();
System.out.println(responseBuilder.toString());
} catch (IOException e) {
LOG.error("", e);
return false;
public static void main(String args[]) {
post("http:
whiteList = new LRUCache<String, Object>(whileListMaxSize);
protected volatile ClassLoader               driverClassLoader;
public ClassLoader getDriverClassLoader() {
return driverClassLoader;
public void setDriverClassLoader(ClassLoader driverClassLoader) {
this.driverClassLoader = driverClassLoader;
public abstract void discardConnection(Connection realConnection);
driver = JdbcUtils.createDriver(driverClassLoader, driverClass);
public void discardConnection(Connection realConnection) {
return createDataSourceInternal(properties);
protected DataSource createDataSourceInternal(Properties properties) throws Exception {
DruidDataSource dataSource = new DruidDataSource();
config(dataSource, properties);
return dataSource;
public void discard() {
if (this.disable) {
DruidConnectionHolder holder = this.holder;
if (holder == null) {
if (dupCloseLogEnable) {
LOG.error("dup close");
holder.getDataSource().discardConnection(holder.getConnection());
return createDriver(null, driverClassName);
public static Driver createDriver(ClassLoader classLoader, String driverClassName) throws SQLException {
if (classLoader != null) {
return (Driver) classLoader.loadClass(driverClassName).newInstance();
} catch (IllegalAccessException e) {
throw new SQLException(e.getMessage(), e);
} catch (InstantiationException e) {
throw new SQLException(e.getMessage(), e);
} catch (ClassNotFoundException e) {
throw new SQLException(e.getMessage(), e);
if (pooledConnection.isTraceEnable()) {
activeConnections.remove(pooledConnection);
pooledConnection.setTraceEnable(false);
if (pooledConnection.isTraceEnable()) {
Object oldInfo = activeConnections.remove(pooledConnection);
if (oldInfo == null) {
if (LOG.isWarnEnabled()) {
LOG.warn("remove abandonded failed. activeConnections.size " + activeConnections.size());
pooledConnection.setTraceEnable(false);
pooledConnection.setTraceEnable(false);
private volatile boolean                 traceEnable = false;
LOG.error("dup close");
if (holder.getDataSource().isRemoveAbandoned()) {
syncClose();
for (ConnectionEventListener listener : holder.getConnectionEventListeners()) {
listener.connectionClosed(new ConnectionEvent(this));
DruidAbstractDataSource dataSource = holder.getDataSource();
List<Filter> filters = dataSource.getProxyFilters();
if (filters.size() > 0) {
FilterChainImpl filterChain = new FilterChainImpl(dataSource);
filterChain.dataSource_recycle(this);
recycle();
this.disable = true;
public synchronized void syncClose() throws SQLException {
if (this.disable) {
DruidConnectionHolder holder = this.holder;
if (holder == null) {
if (dupCloseLogEnable) {
public class TestRemoveAbandoned2 extends TestCase {
private MockDriver      driver;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
driver = new MockDriver();
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(driver);
dataSource.setInitialSize(1);
dataSource.setMaxActive(2);
dataSource.setMaxIdle(2);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(1000 * 300); 
dataSource.setRemoveAbandoned(true);
dataSource.setRemoveAbandonedTimeoutMillis(0);
dataSource.setTestWhileIdle(true);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1");
dataSource.setFilters("stat");
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
dataSource.close();
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_removeAbandoned() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
Assert.assertEquals(0, dataSource.getActiveCount());
Thread abandonThread = new Thread("abandoned") {
public void run() {
for (;;) {
dataSource.removeAbandoned();
if (Thread.interrupted()) {
abandonThread.start();
for (int i = 0; i < 1000 * 100; ++i) {
DruidPooledConnection conn = dataSource.getConnection();
conn.close();
Assert.assertEquals(0, dataSource.getActiveCount());
abandonThread.interrupt();
System.out.println("removeAbandondedCount : " + dataSource.getRemoveAbandonedCount());
protected ReentrantLock                            lock;
protected Condition                                notEmpty;
protected Condition                                empty;
notEmpty = lock.newCondition();
empty = lock.newCondition();
if (maxWaitMillis > 0 && !this.inited) {
final ReentrantLock lock = this.lock;
lock.lock();
if ((!this.inited) && (!lock.isFair())) {
this.lock = new ReentrantLock(true);
this.notEmpty = this.lock.newCondition();
this.empty = this.lock.newCondition();
} finally {
lock.unlock();
this(false);
public class LockFairTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_fair() throws Exception {
Assert.assertEquals(false, ((ReentrantLock)dataSource.getLock()).isFair());
dataSource.setMaxWait(100);
Assert.assertEquals(true, ((ReentrantLock)dataSource.getLock()).isFair());
dataSource.setUrl("jdbc:mock:xx");
Assert.assertEquals(false, ((ReentrantLock) dataSource.getLock()).isFair());
Assert.assertEquals(true, ((ReentrantLock) dataSource.getLock()).isFair());
Connection conn = dataSource.getConnection();
conn.close();
dataSource.setMaxWait(110);
Assert.assertEquals(true, ((ReentrantLock) dataSource.getLock()).isFair());
Connection conn = dataSource.getConnection();
conn.close();
dataSource.setMaxWait(0);
Assert.assertEquals(true, ((ReentrantLock) dataSource.getLock()).isFair());
Connection conn = dataSource.getConnection();
conn.close();
public void test_fair_1() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
Assert.assertEquals(false, ((ReentrantLock) dataSource.getLock()).isFair());
dataSource.setMaxWait(100);
Assert.assertEquals(false, ((ReentrantLock) dataSource.getLock()).isFair());
case IDENTIFIER: 
sqlExpr = new SQLIdentifierExpr('-' + lexer.stringVal());
lexer.nextToken();
public PGSelectParser(String sql){
for (;;) {
if (lexer.token() == Token.LIMIT) {
if (lexer.token() == Token.ALL) {
queryBlock.setLimit(new SQLIdentifierExpr("ALL"));
lexer.nextToken();
SQLExpr limit = expr();
queryBlock.setLimit(limit);
} else if (lexer.token() == Token.OFFSET) {
SQLExpr offset = expr();
queryBlock.setOffset(offset);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
public PGSelectParser(String sql){
for (;;) {
if (lexer.token() == Token.LIMIT) {
if (lexer.token() == Token.ALL) {
queryBlock.setLimit(new SQLIdentifierExpr("ALL"));
lexer.nextToken();
SQLExpr limit = expr();
queryBlock.setLimit(limit);
} else if (lexer.token() == Token.OFFSET) {
SQLExpr offset = expr();
queryBlock.setOffset(offset);
if (lexer.token() == Token.ROW || lexer.token() == Token.ROWS) {
lexer.nextToken();
public class PGSelectTest3 extends PGTest {
public void test_0() throws Exception {
String sql = "SELECT TITLE_ID,WEB_ID,MENU_TYPE_ID,MENU_ID,TITLE" + 
",SOURCE,INFO,RECOMMEND_FLAG,CREATE_TIME,CREATE_IP,CREATE_ACCENDANT_ID" + 
",LAST_UPD_TIME,LAST_UPD_IP,LAST_UPD_ACCENDANT_ID,'http:
",'html' AS STR_SUFFIX FROM WEB_DATA_TITLE_LIST" + 
" WHERE WEB_ID=? AND MENU_ID=? AND MENU_TYPE_ID=? ORDER BY RECOMMEND_FLAG DESC ,LAST_UPD_TIME DESC  OFFSET ? LIMIT ?";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(14, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public SQLExpr primary() {
if (lexer.token() == Token.LBRACKET) {
lexer.nextToken();
SQLExpr name = this.name();
accept(Token.RBRACKET);
return primaryRest(name);
return super.primary();
protected SQLExpr dotRest(SQLExpr expr) {
boolean backet = false;
if (lexer.token() == Token.LBRACKET) {
lexer.nextToken();
backet = true;
expr = super.dotRest(expr);
if (backet) {
accept(Token.RBRACKET);
return expr;
boolean backet = false;
if (lexer.token() == Token.LBRACKET) {
lexer.nextToken();
backet = true;
if (backet) {
accept(Token.RBRACKET);
} else if (filePath.startsWith("classpath:")) {
String resourcePath = filePath.substring("classpath:".length());
inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourcePath);
public class ConfigFilterTest5 extends TestCase {
public void test_loadClassPath() throws Exception {
ConfigFilter filter = new ConfigFilter();
Assert.assertNotNull(filter.loadConfig("classpath:bvt/config/config-0.properties"));
return pos;
public final static int RevisionVersion = 9;
public boolean visit(SQLIntegerExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNumberExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLCaseExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(MySqlBooleanExpr x) {
x.getAttributes().put(EVAL_VALUE, x.getValue());
return false;
public boolean visit(SQLIntegerExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNumberExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLCaseExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLIntegerExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNumberExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLCaseExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLIntegerExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNumberExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLCaseExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public static boolean visit(SQLEvalVisitor visitor, SQLCaseExpr x) {
x.getValueExpr().accept(visitor);
if (!x.getValueExpr().getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object value = x.getValueExpr().getAttribute(EVAL_VALUE);
for (SQLCaseExpr.Item item : x.getItems()) {
item.getConditionExpr().accept(visitor);
if (!item.getConditionExpr().getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object conditionValue = item.getConditionExpr().getAttribute(EVAL_VALUE);
if (_eq(value, conditionValue)) {
item.getValueExpr().accept(visitor);
if (item.getValueExpr().getAttributes().containsKey(EVAL_VALUE)) {
x.getAttributes().put(EVAL_VALUE, item.getValueExpr().getAttribute(EVAL_VALUE));
return false;
if (x.getElseExpr() != null) {
x.getElseExpr().accept(visitor);
if (x.getElseExpr().getAttributes().containsKey(EVAL_VALUE)) {
x.getAttributes().put(EVAL_VALUE, x.getElseExpr().getAttribute(EVAL_VALUE));
return false;
value = add(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = sub(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = multi(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = div(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = gt(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = gteq(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = lt(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
value = lteq(x.getLeft().getAttribute(EVAL_VALUE), x.getRight().getAttributes().get(EVAL_VALUE));
public static boolean visit(SQLEvalVisitor visitor, SQLNumericLiteralExpr x) {
x.getAttributes().put(EVAL_VALUE, x.getNumber());
return false;
public static Object div(Object a, Object b) {
public static boolean gt(Object a, Object b) {
public static boolean gteq(Object a, Object b) {
return gt(a, b);
public static boolean lt(Object a, Object b) {
public static boolean lteq(Object a, Object b) {
return lt(a, b);
public static Object add(Object a, Object b) {
public static Object sub(Object a, Object b) {
public static Object multi(Object a, Object b) {
public interface JdbcConstants {
public static final String JTDS              = "jtds";
public static final String MOCK              = "mock";
public static final String HSQL              = "hsql";
public static final String DB2               = "db2";
public static final String DB2_DRIVER        = "COM.ibm.db2.jdbc.app.DB2Driver";
public static final String POSTGRESQL        = "postgresql";
public static final String SYBASE            = "sybase";
public static final String SQL_SERVER        = "sqlserver";
public static final String ORACLE            = "oracle";
public static final String ALI_ORACLE        = "AliOracle";
public static final String ORACLE_DRIVER     = "oracle.jdbc.driver.OracleDriver";
public static final String ALI_ORACLE_DRIVER = "com.alibaba.jdbc.AlibabaDriver";
public static final String MYSQL             = "mysql";
public static final String MYSQL_DRIVER      = "com.mysql.jdbc.Driver";
public static final String DERBY             = "derby";
public static final String HBASE             = "hbase";
public static final String HIVE              = "hive";
public static final String H2                = "h2";
public static final String H2_DRIVER         = "org.h2.Driver";
public final class JdbcUtils implements JdbcConstants {
public class EvalCaseThen extends TestCase {
public void test_eval_then() throws Exception {
Assert.assertEquals(111, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "case ? when 0 then 111 else 222 end", 0));
Assert.assertEquals(222, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "case ? when 0 then 111 else 222 end", 1));
Assert.assertEquals("A", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?", "A"));
Assert.assertEquals(123, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?", 123));
Assert.assertEquals("AB", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", "A", "B"));
Assert.assertEquals(234, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", 123, 111));
public void testEval_2() throws Exception {
Assert.assertEquals(110, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?", 10, 11));
public void testEval_3() throws Exception {
Assert.assertEquals(new BigDecimal("110"), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?",
new BigDecimal("10"),
new BigDecimal("11")));
public void testEval_4() throws Exception {
Assert.assertEquals(new BigDecimal("110"),
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * 11", new BigDecimal("10")));
public void testEval_5() throws Exception {
Assert.assertEquals(new BigDecimal("110.0"),
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * 11.0", new BigDecimal("10")));
public void testEval_6() throws Exception {
Assert.assertEquals(new BigDecimal("110.0"),
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * 11", new BigDecimal("10.0")));
public void testEval_7() throws Exception {
Assert.assertEquals(new BigDecimal("110.0"),
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * 11.0", "10"));
public boolean visit(SQLBetweenExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLInListExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNullExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLMethodInvokeExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLInListExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNullExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLMethodInvokeExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLInListExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNullExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLMethodInvokeExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLInListExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLNullExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLMethodInvokeExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public static boolean visit(SQLEvalVisitor visitor, SQLMethodInvokeExpr x) {
if ("concat".equals(x.getMethodName())) {
StringBuilder buf = new StringBuilder();
for (SQLExpr item : x.getParameters()) {
item.accept(visitor);
Object itemValue = item.getAttributes().get(EVAL_VALUE);
if (itemValue == null) {
buf.append(itemValue.toString());
x.getAttributes().put(EVAL_VALUE, buf.toString());
} else if ("now".equals(x.getMethodName())) {
x.getAttributes().put(EVAL_VALUE, new Date());
return false;
public static boolean visit(SQLEvalVisitor visitor, SQLBetweenExpr x) {
x.getTestExpr().accept(visitor);
if (!x.getTestExpr().getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object value = x.getTestExpr().getAttribute(EVAL_VALUE);
x.getBeginExpr().accept(visitor);
if (!x.getBeginExpr().getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object begin = x.getBeginExpr().getAttribute(EVAL_VALUE);
if (lt(value, begin)) {
x.getAttributes().put(EVAL_VALUE, x.isNot() ? true : false);
return false;
x.getEndExpr().accept(visitor);
if (!x.getEndExpr().getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object end = x.getEndExpr().getAttribute(EVAL_VALUE);
if (gt(value, end)) {
x.getAttributes().put(EVAL_VALUE, x.isNot() ? true : false);
return false;
x.getAttributes().put(EVAL_VALUE, x.isNot() ? false : true);
return false;
public static boolean visit(SQLEvalVisitor visitor, SQLNullExpr x) {
x.getAttributes().put(EVAL_VALUE, null);
return false;
if (eq(value, conditionValue)) {
return false;
public static boolean visit(SQLEvalVisitor visitor, SQLInListExpr x) {
SQLExpr valueExpr = x.getExpr();
valueExpr.accept(visitor);
if (!valueExpr.getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object value = valueExpr.getAttribute(EVAL_VALUE);
for (SQLExpr item : x.getTargetList()) {
item.accept(visitor);
if (!item.getAttributes().containsKey(EVAL_VALUE)) {
return false;
Object itemValue = item.getAttribute(EVAL_VALUE);
if (eq(value, itemValue)) {
x.getAttributes().put(EVAL_VALUE, x.isNot() ? false : true);
return false;
x.getAttributes().put(EVAL_VALUE, x.isNot() ? true : false);
SQLExpr left = x.getLeft();
SQLExpr right = x.getRight();
left.accept(visitor);
if (!left.getAttributes().containsKey(EVAL_VALUE)) {
right.accept(visitor);
if (!right.getAttributes().containsKey(EVAL_VALUE)) {
value = add(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = sub(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = multi(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = div(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = gt(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = gteq(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = lt(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
value = lteq(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
value = eq(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
x.putAttribute(EVAL_VALUE, value);
case IsNot
value = !eq(left.getAttribute(EVAL_VALUE), right.getAttributes().get(EVAL_VALUE));
if (eq(a, b)) {
if (eq(a, b)) {
public static boolean eq(Object a, Object b) {
public class EvalBetweenTest extends TestCase {
public void test_between() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? between 1 and 3", 0));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? between 1 and 3", 2));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? between 1 and 3", 4));
public void test_not_between() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? not between 1 and 3", 0));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? not between 1 and 3", 2));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? not between 1 and 3", 4));
public class EvalConcatTest extends TestCase {
public void test_concat() throws Exception {
Assert.assertEquals("abcd", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "concat(?, ?)", "ab", "cd"));
Assert.assertEquals("abcdef", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "concat(?, ?, ?)", "ab", "cd", "ef"));
public class EvalInTest extends TestCase {
public void test_in() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? IN (1, 2, 3)", 0));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? IN (1, 2, 3)", 1));
public void test_not_in() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? NOT IN (1, 2, 3)", 0));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? NOT IN (1, 2, 3)", 1));
public class EvalIsNullTest extends TestCase {
public void test_null() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? is null", 0));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? is null", (Object) null));
public class EvalMethodNowTest extends TestCase {
public void test_now() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "now()") instanceof Date);
public boolean visit(SQLQueryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLQueryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLQueryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLQueryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
if ("concat".equalsIgnoreCase(x.getMethodName())) {
} else if ("now".equalsIgnoreCase(x.getMethodName())) {
} else if ("ascii".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() == 0) {
return false;
SQLExpr param = x.getParameters().get(0);
param.accept(visitor);
Object paramValue = param.getAttributes().get(EVAL_VALUE);
if (paramValue == null) {
return false;
String strValue = paramValue.toString();
if (strValue.length() == 0) {
return false;
int ascii = strValue.charAt(0);
x.getAttributes().put(EVAL_VALUE, ascii);
} else if ("instr".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 2) {
return false;
SQLExpr param0 = x.getParameters().get(0);
SQLExpr param1 = x.getParameters().get(1);
param0.accept(visitor);
param1.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
Object param1Value = param1.getAttributes().get(EVAL_VALUE);
if (param0Value == null || param1Value == null) {
return false;
String strValue0 = param0Value.toString();
String strValue1 = param1Value.toString();
int result = strValue0.indexOf(strValue1) + 1;
x.putAttribute(EVAL_VALUE, result);
} else if ("left".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 2) {
return false;
SQLExpr param0 = x.getParameters().get(0);
SQLExpr param1 = x.getParameters().get(1);
param0.accept(visitor);
param1.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
Object param1Value = param1.getAttributes().get(EVAL_VALUE);
if (param0Value == null || param1Value == null) {
return false;
String strValue = param0Value.toString();
int intValue = _int(param1Value);
String result = strValue.substring(0, intValue);
x.putAttribute(EVAL_VALUE, result);
} else if ("right".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 2) {
return false;
SQLExpr param0 = x.getParameters().get(0);
SQLExpr param1 = x.getParameters().get(1);
param0.accept(visitor);
param1.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
Object param1Value = param1.getAttributes().get(EVAL_VALUE);
if (param0Value == null || param1Value == null) {
return false;
String strValue = param0Value.toString();
int intValue = _int(param1Value);
String result = strValue.substring(strValue.length() - intValue, strValue.length());
x.putAttribute(EVAL_VALUE, result);
} else if ("reverse".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 1) {
return false;
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return false;
String strValue = param0Value.toString();
StringBuilder buf = new StringBuilder();
for (int i = strValue.length() - 1; i >= 0; --i) {
buf.append(strValue.charAt(i));
String result = buf.toString();
x.putAttribute(EVAL_VALUE, result);
} else if ("trim".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 1) {
return false;
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return false;
String strValue = param0Value.toString();
String result = strValue.trim();
x.putAttribute(EVAL_VALUE, result);
} else if ("length".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 1) {
return false;
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return false;
String strValue = param0Value.toString();
int result = strValue.length();
x.putAttribute(EVAL_VALUE, result);
} else if ("ucase".equalsIgnoreCase(x.getMethodName()) || "upper".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 1) {
return false;
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return false;
String strValue = param0Value.toString();
String result = strValue.toUpperCase();
x.putAttribute(EVAL_VALUE, result);
} else if ("lcase".equalsIgnoreCase(x.getMethodName()) || "lower".equalsIgnoreCase(x.getMethodName())) {
if (x.getParameters().size() != 1) {
return false;
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return false;
String strValue = param0Value.toString();
String result = strValue.toLowerCase();
x.putAttribute(EVAL_VALUE, result);
public static boolean visit(SQLEvalVisitor visitor, SQLQueryExpr x) {
if (x.getSubQuery().getQuery() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) x.getSubQuery().getQuery();
boolean nullFrom = false;
if (queryBlock.getFrom() == null) {
nullFrom = true;
} else if (queryBlock.getFrom() instanceof SQLExprTableSource) {
SQLExpr expr = ((SQLExprTableSource) queryBlock.getFrom()).getExpr();
if (expr instanceof SQLIdentifierExpr) {
if ("dual".equalsIgnoreCase(((SQLIdentifierExpr) expr).getName())) {
nullFrom = true;
if (nullFrom) {
Object[] row = new Object[queryBlock.getSelectList().size()];
for (int i = 0; i < queryBlock.getSelectList().size(); ++i) {
SQLSelectItem item = queryBlock.getSelectList().get(i);
item.getExpr().accept(visitor);
Object cell = item.getExpr().getAttribute(EVAL_VALUE);
row[i] = cell;
Object result;
if (row.length == 1) {
result = row[0];
result = row;
queryBlock.putAttribute(EVAL_VALUE, result);
x.getSubQuery().putAttribute(EVAL_VALUE, result);
x.putAttribute(EVAL_VALUE, result);
return false;
return false;
case RegExp
case RLike: {
String pattern = _string(right.getAttributes().get(EVAL_VALUE));
String input = _string(left.getAttributes().get(EVAL_VALUE));
boolean matchResult = Pattern.matches(pattern, input);
x.putAttribute(EVAL_VALUE, matchResult);
case NotRegExp
case NotRLike: {
String pattern = _string(right.getAttributes().get(EVAL_VALUE));
String input = _string(left.getAttributes().get(EVAL_VALUE));
boolean matchResult = !Pattern.matches(pattern, input);
x.putAttribute(EVAL_VALUE, matchResult);
public class EvalMethodAsciiTest extends TestCase {
public void test_ascii() throws Exception {
Assert.assertEquals(50, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ascii('2')"));
public class EvalMethodInstrTest extends TestCase {
public void test_length() throws Exception {
Assert.assertEquals(4, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "instr('foobarbar', 'bar')"));
Assert.assertEquals(0, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "instr('xbar', 'foobar')"));
public class EvalMethodLeftTest extends TestCase {
public void test_ascii() throws Exception {
Assert.assertEquals("fooba", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "LEFT('foobarbar', 5)"));
public class EvalMethodLengthTest extends TestCase {
public void test_length() throws Exception {
Assert.assertEquals(4, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "length('text')"));
public class EvalMethodReverseTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals("cba", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "REVERSE('abc')"));
public class EvalMethodRightTest extends TestCase {
public void test_ascii() throws Exception {
Assert.assertEquals("rbar", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "right('foobarbar', 4)"));
public class EvalMethodTrimTest extends TestCase {
public void test_trim() throws Exception {
Assert.assertEquals("bar", SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "TRIM('  bar   ')"));
public class EvalRlikeTest extends TestCase {
public void test_rlike() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'a' REGEXP '^[a-d]'"));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'a' RLIKE '^[a-d]'"));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'1' RLIKE '^[a-d]'"));
public void test_not_rlike() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'a' NOT REGEXP '^[a-d]'"));
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'a' NOT RLIKE '^[a-d]'"));
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "'1' NOT RLIKE '^[a-d]'"));
public class EvalSelectTest extends TestCase {
public void test_select() throws Exception {
Assert.assertEquals(1, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "SELECT 1"));
List<Object> row = new ArrayList<Object>(queryBlock.getSelectList().size());
row.add(cell);
List<List<Object>> rows = new ArrayList<List<Object>>(1);
rows.add(row);
Object result = rows;
List<List<Object>> rows = new ArrayList<List<Object>>();
List<Object> row = new ArrayList<Object>();
row.add(1);
rows.add(row);
Assert.assertEquals(rows, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "SELECT 1"));
public class EvalMethodAbsTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(12, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(-12)"));
Assert.assertEquals(12, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(12)"));
public class EvalMethodAcosTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(0.0D, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos(1)"));
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos(1.001)"));
Assert.assertEquals(Math.acos(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos(0)"));
public class EvalMethodAsinTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.asin(0.2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "asin(0.2)"));
public class EvalMethodAtan2Test extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.atan2(-2, 2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan2(-2, 2)"));
public class EvalMethodAtanTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.atan(2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan(2)"));
Assert.assertEquals(Math.atan(-2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan(-2)"));
public class EvalMethodCeilTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ceil(1.23)"));
Assert.assertEquals(-1, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ceil(-1.23)"));
Assert.assertEquals(-1, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ceiling(-1.24)"));
public class EvalMethodModTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "MOD(29,9)"));
public class EvalMethodPITest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.PI, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "pi()"));
public class MySqlInsertTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO t1 (name) VALUES (" + 
"'eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" + 
"eeeeeeeeeeeeeeeeee\\1')";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLInsertStatement insertStmt = (SQLInsertStatement) stmt;
SQLCharExpr charExpr = (SQLCharExpr) insertStmt.getValues().getValues().get(0);
String text = charExpr.getText();
Assert.assertEquals('1', text.charAt(charExpr.getText().length() - 1));
Assert.assertEquals('\', text.charAt(charExpr.getText().length() - 2));
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
public class MySqlSelectTest_crossjoin extends MysqlTest {
public void test_0() throws Exception {
String sql = "select resource0_.resource_id as resource1_13_, resource0_.asMenu as asMenu13_, resource0_.resource_description as resource3_13_, resource0_.menu_name as menu4_13_, resource0_.resource_name as resource5_13_, resource0_.rg_id as rg7_13_, resource0_.rt_id as rt8_13_, resource0_.resource_serial as resource6_13_ from hnisitc.hnisitc_resource resource0_ cross join hnisitc.hnisitc_resource_type resourcety1_ where resource0_.rt_id=resourcety1_.rt_id and resourcety1_.rt_name='METHOD'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(10, visitor.getColumns().size());
Assert.assertEquals(3, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
public class OracleSelectTest39 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select * from ge_rms_company start with comCode ='11' connect by nocycle prior comCode=UPPERCOMCODE"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ge_rms_company")));
Assert.assertEquals(3, visitor.getColumns().size());
if(isPrettyFormat()) {
if (x.getParent() != null) {
print(";");
println(";");
if (x.isPrior()) {
print("PRIOR ");
if (filePath.startsWith("http:
inStream = url.openStream();
xml = url.getPath().endsWith(".xml");
} catch (UnknownHostException e) {
if(url.getHost().length() == 1 && filePath.startsWith("file:
filePath = filePath.substring("file:
inStream = getFileAsStream(filePath);
xml = filePath.endsWith(".xml");
throw new UnknownHostException(e.getMessage());
xml = resourcePath.endsWith(".xml");
inStream = getFileAsStream(filePath);
private InputStream getFileAsStream(String filePath) throws FileNotFoundException {
InputStream inStream = null;
File file = new File(filePath);
if (file.exists()) {
inStream = new FileInputStream(file);
inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(filePath);
return inStream;
public class OutputVisitorTest {
public void testConnectByParserAndPrettyFormatOutput() {
String sql = "select * from ge_rms_company start with comcode = '00' connect by nocycle prior comcode = uppercomcode";
SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, JdbcUtils.ORACLE);
List<SQLStatement> stmtList = parser.parseStatementList();
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor visitor = new OracleOutputVisitor(out);
for(SQLStatement statement : stmtList) {
statement.accept(visitor);
System.out.println(out);
System.out.println("=========================================n");
out.setLength(0);
visitor = new OracleOutputVisitor(out);
visitor.setPrettyFormat(false);
for(SQLStatement statement : stmtList) {
statement.accept(visitor);
System.out.println(out);
public class OracleOutputVisitorTest_PrettyFormat {
String expectResult = "SELECT *nFROM ge_rms_companynSTART WITH comcode = '00'nCONNECT BY NOCYCLE PRIOR comcode = uppercomcode;n";
Assert.assertEquals(expectResult, out.toString());
expectResult = "SELECT * FROM ge_rms_company START WITH comcode = '00' CONNECT BY NOCYCLE PRIOR comcode = uppercomcode";
Assert.assertEquals(expectResult, out.toString());
public class PGSelectTest4 extends PGTest {
public void test_0() throws Exception {
String sql = "select  offerId,          offerIds    "
"from  cnres.function_select_get_p4p_offer_by_sps('\'1160160508\',\'1085432755\',\'971765217\'')   "
"     as a(    offerId character varying(256),    offerIds character varying(4000)   )";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getTables().size());
if (principalCookieName != null && httpRequest.getCookies() != null) {
"ntDROP INDEX `ix`", output);
Assert.assertEquals("ALTER TABLE `test`.`tb1`" + 
throw new IllegalStateException("dbType not support : " + dbType + ", url " + dataSource.getUrl());
if (this.dbType == null || this.dbType.length() == 0) {
this.dbType = JdbcUtils.getDbType(jdbcUrl, null);
if (dbType == null) {
dbType = JdbcUtils.getDbType(dataSource.getUrl(), null);
if (lexer.token() == Token.OVER) {
@Override
public Savepoint connection_setSavepoint(FilterChain chain, ConnectionProxy connection) throws SQLException {
Savepoint savepoint = chain.connection_setSavepoint(connection);
if (isConnectionLogEnabled()) {
connectionLog("{conn " + connection.getId() + "} setSavepoint-" + savepoint.getSavepointId());
return savepoint;
@Override
public Savepoint connection_setSavepoint(FilterChain chain, ConnectionProxy connection, String name)
throws SQLException {
Savepoint savepoint = chain.connection_setSavepoint(connection, name);
if (isConnectionLogEnabled()) {
connectionLog("{conn " + connection.getId() + "} setSavepoint-" + name);
return savepoint;
@Override
public void connection_rollback(FilterChain chain, ConnectionProxy connection, Savepoint savePoint) throws SQLException {
super.connection_rollback(chain, connection, savePoint);
if (connectionRollbackAfterLogEnable && isConnectionLogEnabled()) {
connectionLog("{conn " + connection.getId() + "} rollback -> " + savePoint.getSavepointId());
private boolean         closed               = false;
private MockDriver      driver;
private int             savepointIdSeed      = 0;
private List<Savepoint> savepoints           = new ArrayList<Savepoint>();
private long            id;
private final long      createdTimeMillis    = System.currentTimeMillis();
private long            lastActiveTimeMillis = System.currentTimeMillis();
public List<Savepoint> getSavepoints() {
return savepoints;
this.savepoints.clear();
MockSavepoint savepoint = new MockSavepoint();
savepoint.setSavepointId(this.savepointIdSeed++);
this.savepoints.add(savepoint);
return savepoint;
MockSavepoint savepoint = new MockSavepoint();
savepoint.setSavepointId(this.savepointIdSeed++);
savepoint.setSavepointName(name);
this.savepoints.add(savepoint);
return savepoint;
int index = this.savepoints.indexOf(savepoint);
if (index == -1) {
throw new SQLException("savepoint not contained");
for (int i = savepoints.size() - 1; i >= index; --i) {
savepoints.remove(i);
if (savepoint == null) {
throw new SQLException("argument is null");
int index = this.savepoints.indexOf(savepoint);
if (index == -1) {
throw new SQLException("savepoint not contained");
savepoints.remove(savepoint);
public class MockSavepoint implements Savepoint {
private int    savepointId;
private String savepointName;
public int getSavepointId() {
return savepointId;
public void setSavepointId(int savepointId) {
this.savepointId = savepointId;
public String getSavepointName() {
return savepointName;
public void setSavepointName(String savepointName) {
this.savepointName = savepointName;
handleEndTransaction(dataSource, null);
handleEndTransaction(dataSource, null);
handleEndTransaction(dataSource, savepoint);
private void handleEndTransaction(DruidAbstractDataSource dataSource, Savepoint savepoint) {
if (transactionInfo != null && savepoint == null) {
private final List<String> sqlList = new ArrayList<String>(4);
Savepoint savepoint = conn.setSavepoint("xx");
conn.rollback(savepoint);
public class SavepointTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setInitialSize(1);
protected void tearDown() throws Exception {
dataSource.close();
public void test_multi_savepoint() throws Exception {
Connection conn = dataSource.getConnection();
MockConnection physicalConn = conn.unwrap(MockConnection.class);
Assert.assertEquals(true, conn.getAutoCommit());
Assert.assertEquals(true, physicalConn.getAutoCommit());
conn.setAutoCommit(false);
Assert.assertEquals(false, conn.getAutoCommit());
Assert.assertEquals(false, physicalConn.getAutoCommit());
Savepoint[] savepoints = new Savepoint[100];
for (int i = 0; i < savepoints.length; ++i) {
Statement stmt = conn.createStatement();
stmt.execute("insert t (" + i + ")");
stmt.close();
savepoints[i] = conn.setSavepoint();
Assert.assertEquals(i + 1, physicalConn.getSavepoints().size());
for (int j = 0; j <= i; ++j) {
Assert.assertTrue(physicalConn.getSavepoints().contains(savepoints[j]));
conn.rollback(savepoints[99]);
Assert.assertEquals(99, physicalConn.getSavepoints().size());
conn.releaseSavepoint(savepoints[97]);
Assert.assertEquals(98, physicalConn.getSavepoints().size());
conn.rollback(savepoints[90]);
Assert.assertEquals(90, physicalConn.getSavepoints().size());
conn.rollback();
Assert.assertEquals(0, physicalConn.getSavepoints().size());
conn.close();
Exception error = null;
conn.rollback(null);
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
Exception error = null;
conn.releaseSavepoint(null);
} catch (SQLException e) {
error = e;
Assert.assertNotNull(error);
rs.getBlob("F12");
public class NutzTransactionTest extends TestCase {
private DataSource dataSource;
protected void setUp() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:jtds:sqlserver:
dataSource.setUsername("sa");
dataSource.setPassword("hello");
dataSource.setFilters("log4j");
this.dataSource = dataSource;
public void test_trans() throws Exception {
Dao dao = new NutDao(dataSource);
dao.clear("test");
doTran2(dao);
void doTran1(final Dao dao) {
Trans.exec(new Atom() {
public void run() {
dao.insert("[test]", Chain.make("name", "1"));
throw new RuntimeException();
} catch (Exception e) {
Assert.assertEquals(0, dao.count("[test]"));
void doTran2(final Dao dao) {
Trans.exec(new Atom() {
public void run() {
dao.insert("[test]", Chain.make("name", "1"));
dao.insert("[test]", Chain.make("name", "111111111111111111111111111111"));
} catch (Exception e) {
Assert.assertEquals(0, dao.count("[test]"));
public SQLStatement parseInsert() {
SQLServerInsertStatement insertStatement = new SQLServerInsertStatement();
if (lexer.token() == Token.INSERT) {
accept(Token.INSERT);
parseInsert0(insertStatement);
return insertStatement;
protected void parseInsert0(SQLInsertInto insert, boolean acceptSubQuery) {
SQLServerInsertStatement insertStatement = (SQLServerInsertStatement) insert;
if (lexer.token() == Token.INTO) {
lexer.nextToken();
SQLName tableName = this.exprParser.name();
insertStatement.setTableName(tableName);
if (lexer.token() == Token.LITERAL_ALIAS) {
insertStatement.setAlias(as());
parseInsert0_hinits(insertStatement);
if (lexer.token() == Token.IDENTIFIER) {
insertStatement.setAlias(lexer.stringVal());
lexer.nextToken();
if (lexer.token() == (Token.LPAREN)) {
lexer.nextToken();
this.exprParser.exprList(insertStatement.getColumns());
accept(Token.RPAREN);
if (lexer.token() == Token.VALUES) {
lexer.nextToken();
for (;;) {
accept(Token.LPAREN);
SQLInsertStatement.ValuesClause values = new SQLInsertStatement.ValuesClause();
this.exprParser.exprList(values.getValues());
insertStatement.getValuesList().add(values);
accept(Token.RPAREN);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
} else if (acceptSubQuery && (lexer.token() == Token.SELECT || lexer.token() == Token.LPAREN)) {
SQLQueryExpr queryExpr = (SQLQueryExpr) this.exprParser.expr();
insertStatement.setQuery(queryExpr.getSubQuery());
public void test_multi_values() throws Exception {
String sql = "INSERT INTO test (name)" + 
"VALUES (N'a'), (N'b'), (N'c')";
String expect = "INSERT INTO test (name)" + 
"nVALUES (N'a'), (N'b'), (N'c')";
public class SQLServerInsertTest3 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "INSERT INTO Production.UnitMeasure " + 
"VALUES (N'F2', N'Square Feet', GETDATE());;";
String expect = "INSERT INTO Production.UnitMeasure" + 
"nVALUES" + 
"n(N'F2', N'Square Feet', GETDATE())";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
println();
print("(");
print("VALUES");
println();
print(",");
println();
String expect = "INSERT INTO test" + 
"nt(name)" + 
"nVALUES" + 
"n(N'a')," + 
"n(N'b')," + 
"n(N'c')";
DruidPooledConnection conn = this.getPoolableConnection();
if (conn == null) {
DruidConnectionHolder holder = conn.getConnectionHolder();
if (holder == null) {
if (holder.getDataSource() == null) {
holder.getDataSource().incrementExecuteCount();
if (conn.getConnectionHolder() != null) {
conn.getConnectionHolder().removeTrace(this);
public class ShardingDataSource {
public class ShardingRuntimeException extends DruidRuntimeException {
private static final long serialVersionUID = 1L;
public ShardingRuntimeException(){
public ShardingRuntimeException(String message, Throwable cause){
super(message, cause);
public ShardingRuntimeException(String message){
super(message);
public ShardingRuntimeException(Throwable cause){
super(cause);
public class LogicTable {
private String                      logicTable;
private Map<String, TablePartition> partitions = new HashMap<String, TablePartition>();
public String getLogicTable() {
return logicTable;
public void setLogicTable(String logicTable) {
this.logicTable = logicTable;
public Map<String, TablePartition> getPartitions() {
return partitions;
public void setPartitions(Map<String, TablePartition> partitions) {
this.partitions = partitions;
public void addPartition(String partitionName, String physicalTableName) {
this.partitions.put(partitionName, new TablePartition(partitionName, physicalTableName));
public void addPartition(String partitionName, String database, String physicalTableName) {
this.partitions.put(partitionName, new TablePartition(partitionName, database, physicalTableName));
public interface MappingRule {
String getTable();
String getColumn();
List<MappingRuleEntry> getEntries();
String getPartition(Object value);
public class MappingRuleAdapter implements MappingRule {
private String                 defaultPartition;
private String                 table;
private String                 column;
private List<MappingRuleEntry> entries = new ArrayList<MappingRuleEntry>();
public List<MappingRuleEntry> getEntries() {
return entries;
public void setEntries(List<MappingRuleEntry> entries) {
this.entries = entries;
public String getPartition(Object value) {
for (MappingRuleEntry entry : this.entries) {
if (entry.match(value)) {
return entry.getPartition();
return this.getDefaultPartition();
public String getTable() {
return table;
public void setTable(String table) {
this.table = table;
public String getColumn() {
return column;
public void setColumn(String column) {
this.column = column;
public String getDefaultPartition() {
return defaultPartition;
public void setDefaultPartition(String defaultPartition) {
this.defaultPartition = defaultPartition;
public interface MappingRuleEntry {
boolean match(Object value);
String getPartition();
public class MappingRuleListEntry implements MappingRuleEntry {
private List<Object> values = new ArrayList<Object>();
private String       partition;
public MappingRuleListEntry() {
public MappingRuleListEntry(String partition, Object...values) {
this.partition = partition;
for (Object value : values) {
this.values.add(value);
public List<Object> getValues() {
return values;
public void setValues(List<Object> values) {
this.values = values;
public String getPartition() {
return partition;
public void setPartition(String partition) {
this.partition = partition;
public boolean match(Object value) {
for (Object item : this.values) {
if (SQLEvalVisitorUtils.eq(item, value)) {
return true;
return false;
public class MappingRuleLtEntry implements MappingRuleEntry {
private Object value;
private String partition;
public Object getValue() {
return value;
public void setValue(Object value) {
this.value = value;
public String getPartition() {
return partition;
public void setPartition(String partition) {
this.partition = partition;
public boolean match(Object value) {
return SQLEvalVisitorUtils.eq(this.value, value);
public class RouteConfig {
private Map<String, LogicTable> logicTables  = new HashMap<String, LogicTable>();
private Map<String, MappingRule>          mappingRules = new HashMap<String, MappingRule>();
public Map<String, LogicTable> getLogicTables() {
return logicTables;
public void setLogicTables(Map<String, LogicTable> logicTables) {
this.logicTables = logicTables;
public Map<String, MappingRule> getMappingRules() {
return mappingRules;
public void setMappingRules(Map<String, MappingRule> mappingRules) {
this.mappingRules = mappingRules;
public MappingRule getMappingRule(String table) {
if (table == null) {
return null;
String lowerTable = table.toLowerCase();
return mappingRules.get(lowerTable);
public TablePartition getPartition(String table, String partitionName) {
if (table == null) {
throw new IllegalArgumentException("table is null");
if (partitionName == null) {
throw new IllegalArgumentException("partitionName is null");
String lowerTable = table.toLowerCase();
LogicTable config = logicTables.get(lowerTable);
if (config == null) {
throw new IllegalArgumentException("table's partition config not exists, tableName : " + table);
String lowerPartitionName = partitionName.toLowerCase();
TablePartition tablePartition = config.getPartitions().get(lowerPartitionName);
if (tablePartition == null) {
throw new IllegalArgumentException("table's partition config not exists, tableName : " + table
+ ", partition : " + lowerPartitionName);
return tablePartition;
public class TablePartition {
private String name;
private String database;
private String table;
public TablePartition(){
public TablePartition(String name, String table){
this.name = name;
this.table = table;
public TablePartition(String name, String database, String table){
this.name = name;
this.database = database;
this.table = table;
public String getDatabase() {
return database;
public void setDatabase(String database) {
this.database = database;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getTable() {
return table;
public void setTable(String table) {
this.table = table;
public class MySqlShardingVisitor extends MySqlASTVisitorAdapter implements ShardingVisitor {
private final RouteConfig  routeConfig;
private final List<Object> parameters;
private List<SQLStatement> result = new ArrayList<SQLStatement>(2);
public MySqlShardingVisitor(RouteConfig routeConfig, List<Object> parameters){
this.routeConfig = routeConfig;
this.parameters = parameters;
public MySqlShardingVisitor(RouteConfig routeConfig, Object... parameters){
this(routeConfig, Arrays.asList(parameters));
public RouteConfig getRouteConfig() {
return routeConfig;
public List<Object> getParameters() {
return parameters;
public boolean visit(MySqlInsertStatement x) {
String table = x.getTableName().getSimleName();
MappingRule mappingRule = routeConfig.getMappingRule(table);
if (mappingRule == null) {
result.add(x);
return false;
if (x.getValues() == null) {
throw new ShardingRuntimeException("sharding rule violation, insert's values clause is null");
String column = mappingRule.getColumn();
int columnIndex = -1;
for (int i = 0; i < x.getColumns().size(); ++i) {
SQLExpr columnExpr = x.getColumns().get(i);
if (columnExpr instanceof SQLIdentifierExpr) {
String columnName = ((SQLIdentifierExpr) columnExpr).getName();
if (column.equalsIgnoreCase(columnName)) {
columnIndex = i;
if (columnIndex == -1) {
throw new ShardingRuntimeException("sharding rule violation, columns not set : " + column);
SQLExpr valueExpr = x.getValues().getValues().get(columnIndex);
Object value = SQLEvalVisitorUtils.eval(null, valueExpr, parameters);
String partition = mappingRule.getPartition(value);
if (partition == null) {
throw new ShardingRuntimeException("sharding rule violation, partition not match, value : " + value);
TablePartition tablePartition = routeConfig.getPartition(table, partition);
x.setTableName(new SQLIdentifierExpr(tablePartition.getTable()));
if (tablePartition.getDatabase() != null) {
x.putAttribute(ATTR_DB, tablePartition.getDatabase());
result.add(x);
return false;
public interface ShardingVisitor {
public static final String ATTR_DB = "sharding.db";
if (a instanceof String || b instanceof String) {
return _string(a).equals(_string(b));
public class InsertTest extends TestCase {
private RouteConfig routeConfig = new RouteConfig();
protected void setUp() throws Exception {
MappingRuleAdapter rule = new MappingRuleAdapter();
rule.setColumn("gender");
rule.getEntries().add(new MappingRuleListEntry("person_m", "M"));
rule.getEntries().add(new MappingRuleListEntry("person_f", "F"));
routeConfig.getMappingRules().put("person", rule);
LogicTable logicTable = new LogicTable();
logicTable.setLogicTable("person");
logicTable.addPartition("person_m", "db0", "person_001");
logicTable.addPartition("person_f", "db1", "person_002");
routeConfig.getLogicTables().put("person", logicTable);
public void test_insert_m() throws Exception {
String sql = "insert into person (name, gender) values ('a', 'M')";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig);
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT INTO person_001 (name, gender)" + 
"nVALUES ('a', 'M')", result);
Assert.assertEquals("db0", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public void test_insert_f() throws Exception {
String sql = "insert into person (name, gender) values ('a', 'F')";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig);
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT INTO person_002 (name, gender)" + 
"nVALUES ('a', 'F')", result);
Assert.assertEquals("db1", stmt.getAttribute(ShardingVisitor.ATTR_DB));
private SQLStatement       input  = null;
public boolean visit(SQLSelectStatement x) {
input = x;
return true;
input = x;
return false;
public boolean visit(MySqlSelectQueryBlock x) {
if (x.getFrom() != null) {
x.getFrom().setParent(x);
x.getFrom().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
return false;
public boolean visit(SQLJoinTableSource x) {
x.getLeft().setParent(x);
x.getRight().setParent(x);
if (x.getCondition() != null) {
x.getCondition().setParent(x);
return true;
public boolean visit(SQLExprTableSource x) {
SQLSelectQueryBlock select = getSQLSelectQueryBlock(x);
Map<String, SQLTableSource> aliasMap = null;
if (select != null) {
aliasMap = getAliasMap(select);
if (aliasMap != null) {
if (x.getAlias() != null) {
aliasMap.put(x.getAlias(), x);
if (x.getExpr() instanceof SQLIdentifierExpr) {
String tableName = ((SQLIdentifierExpr) x.getExpr()).getName();
aliasMap.put(tableName, x);
public boolean visit(SQLBinaryOpExpr x) {
x.getLeft().setParent(x);
x.getRight().setParent(x);
x.getLeft().accept(this);
x.getRight().accept(this);
String column = null;
if ((column = getColumn(x.getLeft())) != null && isValue(x.getRight())) {
boolean isMappingColumn = false;
SQLTableSource tableSource = getBinaryOpExprLeftOrRightTableSource(x.getLeft());
MappingRule mappingRule = getMappingRule(tableSource);
if (mappingRule != null) {
if (mappingRule.getColumn().equalsIgnoreCase(column)) {
isMappingColumn = true;
if (isMappingColumn) {
Object value = SQLEvalVisitorUtils.eval(JdbcConstants.MYSQL, x.getRight(), parameters);
String partitionName = null;
switch (x.getOperator()) {
case Equality
partitionName = mappingRule.getPartition(value);
throw new ShardingRuntimeException("not support operator " + x.getOperator());
if (partitionName == null) {
throw new ShardingRuntimeException("sharding rule violation, partition not match, value : " + value);
TablePartition tablePartition = routeConfig.getPartition(mappingRule.getTable(), partitionName);
if (tableSource.getAttribute(ATTR_PARTITION) == null) {
((SQLExprTableSource) tableSource).setExpr(new SQLIdentifierExpr(tablePartition.getTable()));
tableSource.putAttribute(ATTR_PARTITION, tablePartition);
if (tablePartition.getDatabase() != null && input != null) {
input.putAttribute(ATTR_DB, tablePartition.getDatabase());
} else if (tableSource.getAttribute(ATTR_PARTITION) != tablePartition) {
throw new ShardingRuntimeException("sharding rule violation, multi-partition matched, value : "
return false;
MappingRule getMappingRule(SQLTableSource tableSource) {
if (tableSource instanceof SQLExprTableSource) {
SQLExpr expr = ((SQLExprTableSource) tableSource).getExpr();
if (expr instanceof SQLIdentifierExpr) {
String table = ((SQLIdentifierExpr) expr).getName();
return routeConfig.getMappingRule(table);
return null;
static boolean isValue(SQLExpr x) {
return x instanceof SQLLiteralExpr || x instanceof SQLVariantRefExpr;
static String getColumn(SQLExpr x) {
if (x instanceof SQLPropertyExpr) {
return ((SQLPropertyExpr) x).getName();
if (x instanceof SQLIdentifierExpr) {
return ((SQLIdentifierExpr) x).getName();
return null;
static SQLTableSource getBinaryOpExprLeftOrRightTableSource(SQLExpr x) {
SQLTableSource tableSource = (SQLTableSource) x.getAttribute(ATTR_TABLE_SOURCE);
if (tableSource != null) {
return tableSource;
SQLSelectQueryBlock select = getSQLSelectQueryBlock(x.getParent());
if (select != null && select.getFrom() instanceof SQLExprTableSource) {
SQLExpr expr = ((SQLExprTableSource) select.getFrom()).getExpr();
if (expr instanceof SQLIdentifierExpr) {
x.putAttribute(ATTR_TABLE_SOURCE, select.getFrom());
return select.getFrom();
return null;
public boolean visit(SQLPropertyExpr x) {
x.getOwner().setParent(x);
x.getOwner().accept(this);
return false;
public boolean visit(SQLIdentifierExpr x) {
SQLTableSource tableSource = getTableSource(x.getName(), x.getParent());
if (tableSource != null) {
x.putAttribute(ATTR_TABLE_SOURCE, tableSource);
return false;
public static SQLTableSource getTableSource(String name, SQLObject parent) {
SQLSelectQueryBlock select = getSQLSelectQueryBlock(parent);
if (select == null) {
return null;
Map<String, SQLTableSource> aliasMap = getAliasMap(select);
if (aliasMap == null) {
return null;
SQLTableSource tableSource = aliasMap.get(name);
if (tableSource != null) {
return tableSource;
for (Map.Entry<String, SQLTableSource> entry : aliasMap.entrySet()) {
if (name.equalsIgnoreCase(entry.getKey())) {
return tableSource;
return null;
@SuppressWarnings("unchecked")
public static Map<String, SQLTableSource> getAliasMap(SQLObject x) {
Map<String, SQLTableSource> map = (Map<String, SQLTableSource>) x.getAttribute(ATTR_ALIAS);
if (map == null) {
map = new HashMap<String, SQLTableSource>();
x.putAttribute(ATTR_ALIAS, map);
return map;
public static SQLSelectQueryBlock getSQLSelectQueryBlock(SQLObject x) {
if (x == null) {
return null;
if (x instanceof SQLSelectQueryBlock) {
return (SQLSelectQueryBlock) x;
if (x.getParent() != null) {
return getSQLSelectQueryBlock(x.getParent());
return null;
public static final String ATTR_DB           = "sharding.db";
public static final String ATTR_PARTITION    = "sharding.partition";
public static final String ATTR_TABLE_SOURCE = "sharding.tableSource";
public static final String ATTR_ALIAS        = "sharding.alias";
public class MySqlShardingSelectTest extends TestCase {
private RouteConfig routeConfig = new RouteConfig();
protected void setUp() throws Exception {
MappingRuleAdapter rule = new MappingRuleAdapter();
rule.setColumn("gender");
rule.setTable("person");
rule.getEntries().add(new MappingRuleListEntry("person_m", "M"));
rule.getEntries().add(new MappingRuleListEntry("person_f", "F"));
routeConfig.getMappingRules().put("person", rule);
LogicTable logicTable = new LogicTable();
logicTable.setLogicTable("person");
logicTable.addPartition("person_m", "db0", "person_001");
logicTable.addPartition("person_f", "db1", "person_002");
routeConfig.getLogicTables().put("person", logicTable);
public void test_insert_m() throws Exception {
String sql = "select * from person where name = 'xx' AND gender = 'M'";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig);
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT *" + 
"nFROM person_001" + 
"nWHERE name = 'xx'" + 
"ntAND gender = 'M'", result);
Assert.assertEquals("db0", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public void test_insert_f_params() throws Exception {
String sql = "select * from person where name = 'xx' AND gender = ?";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig, "F"); 
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT *" + 
"nFROM person_002" + 
"nWHERE name = 'xx'" + 
"ntAND gender = ?", result);
Assert.assertEquals("db1", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public class MysqlShardingInsertTest extends TestCase {
public boolean visit(MySqlDeleteStatement x) {
input = x;
if (x.getFrom() != null) {
x.getFrom().setParent(x);
x.getFrom().accept(this);
if (x.getTableSource() != null) {
x.getTableSource().setParent(x);
x.getTableSource().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
result.add(x);
return false;
public boolean visit(MySqlUpdateStatement x) {
input = x;
if (x.getTableSource() != null) {
x.getTableSource().setParent(x);
x.getTableSource().accept(this);
if (x.getWhere() != null) {
x.getWhere().setParent(x);
x.getWhere().accept(this);
result.add(x);
return false;
Map<String, SQLTableSource> aliasMap = getAliasMap(x);
SQLTableSource defaltTableSource = getDefaultTableSource(x.getParent());
if (defaltTableSource instanceof SQLExprTableSource) {
SQLExpr expr = ((SQLExprTableSource) defaltTableSource).getExpr();
x.putAttribute(ATTR_TABLE_SOURCE, defaltTableSource);
return defaltTableSource;
Map<String, SQLTableSource> aliasMap = getAliasMap(parent);
if (x == null) {
return null;
if (x instanceof SQLSelectQueryBlock || x instanceof SQLDeleteStatement) {
Map<String, SQLTableSource> map = (Map<String, SQLTableSource>) x.getAttribute(ATTR_ALIAS);
if (map == null) {
map = new HashMap<String, SQLTableSource>();
x.putAttribute(ATTR_ALIAS, map);
return map;
return getAliasMap(x.getParent());
public static SQLTableSource getDefaultTableSource(SQLObject x) {
return ((SQLSelectQueryBlock) x).getFrom();
if (x instanceof SQLDeleteStatement) {
return ((SQLDeleteStatement) x).getTableSource();
if (x instanceof SQLUpdateStatement) {
return ((SQLUpdateStatement) x).getTableSource();
return getDefaultTableSource(x.getParent());
incrementIndent();
decrementIndent();
incrementIndent();
decrementIndent();
public class MySqlShardingDeleteTest extends TestCase {
private RouteConfig routeConfig = new RouteConfig();
protected void setUp() throws Exception {
MappingRuleAdapter rule = new MappingRuleAdapter();
rule.setColumn("gender");
rule.setTable("person");
rule.getEntries().add(new MappingRuleListEntry("person_m", "M"));
rule.getEntries().add(new MappingRuleListEntry("person_f", "F"));
routeConfig.getMappingRules().put("person", rule);
LogicTable logicTable = new LogicTable();
logicTable.setLogicTable("person");
logicTable.addPartition("person_m", "db0", "person_001");
logicTable.addPartition("person_f", "db1", "person_002");
routeConfig.getLogicTables().put("person", logicTable);
public void test_delete_m() throws Exception {
String sql = "delete from person where name = 'xx' AND gender = 'M'";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig);
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM person_001" + 
"nWHERE name = 'xx'" + 
"ntAND gender = 'M'", result);
Assert.assertEquals("db0", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public void test_delete_f_params() throws Exception {
String sql = "delete from person where name = 'xx' AND gender = ?";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig, "F"); 
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DELETE FROM person_002" + 
"nWHERE name = 'xx'" + 
"ntAND gender = ?", result);
Assert.assertEquals("db1", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public class MySqlShardingUpdateTest extends TestCase {
private RouteConfig routeConfig = new RouteConfig();
protected void setUp() throws Exception {
MappingRuleAdapter rule = new MappingRuleAdapter();
rule.setColumn("gender");
rule.setTable("person");
rule.getEntries().add(new MappingRuleListEntry("person_m", "M"));
rule.getEntries().add(new MappingRuleListEntry("person_f", "F"));
routeConfig.getMappingRules().put("person", rule);
LogicTable logicTable = new LogicTable();
logicTable.setLogicTable("person");
logicTable.addPartition("person_m", "db0", "person_001");
logicTable.addPartition("person_f", "db1", "person_002");
routeConfig.getLogicTables().put("person", logicTable);
public void test_update_m() throws Exception {
String sql = "update person set X = null where name = 'xx' AND gender = 'M'";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig);
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE person_001" + 
"nSET X = NULL" + 
"nWHERE name = 'xx'" + 
"ntAND gender = 'M'", result);
Assert.assertEquals("db0", stmt.getAttribute(ShardingVisitor.ATTR_DB));
public void test_delete_f_params() throws Exception {
String sql = "update person set X = null where name = 'xx' AND gender = ?";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
SQLStatement stmt = stmtList.get(0);
MySqlShardingVisitor visitor = new MySqlShardingVisitor(routeConfig, "F"); 
stmt.accept(visitor);
String result = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE person_002" + 
"nSET X = NULL" + 
"nWHERE name = 'xx'" + 
"ntAND gender = ?", result);
Assert.assertEquals("db1", stmt.getAttribute(ShardingVisitor.ATTR_DB));
"tAND a.member_id = 'abc'", output);
"tAND col2 = 1", output);
"UPDATE net_device d, sys_user unSET d.resp_user_id = u.idnWHERE d.resp_user_login_name = u.usernamentAND d.id IN (?)");
public class ShardingDataSource extends DataSourceAdapter implements DataSource {
private final int       scaleOrLength;
public JdbcParameter(int sqlType, Object value, long length, Calendar calendar, int scaleOrLength){
this.scaleOrLength = scaleOrLength;
public JdbcParameter(int sqlType, Object value, long length, Calendar calendar){
this(sqlType, value, -1, null, -1);
public int getScaleOrLength() {
return scaleOrLength;
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x, -1, null, scaleOrLength));
public class ShardingConnection extends WrapperAdapter implements Connection, ConnectionProxy {
private final ShardingDataSource dataSource;
private Connection               conn;
private DataSourceHolder         dataSourceHolder;
private final long               id;
private Boolean                  autoCommit       = null;
private Boolean                  readOnly         = null;
private String                   catalog          = null;
private Integer                  transactionLeval = null;
private Map<String, Class<?>>    typeMap          = null;
private Integer                  holdability      = null;
private Properties               clientInfo       = null;
private Map<String, Object>      attributes       = null;
private Date                     connectedTime    = null;
private int                      closeCount       = 0;
private TransactionInfo          transcationInfo;
private String                   database;
public ShardingConnection(ShardingDataSource dataSource, long id){
this.dataSource = dataSource;
this.id = id;
public String getDatabase() {
return database;
public void setDatabase(String database) {
this.database = database;
public DataSourceHolder getDataSourceHolder() {
return dataSourceHolder;
public void checkConnection(String sql) throws SQLException {
if (conn == null) {
conn = dataSource.getConnectionBySql(sql);
initConnection(conn);
connectedTime = new Date();
private void initConnection(Connection conn) throws SQLException, SQLClientInfoException {
if (autoCommit != null) {
conn.setAutoCommit(autoCommit);
if (readOnly != null) {
conn.setReadOnly(readOnly);
if (catalog != null) {
conn.setCatalog(catalog);
if (transactionLeval != null) {
conn.setTransactionIsolation(transactionLeval);
if (typeMap != null) {
conn.setTypeMap(typeMap);
if (holdability != null) {
conn.setHoldability(holdability);
if (clientInfo != null) {
conn.setClientInfo(clientInfo);
public ShardingDataSource getDataSource() {
return dataSource;
public String nativeSQL(String sql) throws SQLException {
checkConnection(sql);
return conn.nativeSQL(sql);
public Connection createRealConnectionByDb(String db) throws SQLException {
if (conn != null) {
JdbcUtils.close(conn);
conn = null;
conn = dataSource.getConnectionByDb(db);
initConnection(conn);
return conn;
public Connection getRealConnection() {
return conn;
public void closeRealConnection() {
if (conn != null) {
JdbcUtils.close(conn);
conn = null;
public void setAutoCommit(boolean autoCommit) throws SQLException {
if (conn != null) {
conn.setAutoCommit(autoCommit);
this.autoCommit = Boolean.valueOf(autoCommit);
if (!autoCommit) {
if (transcationInfo == null) {
long transactionId = this.getDirectDataSource().createTransactionId();
transcationInfo = new TransactionInfo(transactionId);
transcationInfo = null;
public boolean getAutoCommit() throws SQLException {
if (conn != null) {
return conn.getAutoCommit();
if (this.autoCommit != null) {
return this.autoCommit.booleanValue();
return false;
public void commit() throws SQLException {
if (conn != null) {
conn.commit();
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
public void rollback() throws SQLException {
if (conn != null) {
conn.rollback();
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
public void close() throws SQLException {
if (closeCount > 0) {
closeCount++;
if (conn != null) {
conn.close();
this.closeCount++;
dataSource.afterConnectionClosed(this);
public boolean isClosed() throws SQLException {
return closeCount > 0;
public DatabaseMetaData getMetaData() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.getMetaData();
public void setReadOnly(boolean readOnly) throws SQLException {
if (conn != null) {
conn.setReadOnly(readOnly);
this.readOnly = Boolean.valueOf(readOnly);
public boolean isReadOnly() throws SQLException {
if (conn != null) {
return conn.isReadOnly();
if (this.readOnly != null) {
return this.readOnly.booleanValue();
return false;
public void setCatalog(String catalog) throws SQLException {
if (conn != null) {
conn.setCatalog(catalog);
this.catalog = catalog;
public String getCatalog() throws SQLException {
if (conn != null) {
return conn.getCatalog();
return this.catalog;
public void setTransactionIsolation(int level) throws SQLException {
if (conn != null) {
conn.setTransactionIsolation(level);
this.transactionLeval = level;
public int getTransactionIsolation() throws SQLException {
if (conn != null) {
return conn.getTransactionIsolation();
if (this.transactionLeval != null) {
return this.transactionLeval;
return TRANSACTION_NONE;
public SQLWarning getWarnings() throws SQLException {
if (conn != null) {
return conn.getWarnings();
return null;
public void clearWarnings() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
if (conn != null) {
conn.clearWarnings();
public Map<String, Class<?>> getTypeMap() throws SQLException {
if (conn != null) {
return conn.getTypeMap();
return typeMap;
public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
if (conn != null) {
conn.setTypeMap(map);
this.typeMap = map;
public void setHoldability(int holdability) throws SQLException {
if (conn != null) {
conn.setHoldability(holdability);
this.holdability = holdability;
public int getHoldability() throws SQLException {
if (conn != null) {
return conn.getHoldability();
if (this.holdability != null) {
return this.holdability;
public Savepoint setSavepoint() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.setSavepoint();
public Savepoint setSavepoint(String name) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.setSavepoint(name);
public void rollback(Savepoint savepoint) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
conn.rollback(savepoint);
if (transcationInfo != null) {
transcationInfo.setEndTimeMillis();
public void releaseSavepoint(Savepoint savepoint) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
conn.releaseSavepoint(savepoint);
public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
long stmtId = dataSource.createStatementId();
ShardingStatement stmt = new ShardingStatement(this, stmtId, resultSetType, resultSetConcurrency);
return stmt;
public Statement createStatement() throws SQLException {
long stmtId = dataSource.createStatementId();
ShardingStatement stmt = new ShardingStatement(this, stmtId);
return stmt;
public PreparedStatement prepareStatement(String sql) throws SQLException {
long stmtId = dataSource.createStatementId();
return new ShardingPreparedStatement(this, sql, stmtId);
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
throws SQLException {
long stmtId = dataSource.createStatementId();
return new ShardingPreparedStatement(this, sql, stmtId);
public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
throw new UnsupportedOperationException();
public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
throw new UnsupportedOperationException();
public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
throw new UnsupportedOperationException();
public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
long stmtId = dataSource.createStatementId();
return new ShardingPreparedStatement(this, sql, stmtId, resultSetType, resultSetConcurrency,
resultSetHoldability);
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
throw new UnsupportedOperationException();
public CallableStatement prepareCall(String sql) throws SQLException {
checkConnection(sql);
CallableStatement stmt = conn.prepareCall(sql);
long stmtId = dataSource.createStatementId();
return new CallableStatementProxyImpl(this, stmt, sql, stmtId);
public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
throws SQLException {
long stmtId = dataSource.createStatementId();
ShardingStatement stmt = new ShardingStatement(this, stmtId, resultSetType, resultSetConcurrency,
resultSetHoldability);
return stmt;
public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
int resultSetHoldability) throws SQLException {
checkConnection(sql);
CallableStatement stmt = conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
long stmtId = dataSource.createStatementId();
return new CallableStatementProxyImpl(this, stmt, sql, stmtId);
public Clob createClob() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createClob();
public Blob createBlob() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createBlob();
public NClob createNClob() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createNClob();
public SQLXML createSQLXML() throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createSQLXML();
public boolean isValid(int timeout) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.isValid(timeout);
public void setClientInfo(String name, String value) throws SQLClientInfoException {
if (conn != null) {
conn.setClientInfo(name, value);
if (clientInfo == null) {
clientInfo = new Properties();
clientInfo.setProperty(name, value);
public void setClientInfo(Properties properties) throws SQLClientInfoException {
if (conn != null) {
conn.setClientInfo(properties);
this.clientInfo = properties;
public String getClientInfo(String name) throws SQLException {
if (conn != null) {
return conn.getClientInfo(name);
if (clientInfo == null) {
return null;
return clientInfo.getProperty(name);
public Properties getClientInfo() throws SQLException {
if (conn != null) {
return conn.getClientInfo();
return clientInfo;
public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createArrayOf(typeName, elements);
public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
return conn.createStruct(typeName, attributes);
public long getId() {
return id;
public Connection getRawObject() {
return conn;
public Map<String, Object> getAttributes() {
if (attributes == null) {
attributes = new HashMap<String, Object>();
return attributes;
public Properties getProperties() {
return dataSource.getProperties();
public DataSourceProxy getDirectDataSource() {
return dataSource;
public Date getConnectedTime() {
return connectedTime;
public boolean isWrapperFor(Class<?> iface) throws SQLException {
boolean result = super.isWrapperFor(iface);
if ((!result) && conn != null) {
result = conn.isWrapperFor(iface);
return result;
public <T> T unwrap(Class<T> iface) throws SQLException {
T object = super.unwrap(iface);
if (object == null && conn != null) {
object = conn.unwrap(iface);
return object;
public void setSchema(String schema) throws SQLException {
throw new SQLFeatureNotSupportedException();
public String getSchema() throws SQLException {
throw new SQLFeatureNotSupportedException();
public void abort(Executor executor) throws SQLException {
if (conn == null) {
throw new SQLException("connection not init");
throw new SQLFeatureNotSupportedException();
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
throw new SQLFeatureNotSupportedException();
public int getNetworkTimeout() throws SQLException {
throw new SQLFeatureNotSupportedException();
public TransactionInfo getTransactionInfo() {
return null;
public int getCloseCount() {
return closeCount;
public class ShardingDataSource extends DataSourceAdapter implements DataSource, DataSourceProxy {
private final AtomicLong connectionIdSeed  = new AtomicLong();
private final AtomicLong statementIdSeed   = new AtomicLong();
private final AtomicLong resultSetIdSeed   = new AtomicLong();
private final AtomicLong transactionIdSeed = new AtomicLong();
private final Properties properties        = new Properties();
private String           dbType;
private List<Filter>     filters           = new CopyOnWriteArrayList<Filter>();
private RouteConfig      routeConfig       = new RouteConfig();
public Connection getConnectionByPartition(String partition) {
throw new UnsupportedOperationException();
public Connection getConnectionByDb(String partition) {
throw new UnsupportedOperationException();
public DruidPooledConnection getConnectionBySql(String partition) {
throw new UnsupportedOperationException();
protected void afterConnectionClosed(ShardingConnection conn) {
public ShardingVisitor createShardingVisitor() {
return createShardingVisitor(new ArrayList<Object>());
public SQLStatement parseStatement(String sql) throws SQLException {
SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, dbType);
List<SQLStatement> stmtList = parser.parseStatementList();
if (stmtList.size() > 0) {
throw new SQLException("not support multi-statement");
return stmtList.get(0);
public ShardingVisitor createShardingVisitor(List<Object> parameters) {
return new MySqlShardingVisitor(routeConfig, parameters);
public RouteConfig getRouteConfig() {
return routeConfig;
public void setRouteConfig(RouteConfig routeConfig) {
this.routeConfig = routeConfig;
public void setDbType(String dbType) {
this.dbType = dbType;
public long createStatementId() {
return statementIdSeed.incrementAndGet();
public long createConnectionId() {
return connectionIdSeed.getAndIncrement();
public Properties getProperties() {
return properties;
public JdbcDataSourceStat getDataSourceStat() {
return null;
public String getName() {
return null;
public String getDbType() {
return dbType;
public Driver getRawDriver() {
return null;
public String getUrl() {
return null;
public String getRawJdbcUrl() {
return null;
public List<Filter> getProxyFilters() {
return filters;
public long createResultSetId() {
return resultSetIdSeed.incrementAndGet();
public long createTransactionId() {
return transactionIdSeed.incrementAndGet();
public Properties getConnectProperties() {
return properties;
public class ShardingPreparedStatement extends ShardingStatement implements PreparedStatement {
private final String                        sql;
private PreparedStatement                   pstmt;
private List<String>                        tables;
protected final Map<Integer, JdbcParameter> parameters = new TreeMap<Integer, JdbcParameter>();
public ShardingPreparedStatement(ShardingConnection conn, String sql, long id){
super(conn, id);
this.sql = sql;
public ShardingPreparedStatement(ShardingConnection conn, String sql, long id, int resultSetType,
int resultSetConcurrency, int resultSetHoldability){
super(conn, id, resultSetType, resultSetConcurrency, resultSetHoldability);
this.sql = sql;
public ShardingPreparedStatement(ShardingConnection conn, String sql, long id, int resultSetType,
int resultSetConcurrency){
super(conn, id, resultSetType, resultSetConcurrency);
this.sql = sql;
public void setArray(int parameterIndex, Array x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.ARRAY, x));
public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x));
public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DECIMAL, x));
public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x));
public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
public void setBlob(int parameterIndex, Blob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
public void setBlob(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
public void setBlob(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x, length));
public void setBoolean(int parameterIndex, boolean x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BOOLEAN, x));
public void setByte(int parameterIndex, byte x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TINYINT, x));
public void setBytes(int parameterIndex, byte[] x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.BYTES, x));
public void setCharacterStream(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x));
public void setCharacterStream(int parameterIndex, Reader x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
public void setCharacterStream(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
public void setClob(int parameterIndex, Clob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
public void setClob(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
public void setClob(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x, length));
public void setDate(int parameterIndex, Date x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x));
public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x, cal));
public void setDouble(int parameterIndex, double x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DOUBLE, x));
public void setFloat(int parameterIndex, float x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.FLOAT, x));
public void setInt(int parameterIndex, int x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.INTEGER, x));
public void setLong(int parameterIndex, long x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BIGINT, x));
public void setNCharacterStream(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x));
public void setNCharacterStream(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x, length));
public void setNClob(int parameterIndex, NClob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
public void setNClob(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
public void setNClob(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x, length));
public void setNString(int parameterIndex, String x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NVARCHAR, x));
public void setNull(int parameterIndex, int sqlType) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
public void setObject(int parameterIndex, Object x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x));
public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x, -1, null, scaleOrLength));
public void setRef(int parameterIndex, Ref x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.REF, x));
public void setRowId(int parameterIndex, RowId x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.ROWID, x));
public void setSQLXML(int parameterIndex, SQLXML x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.SQLXML, x));
public void setShort(int parameterIndex, short x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.SMALLINT, x));
public void setString(int parameterIndex, String x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.VARCHAR, x));
public void setTime(int parameterIndex, Time x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x));
public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x, cal));
public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
public void setURL(int parameterIndex, URL x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.URL, x));
public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.UnicodeStream, x, length));
public void setParameter(int parameterIndex, JdbcParameter parameter) {
this.getParameters().put(parameterIndex, parameter);
public Map<Integer, JdbcParameter> getParameters() {
return parameters;
public void clearParameters() throws SQLException {
this.parameters.clear();
public ResultSetMetaData getMetaData() throws SQLException {
if (pstmt != null) {
return pstmt.getMetaData();
return null;
public ParameterMetaData getParameterMetaData() throws SQLException {
if (pstmt != null) {
return pstmt.getParameterMetaData();
return null;
public ResultSet executeQuery() throws SQLException {
List<Object> values = getParameterValues();
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor(values);
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
checkParameterValues(values, resultSqlStmtList);
if (resultSqlStmtList.size() > 1) {
throw new SQLException("executeQuery not support multi-statement");
SQLStatement resultSqlStmt = resultSqlStmtList.get(0);
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
checkPreparedStatement(resultSqlStmt, resultSql, database);
return pstmt.executeQuery();
@SuppressWarnings("unchecked")
private void checkPreparedStatement(SQLStatement resultSqlStmt, String resultSql, String database)
throws SQLException {
if (conn.getRealConnection() != null 
&& StringUtils.equals(database, conn.getDatabase()) 
if (pstmt == null) {
pstmt = createRealPreparedStatement(conn.getRealConnection(), resultSql);
tables = (List<String>) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_TABLES);
} else if (tables != null 
&& tables.equals(resultSqlStmt.getAttribute(ShardingVisitor.ATTR_TABLES))) {
if (pstmt != null) {
JdbcUtils.close(pstmt);
pstmt = null;
tables = null;
pstmt = createRealPreparedStatement(conn.getRealConnection(), resultSql);
tables = (List<String>) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_TABLES);
conn.closeRealConnection();
if (pstmt != null) {
JdbcUtils.close(pstmt);
pstmt = null;
tables = null;
conn.createRealConnectionByDb(database);
pstmt = createRealPreparedStatement(conn.getRealConnection(), resultSql);
public int executeUpdate() throws SQLException {
List<Object> values = getParameterValues();
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor(values);
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
checkParameterValues(values, resultSqlStmtList);
int updateCount = 0;
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
checkPreparedStatement(resultSqlStmt, resultSql, database);
updateCount += pstmt.executeUpdate();
return updateCount;
private void checkParameterValues(List<Object> values, List<SQLStatement> resultSqlStmtList) throws SQLException {
if (resultSqlStmtList.size() > 1) {
for (Object value : values) {
if (value instanceof InputStream 
|| value instanceof Reader 
|| value instanceof Blob 
|| value instanceof Clob 
|| value instanceof NClob 
throw new SQLException(value.getClass().getName() + " not support multi-statement");
private List<Object> getParameterValues() {
List<Object> values = new ArrayList<Object>();
for (Map.Entry<Integer, JdbcParameter> entry : this.parameters.entrySet()) {
values.add(entry.getValue().getValue());
return values;
public boolean execute() throws SQLException {
List<Object> values = getParameterValues();
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor(values);
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
checkParameterValues(values, resultSqlStmtList);
boolean isSelelct = sqlStmt instanceof SQLSelectStatement;
if (resultSqlStmtList.size() > 1 && isSelelct) {
throw new SQLException("select not support multi-statement");
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
checkPreparedStatement(resultSqlStmt, resultSql, database);
pstmt.execute();
if (!isSelelct) {
if (updateCount == null) {
updateCount = pstmt.getUpdateCount();
updateCount = updateCount.intValue() + pstmt.getUpdateCount();
return isSelelct;
public void addBatch() throws SQLException {
throw new UnsupportedOperationException();
@SuppressWarnings("deprecation")
private PreparedStatement createRealPreparedStatement(Connection conn, String sql) throws SQLException {
PreparedStatement stmt;
if (resultSetType != null && resultSetConcurrency != null && resultSetHoldability != null) {
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
} else if (resultSetType != null && resultSetConcurrency != null) {
stmt = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
stmt = conn.prepareStatement(sql);
initStatement(stmt);
for (Map.Entry<Integer, JdbcParameter> entry : this.parameters.entrySet()) {
int index = entry.getKey();
JdbcParameter param = entry.getValue();
Object value = param.getValue();
if (param.getScaleOrLength() != -1) {
stmt.setObject(index, value, param.getSqlType(), param.getScaleOrLength());
} else if (value == null) {
stmt.setNull(index, param.getSqlType());
switch (param.getSqlType()) {
case Types.ARRAY
stmt.setArray(index, (Array) value);
case TYPE.AsciiInputStream
if (param.getLength() >= 0) {
stmt.setAsciiStream(index, (InputStream) value, param.getLength());
stmt.setAsciiStream(index, (InputStream) value);
case Types.DECIM
stmt.setBigDecimal(index, (BigDecimal) value);
case TYPE.BinaryInputStream
if (param.getLength() >= 0) {
stmt.setBinaryStream(index, (InputStream) value, param.getLength());
stmt.setBinaryStream(index, (InputStream) value);
case Types.BLOB
if (value instanceof Blob) {
stmt.setBlob(index, (Blob) value);
if (param.getLength() >= 0) {
stmt.setBlob(index, (InputStream) value, param.getLength());
stmt.setBlob(index, (InputStream) value);
case Types.BOO
stmt.setBoolean(index, (Boolean) value);
case Types.TINY
stmt.setByte(index, (Byte) value);
case TYPE.BY
stmt.setBytes(index, (byte[]) value);
case TYPE.CharacterInputStream
if (param.getLength() >= 0) {
stmt.setCharacterStream(index, (Reader) value, param.getLength());
stmt.setCharacterStream(index, (Reader) value);
case Types.CLOB
if (value instanceof Clob) {
stmt.setClob(index, (Clob) value);
if (param.getLength() >= 0) {
stmt.setClob(index, (Reader) value, param.getLength());
stmt.setClob(index, (Reader) value);
case Types.D
if (param.getCalendar() != null) {
stmt.setDate(index, (Date) value, param.getCalendar());
stmt.setDate(index, (Date) value);
case Types.DOUB
stmt.setDouble(index, (Double) value);
case Types.FLO
stmt.setFloat(index, (Float) value);
case Types.INTEG
stmt.setInt(index, (Integer) value);
case Types.BIG
stmt.setLong(index, (Long) value);
case TYPE.NCharacterInputStream
if (param.getLength() >= 0) {
stmt.setNCharacterStream(index, (Reader) value, param.getLength());
stmt.setNCharacterStream(index, (Reader) value);
case Types.NCLOB
if (value instanceof Clob) {
stmt.setNClob(index, (NClob) value);
if (param.getLength() >= 0) {
stmt.setNClob(index, (Reader) value, param.getLength());
stmt.setNClob(index, (Reader) value);
case Types.NCH
case Types.NVARCH
stmt.setNString(index, (String) value);
case Types.OTH
stmt.setObject(index, value);
case Types.REF
stmt.setRef(index, (Ref) value);
case Types.ROWID
stmt.setRowId(index, (RowId) value);
case Types.SQLXM
stmt.setSQLXML(index, (SQLXML) value);
case Types.SM
stmt.setShort(index, (Short) value);
case Types.VARCH
case Types.CH
stmt.setString(index, (String) value);
case Types.TIM
if (param.getCalendar() != null) {
stmt.setTime(index, (Time) value, param.getCalendar());
stmt.setTime(index, (Time) value);
case Types.TIMESTAMP
if (param.getCalendar() != null) {
stmt.setTimestamp(index, (Timestamp) value, param.getCalendar());
stmt.setTimestamp(index, (Timestamp) value);
case TYPE.U
stmt.setURL(index, (URL) value);
case TYPE.UnicodeStream
stmt.setUnicodeStream(index, (InputStream) value, (int) param.getLength());
stmt.setObject(index, value);
return stmt;
public class ShardingStatement extends WrapperAdapter implements Statement {
protected final ShardingConnection conn;
private final long                 id;
protected Integer                  resultSetType;
protected Integer                  resultSetConcurrency;
protected Integer                  resultSetHoldability;
private Statement                  stmt;
protected Integer                  updateCount;
private Integer                    maxFieldSize;
private Integer                    maxRows;
private Boolean                    escapeProcessing;
private Integer                    queryTimeout;
private String                     cursorName;
private Integer                    fetchDirection;
private Integer                    fetchSize;
protected void initStatement(Statement stmt) throws SQLException {
if (maxFieldSize != null) {
stmt.setMaxFieldSize(maxFieldSize);
if (maxRows != null) {
stmt.setMaxRows(maxRows);
if (escapeProcessing != null) {
stmt.setEscapeProcessing(escapeProcessing);
if (queryTimeout != null) {
stmt.setQueryTimeout(queryTimeout);
if (cursorName != null) {
stmt.setCursorName(cursorName);
if (fetchDirection != null) {
stmt.setFetchDirection(fetchDirection);
if (fetchSize != null) {
stmt.setFetchSize(fetchSize);
private Statement createRealStatement(Connection conn) throws SQLException {
Statement stmt;
if (resultSetType != null && resultSetConcurrency != null && resultSetHoldability != null) {
stmt = conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
} else if (resultSetType != null && resultSetConcurrency != null) {
stmt = conn.createStatement(resultSetType, resultSetConcurrency);
stmt = conn.createStatement();
initStatement(stmt);
return stmt;
public ShardingStatement(ShardingConnection conn, long id){
this.conn = conn;
this.id = id;
public ShardingStatement(ShardingConnection conn, long id, int resultSetType, int resultSetConcurrency){
this.conn = conn;
this.id = id;
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
public ShardingStatement(ShardingConnection conn, long id, int resultSetType, int resultSetConcurrency,
int resultSetHoldability){
this.conn = conn;
this.id = id;
this.resultSetType = resultSetType;
this.resultSetConcurrency = resultSetConcurrency;
this.resultSetHoldability = resultSetHoldability;
public long getId() {
return id;
public ResultSet executeQuery(String sql) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
if (resultSqlStmtList.size() > 1) {
throw new SQLException("executeQuery not support multi-statement");
SQLStatement resultSqlStmt = resultSqlStmtList.get(0);
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
return stmt.executeQuery(resultSql);
public void close() throws SQLException {
if (stmt != null) {
stmt.close();
public int getMaxFieldSize() throws SQLException {
if (stmt != null) {
return stmt.getMaxFieldSize();
if (maxFieldSize == null) {
return maxFieldSize;
public void setMaxFieldSize(int max) throws SQLException {
if (stmt != null) {
stmt.setMaxFieldSize(max);
this.maxFieldSize = max;
public int getMaxRows() throws SQLException {
if (stmt != null) {
return stmt.getMaxRows();
if (maxRows == null) {
return maxRows;
public void setMaxRows(int max) throws SQLException {
if (stmt != null) {
stmt.setMaxRows(max);
this.maxRows = max;
public void setEscapeProcessing(boolean enable) throws SQLException {
if (stmt != null) {
stmt.setEscapeProcessing(enable);
this.escapeProcessing = enable;
public int getQueryTimeout() throws SQLException {
if (stmt != null) {
return stmt.getQueryTimeout();
if (queryTimeout == null) {
return queryTimeout;
public void setQueryTimeout(int seconds) throws SQLException {
if (stmt != null) {
stmt.setQueryTimeout(seconds);
this.queryTimeout = seconds;
public void cancel() throws SQLException {
if (stmt != null) {
stmt.cancel();
public SQLWarning getWarnings() throws SQLException {
if (stmt != null) {
return stmt.getWarnings();
return null;
public void clearWarnings() throws SQLException {
if (stmt != null) {
stmt.clearWarnings();
public void setCursorName(String name) throws SQLException {
if (stmt != null) {
stmt.setCursorName(name);
this.cursorName = name;
public boolean execute(String sql) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
boolean isSelelct = sqlStmt instanceof SQLSelectStatement;
if (resultSqlStmtList.size() > 1 && isSelelct) {
throw new SQLException("select not support multi-statement");
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
stmt.execute(resultSql);
if (!isSelelct) {
if (updateCount == null) {
updateCount = stmt.getUpdateCount();
updateCount = updateCount.intValue() + stmt.getUpdateCount();
return isSelelct;
public ResultSet getResultSet() throws SQLException {
if (stmt != null) {
return stmt.getResultSet();
return null;
public int getUpdateCount() throws SQLException {
if (updateCount != null) {
return updateCount.intValue();
public boolean getMoreResults() throws SQLException {
if (stmt != null) {
return stmt.getMoreResults();
return false;
public void setFetchDirection(int direction) throws SQLException {
if (stmt != null) {
stmt.setFetchDirection(direction);
this.fetchDirection = direction;
public int getFetchDirection() throws SQLException {
if (stmt != null) {
return stmt.getFetchDirection();
return this.fetchDirection;
public void setFetchSize(int rows) throws SQLException {
if (stmt != null) {
stmt.setFetchSize(rows);
this.fetchSize = rows;
public int getFetchSize() throws SQLException {
if (stmt != null) {
return stmt.getFetchSize();
return this.fetchSize;
public int getResultSetConcurrency() throws SQLException {
if (stmt != null) {
return stmt.getResultSetConcurrency();
if (resultSetConcurrency != null) {
return resultSetConcurrency;
public int getResultSetType() throws SQLException {
if (stmt != null) {
return stmt.getResultSetType();
return resultSetType;
public void addBatch(String sql) throws SQLException {
throw new UnsupportedOperationException();
public void clearBatch() throws SQLException {
if (stmt != null) {
stmt.clearBatch();
public int[] executeBatch() throws SQLException {
if (stmt != null) {
return stmt.executeBatch();
return new int[0];
public ShardingConnection getConnection() throws SQLException {
return conn;
public boolean getMoreResults(int current) throws SQLException {
if (stmt != null) {
return stmt.getMoreResults(current);
return false;
public ResultSet getGeneratedKeys() throws SQLException {
if (stmt != null) {
return stmt.getGeneratedKeys();
return null;
public int executeUpdate(String sql) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
int updateCount = 0;
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
updateCount += stmt.executeUpdate(resultSql);
return updateCount;
public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS && resultSqlStmtList.size() > 1
&& sqlStmt instanceof SQLInsertStatement) {
throw new SQLException("RETURN_GENERATED_KEYS not support multi-statement");
int updateCount = 0;
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
updateCount += stmt.executeUpdate(resultSql, autoGeneratedKeys);
return updateCount;
public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
int updateCount = 0;
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
updateCount += stmt.executeUpdate(resultSql, columnIndexes);
return updateCount;
public int executeUpdate(String sql, String[] columnNames) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
int updateCount = 0;
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
updateCount += stmt.executeUpdate(resultSql, columnNames);
return updateCount;
public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
boolean isSelelct = sqlStmt instanceof SQLSelectStatement;
if (resultSqlStmtList.size() > 1) {
if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS && sqlStmt instanceof SQLInsertStatement) {
throw new SQLException("RETURN_GENERATED_KEYS not support multi-statement");
} else if (isSelelct) {
throw new SQLException("select not support multi-statement");
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
stmt.execute(resultSql, autoGeneratedKeys);
if (!isSelelct) {
if (updateCount == null) {
updateCount = stmt.getUpdateCount();
updateCount = updateCount.intValue() + stmt.getUpdateCount();
return isSelelct;
public boolean execute(String sql, int[] columnIndexes) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
boolean isSelelct = sqlStmt instanceof SQLSelectStatement;
if (resultSqlStmtList.size() > 1 && isSelelct) {
throw new SQLException("select not support multi-statement");
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
stmt.execute(resultSql, columnIndexes);
if (!isSelelct) {
if (updateCount == null) {
updateCount = stmt.getUpdateCount();
updateCount = updateCount.intValue() + stmt.getUpdateCount();
return isSelelct;
public boolean execute(String sql, String[] columnNames) throws SQLException {
ShardingDataSource dataSource = conn.getDataSource();
ShardingVisitor visitor = dataSource.createShardingVisitor();
SQLStatement sqlStmt = dataSource.parseStatement(sql);
sqlStmt.accept(visitor);
List<SQLStatement> resultSqlStmtList = visitor.getResult();
boolean isSelelct = sqlStmt instanceof SQLSelectStatement;
if (resultSqlStmtList.size() > 1 && isSelelct) {
throw new SQLException("select not support multi-statement");
for (SQLStatement resultSqlStmt : resultSqlStmtList) {
String resultSql = SQLUtils.toSQLString(resultSqlStmt, dataSource.getDbType());
String database = (String) resultSqlStmt.getAttribute(ShardingVisitor.ATTR_DB);
if (conn.getRealConnection() != null && StringUtils.equals(database, conn.getDatabase())) {
if (stmt == null) {
stmt = createRealStatement(conn.getRealConnection());
conn.closeRealConnection();
if (stmt != null) {
JdbcUtils.close(stmt);
stmt = null;
conn.createRealConnectionByDb(database);
stmt = createRealStatement(conn.getRealConnection());
stmt.execute(resultSql, columnNames);
if (!isSelelct) {
if (updateCount == null) {
updateCount = stmt.getUpdateCount();
updateCount = updateCount.intValue() + stmt.getUpdateCount();
return isSelelct;
public int getResultSetHoldability() throws SQLException {
if (stmt != null) {
return stmt.getResultSetHoldability();
if (resultSetHoldability != null) {
return resultSetHoldability;
public boolean isClosed() throws SQLException {
if (stmt != null) {
return stmt.isClosed();
return false;
public void setPoolable(boolean poolable) throws SQLException {
throw new SQLException("not supported");
public boolean isPoolable() throws SQLException {
return false;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == null) {
return null;
if (iface.isInstance(this)) {
return (T) this;
if (stmt != null) {
return stmt.unwrap(iface);
return null;
public Boolean isEscapeProcessing() {
return escapeProcessing;
public String getCursorName() {
return cursorName;
public void closeOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isCloseOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
private String                   defaultDatabase;
private Map<String, LogicTable>  logicTables  = new HashMap<String, LogicTable>();
private Map<String, MappingRule> mappingRules = new HashMap<String, MappingRule>();
public String getDefaultDatabase() {
return defaultDatabase;
public void setDefaultDatabase(String defaultDatabase) {
this.defaultDatabase = defaultDatabase;
public List<SQLStatement> getResult() {
return result;
public interface ShardingVisitor extends SQLASTVisitor {
public static final String ATTR_TABLES       = "sharding.tables";
List<SQLStatement> getResult();
case VALUES:
lexer.nextToken();
if (lexer.token() != Token.LPAREN) {
throw new ParserException("syntax error, illegal values clause");
return this.methodRest(new SQLIdentifierExpr("VALUES"), true);
if (x.getValuesList().size() > 1) {
incrementIndent();
print(",");
println();
if (x.getValuesList().size() > 1) {
decrementIndent();
println();
print("ON DUPLICATE KEY UPDATE ");
for (int i = 0, size = x.getDuplicateKeyUpdate().size(); i < size; ++i) {
if (i != 0) {
if (i % 5 == 0) {
println();
print(", ");
x.getDuplicateKeyUpdate().get(i).accept(this);
"VALUES (?, '123')", output);
Assert.assertEquals("INSERT IGNORE INTO test.t1 (t1.id1)nVALUES (?)" + 
"nON DUPLICATE KEY UPDATE ex.col1 = ?, col2 = 12", output);
Assert.assertEquals("INSERT INTO t1nVALUES (123, ?)nON DUPLICATE KEY UPDATE ex.col1 = ?", output);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1nVALUES (0.12, 1, 2)," + 
"nt(?)," + 
"nt(DEFAULT)", output);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1nSELECT idnFROM t1" + 
"nON DUPLICATE KEY UPDATE ex.col1 = ?, col2 = 12",
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (t1.col1)nVALUES (123)," + 
"nt('12''34')", output);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (col1, t1.col2)nVALUES (123, '123''4')" + 
"nON DUPLICATE KEY UPDATE ex.col1 = ?",
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (col1, t1.col2)nSELECT idnFROM t3" + 
"nON DUPLICATE KEY UPDATE ex.col1 = ?",
Assert.assertEquals("INSERT INTO tbl_name (a, b, c)nVALUES (1, 2, 3)," + 
"nt(4, 5, 6)," + 
"nt(7, 8, 9);", text);
Assert.assertEquals("INSERT INTO tbl_name (a, b, c)" + 
"nVALUES (1, 2, 3, 4, 5" + 
"nt, 6, 7, 8, 9);", text);
Assert.assertEquals("INSERT INTO tbl_name (a, b, c)" + 
"nVALUES (1, 2, 3)" + 
"nON DUPLICATE KEY UPDATE c = c + 1;", text);
public class MySqlInsertTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO tbl_name () VALUES();";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLInsertStatement insertStmt = (SQLInsertStatement) stmt;
Assert.assertEquals(0, insertStmt.getValues().getValues().size());
Assert.assertEquals(0, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO tbl_name" + 
"nVALUES ()", SQLUtils.toMySqlString(insertStmt));
public class MySqlInsertTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLInsertStatement insertStmt = (SQLInsertStatement) stmt;
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO tbl_name (col1, col2)" + 
"nVALUES (15, col1 * 2)", SQLUtils.toMySqlString(insertStmt));
public class MySqlInsertTest_3 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLInsertStatement insertStmt = (SQLInsertStatement) stmt;
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO tbl_name (col1, col2)" + 
"nVALUES (col2 * 2, 15)", SQLUtils.toMySqlString(insertStmt));
public class MySqlInsertTest_4 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO tbl_name (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getColumns().size());
Assert.assertEquals(3, insertStmt.getValuesList().size());
Assert.assertEquals(3, insertStmt.getValuesList().get(0).getValues().size());
Assert.assertEquals(3, insertStmt.getValuesList().get(1).getValues().size());
Assert.assertEquals(3, insertStmt.getValuesList().get(2).getValues().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO tbl_name (a, b, c)" + 
"nVALUES (1, 2, 3)," +
"nt(4, 5, 6)," +
"nt(7, 8, 9)", SQLUtils.toMySqlString(insertStmt));
public class MySqlInsertTest_5 extends MysqlTest {
public void test_0() throws Exception {
String sql = "INSERT INTO tbl_name (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getColumns().size());
Assert.assertEquals(1, insertStmt.getValuesList().size());
Assert.assertEquals(9, insertStmt.getValuesList().get(0).getValues().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO tbl_name (a, b, c)" + 
"nVALUES (1, 2, 3, 4, 5" + 
"nt, 6, 7, 8, 9)", SQLUtils.toMySqlString(insertStmt));
public class MySqlInsertTest_6 extends MysqlTest {
public void test_0() throws Exception {
String sql = "insert into document(the_key,the_namespace,Gmt_create,Gmt_modify,Expired_time,the_value) " + 
"values (?,?,now(),now(),date_add(now(),interval ? second),?) " + 
"on duplicate key update Gmt_modify = values(Gmt_modify),Expired_time = values(Expired_time),the_value = values(the_value)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(6, insertStmt.getColumns().size());
Assert.assertEquals(1, insertStmt.getValuesList().size());
Assert.assertEquals(6, insertStmt.getValuesList().get(0).getValues().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO document (the_key, the_namespace, Gmt_create, Gmt_modify, Expired_time" + 
"nt, the_value)" + 
"nVALUES (?, ?, now(), now(), date_add(now(), INTERVAL ? SECOND)" + 
"nt, ?)" + 
"nON DUPLICATE KEY UPDATE Gmt_modify = VALUES(Gmt_modify), Expired_time = VALUES(Expired_time), the_value = VALUES(the_value)",
SQLUtils.toMySqlString(insertStmt));
public class TestHibernateCRUDWithTransactional extends TestCase {
public class HibernateCRUDTest extends TestCase {
private static final Logger log = LoggerFactory.getLogger(HibernateCRUDTest.class);
private DruidDataSource dataSource;
private SessionFactory sessionFactory;
public void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:h2:file:~/.h2/HibernateCRUDTest;AUTO_SERVER=TRUE");
dataSource.setUsername("sa");
dataSource.setPassword("");
dataSource.setDefaultAutoCommit(false);
LocalSessionFactoryBean factoryBean = new LocalSessionFactoryBean();
factoryBean.setDataSource(dataSource);
Properties prop = new Properties();
prop.put("hibernate.show_sql", "true");
prop.put("hibernate.hbm2ddl.auto", "create");
prop.put("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
factoryBean.setHibernateProperties(prop);
factoryBean.setAnnotatedClasses(new Class<?>[]{Sample.class});
factoryBean.afterPropertiesSet();
} catch (IOException e) {
e.printStackTrace();
sessionFactory = factoryBean.getObject();
public void tearDown() throws Exception {
sessionFactory.close();
private void doCreate(Session session) {
Sample sample = new Sample();
sample.setId(1L);
sample.setDesc("sample");
sample.setCreateTime(new Date());
session.save(sample);
private void doGet(Session session) {
Sample sample = (Sample) session.get(Sample.class, 1L);
log.debug("**sample:{}", sample);
assert sample != null;
private void doUpdate(Session session) {
Sample sample = (Sample) session.get(Sample.class, 1L);
assert sample != null;
sample.setDesc("update sample");
sample.setUpdateTime(new Date());
session.update(sample);
private void doDelete(Session session) {
Sample sample = (Sample) session.get(Sample.class, 1L);
assert sample != null;
session.delete(sample);
public void test_create() {
Session session = null;
session = sessionFactory.openSession();
doCreate(session);
} finally {
if (session != null){
session.flush();
session.close();
public void test_get() {
Session session = null;
session = sessionFactory.openSession();
doCreate(session);
doGet(session);
} finally {
if (session != null){
session.flush();
session.close();
public void test_update() {
Session session = null;
session = sessionFactory.openSession();
doCreate(session);
doUpdate(session);
} finally {
if (session != null){
session.flush();
session.close();
public void test_delete() {
Session session = null;
session = sessionFactory.openSession();
doCreate(session);
doDelete(session);
} finally {
if (session != null){
session.flush();
session.close();
public void test_transactional_create() {
Session session = null;
Transaction tran = null;
session = sessionFactory.openSession();
tran = session.beginTransaction();
doCreate(session);
} finally {
if (tran != null) {
tran.commit();
if (session != null){
session.flush();
session.close();
public void test_transactional_update() {
Session session = null;
Transaction tran = null;
session = sessionFactory.openSession();
tran = session.beginTransaction();
doCreate(session);
doUpdate(session);
} finally {
if (tran != null) {
tran.commit();
if (session != null){
session.flush();
session.close();
public void test_transactional_delete() {
Session session = null;
Transaction tran = null;
session = sessionFactory.openSession();
tran = session.beginTransaction();
doCreate(session);
doDelete(session);
} finally {
if (tran != null) {
tran.commit();
if (session != null){
session.flush();
session.close();
@Table(name = "SAMPLE")
public class Sample implements Serializable {
private Long id;
private String name;
private String desc;
private Date createTime;
private Date updateTime;
public Date getCreateTime() {
return createTime;
public void setCreateTime(Date createTime) {
this.createTime = createTime;
public String getDesc() {
return desc;
public void setDesc(String desc) {
this.desc = desc;
public Long getId() {
return id;
public void setId(Long id) {
this.id = id;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public Date getUpdateTime() {
return updateTime;
public void setUpdateTime(Date updateTime) {
this.updateTime = updateTime;
public String toString() {
return "Sample{"
"createTime=" + createTime
", id=" + id
", name='" + name + '''
", desc='" + desc + '''
", updateTime=" + updateTime
double nanos = statement.getLastExecuteTimeNano();
double millis = nanos / (1000 * 1000);
double nanos = statement.getLastExecuteTimeNano();
double millis = nanos / (1000 * 1000);
double nanos = statement.getLastExecuteTimeNano();
double millis = nanos / (1000 * 1000);
double nanos = statement.getLastExecuteTimeNano();
double millis = nanos / (1000 * 1000);
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
public class LogFilterTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:derby:classpath:petstore-db");
dataSource.setFilters("log4j");
public void test_select() throws Exception {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
for (int i = 0; i < 10; ++i) {
ResultSet rs = stmt.executeQuery("SELECT * FROM ITEM WHERE LISTPRICE > 10");
rs.close();
stmt.close();
conn.close();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
+ millis + " millis. " + sql);
+ "} batch executed. " + millis + " millis. " + sql);
+ resultSet.getId() + "} query executed. " + millis + " millis. " + sql);
+ "} update executed. effort " + updateCount + ". " + millis + " millis. " + sql);
public class LogFilterTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:derby:classpath:petstore-db");
dataSource.setFilters("log4j");
public void test_select() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM ITEM WHERE LISTPRICE > 10");
for (int i = 0; i < 10; ++i) {
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
dataSource.setFilters("log4j");
if (activeCount <= 0) {
empty.signal();
JdbcUtils.close(dataSource);
public class DiscardTest extends TestCase {
private DruidDataSource  dataSource;
private MockDriver       driver;
private volatile boolean failed = false;
protected void setUp() throws Exception {
driver = new MockDriver() {
public ResultSet executeQuery(MockStatementBase stmt, String sql) throws SQLException {
if (failed) {
throw new SQLException("", "", 1040);
return super.executeQuery(stmt, sql);
public Connection connect(String url, Properties info) throws SQLException {
while (failed) {
Thread.sleep(1);
} catch (InterruptedException e) {
throw new SQLException(e.getMessage(), e);
return super.connect(url, info);
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setDriver(driver);
dataSource.setDbType("mysql");
dataSource.setMinIdle(1);
dataSource.setMaxActive(1);
dataSource.setFilters("log4j");
dataSource.setExceptionSorter(new MySqlExceptionSorter());
protected void tearDown() throws Exception {
dataSource.close();
public void test_db_fail() throws Exception {
final int THREAD_COUNT = 10;
final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);
Thread[] threads = new Thread[THREAD_COUNT];
Exception error = null;
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
for (int i = 0; i < THREAD_COUNT; ++i) {
threads[i] = new Thread() {
public void run() {
} finally {
endLatch.countDown();
threads[i].start();
this.failed = true;
ResultSet rs = stmt.executeQuery("select 1");
rs.close();
} catch (SQLException e) {
error = e;
stmt.close();
conn.close();
Assert.assertNotNull(error);
this.failed = false;
endLatch.await();
private void exec() {
Connection conn = null;
Statement stmt = null;
ResultSet rs = null;
conn = dataSource.getConnection();
stmt = conn.createStatement();
rs = stmt.executeQuery("select 1");
} catch (Exception ex) {
ex.printStackTrace();
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
JdbcUtils.close(conn);
public final static int RevisionVersion = 10;
public boolean isWrapperFor(Class<?> iface) {
public <T> T unwrap(Class<T> iface) {
public class DruidConnectionProvider implements ConnectionProvider, Configurable, Stoppable {
private static final long serialVersionUID = 1026193803901107651L;
private DruidDataSource   dataSource;
@SuppressWarnings("rawtypes")
public boolean isUnwrappableAs(Class unwrapType) {
return dataSource.isWrapperFor(unwrapType);
public <T> T unwrap(Class<T> unwrapType) {
return dataSource.unwrap(unwrapType);
public Connection getConnection() throws SQLException {
return dataSource.getConnection();
public void closeConnection(Connection conn) throws SQLException {
conn.close();
public boolean supportsAggressiveRelease() {
return false;
@SuppressWarnings("rawtypes")
public void configure(Map configurationValues) {
DruidDataSourceFactory.config(dataSource, configurationValues);
} catch (SQLException e) {
throw new IllegalArgumentException("config error", e);
public void stop() {
dataSource.close();
oracleValidationQueryCheck();
} else if (JdbcUtils.DB2.equals(dbType)) {
db2ValidationQueryCheck();
private void oracleValidationQueryCheck() {
if (validationQuery == null) {
if (validationQuery.length() == 0) {
SQLStatementParser sqlStmtParser = SQLParserUtils.createSQLStatementParser(validationQuery, this.dbType);
List<SQLStatement> stmtList = sqlStmtParser.parseStatementList();
if (stmtList.size() != 1) {
SQLStatement stmt = stmtList.get(0);
if (!(stmt instanceof SQLSelectStatement)) {
SQLSelectQuery query = ((SQLSelectStatement) stmt).getSelect().getQuery();
if (query instanceof SQLSelectQueryBlock) {
if (((SQLSelectQueryBlock) query).getFrom() == null) {
LOG.error("invalid oracle validationQuery. " + validationQuery + ", may should be : " + validationQuery
+ " FROM DUAL");
private void db2ValidationQueryCheck() {
if (validationQuery == null) {
if (validationQuery.length() == 0) {
SQLStatementParser sqlStmtParser = SQLParserUtils.createSQLStatementParser(validationQuery, this.dbType);
List<SQLStatement> stmtList = sqlStmtParser.parseStatementList();
if (stmtList.size() != 1) {
SQLStatement stmt = stmtList.get(0);
if (!(stmt instanceof SQLSelectStatement)) {
SQLSelectQuery query = ((SQLSelectStatement) stmt).getSelect().getQuery();
if (query instanceof SQLSelectQueryBlock) {
if (((SQLSelectQueryBlock) query).getFrom() == null) {
LOG.error("invalid db2 validationQuery. " + validationQuery + ", may should be : " + validationQuery
+ " FROM SYSDUMMY");
public class ValidationQueryLogDB2Test extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDbType(JdbcConstants.DB2);
dataSource.setDriver(new MockDriver() {
public int getMajorVersion() {
return 10;
dataSource.setValidationQuery("SELECT 'x'");
protected void tearDown() throws Exception {
dataSource.close();
public void test_oracle() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log log = (Log) field.get(null);
Assert.assertEquals(1, log.getErrorCount());
public class ValidationQueryLogTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDbType(JdbcConstants.ORACLE);
dataSource.setDriver(new MockDriver() {
public int getMajorVersion() {
return 10;
dataSource.setValidationQuery("SELECT 'x'");
protected void tearDown() throws Exception {
dataSource.close();
public void test_oracle() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log log = (Log) field.get(null);
Assert.assertEquals(1, log.getErrorCount());
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log log = (Log) field.get(null);
log.resetStat();
Field field = DruidDataSource.class.getDeclaredField("LOG");
field.setAccessible(true);
Log log = (Log) field.get(null);
log.resetStat();
throw new SQLException("connect error, url " + url + ", driverClass " + this.driverClass);
if (JdbcUtils.MYSQL.equals(dbType) || JdbcUtils.H2.equals(dbType)) {
public void test_druid() throws Exception {
public void f_test_1() throws Exception {
public void f_test_2() throws Exception {
public void f_test_c3p0() throws Exception {
ComboPooledDataSource dataSource = new ComboPooledDataSource();
dataSource.setMinPoolSize(minIdle);
dataSource.setMaxPoolSize(maxIdle);
dataSource.setDriverClass(driverClass);
dataSource.setJdbcUrl(jdbcUrl);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < LOOP_COUNT; ++i) {
p0(dataSource, "c3p0");
System.out.println();
public void f_test_proxool() throws Exception {
ProxoolDataSource dataSource = new ProxoolDataSource();
dataSource.setMinimumConnectionCount(minIdle);
dataSource.setMaximumConnectionCount(maxIdle);
dataSource.setDriver(driverClass);
dataSource.setDriverUrl(jdbcUrl);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < LOOP_COUNT; ++i) {
p0(dataSource, "proxool");
System.out.println();
public void f_test_tomcat_jdbc() throws Exception {
org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
dataSource.setMinIdle(minIdle);
dataSource.setMaxActive(maxIdle);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
for (int i = 0; i < LOOP_COUNT; ++i) {
p0(dataSource, "tomcat-jdbc");
System.out.println();
Statement stmt = conn.createStatement();
private int    threadCount     = 2;
private int    loopCount       = 5;
final int      LOOP_COUNT      = 1000 * 500;
jdbcUrl = "jdbc:h2:mem:";
driverClass = "org.h2.Driver";
public void test_druid() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
public void test_dbcp() throws Exception {
public void test_bonecp() throws Exception {
public void test_c3p0() throws Exception {
ComboPooledDataSource dataSource = new ComboPooledDataSource();
dataSource.setMinPoolSize(minPoolSize);
dataSource.setMaxPoolSize(maxPoolSize);
dataSource.setDriverClass(driverClass);
dataSource.setJdbcUrl(jdbcUrl);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "c3p0", threadCount);
System.out.println();
public void test_proxool() throws Exception {
ProxoolDataSource dataSource = new ProxoolDataSource();
dataSource.setMinimumConnectionCount(minPoolSize);
dataSource.setMaximumConnectionCount(maxPoolSize);
dataSource.setDriver(driverClass);
dataSource.setDriverUrl(jdbcUrl);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "proxool", threadCount);
System.out.println();
public void test_tomcat_jdbc() throws Exception {
org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
dataSource.setMaxIdle(maxPoolSize);
dataSource.setMinIdle(minPoolSize);
dataSource.setMaxActive(maxPoolSize);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "tomcat-jdbc", threadCount);
System.out.println();
private int    threadCount     = 1;
private int    loopCount       = 10;
final int      LOOP_COUNT      = 1000 * 1000 * 1 / threadCount;
if (dataSource != null && dataSource.getDbType() != null) {
this.dbType = dataSource.getDbType();
this.dbType = JdbcUtils.getDbType(dataSource.getRawJdbcUrl(), "");
public class SpringIbatisBeanTypeAutoProxyCreator extends AbstractAutoProxyCreator implements SpringIbatisBeanTypeAutoProxyCreatorMBean {
ref.add(new StringRefAddr("url", this.getUrl()));
ref.add(new StringRefAddr("username", this.getUsername()));
ref.add(new StringRefAddr("password",this.getPassword()));
if ((!"javax.sql.DataSource".equals(ref.getClassName())) 
&& (!"com.alibaba.druid.pool.DruidDataSource".equals(ref.getClassName())) 
return null;
private boolean             allowDoPrivileged          = false;
public boolean isAllowDoPrivileged() {
return allowDoPrivileged;
public void setAllowDoPrivileged(boolean allowDoPrivileged) {
this.allowDoPrivileged = allowDoPrivileged;
if (config.isAllowDoPrivileged() && privileged.get() == Boolean.TRUE) {
final WallConfig config = new WallConfig();
config.setAllowDoPrivileged(true);
Assert.assertTrue(WallUtils.isValidateMySql("select @@version_compile_os", config));
@SuppressWarnings({ "serial", "deprecation" })
public class SpringIbatisBeanNameAutoProxyCreator extends BeanNameAutoProxyCreator implements SpringIbatisBeanNameAutoProxyCreatorMBean {
private final static Log   LOG            = LogFactory.getLog(SpringIbatisBeanNameAutoProxyCreator.class);
private final List<String> proxyBeanNames = new ArrayList<String>();
public List<String> getProxyBeanNames() {
return proxyBeanNames;
@SuppressWarnings("rawtypes")
protected Object createProxy(Class beanClass, String beanName, Object[] specificInterceptors,
TargetSource targetSource) {
Object target = targetSource.getTarget();
if (target instanceof SqlMapClientWrapper) {
proxyBeanNames.add(beanName);
return target;
if (target instanceof SqlMapClient) {
proxyBeanNames.add(beanName);
return new SqlMapClientWrapper((ExtendedSqlMapClient) target);
return super.createProxy(beanClass, beanName, specificInterceptors, targetSource);
} catch (Throwable ex) {
LOG.error(ex.getMessage(), ex);
return super.createProxy(beanClass, beanName, specificInterceptors, targetSource);
public interface SpringIbatisBeanNameAutoProxyCreatorMBean {
List<String> getProxyBeanNames();
Assert.assertEquals("SELECT *" + 
"nFROM offer a" + 
"ntSTRAIGHT_JOIN wp_image b USE INDEX FOR JOIN (t1, t2) ON a.member_id = b.member_id" + 
"ntINNER JOIN product_visit c" + 
"nWHERE a.member_id = c.member_idn" + 
"tAND c.member_id = 'abc'", output);
Assert.assertEquals("SELECT DISTINCT HIGH_PRIORITY tb1.id, tb2.idnFROM tb1, tb2nWHERE tb1.id2 = tb2.id2",
Assert.assertEquals("SELECT DISTINCTROW HIGH_PRIORITY SQL_SMALL_RESULT tb1.id, tb2.idnFROM tb1, tb2nWHERE tb1.id2 = tb2.id2",
Assert.assertEquals("SELECT DISTINCT HIGH_PRIORITY tb1.id, tb2.idnFROM tb1, tb2nWHERE tb1.id2 = tb2.id2",
String sql = "SELect distinctrow high_priority sql_small_result tb1.id,tb2.id "
+ "from tb1,tb2 where tb1.id2=tb2.id2";
Assert.assertEquals("SELECT DISTINCTROW HIGH_PRIORITY SQL_SMALL_RESULT tb1.id, tb2.idnFROM tb1, tb2nWHERE tb1.id2 = tb2.id2",
Assert.assertEquals("SELECT SQL_CACHE id1, MAX(id2)nFROM tb1nGROUP BY id1nHAVING id1 > 10nORDER BY id3 DESC",
+ "from tb1,tb2 where tb1.id2=tb2.id2";
Assert.assertEquals("SELECT DISTINCT id1, id2nFROM tb1, tb2nWHERE tb1.id1 = tb2.id2nLOCK IN SHARE MODE",
Assert.assertEquals("SELECT t1.id, t2.*nFROM t1, test.t2nWHERE test.t1.id = ''''ntAND t1.id = test.t2.id",
Assert.assertEquals("SELECT *" + 
"nFROM offer a" + 
"ntSTRAIGHT_JOIN wp_image b FORCE INDEX FOR JOIN (t1, t2) ON a.member_id = b.member_id" + 
"ntINNER JOIN product_visit c" + 
"nWHERE a.member_id = c.member_id" + 
"ntAND c.member_id = 'abc'", output);
Assert.assertEquals("SELECT *n" + 
"FROM offer a" + 
"ntSTRAIGHT_JOIN wp_image b IGNORE INDEX FOR JOIN (t1, t2) ON a.member_id = b.member_id" + 
"ntINNER JOIN product_visit c" + 
"nWHERE a.member_id = c.member_id" + 
"ntAND c.member_id = 'abc'", output);
Assert.assertEquals("DELETE t1" + 
"nFROM t1" + 
"ntLEFT JOIN t2 ON t1.id = t2.id" + 
"nWHERE t2.id IS NULL;", text);
Assert.assertEquals("DELETE a1, a2nFROM t1 a1" + 
"ntINNER JOIN t2 a2" + 
"nWHERE a1.id = a2.id;", text);
Assert.assertEquals("DELETE FROM a1, a2nUSING t1 a1" + 
"ntINNER JOIN t2 a2nWHERE a1.id = a2.id;", text);
+ "nFROM Sales.SalesPerson s"
+ "ntINNER JOIN Person.Contact c ON s.SalesPersonID = c.ContactID"
+ "ntINNER JOIN Person.Address a ON a.AddressID = c.ContactID" 
public void test_jobss() throws Exception {
LocalTxDataSourceDO dataSourceDO = new LocalTxDataSourceDO();
dataSourceDO.setBlockingTimeoutMillis(1000 * 60);
dataSourceDO.setMaxPoolSize(maxPoolSize);
dataSourceDO.setMinPoolSize(minPoolSize);
dataSourceDO.setDriverClass(driverClass);
dataSourceDO.setConnectionURL(jdbcUrl);
dataSourceDO.setUserName(user);
dataSourceDO.setPassword(password);
LocalTxDataSource tx = TaobaoDataSourceFactory.createLocalTxDataSource(dataSourceDO);
DataSource dataSource = tx.getDatasource();
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "jboss-datasource", threadCount);
System.out.println();
private String            jdbcUrl;
private String            user;
private String            password;
private String            driverClass;
private int               initialSize      = 10;
private int               minPoolSize      = 10;
private int               maxPoolSize      = 50;
private int               maxActive        = 50;
private String            validationQuery  = "SELECT 1";
private int               threadCount      = 5;
private int               loopCount        = 10;
final int                 LOOP_COUNT       = 1000 * 1000 * 1 / threadCount;
private static AtomicLong physicalConnStat = new AtomicLong();
public static class TestDriver extends MockDriver {
public static TestDriver instance = new TestDriver();
public boolean acceptsURL(String url) throws SQLException {
if (url.startsWith("jdbc:test:")) {
return true;
return super.acceptsURL(url);
public Connection connect(String url, Properties info) throws SQLException {
physicalConnStat.incrementAndGet();
return super.connect("jdbc:mock:case1", info);
DriverManager.registerDriver(TestDriver.instance);
jdbcUrl = "jdbc:test:case1:";
driverClass = "com.alibaba.druid.benckmark.pool.Case1$TestDriver";
physicalConnStat.set(0);
LocalTxDataSourceDO dataSourceDO = new LocalTxDataSourceDO();
dataSourceDO.setBlockingTimeoutMillis(1000 * 60);
dataSourceDO.setMaxPoolSize(maxPoolSize);
dataSourceDO.setMinPoolSize(minPoolSize);
dataSourceDO.setDriverClass(driverClass);
dataSourceDO.setConnectionURL(jdbcUrl);
dataSourceDO.setUserName(user);
dataSourceDO.setPassword(password);
dataSource.setMaxIdle(maxPoolSize);
+ " blocked "
+ NumberFormat.getInstance().format(blockedCount) 
+ " waited " + NumberFormat.getInstance().format(waitedCount) + " physicalConn "
+ physicalConnStat.get());
final int       LOOP_COUNT      = (1000 * 100) / executeCount;
final AtomicLong blockedStat = new AtomicLong();
final AtomicLong waitedStat = new AtomicLong();
long threadId = Thread.currentThread().getId();
long startBlockedCount, startWaitedCount;
ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(threadId);
startBlockedCount = threadInfo.getBlockedCount();
startWaitedCount = threadInfo.getWaitedCount();
ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(threadId);
long blockedCount = threadInfo.getBlockedCount() - startBlockedCount;
long waitedCount = threadInfo.getWaitedCount() - startWaitedCount;
blockedStat.addAndGet(blockedCount);
waitedStat.addAndGet(waitedCount);
+ NumberFormat.getInstance().format(millis) + ", YGC " + ygc + " FGC " + fullGC
+ " blockedCount " + blockedStat.get() + " waitedCount " + waitedStat.get());
Key fakePublicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
cipher.init(Cipher.ENCRYPT_MODE, fakePublicKey);
private boolean             noneBaseStatementAllow     = false;
private boolean             callAllow                  = true;
private boolean             selelctAllow               = true;
private boolean             selectIntoAllow            = true;
private boolean             selectIntoOutfileAllow     = false;
private boolean             selectWhereAlwayTrueCheck  = true;
private boolean             selectHavingAlwayTrueCheck = true;
private boolean             selectUnionCheck           = true;
private boolean             deleteAllow                = true;
private boolean             deleteWhereAlwayTrueCheck  = true;
private boolean             updateAllow                = true;
private boolean             updateWhereAlayTrueCheck   = true;
private boolean             insertAllow                = true;
private boolean             mergeAllow                 = true;
private boolean             multiStatementAllow        = false;
private boolean             truncateAllow              = false;
private boolean             commentAllow               = false;
private boolean             schemaCheck                = true;
private boolean             tableCheck                 = true;
private boolean             functionCheck              = true;
private boolean             objectCheck                = true;
private boolean             variantCheck               = true;
private boolean             mustParameterized          = false;
private boolean             allowDoPrivileged          = false;
protected final Set<String> permitFunctions            = new HashSet<String>();
protected final Set<String> permitTables               = new HashSet<String>();
protected final Set<String> permitSchemas              = new HashSet<String>();
protected final Set<String> permitVariants             = new HashSet<String>();
protected final Set<String> permitObjects              = new HashSet<String>();
protected final Set<String> readOnlyTables             = new HashSet<String>();
private String              dir;
private boolean             inited;
private String              tenantTablePattern;
private String              tenantColumn;
private boolean             wrapAllow                  = false;
public WallConfig(){
public String getTenantTablePattern() {
return tenantTablePattern;
public void setTenantTablePattern(String tenantTablePattern) {
this.tenantTablePattern = tenantTablePattern;
public String getTenantColumn() {
return tenantColumn;
public void setTenantColumn(String tenantColumn) {
this.tenantColumn = tenantColumn;
public boolean isWrapAllow() {
return wrapAllow;
public void setWrapAllow(boolean wrapAllow) {
this.wrapAllow = wrapAllow;
public boolean isAllowDoPrivileged() {
return allowDoPrivileged;
public void setAllowDoPrivileged(boolean allowDoPrivileged) {
this.allowDoPrivileged = allowDoPrivileged;
public boolean isInited() {
return inited;
public WallConfig(String dir){
this.dir = dir;
this.init();
public String getDir() {
return dir;
public void setDir(String dir) {
this.dir = dir;
public final void init() {
loadConfig(dir);
public void loadConfig(String dir) {
if (dir.endsWith("/")) {
dir = dir.substring(0, dir.length() - 1);
loadResource(this.permitVariants, dir + "/permit-variant.txt");
loadResource(this.permitSchemas, dir + "/permit-schema.txt");
loadResource(this.permitFunctions, dir + "/permit-function.txt");
loadResource(this.permitTables, dir + "/permit-table.txt");
loadResource(this.permitObjects, dir + "/permit-object.txt");
loadResource(this.readOnlyTables, dir + "/readonly-table.txt");
public boolean isNoneBaseStatementAllow() {
return noneBaseStatementAllow;
public void setNoneBaseStatementAllow(boolean noneBaseStatementAllow) {
this.noneBaseStatementAllow = noneBaseStatementAllow;
public boolean isTruncateAllow() {
return truncateAllow;
public void setTruncateAllow(boolean truncateAllow) {
this.truncateAllow = truncateAllow;
public boolean isSelelctAllow() {
return selelctAllow;
public void setSelelctAllow(boolean selelctAllow) {
this.selelctAllow = selelctAllow;
public boolean isSelectIntoAllow() {
return selectIntoAllow;
public void setSelectIntoAllow(boolean selectIntoAllow) {
this.selectIntoAllow = selectIntoAllow;
public boolean isSelectIntoOutfileAllow() {
return selectIntoOutfileAllow;
public void setSelectIntoOutfileAllow(boolean selectIntoOutfileAllow) {
this.selectIntoOutfileAllow = selectIntoOutfileAllow;
public boolean isSelectUnionCheck() {
return selectUnionCheck;
public void setSelectUnionCheck(boolean selectUnionCheck) {
this.selectUnionCheck = selectUnionCheck;
public boolean isSelectWhereAlwayTrueCheck() {
return selectWhereAlwayTrueCheck;
public void setSelectWhereAlwayTrueCheck(boolean selectWhereAlwayTrueCheck) {
this.selectWhereAlwayTrueCheck = selectWhereAlwayTrueCheck;
public boolean isSelectHavingAlwayTrueCheck() {
return selectHavingAlwayTrueCheck;
public void setSelectHavingAlwayTrueCheck(boolean selectHavingAlwayTrueCheck) {
this.selectHavingAlwayTrueCheck = selectHavingAlwayTrueCheck;
public boolean isDeleteAllow() {
return deleteAllow;
public void setDeleteAllow(boolean deleteAllow) {
this.deleteAllow = deleteAllow;
public boolean isDeleteWhereAlwayTrueCheck() {
return deleteWhereAlwayTrueCheck;
public void setDeleteWhereAlwayTrueCheck(boolean deleteWhereAlwayTrueCheck) {
this.deleteWhereAlwayTrueCheck = deleteWhereAlwayTrueCheck;
public boolean isUpdateAllow() {
return updateAllow;
public void setUpdateAllow(boolean updateAllow) {
this.updateAllow = updateAllow;
public boolean isUpdateWhereAlayTrueCheck() {
return updateWhereAlayTrueCheck;
public void setUpdateWhereAlayTrueCheck(boolean updateWhereAlayTrueCheck) {
this.updateWhereAlayTrueCheck = updateWhereAlayTrueCheck;
public boolean isInsertAllow() {
return insertAllow;
public void setInsertAllow(boolean insertAllow) {
this.insertAllow = insertAllow;
public boolean isMergeAllow() {
return mergeAllow;
public void setMergeAllow(boolean mergeAllow) {
this.mergeAllow = mergeAllow;
public boolean isMultiStatementAllow() {
return multiStatementAllow;
public void setMultiStatementAllow(boolean multiStatementAllow) {
this.multiStatementAllow = multiStatementAllow;
public boolean isSchemaCheck() {
return schemaCheck;
public void setSchemaCheck(boolean schemaCheck) {
this.schemaCheck = schemaCheck;
public boolean isTableCheck() {
return tableCheck;
public void setTableCheck(boolean tableCheck) {
this.tableCheck = tableCheck;
public boolean isFunctionCheck() {
return functionCheck;
public void setFunctionCheck(boolean functionCheck) {
this.functionCheck = functionCheck;
public boolean isVariantCheck() {
return variantCheck;
public void setVariantCheck(boolean variantCheck) {
this.variantCheck = variantCheck;
public boolean isObjectCheck() {
return objectCheck;
public void setObjectCheck(boolean objectCheck) {
this.objectCheck = objectCheck;
public boolean isCommentAllow() {
return commentAllow;
public void setCommentAllow(boolean commentAllow) {
this.commentAllow = commentAllow;
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitVariants() {
return permitVariants;
public Set<String> getPermitObjects() {
return permitObjects;
public Set<String> getReadOnlyTables() {
return readOnlyTables;
public boolean isMustParameterized() {
return mustParameterized;
public void setMustParameterized(boolean mustParameterized) {
this.mustParameterized = mustParameterized;
public boolean isPermitObjects(String name) {
if (!objectCheck) {
return false;
name = WallVisitorUtils.form(name);
return permitObjects.contains(name);
public boolean isPermitSchema(String name) {
if (!schemaCheck) {
return false;
name = WallVisitorUtils.form(name);
return this.permitSchemas.contains(name);
public boolean isPermitFunction(String name) {
if (!functionCheck) {
return false;
name = WallVisitorUtils.form(name);
return this.permitFunctions.contains(name);
public boolean isCallAllow() {
return callAllow;
public void setCallAllow(boolean callAllow) {
this.callAllow = callAllow;
@Override
public boolean isWrapperFor(FilterChain chain, Wrapper wrapper, Class<?> iface) throws SQLException {
if (!this.provider.getConfig().isWrapAllow()) {
return false;
return chain.isWrapperFor(wrapper, iface);
@Override
public <T> T unwrap(FilterChain chain, Wrapper wrapper, Class<T> iface) throws SQLException {
if (!this.provider.getConfig().isWrapAllow()) {
return null;
return chain.unwrap(wrapper, iface);
lastExecuteSql = sql;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
lastExecuteSql = sql;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
updateCount = null;
lastExecuteSql = sql;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
protected long                 lastExecuteStartNano;
protected long                 lastExecuteTimeNano;
if (lexer.token() == Token.LPAREN) {
return null;
private boolean             selectAllColumnAllow       = true;
public boolean isSelectAllColumnAllow() {
return selectAllColumnAllow;
public void setSelectAllColumnAllow(boolean selectAllColumnAllow) {
this.selectAllColumnAllow = selectAllColumnAllow;
@Override
public boolean visit(SQLSelectItem x) {
WallVisitorUtils.check(this, x);
return true;
@Override
public boolean visit(SQLSelectItem x) {
WallVisitorUtils.check(this, x);
return true;
@Override
public boolean visit(SQLServerSelectQueryBlock x) {
WallVisitorUtils.checkSelelct(this, x);
return true;
@Override
public boolean visit(SQLSelectItem x) {
WallVisitorUtils.check(this, x);
return true;
public static void check(WallVisitor visitor, SQLSelectItem x) {
if (visitor.getConfig().isSelectAllColumnAllow()) {
if (x.getExpr() instanceof SQLAllColumnExpr 
&& x.getParent() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) x.getParent();
SQLTableSource from = queryBlock.getFrom();
if (from instanceof SQLExprTableSource) {
addViolation(visitor, x);
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
checkJoinConditionForMultiTenant(visitor, join, false);
SQLTableSource right = join.getRight();
public class PGSelectTest6 extends PGTest {
public void test_0() throws Exception {
String sql = "select fromUserId, toMemberId, rank, tag " + 
"from cnres.function_get_re_cni_myali_acion_fct0(?) " + 
"as (fromUserId character varying(128), toMemberId character varying(128), rank numeric, tag character varying(128))";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getTables().size());
public class WallAllowSelectAllColumnDefaultTest extends TestCase {
private String sql = "select * from t where fid = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testSQLServer() throws Exception {
Assert.assertTrue(WallUtils.isValidateSqlServer(sql, config));
public class WallAllowSelectAllColumnTest extends TestCase {
private String sql = "select * from t where fid = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setSelectAllColumnAllow(false);
public void testMySql() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testSQLServer() throws Exception {
Assert.assertFalse(WallUtils.isValidateSqlServer(sql, config));
public class WallAllowSelectAllColumnTest1 extends TestCase {
private String sql = "select count(*) from t where fid = ?";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setSelectAllColumnAllow(false);
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testSQLServer() throws Exception {
Assert.assertTrue(WallUtils.isValidateSqlServer(sql, config));
public class WallAllowSelectAllColumnTest2 extends TestCase {
private String sql = "select * from (select id, name from t where fid = ?) as a";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setSelectAllColumnAllow(false);
public void testMySql() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testSQLServer() throws Exception {
Assert.assertTrue(WallUtils.isValidateSqlServer(sql, config));
private final AtomicLong violationCount = new AtomicLong();
violationCount.incrementAndGet();
public long getViolationCount() {
return this.violationCount.get();
long getViolationCount();
private boolean             metadataAllow              = true;
public boolean isMetadataAllow() {
return metadataAllow;
public void setMetadataAllow(boolean metadataAllow) {
this.metadataAllow = metadataAllow;
violationCount.incrementAndGet();
@Override
public DatabaseMetaData connection_getMetaData(FilterChain chain, ConnectionProxy connection) throws SQLException {
if (config.isAllowDoPrivileged() && WallProvider.ispPivileged()) {
return chain.connection_getMetaData(connection);
if (!this.provider.getConfig().isMetadataAllow()) {
violationCount.incrementAndGet();
if (isLogViolation()) {
LOG.error("not support method : Connection.getMetdataData");
if (throwException) {
throw new WallSQLException("not support method : Connection.getMetdataData");
return chain.connection_getMetaData(connection);
if (defaultRowPretch != holder.getDefaultRowPretch()) {
holder.setDefaultRowPretch(defaultRowPretch);
holder.setRowPrefetch(defaultRowPretch);
private final static Log LOG = LogFactory.getLog(OracleUtils.class);
if (oracleStmt == null) {
return -1;
if (oracleStmt != null) {
oracleStmt.setRowPrefetch(value);
if (oracleStmt != null) {
oracleStmt.enterImplicitCache();
if (oracleStmt != null) {
oracleStmt.exitImplicitCacheToClose();
if (oracleStmt != null) {
oracleStmt.exitImplicitCacheToActive();
OraclePreparedStatement unwrapped = stmt.unwrap(OraclePreparedStatement.class);
if (unwrapped == null) {
LOG.error("can not unwrap statement : " + stmt.getClass());
return unwrapped;
private boolean             wrapAllow                  = true;
public class TestOracleWall extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setOracle(true);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(new OracleMockDriver());
dataSource.setPoolPreparedStatements(true);
dataSource.setConnectionProperties("defaultRowPrefetch=50");
dataSource.setFilters("stat,wall");
dataSource.setDbType("oracle");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_oracle() throws Exception {
String sql = "SELECT 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getCachedPreparedStatementCount());
public class TestOracleWall2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
WallFilter wall = new WallFilter();
wall.setConfig(new WallConfig());
wall.getConfig().setWrapAllow(false);
dataSource.setOracle(true);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDriver(new OracleMockDriver());
dataSource.setPoolPreparedStatements(true);
dataSource.setConnectionProperties("defaultRowPrefetch=50");
dataSource.setFilters("stat");
dataSource.getProxyFilters().add(wall);
dataSource.setDbType("oracle");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_oracle() throws Exception {
String sql = "SELECT 1";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
for (int i = 0; i < 10; ++i) {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
rs.next();
rs.close();
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getCachedPreparedStatementCount());
@Override
public int getMajorVersion() {
return 11;
@Override
public int getMinorVersion() {
return 0;
private boolean             describeAllow              = false;
public boolean isDescribeAllow() {
return describeAllow;
public void setDescribeAllow(boolean describeAllow) {
this.describeAllow = describeAllow;
} else if (x instanceof MySqlDescribeStatement) {
allow = config.isDescribeAllow();
public class MySqlWallDescribteTest extends TestCase {
public void test_allow() throws Exception {
WallConfig config = new WallConfig();
config.setDescribeAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql("describe t", config));
public void test_not_allow() throws Exception {
WallConfig config = new WallConfig();
config.setVariantCheck(true);
Assert.assertFalse(WallUtils.isValidateMySql("describe t", config));
case LITERAL_ALIAS:
sqlExpr = new SQLIdentifierExpr('"' + lexer.stringVal() + '"');
lexer.nextToken();
public class PGSelectTest7 extends PGTest {
public void test_0() throws Exception {
String sql = "select id, name, parameters, "algModuleRule.id", "algModuleRule.name"" + 
", "algModuleRule.assembleType", "algModuleRule.algmIds", "algModuleRule.subAlgmIds"" + 
", "algModuleRule.algmRatio", "algModuleRule.algmMaxRatio", "algModuleRule.objectType"" + 
", "cateRule.id", "cateRule.name", "cateRule.assembleType", "cateRule.algmIds"" + 
", "cateRule.algmRatio", "cateRule.algmMaxRatio", "appObject.id","appObject.name"" + 
", "appObject.beanId" " + 
"from cnres.function_select_irecom_scene()" + 
" as a( id text,name text,parameters text, "algModuleRule.id" text,"algModuleRule.name" text" + 
"    , "algModuleRule.assembleType" text,"algModuleRule.algmIds" text" + 
"    , "algModuleRule.subAlgmIds" text,"algModuleRule.algmRatio" text" + 
"    , "algModuleRule.algmMaxRatio" text, "algModuleRule.objectType" text" + 
"    , "cateRule.id" text, "cateRule.name" text, "cateRule.assembleType" text" + 
"    , "cateRule.algmIds" text, "cateRule.algmRatio" text, "cateRule.algmMaxRatio" text" + 
"    , "appObject.id" text,"appObject.name" text, "appObject.beanId" text)";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(20, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getTables().size());
public class PGSelectTest8 extends PGTest {
public void test_0() throws Exception {
String sql = "select id, name, beanId, "algLable.id", "algLable.name"" + 
", "algLable.schemaName", "algLable.tableName", "algLable.fieldName"" + 
" from cnres.function_select_algmodule_rule() " + 
" as a( id text,name text,beanId text, "algLable.id" text,"algLable.name" text" + 
", "algLable.schemaName" text,"algLable.tableName" text, "algLable.fieldName" text)";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(8, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getTables().size());
String prop = System.getProperty("druid.log.stmt");
if (prop == "false") {
statementLogEnabled = false;
String prop = System.getProperty("druid.log.rs");
if (prop == "false") {
resultSetLogEnabled = false;
private final static Log       LOG = LogFactory.getLog(JtdsXAResource.class);
private String                 rmHost;
private static Method          method;
if (method == null) {
method = connection.getClass().getMethod("getRmHost");
} catch (Exception e) {
LOG.error("getRmHost method error", e);
if (method != null) {
rmHost = (String) method.invoke(connection);
} catch (Exception e) {
LOG.error("getRmHost error", e);
public DruidConnectionProvider(){
dataSource = new DruidDataSource();
public class DruidConnectionProviderTest extends TestCase {
private DruidConnectionProvider provider;
protected void setUp() throws Exception {
provider = new DruidConnectionProvider();
Map properties = new HashMap<String, Object>();
properties.put("url", "jdbc:mock:xxx");
provider.configure(properties);
protected void tearDown() throws Exception {
provider.stop();
public void test_hibernate() throws Exception {
Connection conn = provider.getConnection();
Assert.assertFalse(conn.isClosed());
provider.closeConnection(conn);
Assert.assertTrue(conn.isClosed());
public class MySqlTestSuit extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mysql:
dataSource.setUsername("root");
dataSource.setPassword("root");
dataSource.setFilters("stat,log4j");
dataSource.setValidationQuery("SELECT 1");
dataSource.setTestOnBorrow(false);
dataSource.setTestWhileIdle(true);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_suit() throws Exception {
createTable();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("INSERT INTO T (FID) VALUES (1)");
stmt.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("select * from T where fid = ?");
stmt.setInt(1, 1);
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("INSERT INTO T (FID) VALUES (2)");
stmt.close();
stmt.close();
conn.close();
dropTable();
private void dropTable() throws SQLException {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("DROP TABLE T");
stmt.execute();
conn.close();
stmt.close();
} catch (Exception e) {
e.printStackTrace();
private void createTable() throws SQLException {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("CREATE TABLE IF NOT EXISTS T (FID INT)");
stmt.execute();
conn.close();
stmt.close();
} catch (Exception e) {
e.printStackTrace();
Assert.assertEquals(9, dataSource.getRawDriverMinorVersion());
public final static int RevisionVersion = 11;
if (holder.isPoolPreparedStatements()) {
rawStatement.clearParameters();
} catch (SQLException ex) {
LOG.error("clear parameter error", ex);
private boolean           statementExecutableSqlLogEnable      = false;
String prop = System.getProperty("druid.log.stmt.executableSql");
if (prop == "true") {
statementExecutableSqlLogEnable = true;
public boolean isStatementExecutableSqlLogEnable() {
return statementExecutableSqlLogEnable;
public void setStatementExecutableSqlLogEnable(boolean statementExecutableSqlLogEnable) {
this.statementExecutableSqlLogEnable = statementExecutableSqlLogEnable;
logExecutableSql(statement, sql);
String sql;
if (statement instanceof PreparedStatementProxy) {
sql = ((PreparedStatementProxy) statement).getSql();
sql = statement.getBatchSql();
logExecutableSql(statement, sql);
logExecutableSql(statement, sql);
logExecutableSql(statement, sql);
private void logExecutableSql(StatementProxy statement, String sql) {
if (!isStatementExecutableSqlLogEnable()) {
Map<Integer, JdbcParameter> parameterMap = statement.getParameters();
if (parameterMap == null || parameterMap.size() == 0) {
statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. "
List<Object> parameters = new ArrayList<Object>(parameterMap.size());
for (JdbcParameter jdbcParam : parameterMap.values()) {
parameters.add(jdbcParam.getValue());
String dbType = statement.getConnectionProxy().getDirectDataSource().getDbType();
String formattedSql = SQLUtils.format(sql, dbType, parameters);
statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. "
+ formattedSql);
if (holder == null) {
return format(sql, dbType, null);
public static String format(String sql, String dbType, List<Object> parameters) {
return toSQLString(statementList, dbType, parameters);
return toSQLString(statementList, dbType, null);
public static String toSQLString(List<SQLStatement> statementList, String dbType, List<Object> parameters) {
if (parameters != null) {
visitor.setParameters(parameters);
private List<Object>       parameters;
public List<Object> getParameters() {
if (parameters == null) {
parameters = new ArrayList<Object>();
return parameters;
public void setParameters(List<Object> parameters) {
this.parameters = parameters;
public void print(Date date) {
SimpleDateFormat dateFormat;
if (date instanceof java.sql.Timestamp) {
dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
dateFormat = new SimpleDateFormat("yyyy-MM-dd");
print("'" + dateFormat.format(date) + "'");
int index = x.getIndex();
if (parameters == null || index >= parameters.size()) {
print(x.getName());
return false;
Object param = parameters.get(index);
if (param == null) {
print("NULL");
return false;
if (param instanceof Number 
|| param instanceof Boolean) {
print(param.toString());
return false;
if (param instanceof String) {
SQLCharExpr charExpr = new SQLCharExpr((String) param);
visit(charExpr);
return false;
if (param instanceof Date) {
print((Date) param);
return false;
if (param instanceof InputStream) {
print("'<InputStream>");
return false;
if (param instanceof Reader) {
print("'<Reader>");
return false;
if (param instanceof Blob) {
print("'<Blob>");
return false;
if (param instanceof NClob) {
print("'<NClob>");
return false;
if (param instanceof Clob) {
print("'<Clob>");
return false;
print("'" + param.getClass().getName() + "'");
final int                 LOOP_COUNT       = 1000 * 1 * 1 / threadCount;
public class OracleDropDatabaseLinkStatement extends OracleStatementImpl {
private static final long serialVersionUID = 1L;
private boolean           _public;
private SQLName           name;
public boolean isPublic() {
return _public;
public void setPublic(boolean value) {
this._public = value;
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
boolean isPublic = false;
if (identifierEquals("PUBLIC")) {
lexer.nextToken();
isPublic = true;
if (lexer.token() == Token.DATABASE) {
lexer.nextToken();
if (identifierEquals("LINK")) {
lexer.nextToken();
OracleDropDatabaseLinkStatement stmt = new OracleDropDatabaseLinkStatement();
if (isPublic) {
stmt.setPublic(isPublic);
stmt.setName(this.exprParser.name());
statementList.add(stmt);
continue;
boolean visit(OracleDropDatabaseLinkStatement x);
void endVisit(OracleDropDatabaseLinkStatement x);
@Override
public boolean visit(OracleDropDatabaseLinkStatement x) {
return true;
@Override
public void endVisit(OracleDropDatabaseLinkStatement x) {
@Override
public boolean visit(OracleDropDatabaseLinkStatement x) {
print("DROP ");
if (x.isPublic()) {
print("PUBLIC ");
print("DATABASE LINK ");
x.getName().accept(this);
return false;
@Override
public void endVisit(OracleDropDatabaseLinkStatement x) {
@Override
public boolean visit(OracleDropDatabaseLinkStatement x) {
return false;
@Override
public void endVisit(OracleDropDatabaseLinkStatement x) {
public class OracleDropDbLinkTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP PUBLIC DATABASE LINK remote";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals("DROP PUBLIC DATABASE LINK remote",
SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
public void test_1() throws Exception {
String sql = 
"DROP DATABASE LINK local;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals("DROP DATABASE LINK local",
SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
private String             charSetName;
private String             collate;
private String             charType;
public final static String CHAR_TYPE_BYTE = "BYTE";
public final static String CHAR_TYPE_CHAR = "CHAR";
public String getCharType() {
return charType;
public void setCharType(String charType) {
this.charType = charType;
protected boolean isCharType(String dataTypeName) {
return "varchar2".equalsIgnoreCase(dataTypeName) 
|| "nvarchar2".equalsIgnoreCase(dataTypeName) 
|| "char".equalsIgnoreCase(dataTypeName) 
|| "varchar".equalsIgnoreCase(dataTypeName) 
|| "nchar".equalsIgnoreCase(dataTypeName) 
|| "nvarchar".equalsIgnoreCase(dataTypeName) 
if (isCharType(typeName)) {
SQLCharactorDataType charType = new SQLCharactorDataType(typeName);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
charType.getArguments().add(this.expr());
if (identifierEquals("CHAR")) {
lexer.nextToken();
charType.setCharType(SQLCharactorDataType.CHAR_TYPE_CHAR);
} else if (identifierEquals("BYTE")) {
lexer.nextToken();
charType.setCharType(SQLCharactorDataType.CHAR_TYPE_BYTE);
accept(Token.RPAREN);
return parseCharTypeRest(charType);
SQLDataType dataType = new SQLDataTypeImpl(typeName);
if (isCharType(typeName)) {
SQLCharactorDataType charType = new SQLCharactorDataType(typeName);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
charType.getArguments().add(this.expr());
accept(Token.RPAREN);
return parseCharTypeRest(charType);
protected boolean isCharType(String dataTypeName) {
if (!isCharType(dataType.getName())) {
public class OracleCreateTableTest12 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"create table CARD_MONEYOPERATION (" + 
"ID varchar2(50 char) not null, " + 
"DDBH varchar2(50 char) not null, " + 
"IDNO varchar2(18 char), " + 
"JKKH varchar2(50 char) not null, " + 
"JYDW varchar2(50 char), " + 
"JYJE number(19,2) not null, " + 
"JYNO varchar2(50 char), " + 
"JYZT number(19,0) not null, " + 
"NAME varchar2(10 char), " + 
"OPDATE timestamp, " + 
"REMARK varchar2(50 char), " + 
"TYPE varchar2(20 char) not null, " + 
"OPID varchar2(50 char), " + 
"primary key (ID)" + 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(13, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "ID")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "DDBH")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "IDNO")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "JKKH")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "JYDW")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "JYJE")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "JYNO")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "JYZT")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "NAME")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "OPDATE")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "REMARK")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "TYPE")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("CARD_MONEYOPERATION", "OPID")));
public class OracleCreateTableTest13 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"create table T (" + 
"F1 CHAR(1)," + 
"F2 VARCHAR2(2)," + 
"F3 NCHAR(3), " + 
"F4 NVARCHAR2(4), " + 
"F5 NUMBER (10, 2)," + 
"F6 NUMBER(10)," + 
"F7 FLOAT(126)" + 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F1")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F2")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F3")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F4")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F5")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F6")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F7")));
public class OracleDataTypeIntervalDay extends SQLDataTypeImpl implements OracleSQLObject {
private static final long     serialVersionUID  = 1L;
private boolean               toSecond          = false;
protected final List<SQLExpr> fractionalSeconds = new ArrayList<SQLExpr>();
public OracleDataTypeIntervalDay(){
this.setName("INTERVAL DAY");
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getArguments());
visitor.endVisit(this);
public boolean isToSecond() {
return toSecond;
public void setToSecond(boolean toSecond) {
this.toSecond = toSecond;
public List<SQLExpr> getFractionalSeconds() {
return fractionalSeconds;
public class OracleDataTypeIntervalYear extends SQLDataTypeImpl implements OracleSQLObject {
private static final long serialVersionUID = 1L;
public OracleDataTypeIntervalYear(){
this.setName("INTERVAL YEAR");
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getArguments());
visitor.endVisit(this);
public class OracleDataTypeTimestamp extends SQLDataTypeImpl implements OracleSQLObject {
private static final long serialVersionUID  = 1L;
private boolean           withTimeZone      = false;
private boolean           withLocalTimeZone = false;
public OracleDataTypeTimestamp() {
this.setName("TIMESTAMP");
protected void accept0(SQLASTVisitor visitor) {
this.accept0((OracleASTVisitor) visitor);
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getArguments());
visitor.endVisit(this);
public boolean isWithTimeZone() {
return withTimeZone;
public void setWithTimeZone(boolean withTimeZone) {
this.withTimeZone = withTimeZone;
public boolean isWithLocalTimeZone() {
return withLocalTimeZone;
public void setWithLocalTimeZone(boolean withLocalTimeZone) {
this.withLocalTimeZone = withLocalTimeZone;
if (lexer.token() == Token.INTERVAL) {
lexer.nextToken();
if (identifierEquals("YEAR")) {
lexer.nextToken();
OracleDataTypeIntervalYear interval = new OracleDataTypeIntervalYear();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
interval.getArguments().add(this.expr());
accept(Token.RPAREN);
accept(Token.TO);
acceptIdentifier("MONTH");
return interval;
acceptIdentifier("DAY");
OracleDataTypeIntervalDay interval = new OracleDataTypeIntervalDay();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
interval.getArguments().add(this.expr());
accept(Token.RPAREN);
accept(Token.TO);
acceptIdentifier("SECOND");
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
interval.getFractionalSeconds().add(this.expr());
accept(Token.RPAREN);
return interval;
if ("TIMESTAMP".equalsIgnoreCase(typeName)) {
OracleDataTypeTimestamp timestamp = new OracleDataTypeTimestamp();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
timestamp.getArguments().add(this.expr());
accept(Token.RPAREN);
if (lexer.token() == Token.WITH) {
lexer.nextToken();
if (identifierEquals("LOCAL")) {
lexer.nextToken();
timestamp.setWithLocalTimeZone(true);
timestamp.setWithTimeZone(true);
acceptIdentifier("TIME");
acceptIdentifier("ZONE");
return timestamp;
boolean visit(OracleDataTypeTimestamp x);
void endVisit(OracleDataTypeTimestamp x);
boolean visit(OracleDataTypeIntervalYear x);
void endVisit(OracleDataTypeIntervalYear x);
boolean visit(OracleDataTypeIntervalDay x);
void endVisit(OracleDataTypeIntervalDay x);
@Override
public boolean visit(OracleDataTypeTimestamp x) {
return true;
@Override
public void endVisit(OracleDataTypeTimestamp x) {
@Override
public boolean visit(OracleDataTypeIntervalYear x) {
return true;
@Override
public void endVisit(OracleDataTypeIntervalYear x) {
@Override
public boolean visit(OracleDataTypeIntervalDay x) {
return true;
@Override
public void endVisit(OracleDataTypeIntervalDay x) {
@Override
public boolean visit(OracleDataTypeTimestamp x) {
print(x.getName());
if (x.getArguments().size() > 0) {
print("(");
x.getArguments().get(0).accept(this);
print(")");
if (x.isWithTimeZone()) {
print(" WITH TIME ZONE");
} else if (x.isWithLocalTimeZone()) {
print(" WITH LOCAL TIME ZONE");
return false;
@Override
public void endVisit(OracleDataTypeTimestamp x) {
@Override
public boolean visit(OracleDataTypeIntervalYear x) {
print(x.getName());
if (x.getArguments().size() > 0) {
print("(");
x.getArguments().get(0).accept(this);
print(")");
print(" TO MONTH");
return false;
@Override
public void endVisit(OracleDataTypeIntervalYear x) {
@Override
public boolean visit(OracleDataTypeIntervalDay x) {
print(x.getName());
if (x.getArguments().size() > 0) {
print("(");
x.getArguments().get(0).accept(this);
print(")");
print(" TO SECOND");
if (x.getFractionalSeconds().size() > 0) {
print("(");
x.getFractionalSeconds().get(0).accept(this);
print(")");
return false;
@Override
public void endVisit(OracleDataTypeIntervalDay x) {
@Override
public boolean visit(OracleDataTypeTimestamp x) {
return false;
@Override
public void endVisit(OracleDataTypeTimestamp x) {
@Override
public boolean visit(OracleDataTypeIntervalYear x) {
return false;
@Override
public void endVisit(OracleDataTypeIntervalYear x) {
@Override
public boolean visit(OracleDataTypeIntervalDay x) {
return false;
@Override
public void endVisit(OracleDataTypeIntervalDay x) {
public class OracleCreateTableTest15 extends OracleTest {
public void test_types() throws Exception {
String sql = 
"create table T (" + 
"F1 TIMESTAMP," + 
"F2 TIMESTAMP(9), " + 
"F3 TIMESTAMP WITH TIME ZONE," + 
"F4 TIMESTAMP(9) WITH TIME ZONE, " + 
"F5 TIMESTAMP WITH TIME ZONE," + 
"F6 TIMESTAMP(9) WITH TIME ZONE" + 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TABLE T (" + 
"ntF1 TIMESTAMP," + 
"ntF2 TIMESTAMP(9)," + 
"ntF3 TIMESTAMP WITH TIME ZONE," + 
"ntF4 TIMESTAMP(9) WITH TIME ZONE," + 
"ntF5 TIMESTAMP WITH TIME ZONE," + 
"ntF6 TIMESTAMP(9) WITH TIME ZONE" + 
"n)", SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F1")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F2")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F3")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F4")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F5")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F6")));
public class OracleCreateTableTest16 extends OracleTest {
public void test_types() throws Exception {
String sql = 
"create table T (" + 
"F1 INTERVAL YEAR TO MONTH," + 
"F2 INTERVAL YEAR (3) TO MONTH," + 
"F3 INTERVAL DAY TO SECOND," + 
"F4 INTERVAL DAY (3) TO SECOND," + 
"F5 INTERVAL DAY TO SECOND (9)," + 
"F6 INTERVAL DAY (3) TO SECOND (9)" + 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TABLE T (" + 
"ntF1 INTERVAL YEAR TO MONTH," + 
"ntF2 INTERVAL YEAR(3) TO MONTH," + 
"ntF3 INTERVAL DAY TO SECOND," + 
"ntF4 INTERVAL DAY(3) TO SECOND," + 
"ntF5 INTERVAL DAY TO SECOND(9)," + 
"ntF6 INTERVAL DAY(3) TO SECOND(9)" + 
"n)", SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F1")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F2")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F3")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F4")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F5")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("T", "F6")));
public class OracleDropSequenceStatement extends OracleStatementImpl implements OracleDDLStatement {
private static final long serialVersionUID = 1L;
private SQLName           name;
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
if (identifierEquals("SEQUENCE")) {
lexer.nextToken();
SQLName name = this.exprParser.name();
OracleDropSequenceStatement stmt = new OracleDropSequenceStatement();
stmt.setName(name);
statementList.add(stmt);
continue;
boolean visit(OracleDropSequenceStatement x);
void endVisit(OracleDropSequenceStatement x);
@Override
public boolean visit(OracleDropSequenceStatement x) {
return true;
@Override
public void endVisit(OracleDropSequenceStatement x) {
@Override
public boolean visit(OracleDropSequenceStatement x) {
print("DROP SEQUENCE ");
x.getName().accept(this);
return false;
@Override
public void endVisit(OracleDropSequenceStatement x) {
@Override
public boolean visit(OracleDropSequenceStatement x) {
return false;
@Override
public void endVisit(OracleDropSequenceStatement x) {
public class OracleDropSequenceTest extends OracleTest {
public void test_types() throws Exception {
String sql = 
"DROP SEQUENCE oe.customers_seq";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("DROP SEQUENCE oe.customers_seq", SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public void scanComment() {
if (ch != '/' && ch != '-') {
throw new IllegalStateException();
mark = pos;
bufPos = 0;
scanChar();
if (ch == '*') {
scanChar();
while (ch == ' ') {
scanChar();
boolean isHint = false;
int startHintSp = bufPos + 1;
if (ch == '!') {
isHint = true;
scanChar();
for (;;) {
if (ch == '*' && charAt(pos + 1) == '/') {
bufPos += 2;
scanChar();
scanChar();
scanChar();
if (isHint) {
stringVal = subString(mark + startHintSp, (bufPos - startHintSp) - 1);
token = Token.HINT;
stringVal = subString(mark, bufPos);
token = Token.MULTI_LINE_COMMENT;
if (token != Token.HINT && !isAllowComment()) {
throw new NotAllowCommentException();
if (!isAllowComment()) {
throw new NotAllowCommentException();
if (ch == '/' || ch == '-') {
scanChar();
for (;;) {
if (ch == 'r') {
if (charAt(pos + 1) == 'n') {
bufPos += 2;
scanChar();
} else if (ch == EOI) {
if (ch == 'n') {
scanChar();
scanChar();
stringVal = subString(mark + 1, bufPos);
token = Token.LINE_COMMENT;
withSubquery(select);
public boolean parseStatementListDialect(List<SQLStatement> statementList) {
if (lexer.token() == Token.WITH) {
SQLStatement stmt = parseSelect();
statementList.add(stmt);
return true;
return false;
if (lexer.token() == Token.SELECT) {
SQLSelectParser selectParser = createSQLSelectParser();
SQLSelect select = selectParser.select();
return new SQLSelectStatement(select);
public class SQLServerSelectTest6 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "WITH DirReps(ManagerID, DirectReports) AS " + 
"    SELECT ManagerID, COUNT(*) " + 
"    FROM HumanResources.Employee AS e" + 
"    WHERE ManagerID IS NOT NULL" + 
"    GROUP BY ManagerID" + 
"SELECT ManagerID, DirectReports " + 
"FROM DirReps " + 
"ORDER BY ManagerID;";
String expect = "WITH"
"ntDirReps (ManagerID, DirectReports)"
"nttSELECT ManagerID, COUNT(*)"
"nttFROM HumanResources.Employee e"
"nttWHERE ManagerID IS NOT NULL"
"nttGROUP BY ManagerID"
"nSELECT ManagerID, DirectReports"
"nFROM DirReps"
"nORDER BY ManagerID";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerSelectTest7 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "with menu_view as("
"n            select t.*,1 level from sec_portal_menu t where t.parent_id = ?"
"n            union all"
"n            select t.*,level + 1 from sec_portal_menu t , menu_view x where t.parent_id = x.menu_id"
"n        )"
"n        select t.menu_id "id","
"n               t.menu_name "name","
"n               t.parent_id "pId","
"n               case t.level when 1 then 'true' else 'false' end "open","
"n               t.link_type "linkType""
"n                from menu_view t"
"n                where 1=1"
"n                and t.deleted = 0"
"n                --"
"n                AND t.link_type in ('simple','link')"
"n                AND ("
"n                     EXISTS ("
"n                        select p.entity_code from sec_role_auth p where p.entity_code = t.menu_id"
"n                        and p.entity_type = 'menu'"
"n                        and p.role_id in ("
"n                            select r.role_code from sec_role_member rm ,sec_role r where rm.entity_type = 'user'"
"n                            and entity_code = ? --ID"
"n                            and r.role_id = rm.role_id"
"n                            and r.enabled = 1"
"n                            and r.deleted = 0"
"n                        )"
"n                     )"
"n                     or '1'= ? --id"
"n                     or t.need_control = 0"
"n                )"
"n                AND ("
"n                    t.enabled = 1 or '1'= ? --id"
"n                    or t.need_control = 0"
"n                )"
"n        order by t.sort_order";
String expect = "WITH"
"ntmenu_view"
"nttSELECT t.*, 1 AS level"
"nttFROM sec_portal_menu t"
"nttWHERE t.parent_id = ?"
"nttUNION ALL"
"nttSELECT t.*, level + 1"
"nttFROM sec_portal_menu t, menu_view x"
"nttWHERE t.parent_id = x.menu_id"
"nSELECT t.menu_id AS "id", t.menu_name AS "name", t.parent_id AS "pId", CASE t.level WHEN 1 THEN 'true' ELSE 'false' END AS "open", t.link_type AS "linkType""
"nFROM menu_view t"
"nWHERE 1 = 1"
"ntAND t.deleted = 0"
"ntAND t.link_type IN ('simple', 'link')"
"ntAND (EXISTS (SELECT p.entity_code"
"ntttFROM sec_role_auth p"
"ntttWHERE p.entity_code = t.menu_id"
"nttttAND p.entity_type = 'menu'"
"nttttAND p.role_id IN (SELECT r.role_code"
"ntttttFROM sec_role_member rm, sec_role r"
"ntttttWHERE rm.entity_type = 'user'"
"nttttttAND entity_code = ?"
"nttttttAND r.role_id = rm.role_id"
"nttttttAND r.enabled = 1"
"nttttttAND r.deleted = 0))"
"nttOR '1' = ?"
"nttOR t.need_control = 0)"
"ntAND (t.enabled = 1"
"nttOR '1' = ?"
"nttOR t.need_control = 0)"
"nORDER BY t.sort_order";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class MySqlUnionQuery extends SQLUnionQuery implements MySqlObject {
@Override
public boolean visit(MySqlUnionQuery x) {
WallVisitorUtils.checkUnion(this, x);
return true;
public class MySqlWallTest1 extends TestCase {
public MySqlWallTest1(String name){
Assert.assertTrue(WallUtils.isValidateMySql(
"select count(*) from (select DATE_FORMAT(staydate,'%m') as month,sum(a) as addnum,sum(q) as quitnum from (select staydate,1 as a,0 as q from add_person union all select quitdate,0 as a,1 as q from quit_person) t where  (DATE_FORMAT(staydate,'%Y')= ? )  group by DATE_FORMAT(staydate,'%Y-%m'))"));
private SQLServerTop               top;
public SQLServerTop getTop() {
public void setTop(SQLServerTop top) {
public class SQLServerTop extends SQLServerObjectImpl {
private SQLServerTop      top;
private SQLTableSource    from;
public SQLServerTop getTop() {
return top;
public void setTop(SQLServerTop top) {
this.top = top;
acceptChild(visitor, top);
public SQLServerTop parseTop() {
if (lexer.token() == Token.TOP) {
SQLServerTop top = new SQLServerTop();
lexer.nextToken();
boolean paren = false;
if (lexer.token() == Token.LPAREN) {
paren = true;
lexer.nextToken();
top.setExpr(primary());
if (paren) {
accept(Token.RPAREN);
return top;
return null;
protected void scanLBracket() {
mark = pos;
if (buf == null) {
buf = new char[32];
for (;;) {
if (isEOF()) {
lexError("unclosed.str.lit");
ch = charAt(++pos);
if (ch == ']') {
scanChar();
token = IDENTIFIER;
if (bufPos == buf.length) {
putChar(ch);
buf[bufPos++] = ch;
stringVal = subString(mark, bufPos + 2);
SQLServerTop top = new SQLServerTop();
if (lexer.token() == Token.INTO) {
lexer.nextToken();
SQLTableSource into = this.parseTableSource();
queryBlock.setInto((SQLExprTableSource) into);
accept(Token.UPDATE);
SQLServerTop top = this.getExprParser().parseTop();
if (top != null) {
udpateStatement.setTop(top);
SQLTableSource tableSource = this.exprParser.createSelectParser().parseTableSource();
udpateStatement.setTableSource(tableSource);
public SQLServerExprParser getExprParser() {
return (SQLServerExprParser) exprParser;
boolean visit(SQLServerTop x);
void endVisit(SQLServerTop x);
public boolean visit(SQLServerTop x) {
public void endVisit(SQLServerTop x) {
print(' ');
if (x.getInto() != null) {
println();
print("INTO ");
x.getInto().accept(this);
public boolean visit(SQLServerTop x) {
boolean paren = false;
if (x.getParent() instanceof SQLServerUpdateStatement) {
paren = true;
print("(");
if (paren) {
print(")");
public void endVisit(SQLServerTop x) {
if (x.getTop() != null) {
x.getTop().setParent(x);
x.getTop().accept(this);
print(' ');
public boolean visit(SQLServerTop x) {
public void endVisit(SQLServerTop x) {
scanLBracket();
protected void scanLBracket() {
scanChar();
token = LBRACKET;
println();
public class SQLServerSelectTest10 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT c.FirstName, c.LastName, e.Title, a.AddressLine1, a.City" + 
" , sp.Name AS [State/Province], a.PostalCode" + 
" INTO dbo.EmployeeAddresses" + 
" FROM Person.Contact AS c" + 
" JOIN HumanResources.Employee AS e ON e.ContactID = c.ContactID" + 
" JOIN HumanResources.EmployeeAddress AS ea ON ea.EmployeeID = e.EmployeeID" + 
" JOIN Person.Address AS a on a.AddressID = ea.AddressID" + 
" JOIN Person.StateProvince as sp ON sp.StateProvinceID = a.StateProvinceID;";
String expect = "SELECT c.FirstName, c.LastName, e.Title, a.AddressLine1, a.City" + 
"nt, sp.Name AS [State/Province], a.PostalCode" + 
"nINTO dbo.EmployeeAddresses" + 
"nFROM Person.Contact c" + 
"ntJOIN HumanResources.Employee e ON e.ContactID = c.ContactID" + 
"ntJOIN HumanResources.EmployeeAddress ea ON ea.EmployeeID = e.EmployeeID" + 
"ntJOIN Person.Address a ON a.AddressID = ea.AddressID" + 
"ntJOIN Person.StateProvince sp ON sp.StateProvinceID = a.StateProvinceID";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
"FROM [master].[sys].sql_logins";
public class SQLServerSelectTest8 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT Location.Distance (@p)" + " FROM Cities;";
String expect = "SELECT Location.Distance(@p)" + 
"nFROM Cities";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerSelectTest9 extends TestCase {
public void test_isEmpty() throws Exception {
String sql = "SELECT AVG(UnitPrice) AS 'Average Price' " + 
"FROM Sales.SalesOrderDetail;";
String expect = "SELECT AVG(UnitPrice) AS 'Average Price'" + 
"nFROM Sales.SalesOrderDetail";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
"nttWHERE a.FId = ?"
"nttGROUP BY a.FId"
public class SQLServerUpdateTest1 extends TestCase {
public void test_update() throws Exception {
String sql = "UPDATE dbo.Table2 " + 
"SET dbo.Table2.ColB = dbo.Table2.ColB + dbo.Table1.ColB " + 
"FROM dbo.Table2 " + 
"    INNER JOIN dbo.Table1 " + 
"    ON (dbo.Table2.ColA = dbo.Table1.ColA);";
String expect = "UPDATE dbo.Table2" + 
"nSET dbo.Table2.ColB = dbo.Table2.ColB + dbo.Table1.ColB" + 
"nFROM dbo.Table2" + 
"ntINNER JOIN dbo.Table1 ON dbo.Table2.ColA = dbo.Table1.ColA";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerUpdateTest2 extends TestCase {
public void test_update() throws Exception {
String sql = "UPDATE Cities " + 
"SET Location = CONVERT(Point, '12.3:46.2') " + 
"WHERE Name = 'Anchorage';";
String expect = "UPDATE Cities" + 
"nSET Location = CONVERT(Point, '12.3:46.2')" + 
"nWHERE Name = 'Anchorage'";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerUpdateTest3 extends TestCase {
public void test_update() throws Exception {
String sql = "UPDATE Sales.SalesPerson " + 
"SET SalesYTD = SalesYTD + " + 
"    (SELECT SUM(so.SubTotal) " + 
"     FROM Sales.SalesOrderHeader AS so" + 
"     WHERE so.OrderDate = (SELECT MAX(OrderDate)" + 
"                           FROM Sales.SalesOrderHeader AS so2" + 
"                           WHERE so2.SalesPersonID = " + 
"                                 so.SalesPersonID)" + 
"     AND Sales.SalesPerson.SalesPersonID = so.SalesPersonID" + 
"     GROUP BY so.SalesPersonID);";
String expect = "UPDATE Sales.SalesPerson"
"nSET SalesYTD = SalesYTD + ("
"ntSELECT SUM(so.SubTotal)"
"ntFROM Sales.SalesOrderHeader so"
"ntWHERE so.OrderDate = ("
"ntttSELECT MAX(OrderDate)"
"ntttFROM Sales.SalesOrderHeader so2"
"ntttWHERE so2.SalesPersonID = so.SalesPersonID"
"nttAND Sales.SalesPerson.SalesPersonID = so.SalesPersonID"
"ntGROUP BY so.SalesPersonID"
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerUpdateTest4 extends TestCase {
public void test_update() throws Exception {
String sql = "UPDATE TOP (10) HumanResources.Employee "
"SET VacationHours = VacationHours * 1.25 ;";
String expect = "UPDATE TOP (10) HumanResources.Employee"
"nSET VacationHours = VacationHours * 1.25";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
if (lexer.token() != Token.LPAREN) {
throw new SQLParseException("syntax error, expect ')'");
lexer.nextTokenValue();
lexer.nextTokenValue();
public final void nextTokenValue() {
if (ch == ' ') {
scanChar();
if (ch == ''') {
bufPos = 0;
scanString();
if (ch >= '0' && ch <= '9') {
bufPos = 0;
scanNumber();
if (ch == '?') {
scanChar();
token = Token.QUES;
nextToken();
System.out.println(System.getProperty("java.vm.name") + " " + System.getProperty("java.runtime.version"));
List<String> arguments = ManagementFactory.getRuntimeMXBean().getInputArguments();
System.out.println(arguments);
int endIndex = text.indexOf(''', startIndex);
hasSpecial = stringVal.indexOf('\') != -1;
if (isFirstIdentifierChar(ch) && ch != 'N') {
scanIdentifier();
if (expr.getClass() == SQLIdentifierExpr.class) {
String ident = ((SQLIdentifierExpr)expr).getName();
if ("DATE".equalsIgnoreCase(ident)) {
OracleDateExpr timestamp = new OracleDateExpr();
String literal = lexer.stringVal();
timestamp.setLiteral(literal);
accept(Token.LITERAL_CHARS);
return primaryRest(timestamp);
if ("TIMESTAMP".equalsIgnoreCase(ident)) {
if (lexer.token() != Token.LITERAL_ALIAS && lexer.token() != Token.LITERAL_CHARS) {
return new SQLIdentifierExpr("TIMESTAMP");
OracleTimestampExpr timestamp = new OracleTimestampExpr();
String literal = lexer.stringVal();
timestamp.setLiteral(literal);
accept(Token.LITERAL_CHARS);
if (identifierEquals("AT")) {
lexer.nextToken();
acceptIdentifier("TIME");
acceptIdentifier("ZONE");
String timezone = lexer.stringVal();
timestamp.setTimeZone(timezone);
accept(Token.LITERAL_CHARS);
return primaryRest(timestamp);
protected final void parseSelectList(SQLSelectQueryBlock queryBlock) {
final List<SQLSelectItem> selectList = queryBlock.getSelectList();
for (;;) {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.exprParser.primaryRest(expr);
expr = this.exprParser.exprRest(expr);
expr = expr();
final String alias = as();
final SQLSelectItem selectItem = new SQLSelectItem(expr, alias);
selectList.add(selectItem);
if (lexer.token() != Token.COMMA) {
public class MySqlPerfMain_select {
public static void main(String[] args) throws Exception {
System.out.println(System.getProperty("java.vm.name") + " " + System.getProperty("java.runtime.version"));
List<String> arguments = ManagementFactory.getRuntimeMXBean().getInputArguments();
System.out.println(arguments);
String sql = "SELECT ID, NAME, AGE FROM USER WHERE ID = ?";
for (int i = 0; i < 10; ++i) {
perfMySql(sql);
static long perfMySql(String sql) {
long startYGC = TestUtils.getYoungGC();
long startYGCTime = TestUtils.getYoungGCTime();
long startFGC = TestUtils.getFullGC();
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 1000; ++i) {
execMySql(sql);
long millis = System.currentTimeMillis() - startMillis;
long ygc = TestUtils.getYoungGC() - startYGC;
long ygct = TestUtils.getYoungGCTime() - startYGCTime;
long fgc = TestUtils.getFullGC() - startFGC;
System.out.println("MySqlt" + millis + ", ygc " + ygc + ", ygct " + ygct + ", fgc " + fgc);
return millis;
static String execMySql(String sql) {
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
return out.toString();
public class MySqlSelectTest_8 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select 1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
public class SQLServerSelectTest11 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT 1";
String expect = "SELECT 1";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class MySqlPerfMain_visitor {
public static void main(String[] args) throws Exception {
System.out.println(System.getProperty("java.vm.name") + " " + System.getProperty("java.runtime.version"));
List<String> arguments = ManagementFactory.getRuntimeMXBean().getInputArguments();
System.out.println(arguments);
String sql = "SELECT ID, NAME, AGE FROM USER WHERE ID = ?";
for (int i = 0; i < 10; ++i) {
perfMySql(sql);
static long perfMySql(String sql) {
long startYGC = TestUtils.getYoungGC();
long startYGCTime = TestUtils.getYoungGCTime();
long startFGC = TestUtils.getFullGC();
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
long startMillis = System.currentTimeMillis();
for (int i = 0; i < 1000 * 100 * 1; ++i) {
execMySql(statementList);
long millis = System.currentTimeMillis() - startMillis;
long ygc = TestUtils.getYoungGC() - startYGC;
long ygct = TestUtils.getYoungGCTime() - startYGCTime;
long fgc = TestUtils.getFullGC() - startFGC;
System.out.println("MySqlt" + millis + ", ygc " + ygc + ", ygct " + ygct + ", fgc " + fgc);
return millis;
static void execMySql(List<SQLStatement> statementList) {
MySqlASTVisitor visitor = new MySqlSchemaStatVisitor();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
public void reset() {
private FilterChainImpl      filterChain          = null;
public FilterChainImpl createChain() {
FilterChainImpl chain = this.filterChain;
if (chain == null) {
chain = new FilterChainImpl(this.statement.getConnectionProxy().getDirectDataSource());
this.filterChain = null;
return chain;
public void recycleFilterChain(FilterChainImpl chain) {
chain.reset();
this.filterChain = chain;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_absolute(this, row);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
chain.resultSet_afterLast(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_beforeFirst(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_cancelRowUpdates(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_clearWarnings(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_close(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_deleteRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
int value = chain.resultSet_findColumn(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_first(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Array value = chain.resultSet_getArray(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Array value = chain.resultSet_getArray(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getAsciiStream(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getAsciiStream(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
BigDecimal value = chain.resultSet_getBigDecimal(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
BigDecimal value = chain.resultSet_getBigDecimal(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
BigDecimal value = chain.resultSet_getBigDecimal(this, columnIndex, scale);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
BigDecimal value = chain.resultSet_getBigDecimal(this, columnLabel, scale);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getBinaryStream(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getBinaryStream(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Blob value = chain.resultSet_getBlob(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Blob value = chain.resultSet_getBlob(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_getBoolean(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_getBoolean(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
byte value = chain.resultSet_getByte(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
byte value = chain.resultSet_getByte(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
byte[] value = chain.resultSet_getBytes(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
byte[] value = chain.resultSet_getBytes(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Reader value = chain.resultSet_getCharacterStream(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Reader value = chain.resultSet_getCharacterStream(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Clob value = chain.resultSet_getClob(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Clob value = chain.resultSet_getClob(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getConcurrency(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.resultSet_getCursorName(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Date value = chain.resultSet_getDate(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Date value = chain.resultSet_getDate(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Date value = chain.resultSet_getDate(this, columnIndex, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Date value = chain.resultSet_getDate(this, columnLabel, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
double value = chain.resultSet_getDouble(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
double value = chain.resultSet_getDouble(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getFetchDirection(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value =  chain.resultSet_getFetchSize(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
float value = chain.resultSet_getFloat(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
float value = chain.resultSet_getFloat(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getHoldability(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getInt(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getInt(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
long value = chain.resultSet_getLong(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
long value = chain.resultSet_getLong(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
ResultSetMetaData value = chain.resultSet_getMetaData(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Reader value = chain.resultSet_getNCharacterStream(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Reader value = chain.resultSet_getNCharacterStream(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
NClob value = chain.resultSet_getNClob(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
NClob value = chain.resultSet_getNClob(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.resultSet_getNString(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.resultSet_getNString(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Object value = chain.resultSet_getObject(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Object value = chain.resultSet_getObject(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Object value = chain.resultSet_getObject(this, columnIndex, map);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Object value = chain.resultSet_getObject(this, columnLabel, map);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Ref value = chain.resultSet_getRef(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Ref value = chain.resultSet_getRef(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getRow(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
RowId value = chain.resultSet_getRowId(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
RowId value = chain.resultSet_getRowId(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
SQLXML value = chain.resultSet_getSQLXML(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
SQLXML value = chain.resultSet_getSQLXML(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
short value = chain.resultSet_getShort(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
short value = chain.resultSet_getShort(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Statement stmt = chain.resultSet_getStatement(this);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
String value = chain.resultSet_getString(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.resultSet_getString(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Time value = chain.resultSet_getTime(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Time value = chain.resultSet_getTime(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Time value = chain.resultSet_getTime(this, columnIndex, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Time value = chain.resultSet_getTime(this, columnLabel, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Timestamp value = chain.resultSet_getTimestamp(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Timestamp value = chain.resultSet_getTimestamp(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Timestamp value = chain.resultSet_getTimestamp(this, columnIndex, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Timestamp value = chain.resultSet_getTimestamp(this, columnLabel, cal);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.resultSet_getType(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
URL value = chain.resultSet_getURL(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
URL value = chain.resultSet_getURL(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getUnicodeStream(this, columnIndex);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
InputStream value = chain.resultSet_getUnicodeStream(this, columnLabel);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
SQLWarning value = chain.resultSet_getWarnings(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
chain.resultSet_insertRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_isAfterLast(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_isBeforeFirst(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_isClosed(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_isFirst(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_isLast(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_last(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
chain.resultSet_moveToCurrentRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_moveToInsertRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
boolean moreRows = chain.resultSet_next(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
boolean moreRows = chain.resultSet_previous(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_refreshRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_relative(this, rows);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_rowDeleted(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_rowInserted(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.resultSet_rowUpdated(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
chain.resultSet_setFetchDirection(this, direction);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_setFetchSize(this, rows);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateArray(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateArray(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateAsciiStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBigDecimal(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBigDecimal(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBinaryStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBlob(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBoolean(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBoolean(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateByte(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateByte(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBytes(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateBytes(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateCharacterStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateClob(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateDate(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateDate(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateDouble(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateDouble(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateFloat(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateFloat(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateInt(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateInt(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateLong(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateLong(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNCharacterStream(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNCharacterStream(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNCharacterStream(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNCharacterStream(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnIndex, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNClob(this, columnLabel, x, length);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNString(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNString(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNull(this, columnIndex);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateNull(this, columnLabel);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateObject(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateObject(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateObject(this, columnIndex, x, scaleOrLength);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateObject(this, columnLabel, x, scaleOrLength);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateRef(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateRef(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateRow(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateRowId(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateRowId(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateSQLXML(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateSQLXML(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateShort(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateShort(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateString(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateString(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateTime(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateTime(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateTimestamp(this, columnIndex, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.resultSet_updateTimestamp(this, columnLabel, x);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
boolean result = chain.resultSet_wasNull(this);
recycleFilterChain(chain);
return result;
dataSource.setUrl("jdbc:mock:xxx");
ConnectionProxyImpl conn = new ConnectionProxyImpl(dataSource, null, new Properties(), 0);
statement = new StatementProxyImpl(conn, null, 1);
ConnectionProxyImpl conn = new ConnectionProxyImpl(dataSource, null, new Properties(), 0);
statement = new StatementProxyImpl(conn, null, 1);
ConnectionProxyImpl conn = new ConnectionProxyImpl(dataSource, null, new Properties(), 0);
statement = new CallableStatementProxyImpl(conn, mockStmt, "", 1);
private FilterChainImpl       filterChain = null;
public FilterChainImpl createChain() {
FilterChainImpl chain = this.filterChain;
if (chain == null) {
chain = new FilterChainImpl(dataSource);
this.filterChain = null;
return chain;
public void recycleFilterChain(FilterChainImpl chain) {
chain.reset();
this.filterChain = chain;
FilterChainImpl chain = createChain();
chain.connection_clearWarnings(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_close(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_commit(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
Array value = chain.connection_createArrayOf(this, typeName, elements);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Blob value = chain.connection_createBlob(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Clob value = chain.connection_createClob(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
NClob value = chain.connection_createNClob(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
SQLXML value = chain.connection_createSQLXML(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Statement stmt = chain.connection_createStatement(this);
recycleFilterChain(chain);
return stmt;
public Statement createStatement(int resultSetType, 
int resultSetConcurrency 
) throws SQLException {
FilterChainImpl chain = createChain();
Statement stmt = chain.connection_createStatement(this, resultSetType, resultSetConcurrency);
recycleFilterChain(chain);
return stmt;
public Statement createStatement(int resultSetType, 
int resultSetConcurrency, 
int resultSetHoldability 
) throws SQLException {
FilterChainImpl chain = createChain();
Statement stmt = chain.connection_createStatement(this, resultSetType, resultSetConcurrency,
resultSetHoldability);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
Struct value = chain.connection_createStruct(this, typeName, attributes);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.connection_getAutoCommit(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.connection_getCatalog(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Properties value = chain.connection_getClientInfo(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.connection_getClientInfo(this, name);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.connection_getHoldability(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
DatabaseMetaData value = chain.connection_getMetaData(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.connection_getTransactionIsolation(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
Map<String, Class<?>> value = chain.connection_getTypeMap(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
SQLWarning value = chain.connection_getWarnings(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.connection_isClosed(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.connection_isReadOnly(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.connection_isValid(this, timeout);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
String value = chain.connection_nativeSQL(this, sql);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
CallableStatement stmt = chain.connection_prepareCall(this, sql);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
CallableStatement stmt = chain.connection_prepareCall(this, sql, resultSetType, resultSetConcurrency);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
CallableStatement stmt = chain.connection_prepareCall(this, sql, resultSetType, resultSetConcurrency,
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql, autoGeneratedKeys);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql, columnIndexes);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql, columnNames);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql, resultSetType, resultSetConcurrency);
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
PreparedStatement stmt = chain.connection_prepareStatement(this, sql, resultSetType, resultSetConcurrency,
recycleFilterChain(chain);
return stmt;
FilterChainImpl chain = createChain();
chain.connection_releaseSavepoint(this, savepoint);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_rollback(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_rollback(this, savepoint);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setAutoCommit(this, autoCommit);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setCatalog(this, catalog);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setClientInfo(this, properties);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setClientInfo(this, name, value);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setHoldability(this, holdability);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setReadOnly(this, readOnly);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
Savepoint savepoint = chain.connection_setSavepoint(this);
recycleFilterChain(chain);
return savepoint;
FilterChainImpl chain = createChain();
Savepoint savepoint = chain.connection_setSavepoint(this, name);
recycleFilterChain(chain);
return savepoint;
FilterChainImpl chain = createChain();
chain.connection_setTransactionIsolation(this, level);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.connection_setTypeMap(this, map);
recycleFilterChain(chain);
private FilterChainImpl        filterChain = null;
public FilterChainImpl createChain() {
FilterChainImpl chain = this.filterChain;
if (chain == null) {
chain = new FilterChainImpl(this.getConnectionProxy().getDirectDataSource());
this.filterChain = null;
return chain;
public void recycleFilterChain(FilterChainImpl chain) {
chain.reset();
this.filterChain = chain;
FilterChainImpl chain = createChain();
chain.statement_cancel(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_clearBatch(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_clearWarnings(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_close(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, autoGeneratedKeys);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, columnIndexes);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, columnNames);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
int[] updateCounts = chain.statement_executeBatch(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
ResultSet resultSet = chain.statement_executeQuery(this, sql);
recycleFilterChain(chain);
return resultSet;
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, autoGeneratedKeys);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, columnIndexes);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, columnNames);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
Connection conn = chain.statement_getConnection(this);
recycleFilterChain(chain);
return conn;
FilterChainImpl chain = createChain();
int value = chain.statement_getFetchDirection(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getFetchSize(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
ResultSet value = chain.statement_getGeneratedKeys(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getMaxFieldSize(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getMaxRows(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.statement_getMoreResults(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.statement_getMoreResults(this, current);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getQueryTimeout(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
ResultSet value = chain.statement_getResultSet(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetConcurrency(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetHoldability(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetType(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
updateCount = chain.statement_getUpdateCount(this);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
SQLWarning value = chain.statement_getWarnings(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.statement_isClosed(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
boolean value = chain.statement_isPoolable(this);
recycleFilterChain(chain);
return value;
FilterChainImpl chain = createChain();
chain.statement_setCursorName(this, name);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setEscapeProcessing(this, enable);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setFetchDirection(this, direction);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setFetchSize(this, rows);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setMaxFieldSize(this, max);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setMaxRows(this, max);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setPoolable(this, poolable);
recycleFilterChain(chain);
FilterChainImpl chain = createChain();
chain.statement_setQueryTimeout(this, seconds);
recycleFilterChain(chain);
for (int i = 0; i < 5; ++i) {
for (int i = 0; i < 1000 * 1000 * 1; ++i) {
LOG.error("clear parameter error", ex);
public class MySqlWallTest2 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(
"select * from person_qingjia " + 
"where isxiao=1  " + 
"and ((starttime between 2013-01-15 and 2013-01-15)" + 
"        or (endtime between 2013-01- 15 and 2013-01-15)" + 
") " + 
"order by xiaojiatime desc"));
boolean firstResult = chain.preparedStatement_execute(statement);
histogramRecord(nanoSpan);
dataSource.setFilters("stat");
case Equality
public class PagerUtilsTest_Count_Oracle_0 extends TestCase {
public void test_oracle_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_oracle_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Count_PG_0 extends TestCase {
public void test_pg_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_pg_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Count_SQLServer_0 extends TestCase {
public void test_sqlserver_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_sqlserver_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Limit_oracle_0 extends TestCase {
public void test_oracle_oderby_0() throws Exception {
String sql = "select * from t order by id";
String result = PagerUtils.limit(sql, JdbcConstants.ORACLE, 0, 10);
Assert.assertEquals("SELECT _X.*, ROWNUM AS _RN" + 
"nFROM (SELECT *" + 
"ntFROM t" + 
"ntORDER BY id" + 
"nt) _X" + 
"nWHERE ROWNUM <= 10", result);
public void test_oracle_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.ORACLE, 0, 10);
Assert.assertEquals("SELECT *" + 
"nFROM t" + 
"nWHERE ROWNUM <= 10", result);
public void test_oracle_1() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.ORACLE, 10, 10);
Assert.assertEquals("SELECT *" + 
"nFROM (SELECT _X.*, ROWNUM AS _RN" + 
"ntFROM (SELECT *" + 
"nttFROM t" + 
"ntt) _X" + 
"ntWHERE ROWNUM <= 20" + 
"nt) _XX" + 
"nWHERE _RN > 10", result);
public void test_oracle_2() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.ORACLE, 20, 10);
Assert.assertEquals("SELECT *" + 
"nFROM (SELECT _X.*, ROWNUM AS _RN" + 
"ntFROM (SELECT *" + 
"nttFROM t" + 
"ntt) _X" + 
"ntWHERE ROWNUM <= 30" + 
"nt) _XX" + 
"nWHERE _RN > 20", result);
public void test_oracle_3() throws Exception {
String sql = "select id, name, salary from t order by id, name";
String result = PagerUtils.limit(sql, JdbcConstants.ORACLE, 20, 10);
Assert.assertEquals("SELECT *" + 
"nFROM (SELECT _X.*, ROWNUM AS _RN" + 
"ntFROM (SELECT id, name, salary" + 
"nttFROM t" + 
"nttORDER BY id, name" + 
"ntt) _X" + 
"ntWHERE ROWNUM <= 30" + 
"nt) _XX" + 
"nWHERE _RN > 20", result);
if (x.getPartitionBy().size() > 0) {
printAndAccept(x.getPartitionBy(), ", ");
print(' ');
print(")");
public class SQLServerSelectTest12 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT Row, Name " + 
"FROM(" + 
"SELECT ROW_NUMBER() OVER (ORDER BY ProductID) AS Row, Name " + 
"FROM Product " + 
") AS ProductsWithRowNumbers " + 
"WHERE Row >= 6 AND Row <= 10";
String expect = "SELECT Row, Name" + 
"nFROM (SELECT ROW_NUMBER() OVER (ORDER BY ProductID) AS Row, Name" + 
"ntFROM Product" + 
"nt) ProductsWithRowNumbers" + 
"nWHERE Row >= 6" + 
"ntAND Row <= 10";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
private static final String[] AGGREGATE_FUNCTIONS = {
"AVG", 
"CORR", 
"COVAR_POP", 
"COVAR_SAMP", 
"COUNT", 
"CUME_DIST", 
"DENSE_RANK", 
"FIRST", 
"FIRST_VALUE", 
"LAG", 
"LAST", 
"LAST_VALUE", 
"LEAD", 
"MAX",  
"MIN", 
"NTILE", 
"PERCENT_RANK",  
"PERCENTILE_CONT",  
"PERCENTILE_DISC",  
"RANK", 
"RATIO_TO_REPORT", 
"REGR_SLOPE", 
"REGR_INTERCEPT",  
"REGR_COUNT",  
"REGR_R2", 
"REGR_AVGX",  
"REGR_AVGY",  
"REGR_SXX",  
"REGR_SYY",  
"REGR_SXY", 
"ROW_NUMBER",  
"STDDEV",  
"STDDEV_POP",  
"STDDEV_SAMP", 
"SUM", 
"VAR_POP", 
"VAR_SAMP", 
"VARIANCE" 
for (int i = 0; i < AGGREGATE_FUNCTIONS.length; ++i) {
if (AGGREGATE_FUNCTIONS[i].compareToIgnoreCase(word) == 0) {
public boolean isAggreateFunction(String word) {
String[] aggregateFunctions = { "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "ROW_NUMBER" };
for (int i = 0; i < aggregateFunctions.length; ++i) {
if (aggregateFunctions[i].compareToIgnoreCase(word) == 0) {
return true;
return false;
private final static Log        LOG              = LogFactory.getLog(JdbcUtils.class);
private static final Properties driverUrlMapping = new Properties();
} else if (type == Types.NULL) {
out.print("null");
if (objec instanceof byte[]) {
byte[] bytes = (byte[]) objec;
String text = HexBin.encode(bytes);
out.print(text);
out.print(String.valueOf(objec));
boolean isSimpleConstExpr = false;
isSimpleConstExpr = true;
if (!isSimpleConstExpr) {
addViolation(visitor, x);
public class TenantSelectTest4 extends TestCase {
private String     sql    = "SELECT a.*,b.name " + 
"FROM vote_info a left join vote_item b on a.item_id=b.id " + 
"where 1=1 limit 1,10";
private WallConfig config = new WallConfig();
protected void setUp() throws Exception {
config.setTenantTablePattern("*");
config.setTenantColumn("tenant");
public void testMySql() throws Exception {
WallProvider.setTenantValue(123);
MySqlWallProvider provider = new MySqlWallProvider(config);
WallCheckResult checkResult = provider.check(sql);
Assert.assertEquals(0, checkResult.getViolations().size());
String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.MYSQL);
Assert.assertEquals("SELECT a.*, b.name" + 
"nFROM vote_info a" + 
"ntLEFT JOIN vote_item b ON b.tenant = 123" + 
"nttAND a.item_id = b.id" + 
"nWHERE a.tenant = 123" + 
"ntAND 1 = 1" + 
"nLIMIT 1, 10", resultSql);
protected SQLSelect      subQuery;
public SQLSelect getSubQuery() {
public void setSubQuery(SQLSelect subQuery) {
entry.setSubQuery(select());
+ lexer.stringVal() + ", pos " + this.lexer.pos());
entry.setSubQuery(select());
public class MySqlWallTest3 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(
"SELECT COUNT(p.id) FROM TB_PRO p" + 
"        INNER JOIN   TB_Db  b ON b.id =p.dbid " + 
"        WHERE p.index_status='0' AND p.sc=?"));
public class OracleSelectTest40 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"WITH a AS (" + 
"   SELECT TO_CHAR(csl.create_time,'yyyyMMdd') create_time, cwl.client_key ck, csl.src_id src_id " + 
"   FROM xxxx csl, xxxx cwl " + 
"   WHERE 1 =1 AND csl.src_id = cwl.src_id AND csl.curr_url = cwl.curr_url " + 
"       AND TO_CHAR(csl.create_time,'yyyyMMdd') BETWEEN ? " + 
"       AND ? AND cwl.day = TO_CHAR(csl.create_time,'yyyyMMdd') " + 
"   GROUP BY cwl.client_key, csl.src_id, csl.create_time ORDER BY csl.src_id )" + 
", b AS (" + 
"   SELECT itn.buyerpaytime, itn.esc_orderid, itn.oldck, " + 
"       MAX(con.PAYED_AMOUNT) gmv, MAX(con.buyer_onlyid) buyer " + 
"   FROM xxxx itn, xxxx don, xxxx con " + 
"   WHERE don.esc_orderid = itn.esc_orderid " + 
"       AND con.esc_orderid = itn.esc_orderid " + 
"       AND don.order_status IN (4,5,6,7,8) AND itn.buyerpaytime BETWEEN ? AND ? " + 
"   GROUP BY itn.esc_orderid, itn.oldck, itn.buyerpaytime ) " + 
"SELECT MAX(cos.location) AS position , a.src_id AS srcid , " + 
"   COUNT(DISTINCT b.esc_orderid) AS orders , SUM(b.gmv) AS uvGmv, " + 
"   COUNT(DISTINCT buyer) AS buyers FROM a, b, cp_operate_statistics cos " + 
"WHERE a.ck = b.oldck(+) AND TO_CHAR(cos.day,'yyyyMMdd') = a.create_time " + 
"   AND a.create_time = b.buyerpaytime AND a.src_id = cos.src_id GROUP BY a.src_id ORDER BY a.src_id"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(15, visitor.getColumns().size());
public class PGSelectTest9 extends PGTest {
public void test_0() throws Exception {
String sql = "SELECT res.restaurant_id, row_number() " + 
"over (order by ST_Distance(res.restaurant_point,GeomFromEWKT(?))*111.12 ) as row_id " + 
"FROM restaurant res where res.city_id = ? and res.is_delete =false and res.restaurant_id <1000000 limit 10";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
List<Object> parameters = this.getParameters();
int index = x.getIndex();
if (parameters != null && index >= 0 && index < parameters.size()) {
Object param = parameters.get(index);
printParameter(param);
return false;
printParameter(param);
return false;
public void printParameter(Object param) {
public class SQLUtilsTest extends TestCase {
public void test_format() throws Exception {
String formattedSql = SQLUtils.format("select * from t where id = ?", JdbcConstants.MYSQL,
Arrays.<Object> asList("abc"));
Assert.assertEquals("SELECT *" + 
"nFROM t" + 
"nWHERE id = 'abc'", formattedSql);
String expect = "SELECT c.FirstName, c.LastName, ROW_NUMBER() OVER (ORDER BY SalesYTD DESC) AS 'Row Number', s.SalesYTD, a.PostalCode" 
"nFROM (SELECT ROW_NUMBER() OVER (ORDER BY FAlertDate DESC, FAlertLevel, FAlertType) AS RowNumber, *"
if (holder == null) {
throw new SQLException("connection holder is null");
if (closed) {
throw new SQLException("connection closed");
if (disable) {
throw new SQLException("connection disabled");
pooledConnection.disable(t);
private final static Log                 LOG          = LogFactory.getLog(DruidPooledConnection.class);
private volatile boolean                 traceEnable  = false;
private boolean                          disable      = false;
private boolean                          closed       = false;
private volatile boolean                 running      = false;
private volatile boolean                 abandoned    = false;
private Throwable                        disableError = null;
disable(null);
public void disable(Throwable error) {
this.disableError = error;
throw new SQLException("connection disabled", disableError);
setMode(x, Mode.Update);
SQLName identName = x.getTableName();
if (identName != null) {
String ident = identName.toString();
setCurrentTable(ident);
TableStat stat = getTableStat(ident);
stat.incrementUpdateCount();
Map<String, String> aliasMap = getAliasMap();
aliasMap.put(ident, ident);
x.getTableSource().accept(this);
public class MySqlUpdateTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "UPDATE t_price, t_basic_store s " + 
"SET purchasePrice = :purchasePrice, operaterId = :operaterId, " + 
"    operaterRealName = :operaterRealName, operateDateline = :operateDateline " + 
"WHERE goodsId = :goodsId AND s.id = storeId AND s.areaId = :areaId";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(8, visitor.getColumns().size());
Assert.assertEquals(4, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t_price")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t_basic_store")));
public class MySqlWallTest4 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SSELECT a.*,b.name FROM vote_info a left join vote_item b on a.item_id=b.id where a.id<10 or 1=1 limit 1,10"));
public class MySqlWallTest5 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from tbl_product WHERE delFlag=0 AND cateId = 40 OR EXTRACTVALUE(1,CONCAT(0x7c,database(),0x7c)) order by sort desc, productId desc limit 20,20"));
public class MySqlWallTest6 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where a.id<10 or (id <5 or 1=1) limit 1,10"));
protected final Set<String> denyFunctions            = new HashSet<String>();
protected final Set<String> denyTables               = new HashSet<String>();
protected final Set<String> denySchemas              = new HashSet<String>();
protected final Set<String> denyVariants             = new HashSet<String>();
protected final Set<String> denyObjects              = new HashSet<String>();
loadResource(this.denyVariants, dir + "/deny-variant.txt");
loadResource(this.denySchemas, dir + "/deny-schema.txt");
loadResource(this.denyFunctions, dir + "/deny-function.txt");
loadResource(this.denyTables, dir + "/deny-table.txt");
loadResource(this.denyObjects, dir + "/deny-object.txt");
public Set<String> getDenyFunctions() {
return denyFunctions;
public Set<String> getDenyTables() {
return denyTables;
public Set<String> getDenySchemas() {
return denySchemas;
public Set<String> getDenyVariants() {
return denyVariants;
public Set<String> getDenyObjects() {
return denyObjects;
public boolean isDenyObjects(String name) {
return denyObjects.contains(name);
public boolean isDenySchema(String name) {
return this.denySchemas.contains(name);
public boolean isDenyFunction(String name) {
return this.denyFunctions.contains(name);
Set<String> getDenyFunctions();
Set<String> getDenyTables();
Set<String> getDenySchemas();
Set<String> getDenyVariants();
Set<String> getDenyObjects();
boolean isDenyObjects(String name);
boolean isDenySchema(String name);
boolean isDenyFunction(String name);
parser.getLexer().setAllowComment(false); 
boolean isDenyTable(String name);
public boolean isDenyTable(String name) {
return config.getDenyTables().contains(name);
if (config.isVariantCheck() && config.getDenyVariants().contains(name)) {
public boolean isDenyTable(String name) {
return config.getDenyTables().contains(name);
public boolean isDenyTable(String name) {
return config.getDenyTables().contains(name);
if (config.isVariantCheck() && config.getDenyVariants().contains(name)) {
if (x.getSchema() != null && config.isDenySchema(x.getSchema())) {
if (x.getDatabase() != null && config.isDenySchema(x.getDatabase())) {
if (visitor.getConfig().isDenyFunction(methodName.toLowerCase())) {
if (visitor.getConfig().isDenySchema(owner)) {
if (visitor.getConfig().isDenyObjects(owner)) {
if (visitor.isDenyTable(tableName)) {
LOG.error("load oracle deny tables errror", e);
private boolean                                     noneBaseStatementAllow     = false;
private boolean                                     callAllow                  = true;
private boolean                                     selelctAllow               = true;
private boolean                                     selectIntoAllow            = true;
private boolean                                     selectIntoOutfileAllow     = false;
private boolean                                     selectWhereAlwayTrueCheck  = true;
private boolean                                     selectHavingAlwayTrueCheck = true;
private boolean                                     selectUnionCheck           = true;
private boolean                                     selectAllColumnAllow       = true;
private boolean                                     deleteAllow                = true;
private boolean                                     deleteWhereAlwayTrueCheck  = true;
private boolean                                     updateAllow                = true;
private boolean                                     updateWhereAlayTrueCheck   = true;
private boolean                                     insertAllow                = true;
private boolean                                     mergeAllow                 = true;
private boolean                                     multiStatementAllow        = false;
private boolean                                     truncateAllow              = false;
private boolean                                     commentAllow               = false;
private boolean                                     describeAllow              = false;
private boolean                                     schemaCheck                = true;
private boolean                                     tableCheck                 = true;
private boolean                                     functionCheck              = true;
private boolean                                     objectCheck                = true;
private boolean                                     variantCheck               = true;
private boolean                                     mustParameterized          = false;
private boolean                                     doPrivilegedAllow          = false;
protected final ConcurrentMap<String, WallDenyStat> denyFunctions              = new ConcurrentHashMap<String, WallDenyStat>();
protected final ConcurrentMap<String, WallDenyStat> denyTables                 = new ConcurrentHashMap<String, WallDenyStat>();
protected final ConcurrentMap<String, WallDenyStat> denySchemas                = new ConcurrentHashMap<String, WallDenyStat>();
protected final ConcurrentMap<String, WallDenyStat> denyVariants               = new ConcurrentHashMap<String, WallDenyStat>();
protected final ConcurrentMap<String, WallDenyStat> denyObjects                = new ConcurrentHashMap<String, WallDenyStat>();
protected final ConcurrentMap<String, WallDenyStat> readOnlyTables             = new ConcurrentHashMap<String, WallDenyStat>();
private String                                      dir;
private boolean                                     inited;
private String                                      tenantTablePattern;
private String                                      tenantColumn;
private boolean                                     wrapAllow                  = true;
private boolean                                     metadataAllow              = true;
return denyFunctions.keySet();
return denyTables.keySet();
return denySchemas.keySet();
return denyVariants.keySet();
return denyObjects.keySet();
return readOnlyTables.keySet();
public void addReadOnlyTable(String tableName) {
this.readOnlyTables.putIfAbsent(tableName, new WallDenyStat());
public boolean checkReadOnly(String tableName) {
WallDenyStat wallStat = this.readOnlyTables.get(tableName);
if (wallStat == null) {
return false;
wallStat.incrementAndGetDenyCount();
return true;
return denyObjects.containsKey(name);
return this.denySchemas.containsKey(name);
return this.denyFunctions.containsKey(name);
if (visitor.getConfig().checkReadOnly(tableName)) {
public static void loadResource(ConcurrentMap<String, WallDenyStat> names, String resource) {
names.put(line, new WallDenyStat());
config.addReadOnlyTable("members");
private boolean                           noneBaseStatementAllow     = false;
private boolean                           callAllow                  = true;
private boolean                           selelctAllow               = true;
private boolean                           selectIntoAllow            = true;
private boolean                           selectIntoOutfileAllow     = false;
private boolean                           selectWhereAlwayTrueCheck  = true;
private boolean                           selectHavingAlwayTrueCheck = true;
private boolean                           selectUnionCheck           = true;
private boolean                           selectAllColumnAllow       = true;
private boolean                           deleteAllow                = true;
private boolean                           deleteWhereAlwayTrueCheck  = true;
private boolean                           updateAllow                = true;
private boolean                           updateWhereAlayTrueCheck   = true;
private boolean                           insertAllow                = true;
private boolean                           mergeAllow                 = true;
private boolean                           multiStatementAllow        = false;
private boolean                           truncateAllow              = false;
private boolean                           commentAllow               = false;
private boolean                           describeAllow              = false;
private boolean                           schemaCheck                = true;
private boolean                           tableCheck                 = true;
private boolean                           functionCheck              = true;
private boolean                           objectCheck                = true;
private boolean                           variantCheck               = true;
private boolean                           mustParameterized          = false;
private boolean                           doPrivilegedAllow          = false;
protected final Set<String> denyFunctions              = new ConcurrentSkipListSet<String>();
protected final Set<String> denyTables                 = new ConcurrentSkipListSet<String>();
protected final Set<String> denySchemas                = new ConcurrentSkipListSet<String>();
protected final Set<String>               denyVariants               = new ConcurrentSkipListSet<String>();
protected final Set<String>               denyObjects                = new ConcurrentSkipListSet<String>();
protected final Set<String>               readOnlyTables             = new ConcurrentSkipListSet<String>();
private String                            dir;
private boolean                           inited;
private String                            tenantTablePattern;
private String                            tenantColumn;
private boolean                           wrapAllow                  = true;
private boolean                           metadataAllow              = true;
return denyFunctions;
return denyTables;
return denySchemas;
return denyVariants;
return denyObjects;
return readOnlyTables;
this.readOnlyTables.add(tableName);
public boolean isReadOnly(String tableName) {
return this.readOnlyTables.contains(tableName);
return denyObjects.contains(name);
return this.denySchemas.contains(name);
return this.denyFunctions.contains(name);
public class WallDenyStat {
private volatile long                             denyCount;
final static AtomicLongFieldUpdater<WallDenyStat> denyCountUpdater = AtomicLongFieldUpdater.newUpdater(WallDenyStat.class,
"denyCount");
public long incrementAndGetDenyCount() {
return denyCountUpdater.incrementAndGet(this);
public long getDenyCount() {
return denyCount;
if (visitor.getConfig().isReadOnly(tableName)) {
public static void loadResource(Set<String> names, String resource) {
names.add(line);
public class WallCommentTest extends TestCase {
public void testORACLE() throws Exception {
String sql = "SELECT F1, F2 FROM ABC --test";
OracleWallProvider provider = new OracleWallProvider();
Assert.assertFalse(provider.checkValid(sql));
Assert.assertEquals(1, provider.getCommentDenyStat().getDenyCount());
public void testmysql() throws Exception {
String sql = "SELECT F1, F2 FROM ABC --test";
MySqlWallProvider provider = new MySqlWallProvider();
Assert.assertFalse(provider.checkValid(sql));
Assert.assertEquals(1, provider.getCommentDenyStat().getDenyCount());
public void testsqlserver() throws Exception {
String sql = "SELECT F1, F2 FROM ABC --test";
SQLServerWallProvider provider = new SQLServerWallProvider();
Assert.assertFalse(provider.checkValid(sql));
Assert.assertEquals(1, provider.getCommentDenyStat().getDenyCount());
public final static int RevisionVersion = 13;
right.accept(visitor);
if (x.getOperator() == SQLBinaryOperator.BooleanOr) {
final WallConditionContext wallContext = WallVisitorUtils.getWallConditionContext();
if (wallContext != null) {
if (left.getAttribute(EVAL_VALUE) == Boolean.TRUE || right.getAttribute(EVAL_VALUE) == Boolean.TRUE) {
wallContext.setPartAllowTrue(true);
if (Boolean.TRUE == getConditionValue(visitor, where)) {
if (Boolean.TRUE == getConditionValue(visitor, x)) {
if (x.getWhere() == null || Boolean.TRUE == getConditionValue(visitor, x.getWhere())) {
if (x.getWhere() == null || Boolean.TRUE == getConditionValue(visitor, x.getWhere())) {
final WallConditionContext wallContext = WallVisitorUtils.getWallConditionContext();
if (wallContext != null) {
wallContext.setPartAllowTrue(true);
public static class WallConditionContext {
private boolean partAllowTrue;
public boolean isPartAllowTrue() {
return partAllowTrue;
public void setPartAllowTrue(boolean partAllowTrue) {
this.partAllowTrue = partAllowTrue;
private static ThreadLocal<WallConditionContext> wallConditionContextLocal = new ThreadLocal<WallConditionContext>();
public static WallConditionContext getWallConditionContext() {
return wallConditionContextLocal.get();
public static Object getConditionValue(WallVisitor visitor, SQLExpr x) {
final WallConditionContext old = wallConditionContextLocal.get();
wallConditionContextLocal.set(new WallConditionContext());
final Object value = getValue(x);
final WallConditionContext current = wallConditionContextLocal.get();
if (current.isPartAllowTrue() && visitor.getConfig().isUpdateWhereAlayTrueCheck()) {
addViolation(visitor, x);
return value;
} finally {
wallConditionContextLocal.set(old);
public class MySqlWallTest7 extends TestCase {
public void test_stuff() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where a.id<10 and (id <5 or 1=1) limit 1,10")); 
public SQLServerSelectParser createSelectParser() {
return new SQLServerSelectParser(this);
public class SQLServerSelectTest13 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT" + 
"    a.* " + 
"FROM" + 
"    (" + 
"        SELECT" + 
"            row_number () over (ORDER BY a.time_add DESC) ROW," + 
"            a.detail_no AS detailNo," + 
"            a.ba_id AS baId," + 
"            a.ba_name AS baName," + 
"            a.tran_no AS tranNo," + 
"            a.tran_name AS tranName, " + 
"            a.tran_type AS tranType, " + 
"            a.balance_type AS balanceType, " + 
"            a.detail_income AS detailIncome, " + 
"            a.detail_payout AS detailPayout, " + 
"            a.before_balance AS beforeBalance, " + 
"            a.after_balance AS afterBalance, " + 
"            a.time_add AS timeAdd, " + 
"            a.user_add AS userAdd, " + 
"            a.remark AS remark, " + 
"            ( " + 
"                SELECT " + 
"                    top 1 t.param_name " + 
"                FROM " + 
"                    config.sys_params t " + 
"                WHERE " + 
"                    t.param_type = ? " + 
"                AND t.param_value = a.tran_type " + 
"            ) AS tranTypeName " + 
"        FROM " + 
"            bussiness.account_detail a " + 
"        WHERE " + 
"            1 = 1 " + 
"        AND a.time_add >= ? " + 
"        AND a.time_add <= ? " + 
"    ) a " + 
"WHERE " + 
"    a. ROW BETWEEN (?+ 1) " + 
"AND (?+?)"; 
String expect = "SELECT a.*"
"nFROM (SELECT ROW_NUMBER() OVER (ORDER BY a.time_add DESC) AS ROW, a.detail_no AS detailNo, a.ba_id AS baId, a.ba_name AS baName, a.tran_no AS tranNo"
"ntt, a.tran_name AS tranName, a.tran_type AS tranType, a.balance_type AS balanceType, a.detail_income AS detailIncome, a.detail_payout AS detailPayout"
"ntt, a.before_balance AS beforeBalance, a.after_balance AS afterBalance, a.time_add AS timeAdd, a.user_add AS userAdd, a.remark AS remark"
"ntttSELECT TOP 1 t.param_name"
"ntttFROM config.sys_params t"
"ntttWHERE t.param_type = ?"
"nttttAND t.param_value = a.tran_type"
"nttt) AS tranTypeName"
"ntFROM bussiness.account_detail a"
"ntWHERE 1 = 1"
"nttAND a.time_add >= ?"
"nttAND a.time_add <= ?"
"nWHERE a.ROW BETWEEN ? + 1 AND ? + ?";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerSelectTest14 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT " + 
"    a.* " + 
"FROM " + 
"    ( " + 
"            SELECT " + 
"                    row_number () over (ORDER BY a.time_add DESC) ROW, " + 
"                    a.detail_no AS detailNo, " + 
"                    a.ba_id AS baId, " + 
"                    a.ba_name AS baName, " + 
"                    a.tran_no AS tranNo, " + 
"                    a.tran_name AS tranName, " + 
"                    a.tran_type AS tranType, " + 
"                    a.balance_type AS balanceType, " + 
"                    a.detail_income AS detailIncome, " + 
"                    a.detail_payout AS detailPayout, " + 
"                    a.before_balance AS beforeBalance, " + 
"                    a.after_balance AS afterBalance, " + 
"                    a.time_add AS timeAdd, " + 
"                    a.user_add AS userAdd, " + 
"                    a.remark AS remark, " + 
"                    ( " + 
"                            SELECT " + 
"                                    top 1 t.param_name " + 
"                            FROM " + 
"                                    config.sys_params t " + 
"                            WHERE " + 
"                                    t.param_type = 2 " + 
"                            AND t.param_value = a.tran_type " + 
"                    ) AS tranTypeName " + 
"            FROM " + 
"                    bussiness.account_detail a " + 
"            WHERE " + 
"                    1 = 1 " + 
"            AND a.time_add >= 2 " + 
"            AND a.time_add <= 3 " + 
"    ) a " + 
"WHERE " + 
"    a.ROW BETWEEN (10+2) AND 20 "; 
String expect = "SELECT a.*"
"nFROM (SELECT ROW_NUMBER() OVER (ORDER BY a.time_add DESC) AS ROW, a.detail_no AS detailNo, a.ba_id AS baId, a.ba_name AS baName, a.tran_no AS tranNo"
"ntt, a.tran_name AS tranName, a.tran_type AS tranType, a.balance_type AS balanceType, a.detail_income AS detailIncome, a.detail_payout AS detailPayout"
"ntt, a.before_balance AS beforeBalance, a.after_balance AS afterBalance, a.time_add AS timeAdd, a.user_add AS userAdd, a.remark AS remark"
"ntt, (" + 
"ntttSELECT TOP 1 t.param_name" + 
"ntttFROM config.sys_params t" + 
"ntttWHERE t.param_type = 2" + 
"nttttAND t.param_value = a.tran_type" + 
"nttt) AS tranTypeName" + 
"ntFROM bussiness.account_detail a" + 
"ntWHERE 1 = 1" + 
"nttAND a.time_add >= 2" + 
"nttAND a.time_add <= 3" + 
"nt) a" + 
"nWHERE a.ROW BETWEEN 10 + 2 AND 20";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
private boolean             noneBaseStatementAllow     = false;
private boolean             callAllow                  = true;
private boolean             selelctAllow               = true;
private boolean             selectIntoAllow            = true;
private boolean             selectIntoOutfileAllow     = false;
private boolean             selectWhereAlwayTrueCheck  = true;
private boolean             selectHavingAlwayTrueCheck = true;
private boolean             selectUnionCheck           = true;
private boolean             selectAllColumnAllow       = true;
private boolean             deleteAllow                = true;
private boolean             deleteWhereAlwayTrueCheck  = true;
private boolean             updateAllow                = true;
private boolean             updateWhereAlayTrueCheck   = true;
private boolean             insertAllow                = true;
private boolean             mergeAllow                 = true;
private boolean             multiStatementAllow        = false;
private boolean             truncateAllow              = false;
private boolean             commentAllow               = false;
private boolean             describeAllow              = false;
private boolean             schemaCheck                = true;
private boolean             tableCheck                 = true;
private boolean             functionCheck              = true;
private boolean             objectCheck                = true;
private boolean             variantCheck               = true;
private boolean             mustParameterized          = false;
private boolean             doPrivilegedAllow          = false;
protected final Set<String> denyVariants               = new ConcurrentSkipListSet<String>();
protected final Set<String> denyObjects                = new ConcurrentSkipListSet<String>();
protected final Set<String> readOnlyTables             = new ConcurrentSkipListSet<String>();
private String              dir;
private boolean             inited;
private String              tenantTablePattern;
private String              tenantColumn;
private boolean             wrapAllow                  = true;
private boolean             metadataAllow              = true;
if (leftResult == Boolean.TRUE || rightResult == Boolean.TRUE) {
final WallConditionContext current = wallConditionContextLocal.get();
if (current != null) {
current.setPartAllowTrue(true);
public class MySqlWallTest8 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where 1=1 AND FID = ?")); 
public void test_false_1() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where FID = ? AND 1=1")); 
public void test_false_2() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where FID = ? OR (FID = ? AND 1=1)")); 
public void test_false_3() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"SELECT a.* FROM vote_info a where FID = ? OR (1=1 AND FID = ?)")); 
Assert.assertFalse(WallUtils.isValidateMySql(sql));
Assert.assertFalse(WallUtils.isValidateOracle(sql));
Assert.assertFalse(WallUtils.isValidateMySql(sql));
Assert.assertFalse(WallUtils.isValidateOracle(sql));
private boolean             minusAllow                 = false;
public boolean isMinusAllow() {
return minusAllow;
public void setMinusAllow(boolean minusAllow) {
this.minusAllow = minusAllow;
if (x.getOperator() == SQLUnionOperator.MINUS && !visitor.getConfig().isMinusAllow()) {
addViolation(visitor, x);
public class MinusTest extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(
"SELECT * FROM A MINUS SELECT * FROM B")); 
public void test_true() throws Exception {
WallConfig config = new WallConfig();
config.setMinusAllow(true);
Assert.assertTrue(WallUtils.isValidateOracle(
"SELECT * FROM A MINUS SELECT * FROM B", config)); 
private boolean             intersectAllow                  = false;
public boolean isIntersectAllow() {
return intersectAllow;
public void setIntersectAllow(boolean intersectAllow) {
this.intersectAllow = intersectAllow;
if (x.getOperator() == SQLUnionOperator.INTERSECT && !visitor.getConfig().isIntersectAllow()) {
addViolation(visitor, x);
public class IntersectTest extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle(
"SELECT * FROM A MINUS SELECT * FROM B")); 
public void test_true() throws Exception {
WallConfig config = new WallConfig();
config.setMinusAllow(true);
Assert.assertTrue(WallUtils.isValidateOracle(
"SELECT * FROM A MINUS SELECT * FROM B", config)); 
"SELECT * FROM A Intersect SELECT * FROM B")); 
config.setIntersectAllow(true);
"SELECT * FROM A Intersect SELECT * FROM B", config)); 
@SuppressWarnings("restriction")
if (lexer.token() == Token.DEFAULT) {
lexer.nextToken();
if (identifierEquals("CHARACTER")) {
lexer.nextToken();
accept(Token.SET);
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CHARACTER SET", lexer.stringVal());
lexer.nextToken();
} else if (identifierEquals("CHARSET")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CHARACTER SET", lexer.stringVal());
lexer.nextToken();
public static boolean isValidatePostgres(String sql) {
PGWallProvider provider = new PGWallProvider();
return provider.checkValid(sql);
public static boolean isValidatePostgres(String sql, WallConfig config) {
PGWallProvider provider = new PGWallProvider(config);
return provider.checkValid(sql);
public class PGDenyFunctionTest extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidatePostgres(
"SELECT current_catalog() from t where id = ?")); 
public void test_true() throws Exception {
WallConfig config = new WallConfig();
config.setFunctionCheck(false);
Assert.assertTrue(WallUtils.isValidatePostgres(
"SELECT current_catalog() from t where id = ?", config)); 
public class MySqlCreateTableTest5 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `test` (" + 
"  `id` bigint(20) NOT NULL AUTO_INCREMENT," + 
"  `dspcode` char(200) DEFAULT NULL," + 
"  PRIMARY KEY (`id`)," + 
"  KEY `index_name` (`dspcode`)" + 
") ENGINE=InnoDB DEFAULT CHARSET=utf8;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
MySqlCreateTableStatement stmt = (MySqlCreateTableStatement) statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("utf8", stmt.getTableOptions().get("CHARACTER SET"));
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test")));
Assert.assertTrue(visitor.getColumns().contains(new Column("test", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("test", "dspcode")));
public class Case4 extends TestCase {
private String jdbcUrl;
private String user;
private String password;
private String driverClass;
private int    initialSize               = 10;
private int    minPoolSize               = 10;
private int    maxPoolSize               = 50;
private int    maxActive                 = 50;
private String validationQuery           = "SELECT 1";
private int    maxOpenPreparedStatements = 100;
private int    threadCount               = 5;
private int    loopCount                 = 10;
final int      LOOP_COUNT                = 100 * 1 * 1 / threadCount;
protected void setUp() throws Exception {
user = "root";
password = "aaaaaaaa";
jdbcUrl = "jdbc:mysql:
driverClass = "com.mysql.jdbc.Driver";
public void test_druid() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setInitialSize(initialSize);
dataSource.setMaxActive(maxActive);
dataSource.setMinIdle(minPoolSize);
dataSource.setMaxIdle(maxPoolSize);
dataSource.setPoolPreparedStatements(true);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setValidationQuery(validationQuery);
dataSource.setTestOnBorrow(false);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "druid", threadCount);
System.out.println();
public void test_jobss() throws Exception {
LocalTxDataSourceDO dataSourceDO = new LocalTxDataSourceDO();
dataSourceDO.setBlockingTimeoutMillis(1000 * 60);
dataSourceDO.setMaxPoolSize(maxPoolSize);
dataSourceDO.setMinPoolSize(minPoolSize);
dataSourceDO.setDriverClass(driverClass);
dataSourceDO.setConnectionURL(jdbcUrl);
dataSourceDO.setUserName(user);
dataSourceDO.setPassword(password);
LocalTxDataSource tx = TaobaoDataSourceFactory.createLocalTxDataSource(dataSourceDO);
DataSource dataSource = tx.getDatasource();
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "jboss-datasource", threadCount);
System.out.println();
public void test_dbcp() throws Exception {
final BasicDataSource dataSource = new BasicDataSource();
dataSource.setInitialSize(initialSize);
dataSource.setMaxActive(maxActive);
dataSource.setMinIdle(minPoolSize);
dataSource.setMaxIdle(maxPoolSize);
dataSource.setPoolPreparedStatements(true);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setValidationQuery("SELECT 1");
dataSource.setTestOnBorrow(false);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "dbcp", threadCount);
System.out.println();
public void test_bonecp() throws Exception {
BoneCPDataSource dataSource = new BoneCPDataSource();
dataSource.setMinConnectionsPerPartition(minPoolSize);
dataSource.setMaxConnectionsPerPartition(maxPoolSize);
dataSource.setDriverClass(driverClass);
dataSource.setJdbcUrl(jdbcUrl);
dataSource.setStatementsCacheSize(maxOpenPreparedStatements);
dataSource.setServiceOrder("LIFO");
dataSource.setUsername(user);
dataSource.setPassword(password);
dataSource.setPartitionCount(1);
dataSource.setAcquireIncrement(5);
dataSource.setIdleConnectionTestPeriod(0L);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "boneCP", threadCount);
System.out.println();
public void test_c3p0() throws Exception {
ComboPooledDataSource dataSource = new ComboPooledDataSource();
dataSource.setMinPoolSize(minPoolSize);
dataSource.setMaxPoolSize(maxPoolSize);
dataSource.setDriverClass(driverClass);
dataSource.setJdbcUrl(jdbcUrl);
dataSource.setMaxStatements(maxOpenPreparedStatements);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "c3p0", threadCount);
System.out.println();
public void test_proxool() throws Exception {
ProxoolDataSource dataSource = new ProxoolDataSource();
dataSource.setMinimumConnectionCount(minPoolSize);
dataSource.setMaximumConnectionCount(maxPoolSize);
dataSource.setDriver(driverClass);
dataSource.setDriverUrl(jdbcUrl);
dataSource.setUser(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "proxool", threadCount);
System.out.println();
public void test_tomcat_jdbc() throws Exception {
org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
dataSource.setMaxIdle(maxPoolSize);
dataSource.setMinIdle(minPoolSize);
dataSource.setMaxActive(maxPoolSize);
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setUsername(user);
dataSource.setPassword(password);
for (int i = 0; i < loopCount; ++i) {
p0(dataSource, "tomcat-jdbc", threadCount);
System.out.println();
private void p0(final DataSource dataSource, String name, int threadCount) throws Exception {
final CountDownLatch startLatch = new CountDownLatch(1);
final CountDownLatch endLatch = new CountDownLatch(threadCount);
final CountDownLatch dumpLatch = new CountDownLatch(1);
Thread[] threads = new Thread[threadCount];
final TableOperator operator = new TableOperator();
operator.setDataSource(dataSource);
operator.createTable();
for (int i = 0; i < threadCount; ++i) {
Thread thread = new Thread() {
public void run() {
startLatch.await();
for (int i = 0; i < LOOP_COUNT; ++i) {
operator.insert();
} catch (Exception ex) {
ex.printStackTrace();
endLatch.countDown();
dumpLatch.await();
} catch (InterruptedException e) {
e.printStackTrace();
threads[i] = thread;
thread.start();
long startMillis = System.currentTimeMillis();
long startYGC = TestUtil.getYoungGC();
long startFullGC = TestUtil.getFullGC();
startLatch.countDown();
endLatch.await();
long[] threadIdArray = new long[threads.length];
for (int i = 0; i < threads.length; ++i) {
threadIdArray[i] = threads[i].getId();
ThreadInfo[] threadInfoArray = ManagementFactory.getThreadMXBean().getThreadInfo(threadIdArray);
dumpLatch.countDown();
operator.dropTable();
long blockedCount = 0;
long waitedCount = 0;
for (int i = 0; i < threadInfoArray.length; ++i) {
ThreadInfo threadInfo = threadInfoArray[i];
blockedCount += threadInfo.getBlockedCount();
waitedCount += threadInfo.getWaitedCount();
long millis = System.currentTimeMillis() - startMillis;
long ygc = TestUtil.getYoungGC() - startYGC;
long fullGC = TestUtil.getFullGC() - startFullGC;
System.out.println("thread " + threadCount + " " + name + " millis : "
+ NumberFormat.getInstance().format(millis) + "; YGC " + ygc + " FGC " + fullGC
+ " blocked " + NumberFormat.getInstance().format(blockedCount) 
+ " waited " + NumberFormat.getInstance().format(waitedCount));
public class TableOperator {
private DataSource dataSource;
public void setDataSource(DataSource dataSource) {
this.dataSource = dataSource;
private static final int COUNT = 2;
public TableOperator() {
public void insert() throws Exception {
StringBuffer ddl = new StringBuffer();
ddl.append("INSERT INTO t_big (");
for (int i = 0; i < COUNT; ++i) {
if (i != 0) {
ddl.append(", ");
ddl.append("F" + i);
ddl.append(") VALUES (");
for (int i = 0; i < COUNT; ++i) {
if (i != 0) {
ddl.append(", ");
ddl.append("?");
ddl.append(")");
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(ddl.toString());
for (int i = 0; i < COUNT; ++i) {
stmt.setInt(i + 1, i);
stmt.execute();
stmt.close();
} finally {
conn.close();
public void dropTable() throws SQLException {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE t_big");
stmt.close();
} finally {
conn.close();
public void createTable() throws SQLException {
StringBuffer ddl = new StringBuffer();
ddl.append("CREATE TABLE t_big (FID INT AUTO_INCREMENT PRIMARY KEY ");
for (int i = 0; i < COUNT; ++i) {
ddl.append(", ");
ddl.append("F" + i);
ddl.append(" BIGINT NULL");
ddl.append(")");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.addBatch("DROP TABLE IF EXISTS t_big");
stmt.addBatch(ddl.toString());
stmt.executeBatch();
stmt.close();
} finally {
conn.close();
dataSource.setJdbcUrl(jdbcUrl);
private static final int COUNT = 2;
public TableOperator(){
public static String returnJSONResult(int resultCode, Object content) {
public static final String  PARAM_NAME_JMX_URL          = "jmxUrl";
public static final String  PARAM_NAME_JMX_USERNAME     = "jmxUsername";
public static final String  PARAM_NAME_JMX_PASSWORD     = "jmxPassword";
private String              jmxUrl                      = null;
private String              jmxUsername                 = null;
private String              jmxPassword                 = null;
private MBeanServerConnection conn                      = null;
String param = readInitParam(PARAM_NAME_JMX_URL);
if (param != null) {
jmxUrl = param;
jmxUsername = readInitParam(PARAM_NAME_JMX_USERNAME);
jmxPassword = readInitParam(PARAM_NAME_JMX_PASSWORD);
initJmxConn();
} catch (IOException e) {
LOG.error("init jmx connection error", e);
private String readInitParam(String key) {
String value = null;
String param = getInitParameter(key);
if (param != null) {
param = param.trim();
if (param.length() > 0) {
value = param;
} catch (Exception e) {
String msg = "initParameter config ["+ key +"] error";
LOG.warn(msg, e);
return value;
private void initJmxConn() throws IOException {
if (jmxUrl != null) {
JMXServiceURL url = new JMXServiceURL(jmxUrl);
Map<String, String[]> env = null;
if (jmxUsername != null) {
env = new HashMap<String, String[]>();
String[] credentials = new String[]{jmxUsername,jmxPassword};
env.put(JMXConnector.CREDENTIALS, credentials);
JMXConnector jmxc = JMXConnectorFactory.connect(url, env);
conn = jmxc.getMBeanServerConnection();
private String getJmxResult(MBeanServerConnection connetion,String url)
throws Exception {
ObjectName name = new ObjectName(DruidStatService.MBEAN_NAME);
String result = (String) conn.invoke(name, "service",
new String[] { url }, new String[] { String.class.getName() });
return result;
private String genServiceResponse(String url) {
String resp = null;
if (jmxUrl == null) {
resp = statService.service(url);
if (conn == null) {
try {
initJmxConn();
} catch (IOException e) {
LOG.error("init jmx connection error", e);
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "init jmx connection error"+e.getMessage());
if (conn != null) {
resp = getJmxResult(conn,url);
} catch (Exception e) {
LOG.error("get jmx data error", e);
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error:"+e.getMessage());
} else {
resp = getJmxResult(conn,url);
} catch (Exception e) {
LOG.error("get jmx data error", e);
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error"+e.getMessage());
return resp;
response.getWriter().print(genServiceResponse(fullUrl));
private final static Log      LOG                         = LogFactory.getLog(StatViewServlet.class);
private static final long     serialVersionUID            = 1L;
public static final String    PARAM_NAME_RESET_ENABLE     = "resetEnable";
public static final String    PARAM_NAME_ALLOW            = "allow";
public static final String    PARAM_NAME_DENY             = "deny";
public static final String    PARAM_NAME_USERNAME         = "loginUsername";
public static final String    PARAM_NAME_PASSWORD         = "loginPassword";
public static final String    PARAM_NAME_JMX_URL          = "jmxUrl";
public static final String    PARAM_NAME_JMX_USERNAME     = "jmxUsername";
public static final String    PARAM_NAME_JMX_PASSWORD     = "jmxPassword";
public static final String    SESSION_USER_KEY            = "druid-user";
private final static String   RESOURCE_PATH               = "support/http/resources";
private final static String   TEMPLATE_PAGE_RESOURCE_PATH = RESOURCE_PATH + "/template.html";
private DruidStatService      statService                 = DruidStatService.getInstance();
public String                 templatePage;
private List<IPRange>         allowList                   = new ArrayList<IPRange>();
private List<IPRange>         denyList                    = new ArrayList<IPRange>();
private String                username                    = null;
private String                password                    = null;
private String                jmxUrl                      = null;
private String                jmxUsername                 = null;
private String                jmxPassword                 = null;
private MBeanServerConnection conn                        = null;
String msg = "initParameter config [" + key + "] error";
if (jmxUrl != null) {
String[] credentials = new String[] { jmxUsername, jmxPassword };
JMXConnector jmxc = JMXConnectorFactory.connect(url, env);
conn = jmxc.getMBeanServerConnection();
private String getJmxResult(MBeanServerConnection connetion, String url) throws Exception {
String result = (String) conn.invoke(name, "service", new String[] { url },
new String[] { String.class.getName() });
if (conn == null) {
try {
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,
"init jmx connection error" + e.getMessage());
if (conn != null) {
resp = getJmxResult(conn, url);
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error:"
+ e.getMessage());
} else {
resp = getJmxResult(conn, url);
resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,
"get data error" + e.getMessage());
public final static int RevisionVersion = 15;
public final static int RevisionVersion = 16;
if (!isFirst(x.getLeft())) {
public static boolean isFirst(SQLObject x) {
SQLObject parent = x.getParent();
if (!(parent instanceof SQLExpr)) {
return true;
if (parent instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryExpr = (SQLBinaryOpExpr) parent;
if (isFirst(binaryExpr.getParent()) && x == binaryExpr.getLeft()) {
return true;
return false;
public boolean visit(SQLIdentifierExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public static final String EVAL_EXPR  = "eval.expr";
public boolean visit(SQLIdentifierExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
functions.put("hex", Hex.instance);
functions.put("unhex", Unhex.instance);
boolean leftHasValue = left.getAttributes().containsKey(EVAL_VALUE);
boolean rightHasValue = right.getAttributes().containsKey(EVAL_VALUE);
if ((!leftHasValue) && !rightHasValue) {
SQLExpr leftEvalExpr = (SQLExpr) left.getAttribute(EVAL_EXPR);
SQLExpr rightEvalExpr = (SQLExpr) right.getAttribute(EVAL_EXPR);
if (leftEvalExpr.equals(rightEvalExpr)) {
switch (x.getOperator()) {
case Equality
case GreaterThanOrEqual
case LessThanOrEqual
case NotLessThan
case NotGreaterThan
x.putAttribute(EVAL_VALUE, Boolean.TRUE);
return false;
case NotEqual
case NotLike
case GreaterThan
case LessThan
x.putAttribute(EVAL_VALUE, Boolean.FALSE);
return false;
if (!leftHasValue) {
if (!rightHasValue) {
public static boolean visit(SQLEvalVisitor visitor, SQLIdentifierExpr x) {
x.putAttribute(EVAL_EXPR, x);
return false;
if (x.getParameters().size() != 1) {
SQLExpr param0 = x.getParameters().get(0);
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return SQLEvalVisitor.EVAL_ERROR;
if (param0Value instanceof String) {
byte[] bytes = ((String) param0Value).getBytes();
String result = HexBin.encode(bytes);
return result;
if (param0Value instanceof Number) {
long value = ((Number) param0Value).longValue();
String result = Long.toHexString(value).toUpperCase();
return result;
return SQLEvalVisitor.EVAL_ERROR;
public class Unhex implements Function {
public final static Unhex instance = new Unhex();
public Object eval(SQLEvalVisitor visitor, SQLMethodInvokeExpr x) {
if (x.getParameters().size() != 1) {
throw new ParserException("argument's != 1, " + x.getParameters().size());
SQLExpr param0 = x.getParameters().get(0);
if (param0 instanceof SQLMethodInvokeExpr) {
SQLMethodInvokeExpr paramMethodExpr = (SQLMethodInvokeExpr) param0;
if (paramMethodExpr.getMethodName().equalsIgnoreCase("hex")) {
SQLExpr subParamExpr = paramMethodExpr.getParameters().get(0);
subParamExpr.accept(visitor);
Object param0Value = subParamExpr.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
x.putAttribute(EVAL_EXPR, subParamExpr);
return SQLEvalVisitor.EVAL_ERROR;
return param0Value;
param0.accept(visitor);
Object param0Value = param0.getAttributes().get(EVAL_VALUE);
if (param0Value == null) {
return SQLEvalVisitor.EVAL_ERROR;
if (param0Value instanceof String) {
byte[] bytes = HexBin.decode((String) param0Value);
String result;
result = new String(bytes, "UTF-8");
} catch (UnsupportedEncodingException e) {
throw new IllegalStateException(e.getMessage(), e);
return result;
return SQLEvalVisitor.EVAL_ERROR;
public class MySqlWallTest27 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where hex('abc') = '616263'")); 
public class MySqlWallTest28 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where hex(123) = '7B'")); 
public class MySqlWallTest29 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where UNHEX('4D7953514C') = 'MySQL'")); 
public class MySqlWallTest30 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where UNHEX(HEX('MySQL')) = 'MySQL'")); 
public class MySqlWallTest31 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where UNHEX(HEX(FNAME)) = FNAME")); 
public class MySqlWallTest32 extends TestCase {
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where NOT(UNHEX(HEX(FNAME)) != FNAME)")); 
public void test_false_1() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where NOT(UNHEX(HEX(FNAME)) > FNAME)")); 
public void test_false_2() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where NOT(UNHEX(HEX(FNAME)) < FNAME)")); 
public void test_false_3() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select * from t where NOT(UNHEX(HEX(FNAME)) NOT LIKE FNAME)")); 
public class MySqlHexTest extends TestCase {
final int COUNT = 800;
private String          jdbcUrl;
private String          user;
private String          password;
private String          driverClass;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
jdbcUrl = "jdbc:mysql:
user = "circe";
password = "circe";
driverClass = "com.mysql.jdbc.Driver";
dataSource = new DruidDataSource();
dataSource.setDriverClassName(driverClass);
dataSource.setUrl(jdbcUrl);
dataSource.setPoolPreparedStatements(true);
dataSource.setUsername(user);
dataSource.setPassword(password);
public void test_0() throws Exception {
Connection conn = dataSource.getConnection();
String sql = "select hex('123'),hex(123)";
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();
JdbcUtils.printResultSet(rs);
rs.close();
stmt.close();
conn.close();
private boolean             deleteWhereNoneCheck       = false;
private boolean             updateWhereNoneCheck       = false;
public boolean isDeleteWhereNoneCheck() {
return deleteWhereNoneCheck;
public void setDeleteWhereNoneCheck(boolean deleteWhereNoneCheck) {
this.deleteWhereNoneCheck = deleteWhereNoneCheck;
public boolean isUpdateWhereNoneCheck() {
return updateWhereNoneCheck;
public void setUpdateWhereNoneCheck(boolean updateWhereNoneCheck) {
this.updateWhereNoneCheck = updateWhereNoneCheck;
WallConfig config = visitor.getConfig();
if (!config.isDeleteAllow()) {
if (x.getWhere() == null && config.isDeleteWhereNoneCheck()) {
addViolation(visitor, "delete none condition not allow", x);
if (Boolean.TRUE == getConditionValue(visitor, x.getWhere(), config.isDeleteWhereAlwayTrueCheck())) {
WallConfig config = visitor.getConfig();
if (!config.isUpdateAllow()) {
if (x.getWhere() == null && config.isUpdateWhereNoneCheck()) {
if (x instanceof MySqlUpdateStatement) {
MySqlUpdateStatement mysqlUpdate = (MySqlUpdateStatement) x;
if (mysqlUpdate.getLimit() == null) {
addViolation(visitor, "update none condition not allow", x);
if (config.isUpdateWhereAlayTrueCheck()) {
if (where != null) {
where.setParent(this);
public void test_true_1() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(
"update test.dml_health_check set id=?")); 
public void test_true_2() throws Exception {
WallConfig config = new WallConfig();
config.setUpdateWhereNoneCheck(true);
Assert.assertTrue(WallUtils.isValidateMySql(
"update test.dml_health_check set id=? limit ?", config)); 
WallConfig config = new WallConfig();
config.setUpdateWhereNoneCheck(true);
"update test.dml_health_check set id=?", config)); 
Assert.assertTrue(WallUtils.isValidateMySql(sql));
Assert.assertTrue(WallUtils.isValidateOracle(sql));
public void testMySql_false() throws Exception {
WallConfig config = new WallConfig();
config.setDeleteWhereNoneCheck(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void testORACLE_false() throws Exception {
WallConfig config = new WallConfig();
config.setDeleteWhereNoneCheck(true);
Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
public void testMySql_true() throws Exception {
WallConfig config = new WallConfig();
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
public void testORACLE_true() throws Exception {
WallConfig config = new WallConfig();
Assert.assertTrue(WallUtils.isValidateOracle(sql, config));
public void testMySql_false() throws Exception {
WallConfig config = new WallConfig();
config.setUpdateAllow(false);
public void testORACLE_false() throws Exception {
WallConfig config = new WallConfig();
config.setUpdateAllow(false);
if (where != null) {
where.setParent(this);
public class StatViewServlet extends HttpServlet {
private final static Log    LOG                         = LogFactory.getLog(StatViewServlet.class);
private static final long   serialVersionUID            = 1L;
public static final String  PARAM_NAME_RESET_ENABLE     = "resetEnable";
public static final String  PARAM_NAME_ALLOW            = "allow";
public static final String  PARAM_NAME_DENY             = "deny";
public static final String  PARAM_NAME_USERNAME         = "loginUsername";
public static final String  PARAM_NAME_PASSWORD         = "loginPassword";
public static final String  SESSION_USER_KEY            = "druid-user";
private final static String RESOURCE_PATH               = "support/http/resources";
private final static String TEMPLATE_PAGE_RESOURCE_PATH = RESOURCE_PATH + "/template.html";
private DruidStatService    statService                 = DruidStatService.getInstance();
public String               templatePage;
private List<IPRange>       allowList                   = new ArrayList<IPRange>();
private List<IPRange>       denyList                    = new ArrayList<IPRange>();
private String              username                    = null;
private String              password                    = null;
public void init() throws ServletException {
initAuthEnv();
templatePage = IOUtils.readFromResource(TEMPLATE_PAGE_RESOURCE_PATH);
} catch (IOException e) {
throw new ServletException("error read templatePage:" + TEMPLATE_PAGE_RESOURCE_PATH, e);
String param = getInitParameter(PARAM_NAME_RESET_ENABLE);
if (param != null && param.trim().length() != 0) {
param = param.trim();
boolean resetEnable = Boolean.parseBoolean(param);
statService.setResetEnable(resetEnable);
} catch (Exception e) {
String msg = "initParameter config error, resetEnable : " + getInitParameter(PARAM_NAME_RESET_ENABLE);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_ALLOW);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
continue;
IPRange ipRange = new IPRange(item);
allowList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, allow : " + getInitParameter(PARAM_NAME_ALLOW);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_DENY);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
continue;
IPRange ipRange = new IPRange(item);
denyList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, deny : " + getInitParameter(PARAM_NAME_DENY);
LOG.error(msg, e);
private void initAuthEnv() {
String paramUserName = getInitParameter(PARAM_NAME_USERNAME);
if (!StringUtils.isEmpty(paramUserName)) {
this.username = paramUserName;
String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);
if (!StringUtils.isEmpty(paramPassword)) {
this.password = paramPassword;
public boolean isRequireAuth() {
return this.username != null;
public boolean isPermittedRequest(HttpServletRequest request) {
String remoteAddress = request.getRemoteAddr();
return isPermittedRequest(remoteAddress);
public boolean isPermittedRequest(String remoteAddress) {
boolean ipV6 = remoteAddress != null && remoteAddress.indexOf(':') != -1;
if (ipV6) {
if (denyList.size() == 0 && allowList.size() == 0) {
return true;
IPAddress ipAddress = new IPAddress(remoteAddress);
for (IPRange range : denyList) {
if (range.isIPAddressInRange(ipAddress)) {
return false;
if (allowList.size() > 0) {
for (IPRange range : allowList) {
if (range.isIPAddressInRange(ipAddress)) {
return true;
return false;
return true;
public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
HttpSession session = request.getSession();
String contextPath = request.getContextPath();
String servletPath = request.getServletPath();
String requestURI = request.getRequestURI();
response.setCharacterEncoding("utf-8");
if (contextPath == null) { 
contextPath = "";
String uri = contextPath + servletPath;
String path = requestURI.substring(contextPath.length() + servletPath.length());
if (!isPermittedRequest(request)) {
path = "/nopermit.html";
returnResourceFile(path, uri, response);
if ("/submitLogin".equals(path)) {
String usernameParam = request.getParameter(PARAM_NAME_USERNAME);
String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);
if (username.equals(usernameParam) && password.equals(passwordParam)) {
request.getSession().setAttribute(SESSION_USER_KEY, username);
response.getWriter().print("success");
response.getWriter().print("error");
if (isRequireAuth()
&& session.getAttribute(SESSION_USER_KEY) == null
&& !("/login.html".equals(path) || path.startsWith("/css") || path.startsWith("/js") || path.startsWith("/img"))) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/login.html");
response.sendRedirect("druid/login.html");
if ("".equals(path)) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/index.html");
response.sendRedirect("druid/index.html");
if ("/".equals(path)) {
response.sendRedirect("index.html");
if (path.indexOf(".json") >= 0) {
String fullUrl = path;
if (request.getQueryString() != null && request.getQueryString().length() > 0) {
fullUrl += "?" + request.getQueryString();
response.getWriter().print(statService.service(fullUrl));
returnResourceFile(path, uri, response);
private void returnResourceFile(String fileName, String uri, HttpServletResponse response) throws ServletException,
IOException {
if (fileName.endsWith(".jpg")) {
byte[] bytes = IOUtils.readByteArrayFromResource(RESOURCE_PATH + fileName);
if (bytes != null) {
response.getOutputStream().write(bytes);
String text = IOUtils.readFromResource(RESOURCE_PATH + fileName);
if (text == null) {
response.sendRedirect(uri + "/index.html");
if (fileName.endsWith(".css")) {
response.setContentType("text/css;charset=utf-8");
} else if (fileName.endsWith(".js")) {
response.setContentType("text/javascript;charset=utf-8");
response.getWriter().write(text);
public class StatViewServlet extends HttpServlet {
private final static Log    LOG                         = LogFactory.getLog(StatViewServlet.class);
private static final long   serialVersionUID            = 1L;
public static final String  PARAM_NAME_RESET_ENABLE     = "resetEnable";
public static final String  PARAM_NAME_ALLOW            = "allow";
public static final String  PARAM_NAME_DENY             = "deny";
public static final String  PARAM_NAME_USERNAME         = "loginUsername";
public static final String  PARAM_NAME_PASSWORD         = "loginPassword";
public static final String  SESSION_USER_KEY            = "druid-user";
private final static String RESOURCE_PATH               = "support/http/resources";
private final static String TEMPLATE_PAGE_RESOURCE_PATH = RESOURCE_PATH + "/template.html";
private DruidStatService    statService                 = DruidStatService.getInstance();
public String               templatePage;
private List<IPRange>       allowList                   = new ArrayList<IPRange>();
private List<IPRange>       denyList                    = new ArrayList<IPRange>();
private String              username                    = null;
private String              password                    = null;
public void init() throws ServletException {
initAuthEnv();
templatePage = IOUtils.readFromResource(TEMPLATE_PAGE_RESOURCE_PATH);
} catch (IOException e) {
throw new ServletException("error read templatePage:" + TEMPLATE_PAGE_RESOURCE_PATH, e);
String param = getInitParameter(PARAM_NAME_RESET_ENABLE);
if (param != null && param.trim().length() != 0) {
param = param.trim();
boolean resetEnable = Boolean.parseBoolean(param);
statService.setResetEnable(resetEnable);
} catch (Exception e) {
String msg = "initParameter config error, resetEnable : " + getInitParameter(PARAM_NAME_RESET_ENABLE);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_ALLOW);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
IPRange ipRange = new IPRange(item);
allowList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, allow : " + getInitParameter(PARAM_NAME_ALLOW);
LOG.error(msg, e);
String param = getInitParameter(PARAM_NAME_DENY);
if (param != null && param.trim().length() != 0) {
param = param.trim();
String[] items = param.split(",");
for (String item : items) {
if (item == null || item.length() == 0) {
IPRange ipRange = new IPRange(item);
denyList.add(ipRange);
} catch (Exception e) {
String msg = "initParameter config error, deny : " + getInitParameter(PARAM_NAME_DENY);
LOG.error(msg, e);
private void initAuthEnv() {
String paramUserName = getInitParameter(PARAM_NAME_USERNAME);
if (!StringUtils.isEmpty(paramUserName)) {
this.username = paramUserName;
String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);
if (!StringUtils.isEmpty(paramPassword)) {
this.password = paramPassword;
public boolean isRequireAuth() {
return this.username != null;
public boolean isPermittedRequest(HttpServletRequest request) {
String remoteAddress = request.getRemoteAddr();
return isPermittedRequest(remoteAddress);
public boolean isPermittedRequest(String remoteAddress) {
boolean ipV6 = remoteAddress != null && remoteAddress.indexOf(':') != -1;
if (ipV6) {
if (denyList.size() == 0 && allowList.size() == 0) {
return true;
IPAddress ipAddress = new IPAddress(remoteAddress);
for (IPRange range : denyList) {
if (range.isIPAddressInRange(ipAddress)) {
return false;
if (allowList.size() > 0) {
for (IPRange range : allowList) {
if (range.isIPAddressInRange(ipAddress)) {
return true;
return false;
return true;
public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
HttpSession session = request.getSession();
String contextPath = request.getContextPath();
String servletPath = request.getServletPath();
String requestURI = request.getRequestURI();
response.setCharacterEncoding("utf-8");
if (contextPath == null) { 
contextPath = "";
String uri = contextPath + servletPath;
String path = requestURI.substring(contextPath.length() + servletPath.length());
if (!isPermittedRequest(request)) {
path = "/nopermit.html";
returnResourceFile(path, uri, response);
if ("/submitLogin".equals(path)) {
String usernameParam = request.getParameter(PARAM_NAME_USERNAME);
String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);
if (username.equals(usernameParam) && password.equals(passwordParam)) {
request.getSession().setAttribute(SESSION_USER_KEY, username);
response.getWriter().print("success");
response.getWriter().print("error");
if (isRequireAuth()
&& session.getAttribute(SESSION_USER_KEY) == null
&& !("/login.html".equals(path) || path.startsWith("/css") || path.startsWith("/js") || path.startsWith("/img"))) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/login.html");
response.sendRedirect("login.html");
if ("".equals(path)) {
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/index.html");
response.sendRedirect("druid/index.html");
if ("/".equals(path)) {
response.sendRedirect("index.html");
if (path.indexOf(".json") >= 0) {
String fullUrl = path;
if (request.getQueryString() != null && request.getQueryString().length() > 0) {
fullUrl += "?" + request.getQueryString();
response.getWriter().print(statService.service(fullUrl));
returnResourceFile(path, uri, response);
private void returnResourceFile(String fileName, String uri, HttpServletResponse response) throws ServletException,
IOException {
if (fileName.endsWith(".jpg")) {
byte[] bytes = IOUtils.readByteArrayFromResource(RESOURCE_PATH + fileName);
if (bytes != null) {
response.getOutputStream().write(bytes);
String text = IOUtils.readFromResource(RESOURCE_PATH + fileName);
if (text == null) {
response.sendRedirect(uri + "/index.html");
if (fileName.endsWith(".css")) {
response.setContentType("text/css;charset=utf-8");
} else if (fileName.endsWith(".js")) {
response.setContentType("text/javascript;charset=utf-8");
response.getWriter().write(text);
if (contextPath == null || contextPath.equals("") || contextPath.equals("/")) {
response.sendRedirect("/druid/login.html");
response.sendRedirect("druid/login.html");
if (url.startsWith("/wall.json")) {
Object result = statManagerFacade.getWallStatMap(null);
return returnJSONResult(RESULT_CODE_SUCCESS, result);
if (url.startsWith("/wall-") && url.indexOf(".json") > 0) {
Integer dataSourceId = StringUtils.subStringToInteger(url, "wall-", ".json");
Object result = statManagerFacade.getWallStatMap(dataSourceId);
return returnJSONResult(result == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, result);
if (identifierEquals("precision") && column.getDataType().getName().equalsIgnoreCase("double")) {
lexer.nextToken();
private static final long   serialVersionUID = 1L;
private boolean             lowPriority      = false;
private boolean             delayed          = false;
private SQLExprTableSource      tableSource;
private final List<SQLExpr> columns          = new ArrayList<SQLExpr>();
private List<ValuesClause>  valuesList       = new ArrayList<ValuesClause>();
private SQLQueryExpr        query;
if (tableSource == null) {
return null;
return (SQLName) tableSource.getExpr();
this.setTableSource(new SQLExprTableSource(tableName));
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
if (tableSource != null) {
tableSource.setParent(this);
this.tableSource = tableSource;
acceptChild(visitor, tableSource);
Map<String, Object> newMap = new LinkedHashMap<String, Object>();
newMap.put(key, valueB);
} else if (valueB == null) {
newMap.put(key, valueA);
newMap.put(key, newValue);
} else if (valueA instanceof Set && valueB instanceof Set) {
Set<Object> set = new HashSet<Object>();
set.addAll((Set) valueA);
set.addAll((Set) valueB);
newMap.put(key, set);
Object sum = SQLEvalVisitorUtils.add(valueA, valueB);
newMap.put(key, sum);
return newMap;
private int replaceCount;
public int getReplaceCount() {
return replaceCount;
public int incrementReplaceCount() {
return replaceCount++;
public void addReplaceCount(int value) {
this.replaceCount+= value;
private volatile long                              replaceCount;
final static AtomicLongFieldUpdater<WallTableStat> replaceCountUpdater    = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"replaceCount");
public long getReplaceCount() {
return replaceCount;
long val = stat.getReplaceCount();
if (val > 0) {
replaceCountUpdater.addAndGet(this, val);
if (replaceCount > 0) {
map.put("replaceCount", replaceCount);
@Override
public boolean visit(MySqlReplaceStatement x) {
return true;
} else if (parent instanceof MySqlReplaceStatement) {
tableStat.incrementReplaceCount();
public class MySqlWallTest35 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"REPLACE INTO `test2tb` VALUES " + 
"('51', '6714105741', ' <span class=H></span>', 'http:
Assert.assertEquals(1, provider.getTableStat("test2tb").getReplaceCount());
System.out.println(JSONUtils.toJSONString(provider.getStatsMap()));
public class WallStatTest_statMap extends TestCase {
protected void setUp() throws Exception {
WallContext.clearContext();
protected void tearDown() throws Exception {
WallContext.clearContext();
public void testMySql() throws Exception {
WallProvider providerA = new MySqlWallProvider();
String sql = "select * from t where len(fname) = 1";
Assert.assertTrue(providerA.checkValid(sql));
WallProvider providerB = new MySqlWallProvider();
String sql = "select * from t where len(fname) = 2";
Assert.assertTrue(providerB.checkValid(sql));
Map<String, Object> statMapA = providerA.getStatsMap();
Map<String, Object> statMapB = providerB.getStatsMap();
System.out.println(JSONUtils.toJSONString(statMapA));
System.out.println(JSONUtils.toJSONString(statMapB));
Map<String, Object> statMapMerged = DruidStatManagerFacade.mergWallStat(statMapA, statMapB);
System.out.println(JSONUtils.toJSONString(statMapMerged));
Assert.assertEquals(2L, statMapMerged.get("checkCount"));
public class MySqlCreateTableTest10 extends MysqlTest {
public void test_0() throws Exception {
String sql = "create table TACCOUNT (" + 
"        ID varchar(36) not null," + 
"        ACCOUNT varchar(100) not null," + 
"        account_money double precision," + 
"        NAME varchar(100) not null," + 
"        TYPE integer," + 
"        primary key (ID)" + 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLCreateTableStatement stmt = (SQLCreateTableStatement) statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("TACCOUNT")));
Assert.assertTrue(visitor.getColumns().contains(new Column("TACCOUNT", "ID")));
Assert.assertTrue(visitor.getColumns().contains(new Column("TACCOUNT", "ACCOUNT")));
Assert.assertTrue(visitor.getColumns().contains(new Column("TACCOUNT", "account_money")));
Assert.assertTrue(visitor.getColumns().contains(new Column("TACCOUNT", "NAME")));
Assert.assertTrue(visitor.getColumns().contains(new Column("TACCOUNT", "TYPE")));
public class MySqlShowFieldsTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "SHOW FIELDS FROM `schema_migrations`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class JSONParserTest3 extends TestCase {
public void test_parse() throws Exception {
String text = IOUtils.readFromResource("bvt/sonar-sql.json");
Map<String, Object> result = (Map<String, Object>)JSONUtils.parse(text);
LinkedHashMap wallStats = (LinkedHashMap) result.get("Content");
System.out.println(wallStats.get("blackList"));
private int                                           whiteSqlMaxSize   = 500;                                             
private int                                           blackSqlMaxSize   = 500;                                             
Assert.assertEquals(500, provider.getWhiteList().size());
Assert.assertEquals(500, provider.getBlackList().size());
public final class DruidStatService implements DruidStatServiceMBean {
private final static Log              LOG                    = LogFactory.getLog(DruidStatService.class);
public final static String            MBEAN_NAME             = "com.alibaba.druid:type=DruidStatService";
private final static DruidStatService instance               = new DruidStatService();
private static DruidStatManagerFacade statManagerFacade      = DruidStatManagerFacade.getInstance();
public final static int               RESULT_CODE_SUCCESS    = 1;
public final static int               RESULT_CODE_ERROR      = -1;
private final static int              DEFAULT_PAGE           = 1;
private final static int              DEFAULT_PER_PAGE_COUNT = Integer.MAX_VALUE;
private static final String           DEFAULT_ORDER_TYPE     = "asc";
private static final String           DEFAULT_ORDERBY        = "SQL";
private DruidStatService(){
public static DruidStatService getInstance() {
return instance;
public boolean isResetEnable() {
return statManagerFacade.isResetEnable();
public void setResetEnable(boolean value) {
statManagerFacade.setResetEnable(value);
public String service(String url) {
Map<String, String> parameters = getParameters(url);
if (url.equals("/basic.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.returnJSONBasicStat());
if (url.equals("/reset-all.json")) {
statManagerFacade.resetAll();
return returnJSONResult(RESULT_CODE_SUCCESS, null);
if (url.equals("/datasource.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.getDataSourceStatDataList());
if (url.equals("/activeConnectionStackTrace.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.getActiveConnStackTraceList());
if (url.startsWith("/datasource-")) {
Integer id = StringUtils.subStringToInteger(url, "datasource-", ".");
Object result = statManagerFacade.getDataSourceStatData(id);
return returnJSONResult(result == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, result);
if (url.startsWith("/connectionInfo-") && url.endsWith(".json")) {
Integer id = StringUtils.subStringToInteger(url, "connectionInfo-", ".");
List<?> connectionInfoList = statManagerFacade.getPoolingConnectionInfoByDataSourceId(id);
return returnJSONResult(connectionInfoList == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS,
connectionInfoList);
if (url.startsWith("/activeConnectionStackTrace-") && url.endsWith(".json")) {
Integer id = StringUtils.subStringToInteger(url, "activeConnectionStackTrace-", ".");
return returnJSONActiveConnectionStackTrace(id);
if (url.startsWith("/sql.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getSqlStatDataList(parameters));
if (url.startsWith("/wall.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWallStatMap(parameters));
if (url.startsWith("/wall-") && url.indexOf(".json") > 0) {
Integer dataSourceId = StringUtils.subStringToInteger(url, "wall-", ".json");
Object result = statManagerFacade.getWallStatMap(dataSourceId);
return returnJSONResult(result == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, result);
if (url.startsWith("/sql-") && url.indexOf(".json") > 0) {
Integer id = StringUtils.subStringToInteger(url, "sql-", ".json");
return getSqlStat(id);
if (url.startsWith("/weburi.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatDataList(parameters));
if (url.startsWith("/weburi-") && url.indexOf(".json") > 0) {
String uri = StringUtils.subString(url, "weburi-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatData(uri));
if (url.startsWith("/webapp.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebAppStatDataList(parameters));
if (url.startsWith("/websession.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionStatDataList(parameters));
if (url.startsWith("/websession-") && url.indexOf(".json") > 0) {
String id = StringUtils.subString(url, "websession-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionStatData(id));
if (url.startsWith("/spring.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getSpringStatDataList(parameters));
if (url.startsWith("/spring-detail.json")) {
String clazz = parameters.get("class");
String method = parameters.get("method");
return returnJSONResult(RESULT_CODE_SUCCESS, getSpringMethodStatData(clazz, method));
return returnJSONResult(RESULT_CODE_ERROR, "Do not support this request, please contact with administrator.");
private List<Map<String, Object>> getSpringStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = SpringStatManager.getInstance().getMethodStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> getWebURIStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getURIStatData();
return comparatorOrderBy(array, parameters);
private Map<String, Object> getWebURIStatData(String uri) {
return WebAppStatManager.getInstance().getURIStatData(uri);
private Map<String, Object> getWebSessionStatData(String sessionId) {
return WebAppStatManager.getInstance().getSessionStat(sessionId);
private Map<String, Object> getSpringMethodStatData(String clazz, String method) {
return SpringStatManager.getInstance().getMethodStatData(clazz, method);
private List<Map<String, Object>> getWebSessionStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getSessionStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> getWebAppStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getWebAppStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> comparatorOrderBy(List<Map<String, Object>> array, Map<String, String> parameters) {
if (array == null || array.isEmpty()) {
return null;
String orderBy, orderType = null;
Integer page = DEFAULT_PAGE;
Integer perPageCount = DEFAULT_PER_PAGE_COUNT;
if (parameters == null) {
orderBy = DEFAULT_ORDER_TYPE;
orderType = DEFAULT_ORDER_TYPE;
page = DEFAULT_PAGE;
perPageCount = DEFAULT_PER_PAGE_COUNT;
orderBy = parameters.get("orderBy");
orderType = parameters.get("orderType");
String pageParam = parameters.get("page");
if (pageParam != null && pageParam.length() != 0) {
page = Integer.parseInt(pageParam);
String pageCountParam = parameters.get("perPageCount");
if (pageCountParam != null && pageCountParam.length() > 0) {
perPageCount = Integer.parseInt(pageCountParam);
orderBy = orderBy == null ? DEFAULT_ORDERBY : orderBy;
orderType = orderType == null ? DEFAULT_ORDER_TYPE : orderType;
if (!"desc".equals(orderType)) {
orderType = DEFAULT_ORDER_TYPE;
if (orderBy != null && orderBy.trim().length() != 0) {
Collections.sort(array, new MapComparator<String, Object>(orderBy, DEFAULT_ORDER_TYPE.equals(orderType)));
int fromIndex = (page - 1) * perPageCount;
int toIndex = page * perPageCount;
if (toIndex > array.size()) {
toIndex = array.size();
return array.subList(fromIndex, toIndex);
private List<Map<String, Object>> getSqlStatDataList(Map<String, String> parameters) {
Integer dataSourceId = null;
String dataSourceIdParam = parameters.get("dataSourceId");
if (dataSourceIdParam != null && dataSourceIdParam.length() > 0) {
dataSourceId = Integer.parseInt(dataSourceIdParam);
List<Map<String, Object>> array = statManagerFacade.getSqlStatDataList(dataSourceId);
List<Map<String, Object>> sortedArray = comparatorOrderBy(array, parameters);
return sortedArray;
public Map<String, Object> getWallStatMap(Map<String, String> parameters) {
Integer dataSourceId = null;
String dataSourceIdParam = parameters.get("dataSourceId");
if (dataSourceIdParam != null && dataSourceIdParam.length() > 0) {
dataSourceId = Integer.parseInt(dataSourceIdParam);
Map<String, Object> result = statManagerFacade.getWallStatMap(dataSourceId);
List<Map<String, Object>> sortedArray = comparatorOrderBy((List<Map<String, Object>>)result.get("tables"), parameters);
result.put("tables", sortedArray);
sortedArray = comparatorOrderBy((List<Map<String, Object>>)result.get("functions"), parameters);
result.put("functions", sortedArray);
return result;
private String getSqlStat(Integer id) {
Map<String, Object> map = statManagerFacade.getSqlStatData(id);
if (map == null) {
return returnJSONResult(RESULT_CODE_ERROR, null);
String dbType = (String) map.get("DbType");
String sql = (String) map.get("SQL");
map.put("formattedSql", SQLUtils.format(sql, dbType));
List<SQLStatement> statementList = SQLUtils.parseStatements(sql, dbType);
if (!statementList.isEmpty()) {
SQLStatement statemen = statementList.get(0);
SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, dbType);
statemen.accept(visitor);
map.put("parsedTable", visitor.getTables().toString());
map.put("parsedFields", visitor.getColumns().toString());
map.put("parsedConditions", visitor.getConditions().toString());
map.put("parsedRelationships", visitor.getRelationships().toString());
map.put("parsedOrderbycolumns", visitor.getOrderByColumns().toString());
DateFormat format = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
Date maxTimespanOccurTime = (Date) map.get("MaxTimespanOccurTime");
if (maxTimespanOccurTime != null) {
map.put("MaxTimespanOccurTime", format.format(maxTimespanOccurTime));
return returnJSONResult(map == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, map);
private String returnJSONActiveConnectionStackTrace(Integer id) {
List<String> result = statManagerFacade.getActiveConnectionStackTraceByDataSourceId(id);
if (result == null) {
return returnJSONResult(RESULT_CODE_ERROR, "require set removeAbandoned=true");
return returnJSONResult(RESULT_CODE_SUCCESS, result);
public static String returnJSONResult(int resultCode, Object content) {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("ResultCode", resultCode);
dataMap.put("Content", content);
return JSONUtils.toJSONString(dataMap);
public static void registerMBean() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
ObjectName objectName = new ObjectName(MBEAN_NAME);
if (!mbeanServer.isRegistered(objectName)) {
mbeanServer.registerMBean(instance, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
public static void unregisterMBean() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
mbeanServer.unregisterMBean(new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
public static Map<String, String> getParameters(String url) {
if (url == null || (url = url.trim()).length() == 0) {
return Collections.<String, String> emptyMap();
String parametersStr = StringUtils.subString(url, "?", null);
if (parametersStr == null || parametersStr.length() == 0) {
return Collections.<String, String> emptyMap();
String[] parametersArray = parametersStr.split("&");
Map<String, String> parameters = new LinkedHashMap<String, String>();
for (String parameterStr : parametersArray) {
int index = parameterStr.indexOf("=");
if (index <= 0) {
continue;
String name = parameterStr.substring(0, index);
String value = parameterStr.substring(index + 1);
parameters.put(name, value);
return parameters;
public final class DruidStatService implements DruidStatServiceMBean {
private final static Log              LOG                    = LogFactory.getLog(DruidStatService.class);
public final static String            MBEAN_NAME             = "com.alibaba.druid:type=DruidStatService";
private final static DruidStatService instance               = new DruidStatService();
private static DruidStatManagerFacade statManagerFacade      = DruidStatManagerFacade.getInstance();
public final static int               RESULT_CODE_SUCCESS    = 1;
public final static int               RESULT_CODE_ERROR      = -1;
private final static int              DEFAULT_PAGE           = 1;
private final static int              DEFAULT_PER_PAGE_COUNT = Integer.MAX_VALUE;
private static final String           DEFAULT_ORDER_TYPE     = "asc";
private static final String           DEFAULT_ORDERBY        = "SQL";
private DruidStatService(){
public static DruidStatService getInstance() {
return instance;
public boolean isResetEnable() {
return statManagerFacade.isResetEnable();
public void setResetEnable(boolean value) {
statManagerFacade.setResetEnable(value);
public String service(String url) {
Map<String, String> parameters = getParameters(url);
if (url.equals("/basic.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.returnJSONBasicStat());
if (url.equals("/reset-all.json")) {
statManagerFacade.resetAll();
return returnJSONResult(RESULT_CODE_SUCCESS, null);
if (url.equals("/datasource.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.getDataSourceStatDataList());
if (url.equals("/activeConnectionStackTrace.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, statManagerFacade.getActiveConnStackTraceList());
if (url.startsWith("/datasource-")) {
Integer id = StringUtils.subStringToInteger(url, "datasource-", ".");
Object result = statManagerFacade.getDataSourceStatData(id);
return returnJSONResult(result == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, result);
if (url.startsWith("/connectionInfo-") && url.endsWith(".json")) {
Integer id = StringUtils.subStringToInteger(url, "connectionInfo-", ".");
List<?> connectionInfoList = statManagerFacade.getPoolingConnectionInfoByDataSourceId(id);
return returnJSONResult(connectionInfoList == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS,
connectionInfoList);
if (url.startsWith("/activeConnectionStackTrace-") && url.endsWith(".json")) {
Integer id = StringUtils.subStringToInteger(url, "activeConnectionStackTrace-", ".");
return returnJSONActiveConnectionStackTrace(id);
if (url.startsWith("/sql.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getSqlStatDataList(parameters));
if (url.startsWith("/wall.json")) {
Object result = statManagerFacade.getWallStatMap(null);
return returnJSONResult(RESULT_CODE_SUCCESS, result);
if (url.startsWith("/wall-") && url.indexOf(".json") > 0) {
Integer dataSourceId = StringUtils.subStringToInteger(url, "wall-", ".json");
Object result = statManagerFacade.getWallStatMap(dataSourceId);
return returnJSONResult(result == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, result);
if (url.startsWith("/sql-") && url.indexOf(".json") > 0) {
Integer id = StringUtils.subStringToInteger(url, "sql-", ".json");
return getSqlStat(id);
if (url.startsWith("/weburi.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatDataList(parameters));
if (url.startsWith("/weburi-") && url.indexOf(".json") > 0) {
String uri = StringUtils.subString(url, "weburi-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatData(uri));
if (url.startsWith("/webapp.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebAppStatDataList(parameters));
if (url.startsWith("/websession.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionStatDataList(parameters));
if (url.startsWith("/websession-") && url.indexOf(".json") > 0) {
String id = StringUtils.subString(url, "websession-", ".json");
return returnJSONResult(RESULT_CODE_SUCCESS, getWebSessionStatData(id));
if (url.startsWith("/spring.json")) {
return returnJSONResult(RESULT_CODE_SUCCESS, getSpringStatDataList(parameters));
if (url.startsWith("/spring-detail.json")) {
String clazz = parameters.get("class");
String method = parameters.get("method");
return returnJSONResult(RESULT_CODE_SUCCESS, getSpringMethodStatData(clazz, method));
return returnJSONResult(RESULT_CODE_ERROR, "Do not support this request, please contact with administrator.");
private List<Map<String, Object>> getSpringStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = SpringStatManager.getInstance().getMethodStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> getWebURIStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getURIStatData();
return comparatorOrderBy(array, parameters);
private Map<String, Object> getWebURIStatData(String uri) {
return WebAppStatManager.getInstance().getURIStatData(uri);
private Map<String, Object> getWebSessionStatData(String sessionId) {
return WebAppStatManager.getInstance().getSessionStat(sessionId);
private Map<String, Object> getSpringMethodStatData(String clazz, String method) {
return SpringStatManager.getInstance().getMethodStatData(clazz, method);
private List<Map<String, Object>> getWebSessionStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getSessionStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> getWebAppStatDataList(Map<String, String> parameters) {
List<Map<String, Object>> array = WebAppStatManager.getInstance().getWebAppStatData();
return comparatorOrderBy(array, parameters);
private List<Map<String, Object>> comparatorOrderBy(List<Map<String, Object>> array, Map<String, String> parameters) {
if (array == null || array.isEmpty()) {
return null;
String orderBy, orderType = null;
Integer page = DEFAULT_PAGE;
Integer perPageCount = DEFAULT_PER_PAGE_COUNT;
if (parameters == null) {
orderBy = DEFAULT_ORDER_TYPE;
orderType = DEFAULT_ORDER_TYPE;
page = DEFAULT_PAGE;
perPageCount = DEFAULT_PER_PAGE_COUNT;
orderBy = parameters.get("orderBy");
orderType = parameters.get("orderType");
String pageParam = parameters.get("page");
if (pageParam != null && pageParam.length() != 0) {
page = Integer.parseInt(pageParam);
String pageCountParam = parameters.get("perPageCount");
if (pageCountParam != null && pageCountParam.length() > 0) {
perPageCount = Integer.parseInt(pageCountParam);
orderBy = orderBy == null ? DEFAULT_ORDERBY : orderBy;
orderType = orderType == null ? DEFAULT_ORDER_TYPE : orderType;
if (!"desc".equals(orderType)) {
orderType = DEFAULT_ORDER_TYPE;
if (orderBy != null && orderBy.trim().length() != 0) {
Collections.sort(array, new MapComparator<String, Object>(orderBy, DEFAULT_ORDER_TYPE.equals(orderType)));
int fromIndex = (page - 1) * perPageCount;
int toIndex = page * perPageCount;
if (toIndex > array.size()) {
toIndex = array.size();
return array.subList(fromIndex, toIndex);
private List<Map<String, Object>> getSqlStatDataList(Map<String, String> parameters) {
Integer dataSourceId = null;
String dataSourceIdParam = parameters.get("dataSourceId");
if (dataSourceIdParam != null && dataSourceIdParam.length() > 0) {
dataSourceId = Integer.parseInt(dataSourceIdParam);
List<Map<String, Object>> array = statManagerFacade.getSqlStatDataList(dataSourceId);
List<Map<String, Object>> sortedArray = comparatorOrderBy(array, parameters);
return sortedArray;
public Map<String, Object> getWallStatMap(Map<String, String> parameters) {
Integer dataSourceId = null;
String dataSourceIdParam = parameters.get("dataSourceId");
if (dataSourceIdParam != null && dataSourceIdParam.length() > 0) {
dataSourceId = Integer.parseInt(dataSourceIdParam);
return statManagerFacade.getWallStatMap(dataSourceId);
private String getSqlStat(Integer id) {
Map<String, Object> map = statManagerFacade.getSqlStatData(id);
if (map == null) {
return returnJSONResult(RESULT_CODE_ERROR, null);
String dbType = (String) map.get("DbType");
String sql = (String) map.get("SQL");
map.put("formattedSql", SQLUtils.format(sql, dbType));
List<SQLStatement> statementList = SQLUtils.parseStatements(sql, dbType);
if (!statementList.isEmpty()) {
SQLStatement statemen = statementList.get(0);
SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(statementList, dbType);
statemen.accept(visitor);
map.put("parsedTable", visitor.getTables().toString());
map.put("parsedFields", visitor.getColumns().toString());
map.put("parsedConditions", visitor.getConditions().toString());
map.put("parsedRelationships", visitor.getRelationships().toString());
map.put("parsedOrderbycolumns", visitor.getOrderByColumns().toString());
DateFormat format = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss:SSS");
Date maxTimespanOccurTime = (Date) map.get("MaxTimespanOccurTime");
if (maxTimespanOccurTime != null) {
map.put("MaxTimespanOccurTime", format.format(maxTimespanOccurTime));
return returnJSONResult(map == null ? RESULT_CODE_ERROR : RESULT_CODE_SUCCESS, map);
private String returnJSONActiveConnectionStackTrace(Integer id) {
List<String> result = statManagerFacade.getActiveConnectionStackTraceByDataSourceId(id);
if (result == null) {
return returnJSONResult(RESULT_CODE_ERROR, "require set removeAbandoned=true");
return returnJSONResult(RESULT_CODE_SUCCESS, result);
public static String returnJSONResult(int resultCode, Object content) {
Map<String, Object> dataMap = new LinkedHashMap<String, Object>();
dataMap.put("ResultCode", resultCode);
dataMap.put("Content", content);
return JSONUtils.toJSONString(dataMap);
public static void registerMBean() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
ObjectName objectName = new ObjectName(MBEAN_NAME);
if (!mbeanServer.isRegistered(objectName)) {
mbeanServer.registerMBean(instance, objectName);
} catch (JMException ex) {
LOG.error("register mbean error", ex);
public static void unregisterMBean() {
MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
mbeanServer.unregisterMBean(new ObjectName(MBEAN_NAME));
} catch (JMException ex) {
LOG.error("unregister mbean error", ex);
public static Map<String, String> getParameters(String url) {
if (url == null || (url = url.trim()).length() == 0) {
return Collections.<String, String> emptyMap();
String parametersStr = StringUtils.subString(url, "?", null);
if (parametersStr == null || parametersStr.length() == 0) {
return Collections.<String, String> emptyMap();
String[] parametersArray = parametersStr.split("&");
Map<String, String> parameters = new LinkedHashMap<String, String>();
for (String parameterStr : parametersArray) {
int index = parameterStr.indexOf("=");
if (index <= 0) {
String name = parameterStr.substring(0, index);
String value = parameterStr.substring(index + 1);
parameters.put(name, value);
return parameters;
@Override
public int[] statement_executeBatch(FilterChain chain, StatementProxy statement) throws SQLException {
WallSqlStat sqlStat = (WallSqlStat) statement.getAttributes().get(ATTR_SQL_STAT);
int[] updateCounts = chain.statement_executeBatch(statement);
for (int i = 0; i < updateCounts.length; ++i) {
int updateCount = updateCounts[i];
statExecuteUpdate(sqlStat, updateCount);
return updateCounts;
} finally {
WallContext.clearContext();
if (updateCount > 0) {
statExecuteUpdate(sqlStat, updateCount);
if (sqlStat == null) {
} else if (sqlTableStat.getUpdateCount() > 0) {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("update t SET fname = 'xx' where FID = ?");
stmt.setInt(1, 3);
stmt.addBatch();
stmt.setInt(1, 4);
stmt.addBatch();
stmt.executeBatch();
stmt.close();
conn.close();
Assert.assertEquals(8, wallFilter.getProvider().getTableStat("t").getUpdateDataCount());
public final static int RevisionVersion = 17;
@SuppressWarnings("rawtypes")
@SuppressWarnings("rawtypes")
public class MySqlWallTest53 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setLimitZeroAllow(true);
Assert.assertTrue(provider.checkValid(
"select * from t limit 0,0"));
Assert.assertEquals(1, provider.getTableStats().size());
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertFalse(provider.checkValid(
"select * from t limit 0,0"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest54 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(false);
Assert.assertTrue(provider.checkValid(
"select `ENGINE`, `SUPPORT` from information_schema.Engines"));
Assert.assertEquals(1, provider.getTableStats().size());
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertFalse(provider.checkValid(
"select `ENGINE`, `SUPPORT` from information_schema.Engines"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest55 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"SELECT USER()"));
Assert.assertEquals(0, provider.getTableStats().size());
public void test_true_1() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"SELECT USER() FROM DUAL"));
Assert.assertEquals(1, provider.getTableStats().size());
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertFalse(provider.checkValid(
"SELECT USER() FROM X"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest56 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"SHOW GRANTS FOR CURRENT_USER()"));
Assert.assertEquals(0, provider.getTableStats().size());
public class MySqlWallTest57 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"SELECT @@version"));
Assert.assertEquals(0, provider.getTableStats().size());
public void test_true_1() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"SELECT @@version FROM DUAL"));
Assert.assertEquals(1, provider.getTableStats().size());
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertFalse(provider.checkValid(
"SELECT @@version FROM X"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest58 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(false);
Assert.assertTrue(provider.checkValid(
"SELECT COUNT(*) FROM information_schema.processlist " + 
"WHERE user <> 'replication' AND id <> CONNECTION_ID() " + 
"AND time > 60 AND command <> 'Sleep'"));
Assert.assertEquals(1, provider.getTableStats().size());
public void setName(SQLExpr name) {
if (name != null) {
name.setParent(this);
this.name = name;
public static final String EVAL_VALUE       = "eval.value";
public static final String EVAL_EXPR        = "eval.expr";
public static final Object EVAL_ERROR       = new Object();
public static final Object EVAL_VALUE_COUNT = new Object();
private int showCount;
this.replaceCount += value;
public int getShowCount() {
return showCount;
public void incrementShowCount() {
this.showCount++;
@Override
public boolean visit(MySqlShowCreateTableStatement x) {
String tableName = ((SQLName) x.getName()).getSimleName();
WallContext context = WallContext.current();
if (context != null) {
WallSqlTableStat tableStat = context.getTableStat(tableName);
if (tableStat != null) {
tableStat.incrementShowCount();
return false;
public static boolean isTopNoneFromSelect(SQLObject x) {
boolean topSelectStatement = isTopSelectStatement(x);
if (!topSelectStatement) {
addViolation(visitor, "deny schema : " + owner, x);
private static boolean isTopSelectStatement(SQLObject x) {
boolean topSelectStatement = false;
SQLObject parent = x.getParent();
if (parent instanceof SQLPropertyExpr) {
parent = parent.getParent();
if (parent instanceof SQLExprTableSource) {
parent = parent.getParent();
if (parent instanceof SQLSelectQueryBlock) {
parent = parent.getParent();
if (parent instanceof SQLSelect) {
parent = parent.getParent();
if (parent instanceof SQLSelectStatement || parent instanceof MySqlShowStatement) {
parent = parent.getParent();
if (parent == null) {
topSelectStatement = true;
return topSelectStatement;
boolean isTopNoneFrom = isTopSelectStatement(x);
if (isTopNoneFrom) {
return false;
boolean isTopUpdateStatement = false;
SQLObject selectParent = x.getParent();
while (selectParent instanceof SQLUnionQuery 
|| selectParent instanceof SQLJoinTableSource 
|| selectParent instanceof SQLSubqueryTableSource 
|| selectParent instanceof SQLSelect) {
selectParent = selectParent.getParent();
if (selectParent instanceof SQLUpdateStatement) {
isTopUpdateStatement = true;
if (isTopUpdateStatement) {
Assert.assertFalse(WallUtils.isValidateMySql("select @@version_compile_os  FROM X"));
Assert.assertTrue(WallUtils.isValidateMySql("select @@version_compile_os FROM X", config));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION SELECT User,Password FROM mysql.user"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION SELECT User,Password FROM `mysql`.`user`"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION SELECT User,Password FROM "mysql"."user""));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION SELECT User,Password FROM MYSQL.USER"));
Assert.assertTrue(WallUtils.isValidateMySql("select @@version_compile_os FROM X", config));
Assert.assertFalse(WallUtils.isValidateMySql("select @@version_compile_os FROM X", config));
Assert.assertFalse(WallUtils.isValidateMySql("select 14,13,12,11,10,@@version_compile_os,8,7,6,5,4,3,2,1 FROM X"));
Assert.assertTrue(WallUtils.isValidateMySql("select '@@version_compile_os' FROM X"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION select 1 from information_schema.columns"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT *FROM T UNION select 1 from mysql.user"));
Assert.assertTrue(WallUtils.isValidateMySql(
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select @@basedir FROM X")); 
Assert.assertEquals(1, provider.getTableStats().size());
"SELECT *FROM T UNION select `ENGINE`, `SUPPORT` from information_schema.Engines"));
Assert.assertEquals(2, provider.getTableStats().size());
"SELECT *FROM T UNION select `ENGINE`, `SUPPORT` from information_schema.Engines"));
Assert.assertEquals(2, provider.getTableStats().size());
public class MySqlWallTest59 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertTrue(provider.checkValid(
"SELECT * FROM mysql.proc " + 
"WHERE 1=1 AND db LIKE 'dsmessagedb001'" + 
" AND name LIKE 'Proc_getRemindinfoByRemindFlag'"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest60 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertTrue(provider.checkValid(
"show create table `mysql`.`help_relation`"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest61 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertTrue(provider.checkValid(
"SELECT * FROM `information_schema`.`columns` WHERE TABLE_NAME='aaaa' AND TABLE_SCHEMA='xxxx'"));
Assert.assertEquals(1, provider.getTableStats().size());
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertFalse(provider.checkValid(
"SELECT * FROM T " + 
"UNION " + 
"SELECT * FROM `information_schema`.`columns` WHERE TABLE_NAME='aaaa' AND TABLE_SCHEMA='xxxx'"));
Assert.assertEquals(2, provider.getTableStats().size());
public class MySqlWallTest62 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertTrue(provider.checkValid(
"select temp.*, u.CanComment, u.CanBeShared, u.CanForward, COALESCE(b.UserID,0) as isBlocked" + 
"   , COALESCE(f.UserID,0) as Followed, COALESCE(ff.UserID,0) as IsFollowed" + 
"   , COALESCE(ul.UserID,0) as liked, COALESCE(fff.UserID,0) as RIsFollowed " + 
"from (select 294765 as UserID, 0  as RUserID, 7785977 as PicID " + 
"       union all select 294765 as UserID, 0  as RUserID, 7780341 as PicID) temp     " + 
"left join Users as u on u.UserID = temp.UserID   " + 
"left join BlockUser as b on b.UserID = temp.UserID and b.BlockUserID = 294765     " + 
"left join Fans as f on f.FansID = temp.UserID and f.UserID = 294765   " + 
"left join Fans as ff ON ff.FansID = 294765 and ff.UserID = temp.UserID   " + 
"left join Fans as fff ON fff.FansID = 294765 and fff.UserID = temp.RUserID   " + 
"left join UserLikes as ul on ul.PicID = temp.PicID and ul.UserID = 294765"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest63 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertFalse(provider.checkValid(
"SELECT FID, FNAME FROM T UNION SELECT 1, 'AAA'"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlWallTest64 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertFalse(provider.checkValid(
"SELECT email, passwd, login_id, full_name" +
" FROM members" +
" WHERE member_id = 3 AND 1=(SELECT COUNT(*) FROM tabname);'"));
Assert.assertEquals(2, provider.getTableStats().size());
public class MySqlWallTest65 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
Assert.assertFalse(provider.checkValid(
"SELECT email, passwd, login_id, full_name" +
" FROM members" +
" WHERE member_id = 3 AND 0<(SELECT COUNT(*) FROM tabname);'"));
Assert.assertEquals(2, provider.getTableStats().size());
public void test_true() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle("select banner from sys.v_$version where rownum=1"));
Assert.assertTrue(WallUtils.isValidateOracle("select banner from sys.v where rownum=1"));
public void test_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select banner from sys.v_$version where rownum=1"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select banner from sys.v where rownum=1"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from TAB"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from tab"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from SYS.TAB"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from SYS."TAB""));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from all_users"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from TAB"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT * FROM T UNION select * from ALL_TABLES where (1=1 or (1+1)=2) and (4=8 or 1=1)"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name, password FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT permission_name FROM master..fn_my_permissions(null, DATABASE); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT permission_name FROM master..fn_my_permissions(null, SERVER); "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT permission_name FROM master..fn_my_permissions(master..syslogins, OBJECT);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT permission_name FROM master..fn_my_permissions(sa, USER);"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE denylogin = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE hasaccess = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE isntname = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE isntgroup = 0;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE sysadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE securityadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE serveradmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE setupadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE processadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE diskadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE dbcreator = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE bulkadmin = 1;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=sometable; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..sysobjects WHERE xtype = U;  use xtype = V for views SELECT name FROM someotherdb..sysobjects WHERE xtype = U; "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins WHERE sysadmin = 1 "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..sysdatabases;"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT TOP 1 name FROM (SELECT TOP 9 name FROM master..syslogins ORDER BY name ASC) sq ORDER BY name DESC "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name + - + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT loginame FROM master..sysprocesses WHERE spid = @@SPID"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name FROM master..syslogins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT *FROM T UNION SELECT name, password_hash FROM master.sys.sql_logins"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT * FROM T UNION select * from sysObjects"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT * FROM T UNION select * from sysdatabases"));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT * FROM T UNION SELECT sysobjects.name as tablename, syscolumns.name as columnname FROM sysobjects JOIN syscolumns ON sysobjects.id = syscolumns.id WHERE sysobjects.xtype = U AND syscolumns.name LIKE %PASSWORD% "));
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT * FROM T UNION SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = mytable);"));
String sql = "SELECT * FROM T UNION SELECT F1, F2 FROM ALL_ALL_TABLES";
String sql = "SELECT *FROM T UNION SELECT F1, F2 FROM SYS.ABC";
if (disableError != null) {
throw new SQLException("connection holder is null", disableError);
throw new SQLException("connection holder is null");
if (disableError != null) {
throw new SQLException("connection closed", disableError);
throw new SQLException("connection closed");
if (disableError != null) {
throw new SQLException("connection disabled", disableError);
throw new SQLException("connection disabled");
LOG.warn("get/close not same thread");
if (sqlFile != null) {
JdbcSqlStat.setContextSqlFile(null);
if (sqlName != null) {
JdbcSqlStat.setContextSqlName(null);
if (sqlFile != null) {
JdbcSqlStat.setContextSqlFile(sqlFile);
if (sqlName != null) {
JdbcSqlStat.setContextSqlName(sqlName);
stmt.execute("CREATE TABLE sequence_seed (value INTEGER, name VARCHAR(50) PRIMARY KEY)");
stmt.execute("CREATE TABLE t_User (id BIGINT PRIMARY KEY, name VARCHAR(50))");
boolean useLocalSessionState = holder.getDataSource().isUseLocalSessionState();
if (useLocalSessionState) {
if (readOnly == holder.isUnderlyingReadOnly()) {
boolean useLocalSessionState = holder.getDataSource().isUseLocalSessionState();
if (useLocalSessionState) {
if (level == holder.getUnderlyingTransactionIsolation()) {
boolean useLocalSessionState = holder.getDataSource().isUseLocalSessionState();
if (useLocalSessionState) {
if (holdability == holder.getUnderlyingHoldability()) {
if (this.dbType == JdbcConstants.MYSQL) {
boolean cacheServerConfigurationSet = false;
if (this.connectProperties.containsKey("cacheServerConfiguration")) {
cacheServerConfigurationSet = true;
} else if (this.jdbcUrl.indexOf("cacheServerConfiguration") != -1) {
cacheServerConfigurationSet = true;
if (cacheServerConfigurationSet) {
this.connectProperties.put("cacheServerConfiguration", "true");
if (this.createError == null) {
throw new GetConnectionTimeoutException(createError);
throw new GetConnectionTimeoutException();
return visit((SQLAlterTableStatement) x);
if (lexer.token() == Token.TABLE) {
lexer.nextToken();
SQLAlterTableStatement stmt = new SQLAlterTableStatement();
stmt.setName(this.exprParser.name());
for (;;) {
if (identifierEquals("ADD")) {
lexer.nextToken();
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("DISABLE")) {
lexer.nextToken();
if (lexer.token() == Token.CONSTRAINT) {
lexer.nextToken();
SQLAlterTableDisableConstraint item = new SQLAlterTableDisableConstraint();
item.setConstraintName(this.exprParser.name());
stmt.getItems().add(item);
acceptIdentifier("KEYS");
SQLAlterTableDisableKeys item = new SQLAlterTableDisableKeys();
stmt.getItems().add(item);
} else if (identifierEquals("ENABLE")) {
lexer.nextToken();
if (lexer.token() == Token.CONSTRAINT) {
lexer.nextToken();
SQLAlterTableEnableConstraint item = new SQLAlterTableEnableConstraint();
item.setConstraintName(this.exprParser.name());
stmt.getItems().add(item);
acceptIdentifier("KEYS");
SQLAlterTableEnableKeys item = new SQLAlterTableEnableKeys();
stmt.getItems().add(item);
return stmt;
@Override
public boolean visit(SQLAlterTableStatement x) {
print("ALTER TABLE ");
x.getName().accept(this);
incrementIndent();
for (int i = 0; i < x.getItems().size(); ++i) {
SQLAlterTableItem item = x.getItems().get(i);
if (i != 0) {
print(',');
println();
item.accept(this);
decrementIndent();
return false;
@Override
public boolean visit(SQLAlterTableStatement x) {
String tableName = x.getName().toString();
TableStat stat = getTableStat(tableName);
stat.incrementAlterCount();
setCurrentTable(x, tableName);
for (SQLAlterTableItem item : x.getItems()) {
item.setParent(x);
item.accept(this);
return false;
public class SQLServerlAlterTableTest_0 extends TestCase {
public void test_alter_first() throws Exception {
String sql = "alter table st_jklsxxb enable constraint FK_ST_xxx_REFERENCE_ST_xxx";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE st_jklsxxb" + 
"ntENABLE CONSTRAINT FK_ST_xxx_REFERENCE_ST_xxx", output);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
} else if (identifierEquals("DISABLE")) {
lexer.nextToken();
if (lexer.token() == Token.CONSTRAINT) {
lexer.nextToken();
SQLAlterTableEnableConstraint item = new SQLAlterTableEnableConstraint();
item.setConstraintName(this.exprParser.name());
stmt.getItems().add(item);
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("ENABLE")) {
lexer.nextToken();
if (lexer.token() == Token.CONSTRAINT) {
lexer.nextToken();
SQLAlterTableDisableConstraint item = new SQLAlterTableDisableConstraint();
item.setConstraintName(this.exprParser.name());
stmt.getItems().add(item);
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
public class OracleAlterTableTest12 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"alter table st_jklsxxb enable constraint FK_ST_xxx_REFERENCE_ST_xxx";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("st_jklsxxb")));
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleAlterTableTest13 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"alter table st_jklsxxb disable constraint FK_ST_xxx_REFERENCE_ST_xxx";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("st_jklsxxb")));
Assert.assertEquals(0, visitor.getColumns().size());
public class PGCreateTableTest_0 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE my_first_table (" + 
"    first_column text," + 
"    second_column integer" + 
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("my_first_table")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("my_first_table")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 2);
public class PGCreateTableTest_1 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE products (" + 
"    product_no integer," + 
"    name text," + 
"    price numeric" + 
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 3);
public class PGCreateTableTest_2 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE products (" + 
"    product_no integer," + 
"    name text," + 
"    price numeric DEFAULT 9.99" + 
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 3);
public class PGCreateTableTest_3 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE products (" + 
"    product_no integer," + 
"    name text," + 
"    price numeric DEFAULT nextval('products_product_no_seq')" + 
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 3);
public class PGCreateTableTest_4 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE products (" + 
"    product_no integer," + 
"    name text," + 
"    price numeric CHECK (price > 0)" + 
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 3);
public class MySqlSetTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmt = parser.parseStatementList();
SQLStatement statemen = stmt.get(0);
print(stmt);
Assert.assertEquals(1, stmt.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String text = output(stmt);
Assert.assertEquals("SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ", text);
public class MySqlShowTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SHOW TRIGGERS FROM `sonar` LIKE 'action_plans'";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlShowTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SHOW INDEXES FROM `sonar`.`action_plans`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlShowTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SHOW CREATE TABLE `sonar`.`action_plans`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlShowTest_3 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SHOW FULL COLUMNS FROM `sonar`.`action_plans`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
if (identifierEquals("COMMENT")) {
lexer.nextToken();
column.setComment(lexer.stringVal());
accept(Token.LITERAL_CHARS);
public class MySqlCreateTableTest11 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `tmall_campaign` (" + 
"`id` int(11) NOT NULL AUTO_INCREMENT," + 
"`campaign_name` varchar(200) NOT NULL COMMENT ''," + 
"`create_date` datetime DEFAULT NULL COMMENT ''," + 
"`delete_flag` int(11) DEFAULT '0' COMMENT ''," + 
"PRIMARY KEY (`id`)" + 
") ENGINE=InnoDB DEFAULT CHARSET=gbk;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLCreateTableStatement stmt = (SQLCreateTableStatement) statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("tmall_campaign")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tmall_campaign", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tmall_campaign", "campaign_name")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tmall_campaign", "create_date")));
Assert.assertTrue(visitor.getColumns().contains(new Column("tmall_campaign", "delete_flag")));
public class OBTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mysql:
dataSource.setUsername("admin");
dataSource.setPassword("admin");
dataSource.setFilters("log4j");
public void test_connect() throws Exception {
Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);
conn.close();
Connection conn = dataSource.getConnection();
conn.setAutoCommit(true);
conn.close();
String property = System.getProperty("druid.testWhileIdle");
if ("true".equals(property)) {
this.setTestWhileIdle(true);
String property = System.getProperty("druid.validationQuery");
if (property != null && property.length() > 0) {
this.setValidationQuery(property);
if (identifierEquals("AUTO_INCREMENT")) {
lexer.nextToken();
accept(Token.EQ);
stmt.getTableOptions().put("AUTO_INCREMENT", lexer.numberString());
lexer.nextToken();
continue;
public class MySqlCreateTableTest13 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `xx_video` (" + 
"`id` int(11) NOT NULL AUTO_INCREMENT," + 
"`video_url` varchar(500) DEFAULT NULL," + 
"`video_title` varchar(200) DEFAULT NULL," + 
"`video_des` varchar(500) DEFAULT NULL," + 
"`video_type` varchar(11) NOT NULL," + 
"`delete_flag` int(11) DEFAULT '0'," + 
"`create_date` datetime DEFAULT NULL," + 
"`last_update` datetime DEFAULT NULL," + 
"PRIMARY KEY (`id`)" + 
") ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=gbk;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(8, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("xx_video")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xx_video", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xx_video", "video_url")));
return primaryRest(expr);
} else if ("POSITION".equalsIgnoreCase(ident)) {
accept(Token.LPAREN);
SQLExpr subStr = this.primary();
accept(Token.IN);
SQLExpr str = this.expr();
accept(Token.RPAREN);
SQLMethodInvokeExpr locate = new SQLMethodInvokeExpr("LOCATE");
locate.getParameters().add(subStr);
locate.getParameters().add(str);
expr = locate;
public class MySqlSelectTest_POSITION extends MysqlTest {
public void test_0() throws Exception {
String sql = "select a.rule_id, " + 
"b.object_id, " + 
"a.user_nick, " + 
"SUBSTRING(b.content, POSITION('bizOrderId' IN b.content), 30) as dingdanhao, " + 
"SUBSTRING(b.content, POSITION('loginIn7Days' IN b.content), 88) as shengdajieguo, " + 
"a.action_time " + 
"from ctu_scheme_0025 a, " + 
"ctu_scheme_detail_0025 b";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ctu_scheme_0025")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ctu_scheme_detail_0025")));
if (identifierEquals("COMMENT")) {
lexer.nextToken();
accept(Token.EQ);
stmt.getTableOptions().put("COMMENT", lexer.stringVal());
lexer.nextToken();
continue;
continue;
continue;
if (identifierEquals("USING")) {
lexer.nextToken();
key.setIndexType(lexer.stringVal());
lexer.nextToken();
String key = option.getKey();
print(key);
if ("COMMENT".equals(key)) {
print(''');
print(option.getValue());
print(''');
print(option.getValue());
public class MySqlCreateTableTest14 extends MysqlTest {
public void test_0() throws Exception {
String sql = " CREATE TABLE `OptionList` ( " + 
"`ID` int(11) NOT NULL AUTO_INCREMENT, " + 
"`OptionID` int(11) DEFAULT NULL COMMENT 'ID', " + 
"`QuizID` int(11) DEFAULT NULL COMMENT 'ID', " + 
"`OptionName` varchar(500) DEFAULT NULL COMMENT '', " + 
"`OptionCount` int(11) DEFAULT NULL COMMENT '', " + 
"PRIMARY KEY (`ID`), KEY `quizId` (`QuizID`) USING BTREE, " + 
"KEY `optionId` (`OptionID`) USING BTREE" + 
") ENGINE=InnoDB DEFAULT CHARSET=gbk COMMENT=''";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("OptionList")));
Assert.assertTrue(visitor.getColumns().contains(new Column("OptionList", "ID")));
Assert.assertTrue(visitor.getColumns().contains(new Column("OptionList", "OptionCount")));
protected SQLDataType parseDataTypeRest(SQLDataType dataType) {
super.parseDataTypeRest(dataType);
if (identifierEquals("UNSIGNED")) {
lexer.nextToken();
dataType.getAttributes().put("unsigned", true);
return dataType;
if (Boolean.TRUE == x.getAttribute("unsigned")) {
print(" unsigned");
public class MySqlCreateTableTest15 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `xxx` (" + 
"                `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID'," + 
"                `create_date` datetime DEFAULT NULL," + 
"                `update_date` datetime DEFAULT NULL," + 
"                `product_id` int(11) NOT NULL COMMENT 'ID'," + 
"                `memeber_id` int(11) NOT NULL COMMENT 'ID'," + 
"                `name` varchar(50) DEFAULT NULL COMMENT ''," + 
"                `address` varchar(500) DEFAULT NULL COMMENT ''," + 
"                `mobile` varchar(50) DEFAULT NULL COMMENT ''," + 
"                `amount` int(11) DEFAULT NULL COMMENT ''," + 
"                PRIMARY KEY (`id`)" + 
"              ) ENGINE=InnoDB DEFAULT CHARSET=gbk;" + 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(9, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("xxx")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xxx", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xxx", "amount")));
public class MySqlCreateTableTest16 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `xxx` (" + 
"                `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID'," + 
"                `create_date` datetime DEFAULT NULL," + 
"                `update_date` datetime DEFAULT NULL," + 
"                `product_id` int(11) NOT NULL COMMENT 'ID'," + 
"                `memeber_id` int(11) NOT NULL COMMENT 'ID'," + 
"                `name` varchar(50) DEFAULT NULL COMMENT ''," + 
"                `address` varchar(500) DEFAULT NULL COMMENT ''," + 
"                `mobile` varchar(50) DEFAULT NULL COMMENT ''," + 
"                `amount` int(11) DEFAULT NULL COMMENT ''," + 
"                PRIMARY KEY (`id`)" + 
"              ) ENGINE=InnoDB DEFAULT CHARSET=gbk;" + 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(9, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("xxx")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xxx", "id")));
Assert.assertTrue(visitor.getColumns().contains(new Column("xxx", "amount")));
private SQLExpr           onUpdate;
public SQLExpr getOnUpdate() {
return onUpdate;
public void setOnUpdate(SQLExpr onUpdate) {
this.onUpdate = onUpdate;
if (lexer.token() == Token.ON) {
lexer.nextToken();
accept(Token.UPDATE);
SQLExpr expr = this.expr();
((MySqlSQLColumnDefinition) column).setOnUpdate(expr);
if (mysqlColumn != null && mysqlColumn.getOnUpdate() != null) {
print(" ON UPDATE ");
mysqlColumn.getOnUpdate().accept(this);
public class MySqlCreateTableTest17 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE t1 (" + 
"  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)" + 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "ts")));
public class MySqlSelectTest_10 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM t_department  WHERE name IN ('0000','4444') ORDER BY name ASC";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNotNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("group")));
public class OracleSelectTest42 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT * FROM t_department  " + 
"WHERE name IN ('0000','4444') " + 
"ORDER BY name ASC"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(4, visitor.getTables().size());
Assert.assertEquals(9, visitor.getColumns().size());
boolean poolPreparedStatements = Boolean.valueOf(value).booleanValue();
dataSource.setPoolPreparedStatements(poolPreparedStatements);
if (poolPreparedStatements) {
value = (String) properties.get(PROP_MAXOPENPREPAREDSTATEMENTS);
if (value != null) {
dataSource.setMaxOpenPreparedStatements(Integer.parseInt(value));
public class DruidDataSourceFactoryTest2 extends TestCase {
private DruidDataSource dataSource;
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_factory() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_POOLPREPAREDSTATEMENTS, "false");
properties.put(DruidDataSourceFactory.PROP_MAXOPENPREPAREDSTATEMENTS, "100");
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
Assert.assertFalse(dataSource.isPoolPreparedStatements());
public class MySqlWallTest83 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
Assert.assertTrue(provider.checkValid(
"alter table rms.rms_Person_Event drop foreign key FKA382487726D72F65"));
Assert.assertEquals(1, provider.getTableStats().size());
public class MySqlAlterTableTest17 extends TestCase {
public void test_alter_first() throws Exception {
String sql = "alter table rms.rms_Person_Event drop foreign key FKA382487726D72F65";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE rms.rms_Person_Eventn" + 
"tDROP FOREIGN KEY FKA382487726D72F65", output);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public Throwable getDisableError() {
return disableError;
Throwable disableError = null;
if (this.conn != null) {
disableError = this.conn.getDisableError();
if (disableError != null) {
throw new SQLException("statement is closed", disableError);
throw new SQLException("statement is closed");
if (closed) {
@SuppressWarnings("serial")
public class SQLExprHint extends SQLObjectImpl implements SQLHint {
private SQLExpr expr;
public SQLExprHint() {
public SQLExprHint(SQLExpr expr) {
this.setExpr(expr);
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
if (expr != null) {
expr.setParent(this);
this.expr = expr;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, expr);
visitor.endVisit(this);
protected SQLTableSource parseTableSourceRest(SQLTableSource tableSource) {
if (lexer.token() == Token.WITH) {
lexer.nextToken();
accept(Token.LPAREN);
for (;;) {
SQLExpr expr = this.expr();
SQLExprHint hint = new SQLExprHint(expr);
hint.setParent(tableSource);
tableSource.getHints().add(hint);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
accept(Token.RPAREN);
return super.parseTableSourceRest(tableSource);
public boolean visit(SQLExprTableSource x) {
x.getExpr().accept(this);
if (x.getHints() != null && x.getHints().size() > 0) {
print(" WITH (");
printAndAccept(x.getHints(), ", ");
print(")");
if (x.getAlias() != null) {
print(' ');
print(x.getAlias());
return false;
@Override
public boolean visit(SQLExprHint x) {
x.getExpr().accept(this);
return false;
boolean visit(SQLExprHint x);
void endVisit(SQLExprHint x);
public boolean visit(SQLExprHint x) {
return true;
public void endVisit(SQLExprHint x) {
public class SQLServerSelectTest16 extends TestCase {
public void test_simple() throws Exception {
String sql = "select GEN_VAL " + 
"from ID_GENERATOR with (updlock, rowlock) " + 
"where GEN_NAME = 'T_USERS'"; 
String expect = "SELECT GEN_VAL" + 
"nFROM ID_GENERATOR WITH (updlock, rowlock)" + 
"nWHERE GEN_NAME = 'T_USERS'";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
private List<SQLCommentHint>  hints        = new ArrayList<SQLCommentHint>();
private SQLExprTableSource    like;
public SQLExprTableSource getLike() {
return like;
public void setLike(SQLName like) {
this.setLike(new SQLExprTableSource(like));
public void setLike(SQLExprTableSource like) {
if (like != null) {
like.setParent(this);
this.like = like;
this.acceptChild(visitor, getLike());
this.acceptChild(visitor, getQuery());
if (lexer.token() == Token.LIKE) {
lexer.nextToken();
SQLName name = this.exprParser.name();
stmt.setLike(name);
if (lexer.token() == Token.LIKE) {
lexer.nextToken();
SQLName name = this.exprParser.name();
stmt.setLike(name);
for (;;) {
if (lexer.token() == Token.IDENTIFIER || lexer.token() == Token.LITERAL_CHARS) {
SQLColumnDefinition column = this.exprParser.parseColumn();
stmt.getTableElementList().add(column);
} else if (lexer.token() == Token.CONSTRAINT 
|| lexer.token() == Token.PRIMARY 
|| lexer.token() == Token.UNIQUE) {
stmt.getTableElementList().add(parseConstraint());
} else if (lexer.token() == (Token.INDEX)) {
lexer.nextToken();
MySqlTableIndex idx = new MySqlTableIndex();
if (lexer.token() == Token.IDENTIFIER) {
if (!"USING".equalsIgnoreCase(lexer.stringVal())) {
idx.setName(this.exprParser.name());
if (identifierEquals("USING")) {
lexer.nextToken();
idx.setIndexType(lexer.stringVal());
accept(Token.LPAREN);
for (;;) {
idx.getColumns().add(this.exprParser.expr());
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
accept(Token.RPAREN);
stmt.getTableElementList().add(idx);
} else if (lexer.token() == (Token.KEY)) {
stmt.getTableElementList().add(parseConstraint());
} else if (lexer.token() == (Token.PRIMARY)) {
stmt.getTableElementList().add(parseConstraint());
} else if (lexer.token() == (Token.FOREIGN)) {
MySqlForeignKey fk = this.getExprParser().parseForeignKey();
stmt.getTableElementList().add(fk);
} else if (lexer.token() == Token.CHECK) {
lexer.nextToken();
SQLCheck check = new SQLCheck();
accept(Token.LPAREN);
check.setExpr(this.exprParser.expr());
accept(Token.RPAREN);
stmt.getTableElementList().add(check);
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
if (identifierEquals("AVG_ROW_LENGTH")) {
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("AVG_ROW_LENGTH", lexer.numberString());
lexer.nextToken();
continue;
if (lexer.token() == Token.DEFAULT) {
lexer.nextToken();
parseTableOptionCharsetOrCollate(stmt);
continue;
if (parseTableOptionCharsetOrCollate(stmt)) {
continue;
if (identifierEquals("CHECKSUM")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CHECKSUM", lexer.numberString());
if (lexer.token() == Token.EQ) {
lexer.nextToken();
if (identifierEquals("CONNECTION")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CONNECTION", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("DATA")) {
lexer.nextToken();
acceptIdentifier("DIRECTORY");
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("DATA DIRECTORY", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("DELAY_KEY_WRITE")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("DELAY_KEY_WRITE", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("INDEX")) {
lexer.nextToken();
acceptIdentifier("DIRECTORY");
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("INDEX DIRECTORY", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("INSERT_METHOD")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("INSERT_METHOD", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("KEY_BLOCK_SIZE")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("KEY_BLOCK_SIZE", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("MAX_ROWS")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("MAX_ROWS", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("MIN_ROWS")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("MIN_ROWS", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("PACK_KEYS")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("PACK_KEYS", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("PASSWORD")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("PASSWORD", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("ROW_FORMAT")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("ROW_FORMAT", lexer.stringVal());
lexer.nextToken();
continue;
if (identifierEquals("TYPE")) {
lexer.nextToken();
accept(Token.EQ);
stmt.getTableOptions().put("TYPE", lexer.stringVal());
lexer.nextToken();
continue;
private boolean parseTableOptionCharsetOrCollate(MySqlCreateTableStatement stmt) {
if (identifierEquals("CHARACTER")) {
lexer.nextToken();
accept(Token.SET);
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CHARACTER SET", lexer.stringVal());
lexer.nextToken();
return true;
if (identifierEquals("CHARSET")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("CHARSET", lexer.stringVal());
lexer.nextToken();
return true;
if (identifierEquals("COLLATE")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("COLLATE", lexer.stringVal());
lexer.nextToken();
return true;
return false;
if (x.getLike() != null) {
print(" LIKE ");
x.getLike().accept(this);
int size = x.getTableElementList().size();
if (size > 0) {
print(" (");
incrementIndent();
println();
for (int i = 0; i < size; ++i) {
if (i != 0) {
print(", ");
println();
x.getTableElementList().get(i).accept(this);
decrementIndent();
println();
print(")");
new SQLCharExpr(option.getValue()).accept(this);
} else if ("CONNECTION".equals(key)) {
new SQLCharExpr(option.getValue()).accept(this);
} else if ("DATA DIRECTORY".equals(key)) {
new SQLCharExpr(option.getValue()).accept(this);
} else if ("INDEX DIRECTORY".equals(key)) {
new SQLCharExpr(option.getValue()).accept(this);
} else if ("PASSWORD".equals(key)) {
new SQLCharExpr(option.getValue()).accept(this);
public class MySqlCreateTableTest19 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE new_tbl LIKE orig_tbl;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("new_tbl")));
public class MySqlCreateTableTest20 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE new_tbl (LIKE orig_tbl);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("new_tbl")));
public class MySqlCreateTableTest21 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE new_tbl (LIKE orig_tbl);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("new_tbl")));
private SQLExpr           storage;
public SQLExpr getStorage() {
return storage;
public void setStorage(SQLExpr storage) {
this.storage = storage;
if (identifierEquals("TABLESPACE")) {
lexer.nextToken();
String tablespace_name = lexer.stringVal();
accept(Token.IDENTIFIER);
if (identifierEquals("STORAGE")) {
throw new ParserException("TODO STORAGE");
stmt.getTableOptions().put("TABLESPACE", tablespace_name);
continue;
if (identifierEquals("STORAGE")) {
lexer.nextToken();
SQLExpr expr = expr();
if (column instanceof MySqlSQLColumnDefinition) {
((MySqlSQLColumnDefinition) column).setStorage(expr);
if (mysqlColumn != null && mysqlColumn.getStorage() != null) {
print(" STORAGE ");
mysqlColumn.getStorage().accept(this);
print(' ');
if ("TABLESPACE".equals(key)) {
print(' ');
print(option.getValue());
continue;
public class MySqlCreateTableTest22 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE t1 (" + 
"c1 INT STORAGE DISK," + 
"c2 INT STORAGE MEMORY " + 
") TABLESPACE ts_1 ENGINE NDB;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE t1 (" + 
"ntc1 INT STORAGE DISK, " + 
"ntc2 INT STORAGE MEMORY" + 
"n) TABLESPACE ts_1 ENGINE = NDB", output);
public class MySqlCreateTableTest23 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  ENGINE = MEMORY;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) ENGINE = MEMORY", output);
public final static boolean                        DEFAULT_TEST_ON_BORROW                    = false;
public final static boolean                        DEFAULT_WHILE_IDLE                        = true;
if (this.validConnectionChecker != null) {
Exception error = null;
DruidPooledConnection conn = dataSource.getConnection().unwrap(DruidPooledConnection.class);
dataSource.validateConnection(conn);
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
Assert.assertEquals(1, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t_department")));
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
private Map<String, SQLObject>   tableOptions = new LinkedHashMap<String, SQLObject>();
public void setTableOptions(Map<String, SQLObject> tableOptions) {
public Map<String, SQLObject> getTableOptions() {
public static class TableSpaceOption extends MySqlObjectImpl {
private SQLName name;
private SQLExpr storage;
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
public SQLExpr getStorage() {
return storage;
public void setStorage(SQLExpr storage) {
this.storage = storage;
@Override
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, getName());
acceptChild(visitor, getStorage());
visitor.endVisit(this);
public class MySqlPartitionByHash extends MySqlObjectImpl implements SQLPartitioningClause {
private static final long serialVersionUID = 1L;
private SQLExpr           expr;
private SQLExpr           partitionCount;
@Override
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, expr);
acceptChild(visitor, partitionCount);
visitor.endVisit(this);
public SQLExpr getPartitionCount() {
return partitionCount;
public void setPartitionCount(SQLExpr partitionCount) {
this.partitionCount = partitionCount;
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
this.expr = expr;
stmt.getTableOptions().put("ENGINE", this.exprParser.expr());
stmt.getTableOptions().put("AUTO_INCREMENT", this.exprParser.expr());
stmt.getTableOptions().put("AVG_ROW_LENGTH", this.exprParser.expr());
stmt.getTableOptions().put("CHECKSUM", this.exprParser.expr());
stmt.getTableOptions().put("COMMENT", this.exprParser.expr());
stmt.getTableOptions().put("CONNECTION", this.exprParser.expr());
stmt.getTableOptions().put("DATA DIRECTORY", this.exprParser.expr());
stmt.getTableOptions().put("DELAY_KEY_WRITE", this.exprParser.expr());
stmt.getTableOptions().put("INDEX DIRECTORY", this.exprParser.expr());
stmt.getTableOptions().put("INSERT_METHOD", this.exprParser.expr());
stmt.getTableOptions().put("KEY_BLOCK_SIZE", this.exprParser.expr());
stmt.getTableOptions().put("MAX_ROWS", this.exprParser.expr());
stmt.getTableOptions().put("MIN_ROWS", this.exprParser.expr());
stmt.getTableOptions().put("PACK_KEYS", this.exprParser.expr());
stmt.getTableOptions().put("PASSWORD", this.exprParser.expr());
stmt.getTableOptions().put("ROW_FORMAT", this.exprParser.expr());
continue;
if (identifierEquals("STATS_AUTO_RECALC")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("STATS_AUTO_RECALC", this.exprParser.expr());
continue;
if (identifierEquals("STATS_PERSISTENT")) {
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("STATS_PERSISTENT", this.exprParser.expr());
TableSpaceOption option = new TableSpaceOption();
option.setName(this.exprParser.name());
lexer.nextToken();
option.setStorage(this.exprParser.name());
stmt.getTableOptions().put("TABLESPACE", option);
stmt.getTableOptions().put("TYPE", this.exprParser.expr());
if (identifierEquals("PARTITIONS")) {
lexer.nextToken();
clause.setPartitionCount(this.exprParser.expr());
} else if (identifierEquals("HASH")) {
lexer.nextToken();
MySqlPartitionByHash clause = new MySqlPartitionByHash();
accept(Token.LPAREN);
clause.setExpr(this.exprParser.expr());
accept(Token.RPAREN);
stmt.setPartitioning(clause);
stmt.getTableOptions().put("CHARACTER SET", this.exprParser.expr());
stmt.getTableOptions().put("CHARSET", this.exprParser.expr());
stmt.getTableOptions().put("COLLATE", this.exprParser.expr());
boolean visit(MySqlCreateTableStatement.TableSpaceOption x);
void endVisit(MySqlCreateTableStatement.TableSpaceOption x);
boolean visit(MySqlPartitionByHash x);
void endVisit(MySqlPartitionByHash x);
@Override
public boolean visit(TableSpaceOption x) {
return true;
@Override
public void endVisit(TableSpaceOption x) {
@Override
public boolean visit(MySqlPartitionByHash x) {
return true;
@Override
public void endVisit(MySqlPartitionByHash x) {
for (Map.Entry<String, SQLObject> option : x.getTableOptions().entrySet()) {
option.getValue().accept(this);
option.getValue().accept(this);
if (x.getPartitioning() != null) {
print(' ');
x.getPartitioning().accept(this);
@Override
public void endVisit(MySqlPartitionByHash x) {
@Override
public boolean visit(MySqlPartitionByHash x) {
print("PARTITION BY HASH (");
x.getExpr().accept(this);
print(")");
if (x.getPartitionCount() != null) {
print(" PARTITIONS ");
x.getPartitionCount().accept(this);
return false;
@Override
public boolean visit(TableSpaceOption x) {
x.getName().accept(this);
if (x.getStorage() != null) {
print(' ');
x.getStorage().accept(this);
return false;
@Override
public void endVisit(TableSpaceOption x) {
@Override
public boolean visit(TableSpaceOption x) {
return false;
@Override
public void endVisit(TableSpaceOption x) {
@Override
public boolean visit(MySqlPartitionByHash x) {
return false;
@Override
public void endVisit(MySqlPartitionByHash x) {
public class MySqlCreateTableTest24 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  AVG_ROW_LENGTH = 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) AVG_ROW_LENGTH = 1024", output);
public class MySqlCreateTableTest25 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  AVG_ROW_LENGTH 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) AVG_ROW_LENGTH = 1024", output);
public class MySqlCreateTableTest26 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  MAX_ROWS 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) MAX_ROWS = 1024", output);
public class MySqlCreateTableTest27 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  MAX_ROWS = 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) MAX_ROWS = 1024", output);
public class MySqlCreateTableTest28 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  MIN_ROWS = 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) MIN_ROWS = 1024", output);
public class MySqlCreateTableTest29 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  MIN_ROWS 1024;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) MIN_ROWS = 1024", output);
public class MySqlCreateTableTest30 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  DELAY_KEY_WRITE 0;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) DELAY_KEY_WRITE = 0", output);
public class MySqlCreateTableTest31 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  DELAY_KEY_WRITE = 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) DELAY_KEY_WRITE = 1", output);
public class MySqlCreateTableTest32 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  DATA DIRECTORY = 'aaa';"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) DATA DIRECTORY = 'aaa'", output);
public class MySqlCreateTableTest33 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  CONNECTION = 'aaa';"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) CONNECTION = 'aaa'", output);
public class MySqlCreateTableTest34 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  CHECKSUM = 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) CHECKSUM = 1", output);
public class MySqlCreateTableTest35 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  AUTO_INCREMENT = 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) AUTO_INCREMENT = 1", output);
public class MySqlCreateTableTest36 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  STATS_AUTO_RECALC = 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) STATS_AUTO_RECALC = 1", output);
public class MySqlCreateTableTest37 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  STATS_AUTO_RECALC DEFAULT;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) STATS_AUTO_RECALC = DEFAULT", output);
public class MySqlCreateTableTest38 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  STATS_PERSISTENT DEFAULT;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) STATS_PERSISTENT = DEFAULT", output);
public class MySqlCreateTableTest39 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  STATS_PERSISTENT 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) STATS_PERSISTENT = 1", output);
public class MySqlCreateTableTest40 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE t1 (col1 INT, col2 CHAR(5))" + 
" PARTITION BY HASH(col1);"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE t1 (" + 
"ntcol1 INT, " + 
"ntcol2 CHAR(5)" + 
"n) PARTITION BY HASH (col1)", output);
Assert.assertEquals("utf8", stmt.getTableOptions().get("CHARSET").toString());
private boolean           linear;
public boolean isLinear() {
return linear;
public void setLinear(boolean linear) {
this.linear = linear;
private boolean           linear;
public boolean isLinear() {
return linear;
public void setLinear(boolean linear) {
this.linear = linear;
boolean linera = false;
if (identifierEquals("LINEAR")) {
lexer.nextToken();
linera = true;
if (linera) {
clause.setLinear(true);
if (linera) {
clause.setLinear(true);
if (x.isLinear()) {
print("PARTITION BY LINEAR KEY (");
print("PARTITION BY KEY (");
if (x.isLinear()) {
print("PARTITION BY LINEAR HASH (");
print("PARTITION BY HASH (");
public class MySqlCreateTableTest41 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)" + 
"    PARTITION BY LINEAR KEY(col3)" + 
"    PARTITIONS 5;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("tk")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE tk (" + 
"ntcol1 INT, " + 
"ntcol2 CHAR(5), " + 
"ntcol3 DATE" + 
"n) PARTITION BY LINEAR KEY (col3) PARTITIONS 5", output);
lock.lockInterruptibly();
} catch (InterruptedException e) {
LOG.error("interrupt");
Assert.assertNull(error);
Assert.assertEquals(1, dataSource.getPoolingCount());
Assert.assertNull(error);
mockConn.close();
Exception stmtClosedError = null;
stmt.close();
} catch (Exception ex) {
stmtClosedError = ex;
Assert.assertNotNull(stmtClosedError);
String threadName = "Druid-ConnectionPool-Destory-" + System.identityHashCode(this);
destoryConnectionThread = new DestroyConnectionThread(threadName);
String threadName = "Druid-ConnectionPool-Create-" + System.identityHashCode(this);
createConnectionThread = new CreateConnectionThread(threadName);
if (dataSourceStat == null) {
dataSourceStat = new JdbcDataSourceStat("Global", "Global", this.dbType);
JdbcDataSourceStat.setGlobal(dataSourceStat);
if (globalStat != null) {
JdbcUtils.close(dataSource);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
dropTable();
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
protected void tearDown() throws Exception {
JdbcUtils.close(dataSourceA);
JdbcUtils.close(dataSourceB);
JdbcDataSourceStat.setGlobal(null);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
TabularData sqlList = JdbcStatManager.getInstance().getSqlList();
if (sqlList.size() > 0) {
for (Object item : JdbcStatManager.getInstance().getSqlList().values()) {
String text = JSONUtils.toJSONString(item);
System.out.println(text);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
JdbcUtils.close(dataSource);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
private DruidDataSource dataSource;
JdbcUtils.close(dataSource);
TabularData dataSourceList = DruidDataSourceStatManager.getInstance().getDataSourceList();
if (dataSourceList.size() > 0) {
DruidDataSource first = DruidDataSourceStatManager.getInstance().getDruidDataSourceInstances().iterator().next();
System.out.println(first.getInitStackTrace());
Assert.assertEquals(0, dataSourceList.size());
dataSource = new DruidDataSource();
protected void tearDown() throws Exception {
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
protected void tearDown() throws Exception {
Class<?> declareClass = logConstructor.getDeclaringClass();
if (!Log.class.isAssignableFrom(declareClass)) {
logConstructor = null;
private ClassLoader                           contextClassLoader;
private DruidDataSource                       dataSource;
protected void setUp() throws Exception {
contextClassLoader = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(contextClassLoader);
|| (error_code == 17410) 
private final AtomicLong                 recycleErrorCount       = new AtomicLong();
recycleErrorCount.set(0);
recycleErrorCount.incrementAndGet();
public long getRecycleErrorCount() {
return recycleErrorCount.get();
boolean allow = true;
if (isDeny(varName)) {
allow = false;
if (allow) {
if (WallVisitorUtils.isWhereOrHaving(x)) {
allow = false;
if (!allow) {
violations.add(new IllegalSQLObjectViolation(ErrorCode.VARIANT_DENY, "variable not allow : "
+ x.getName(), toSQL(x)));
public boolean isDeny(String varName) {
if (varName.startsWith("@@")) {
varName = varName.substring(2);
return config.getDenyVariants().contains(varName);
boolean isTop = WallVisitorUtils.isTopNoneFromSelect(this, x);
if (!isTop) {
boolean allow = true;
if (isDeny(varName)) {
allow = false;
if (allow) {
if (WallVisitorUtils.isWhereOrHaving(x)) {
allow = false;
if (!allow) {
violations.add(new IllegalSQLObjectViolation(ErrorCode.VARIANT_DENY, "variable not allow : "
+ x.getName(), toSQL(x)));
public static boolean isWhereOrHaving(SQLObject x) {
if (x == null) {
return false;
for (;;) {
SQLObject parent = x.getParent();
if (parent == null) {
return false;
if (parent instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock query = (SQLSelectQueryBlock) parent;
if (query.getWhere() == x) {
return true;
return false;
if (parent instanceof SQLSelectGroupByClause) {
SQLSelectGroupByClause groupBy = (SQLSelectGroupByClause) parent;
if (x == groupBy.getHaving()) {
return true;
return false;
x = parent;
MySqlWallProvider provider = new MySqlWallProvider();
provider.getConfig().setVariantCheck(false);
Assert.assertTrue(provider.checkValid("select @@version_compile_os FROM X"));
MySqlWallProvider provider = new MySqlWallProvider();
provider.getConfig().setVariantCheck(true);
Assert.assertFalse(provider.checkValid("select @@version_compile_os FROM X"));
"select * from t  where fid = 123 AND 1=1"));
Assert.assertEquals(0, LOG.getErrorCount());
public class OracleExceptionSorterTest_concurrent extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
dataSource = new DruidDataSource();
dataSource.setExceptionSorter(new OracleExceptionSorter());
dataSource.setDriver(new OracleMockDriver());
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(100);
dataSource.setMaxActive(1);
dataSource.setMaxWait(1000 * 100);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
Assert.assertEquals(0, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
public void test_connect() throws Exception {
final CountDownLatch latch_0 = new CountDownLatch(1);
Thread errorThread = new Thread() {
public void run() {
Connection conn = dataSource.getConnection();
latch_0.countDown();
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertNotNull(mockConn);
SQLException exception = new SQLException("xx", "xxx", 28);
mockConn.setError(exception);
conn.createStatement();
} catch (SQLException ex) {
conn.close();
} catch (Exception error) {
error.printStackTrace();
errorThread.start();
final CountDownLatch workLatch = new CountDownLatch(2);
final CountDownLatch workCompleteLatch = new CountDownLatch(2);
for (int i = 0; i < 2; ++i) {
Thread thread = new Thread() {
public void run() {
for (int i = 0; i < 1000; ++i) {
workLatch.countDown();
Connection conn = dataSource.getConnection();
conn.close();
} catch (Exception ex) {
ex.printStackTrace();
} finally {
workCompleteLatch.countDown();
thread.start();
workLatch.await();
latch_0.countDown();
workCompleteLatch.await();
Assert.assertEquals(2001, dataSource.getConnectCount());
public class DruidDataSourceTest_oracle3 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:oracle:thin:@192.168.122.184:1521:ORCL");
dataSource.setUsername("system");
dataSource.setPassword("druid");
dataSource.setInitialSize(1);
dataSource.setMaxActive(14);
dataSource.setMinIdle(1);
dataSource.setMinEvictableIdleTimeMillis(300 * 1000); 
dataSource.setTimeBetweenEvictionRunsMillis(180 * 1000); 
dataSource.setTestWhileIdle(false);
dataSource.setTestOnBorrow(false);
dataSource.setValidationQuery("SELECT 1 FROM DUAL");
dataSource.setFilters("stat,log4j");
protected void tearDown() throws Exception {
dataSource.close();
public void test_error() throws Exception {
dataSource.init();
Assert.assertTrue(dataSource.isOracle());
Assert.assertTrue(dataSource.getValidConnectionChecker() instanceof OracleValidConnectionChecker);
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1 FROM DUAL");
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
} catch (Exception e) {
e.printStackTrace();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1 FROM DUAL");
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
} catch (Exception e) {
e.printStackTrace();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT 1 FROM DUAL");
while (rs.next()) {
rs.close();
stmt.close();
conn.close();
} catch (Exception e) {
e.printStackTrace();
private static JdbcDataSourceStat                           global;
String dbType = null;
String property = System.getProperty("druid.globalDbType");
if (property != null && property.length() > 0) {
dbType = property;
global = new JdbcDataSourceStat("Global", "Global", dbType);
int numberCount = 0;
for (int i = name.length() - 1; i >= 0; --i) {
char ch = name.charAt(i);
if (ch < '0' || ch > '9') {
numberCount++;
if (numberCount > 1) {
int numPos = name.length() - numberCount;
String realName = name.substring(0, numPos);
print(realName);
return false;
public class MergeStatFilterTest_tddl_1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
TabularData sqlList = JdbcStatManager.getInstance().getSqlList();
if (sqlList.size() > 0) {
for (Object item : JdbcStatManager.getInstance().getSqlList().values()) {
String text = JSONUtils.toJSONString(item);
System.out.println(text);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("mergeStat");
dataSource.setDbType("mysql");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
public void test_merge() throws Exception {
for (int i = 1000; i < 2000; ++i) {
String tableName = "t" + i;
String sql = "select * from " + tableName + " where " + tableName + ".id = " + i;
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute(sql);
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getDataSourceStat().getSqlStatMap().size());
if (uriStat != null) {
uriStat.getProfiletat().record(requestStatsMap);
public final static int RevisionVersion = 18;
if (webAppStat == null) {
webAppStat = new WebAppStat(contextPath, this.sessionStatMaxCount);
public void setWebAppStat(WebAppStat webAppStat) {
this.webAppStat = webAppStat;
public class WebStatFilterTest3_WebURIStatNull extends TestCase {
public void test_sessionStatDisable() throws Exception {
MockServletContext servletContext = new MockServletContext();
MockFilterConfig filterConfig = new MockFilterConfig(servletContext);
filterConfig.addInitParameter(WebStatFilter.PARAM_NAME_SESSION_STAT_ENABLE, "false");
WebStatFilter filter = new WebStatFilter();
WebAppStat appStat = new WebAppStat() {
public WebURIStat getURIStat(String uri, boolean create) {
return null;
filter.setWebAppStat(appStat);
filter.setProfileEnable(true);
Assert.assertNotNull(filter.getWebAppStat());
filter.init(filterConfig);
Assert.assertSame(appStat, filter.getWebAppStat());
Assert.assertFalse(filter.isSessionStatEnable());
Assert.assertTrue(WebAppStatManager.getInstance().getWebAppStatSet().contains(appStat));
Assert.assertTrue(StatFilterContext.getInstance().getListeners().contains(filter.getStatFilterContextListener()));
MockHttpServletRequest request = new MockHttpServletRequest();
MockHttpServletResponse response = new MockHttpServletResponse();
MockFilterChain chain = new MockFilterChain();
Assert.assertNull(filter.getSessionStat(request));
filter.doFilter(request, response, chain);
Assert.assertEquals(0, appStat.getSessionStatDataList().size());
filter.destroy();
Assert.assertFalse(WebAppStatManager.getInstance().getWebAppStatSet().contains(appStat));
Assert.assertFalse(StatFilterContext.getInstance().getListeners().contains(filter.getStatFilterContextListener()));
Map<String, Object> statData = appStat.getStatData();
Assert.assertEquals(1L, statData.get("RequestCount"));
final ReentrantLock lock = this.lock;
out.println(DruidDataSourceFactory.PROP_MAXWAIT + "=1000");
public DruidDataSourceStatLogger getStatLogger() {
return statLogger;
public void setStatLoggerClassName(String className) {
Class<?> clazz;
clazz = Class.forName(className);
DruidDataSourceStatLogger statLogger = (DruidDataSourceStatLogger) clazz.newInstance();
this.setStatLogger(statLogger);
} catch (Exception e) {
throw new IllegalArgumentException(className, e);
public void setStatLogger(DruidDataSourceStatLogger statLogger) {
this.statLogger = statLogger;
value.pstmtCacheHitCount = cachedPreparedStatementHitCount.getAndSet(0);
value.pstmtCacheMissCount = cachedPreparedStatementMissCount.getAndSet(0);
void setStatLoggerClassName(String className);
long getTimeBetweenLogStatsMillis();
void setTimeBetweenLogStatsMillis(long timeBetweenLogStatsMillis);
private static Log LOG = LogFactory.getLog(DruidDataSourceStatLoggerImpl.class);
if (LOG.isInfoEnabled()) {
Map<String, Object> map = new LinkedHashMap<String, Object>();
map.put("url", statValue.url);
map.put("dbType", statValue.dbType);
map.put("name", statValue.name);
map.put("activeCount", statValue.activeCount);
map.put("activePeak", statValue.activePeak);
map.put("activePeakTime", statValue.getActivePeakTime());
map.put("poolingCount", statValue.poolingCount);
map.put("poolingPeak", statValue.poolingPeak);
map.put("poolingPeakTime", statValue.getPoolingPeakTime());
map.put("connectCount", statValue.connectCount);
map.put("closeCount", statValue.closeCount);
map.put("waitThreadCount", statValue.waitThreadCount);
map.put("notEmptyWaitCount", statValue.notEmptyWaitCount);
map.put("notEmptyWaitMillis", statValue.getNotEmptyWaitMillis());
map.put("logicConnectErrorCount", statValue.logicConnectErrorCount);
map.put("physicalConnectCount", statValue.physicalConnectCount);
map.put("physicalCloseCount", statValue.physicalCloseCount);
map.put("physicalConnectErrorCount", statValue.physicalConnectErrorCount);
map.put("executeCount", statValue.executeCount);
if (statValue.errorCount > 0) {
map.put("errorCount", statValue.errorCount);
if (statValue.commitCount > 0) {
map.put("commitCount", statValue.commitCount);
if (statValue.rollbackCount > 0) {
map.put("rollbackCount", statValue.rollbackCount);
map.put("pstmtCacheHitCount", statValue.pstmtCacheHitCount);
map.put("pstmtCacheMissCount", statValue.pstmtCacheMissCount);
if (statValue.startTransactionCount > 0) {
map.put("startTransactionCount", statValue.startTransactionCount);
map.put("transactionHistogram", statValue.transactionHistogram);
map.put("connectionHoldTimeHistogram", statValue.connectionHoldTimeHistogram);
if (statValue.clobOpenCount > 0) {
map.put("clobOpenCount", statValue.clobOpenCount);
if (statValue.blobOpenCount > 0) {
map.put("blobOpenCount", statValue.blobOpenCount);
ArrayList<Map<String, Object>> sqlList = new ArrayList<Map<String, Object>>();
for (JdbcSqlStatValue sqlStat : statValue.sqlList) {
Map<String, Object> sqlStatMap = new LinkedHashMap<String, Object>();
sqlStatMap.put("sql", sqlStat.sql);
sqlStatMap.put("executeCount", sqlStat.getExecuteCount());
if (sqlStat.executeErrorCount > 0) {
sqlStatMap.put("executeErrorCount", sqlStat.executeErrorCount);
if (sqlStat.runningCount > 0) {
sqlStatMap.put("runningCount", sqlStat.runningCount);
sqlStatMap.put("concurrentMax", sqlStat.concurrentMax);
sqlStatMap.put("executeMillisMax", sqlStat.getExecuteMillisMax());
sqlStatMap.put("executeMillisTotal", sqlStat.getExecuteMillisTotal());
sqlStatMap.put("executeHistogram", sqlStat.getExecuteHistogram());
sqlStatMap.put("executeAndResultHoldHistogram", sqlStat.getExecuteAndResultHoldHistogram());
if (sqlStat.fetchRowCount > 0) {
sqlStatMap.put("fetchRowCount", sqlStat.fetchRowCount);
sqlStatMap.put("fetchRowCount", sqlStat.fetchRowCountMax);
sqlStatMap.put("fetchRowHistogram", sqlStat.getFetchRowHistogram());
if (sqlStat.updateCount > 0) {
sqlStatMap.put("updateCount", sqlStat.updateCount);
sqlStatMap.put("updateCountMax", sqlStat.updateCountMax);
sqlStatMap.put("updateHistogram", sqlStat.getUpdateHistogram());
if (sqlStat.inTransactionCount > 0) {
sqlStatMap.put("inTransactionCount", sqlStat.inTransactionCount);
if (sqlStat.clobOpenCount > 0) {
sqlStatMap.put("clobOpenCount", sqlStat.clobOpenCount);
if (sqlStat.blobOpenCount > 0) {
sqlStatMap.put("blobOpenCount", sqlStat.blobOpenCount);
String text = JSONUtils.toJSONString(map);
LOG.info(text);
public String                 name;
public String                 dbType;
public String                 driverClassName;
public String                 url;
public String                 userName;
public List<String>           filterClassNames;
public boolean                removeAbandoned;
public int                    initialSize;
public int                    minIdle;
public int                    maxActive;
public int                    queryTimeout;
public int                    transactionQueryTimeout;
public int                    loginTimeout;
public String                 validConnectionCheckerClassName;
public String                 exceptionSorterClassName;
public boolean                testOnBorrow;
public boolean                testOnReturn;
public boolean                testWhileIdle;
public boolean                defaultAutoCommit;
public boolean                defaultReadOnly;
public int                    defaultTransactionIsolation;
public int                    activeCount;
public int                    activePeak;
public long                   activePeakTime;
public int                    poolingCount;
public int                    poolingPeak;
public long                   poolingPeakTime;
public long                   connectCount;
public long                   closeCount;
public long                   waitThreadCount;
public long                   notEmptyWaitCount;
public long                   notEmptyWaitNanos;
public long                   logicConnectErrorCount;
public long                   physicalConnectCount;
public long                   physicalCloseCount;
public long                   physicalConnectErrorCount;
public long                   executeCount;
public long                   errorCount;
public long                   commitCount;
public long                   rollbackCount;
public long                   pstmtCacheHitCount;
public long                   pstmtCacheMissCount;
public long                   startTransactionCount;
public long[]                 transactionHistogram;
public long[]                 connectionHoldTimeHistogram;
public long                   clobOpenCount;
public long                   blobOpenCount;
public Date getPoolingPeakTime() {
if (poolingPeakTime <= 0) {
return null;
return new Date(poolingPeakTime);
public Date getActivePeakTime() {
if (activePeakTime <= 0) {
return null;
return new Date(activePeakTime);
public long getNotEmptyWaitMillis() {
return notEmptyWaitNanos / (1000 * 1000);
public long[] getExecuteHistogram() {
return new long[] { histogram_0_1, 
histogram_1_10, 
histogram_10_100, 
histogram_100_1000, 
histogram_1000_10000, 
histogram_10000_100000, 
histogram_100000_1000000, 
histogram_1000000_more, 
public long executeAndResultHoldTime_0_1;
public long executeAndResultHoldTime_1_10;
public int  executeAndResultHoldTime_10_100;
public int  executeAndResultHoldTime_100_1000;
public int  executeAndResultHoldTime_1000_10000;
public int  executeAndResultHoldTime_10000_100000;
public int  executeAndResultHoldTime_100000_1000000;
public int  executeAndResultHoldTime_1000000_more;
public long[] getExecuteAndResultHoldHistogram() {
return new long[] { executeAndResultHoldTime_0_1, 
executeAndResultHoldTime_1_10, 
executeAndResultHoldTime_10_100, 
executeAndResultHoldTime_100_1000, 
executeAndResultHoldTime_1000_10000, 
executeAndResultHoldTime_10000_100000, 
executeAndResultHoldTime_100000_1000000, 
executeAndResultHoldTime_1000000_more, 
public long fetchRowCount_0_1;
public long fetchRowCount_1_10;
public long fetchRowCount_10_100;
public int  fetchRowCount_100_1000;
public int  fetchRowCount_1000_10000;
public int  fetchRowCount_10000_more;
public long[] getFetchRowHistogram() {
return new long[] { fetchRowCount_0_1, 
fetchRowCount_1_10, 
fetchRowCount_10_100, 
fetchRowCount_100_1000, 
fetchRowCount_1000_10000, 
fetchRowCount_10000_more, 
public long updateCount_0_1;
public long updateCount_1_10;
public long updateCount_10_100;
public int  updateCount_100_1000;
public int  updateCount_1000_10000;
public int  updateCount_10000_more;
public long[] getUpdateHistogram() {
return new long[] { updateCount_0_1, 
updateCount_1_10, 
updateCount_10_100, 
updateCount_100_1000, 
updateCount_1000_10000, 
updateCount_10000_more, 
public long getExecuteCount() {
return executeErrorCount + executeSuccessCount;
public long getExecuteMillisMax() {
return executeSpanNanoMax / (1000 * 1000);
public long getExecuteMillisTotal() {
return executeSpanNanoTotal / (1000 * 1000);
public final static int RevisionVersion = 19;
public class WallBenchmarkTest1 extends TestCase {
WallProvider            provider = new OracleWallProvider();
public final static int COUNT    = 1000 * 1000;
public void test_0() throws Exception {
String sql = "SELECT t1.department_id, t2.*n" + 
"FROM hr_info t1, TABLE(t1.people) t2n" + 
"WHERE t2.department_id = t1.department_id";
for (int i = 0; i < 10; ++i) {
provider.clearCache();
long startMillis = System.currentTimeMillis();
perf(sql);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("millis : " + millis);
public void perf(String sql) {
for (int i = 0; i < COUNT; ++i) {
String text = sql + " AND FID = " + i;
provider.check(text);
public final static int RevisionVersion = 20;
sqlStatMap.put("sql", sqlStat.getSql());
long executeErrorCount = sqlStat.getExecuteErrorCount();
if (executeErrorCount > 0) {
sqlStatMap.put("executeErrorCount", executeErrorCount);
int runningCount = sqlStat.getRunningCount();
if (runningCount > 0) {
sqlStatMap.put("runningCount", runningCount);
int concurrentMax = sqlStat.getConcurrentMax();
if (concurrentMax > 0) {
sqlStatMap.put("concurrentMax", concurrentMax);
if (sqlStat.getFetchRowCount() > 0) {
sqlStatMap.put("fetchRowCount", sqlStat.getFetchRowCount());
sqlStatMap.put("fetchRowCount", sqlStat.getFetchRowCountMax());
if (sqlStat.getUpdateCount() > 0) {
sqlStatMap.put("updateCount", sqlStat.getUpdateCount());
sqlStatMap.put("updateCountMax", sqlStat.getUpdateCountMax());
if (sqlStat.getInTransactionCount() > 0) {
sqlStatMap.put("inTransactionCount", sqlStat.getInTransactionCount());
if (sqlStat.getClobOpenCount() > 0) {
sqlStatMap.put("clobOpenCount", sqlStat.getClobOpenCount());
if (sqlStat.getBlobOpenCount() > 0) {
sqlStatMap.put("blobOpenCount", sqlStat.getBlobOpenCount());
protected String                 name;
protected String                 dbType;
protected String                 driverClassName;
protected String                 url;
protected String                 userName;
protected List<String>           filterClassNames;
protected boolean                removeAbandoned;
protected int                    initialSize;
protected int                    minIdle;
protected int                    maxActive;
protected int                    queryTimeout;
protected int                    transactionQueryTimeout;
protected int                    loginTimeout;
protected String                 validConnectionCheckerClassName;
protected String                 exceptionSorterClassName;
protected boolean                testOnBorrow;
protected boolean                testOnReturn;
protected boolean                testWhileIdle;
protected boolean                defaultAutoCommit;
protected boolean                defaultReadOnly;
protected Integer                defaultTransactionIsolation;
protected int                    activeCount;
protected int                    activePeak;
protected long                   activePeakTime;
protected int                    poolingCount;
protected int                    poolingPeak;
protected long                   poolingPeakTime;
protected long                   connectCount;
protected long                   closeCount;
protected long                   waitThreadCount;
protected long                   notEmptyWaitCount;
protected long                   notEmptyWaitNanos;
protected long                   logicConnectErrorCount;
protected long                   physicalConnectCount;
protected long                   physicalCloseCount;
protected long                   physicalConnectErrorCount;
protected long                   executeCount;
protected long                   errorCount;
protected long                   commitCount;
protected long                   rollbackCount;
protected long                   pstmtCacheHitCount;
protected long                   pstmtCacheMissCount;
protected long                   startTransactionCount;
protected long[]                 transactionHistogram;
protected long[]                 connectionHoldTimeHistogram;
protected long                   clobOpenCount;
protected long                   blobOpenCount;
protected List<JdbcSqlStatValue> sqlList;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public String getDriverClassName() {
return driverClassName;
public void setDriverClassName(String driverClassName) {
this.driverClassName = driverClassName;
public String getUrl() {
return url;
public void setUrl(String url) {
this.url = url;
public String getUserName() {
return userName;
public void setUserName(String userName) {
this.userName = userName;
public List<String> getFilterClassNames() {
return filterClassNames;
public void setFilterClassNames(List<String> filterClassNames) {
this.filterClassNames = filterClassNames;
public boolean isRemoveAbandoned() {
return removeAbandoned;
public void setRemoveAbandoned(boolean removeAbandoned) {
this.removeAbandoned = removeAbandoned;
public int getInitialSize() {
return initialSize;
public void setInitialSize(int initialSize) {
this.initialSize = initialSize;
public int getMinIdle() {
return minIdle;
public void setMinIdle(int minIdle) {
this.minIdle = minIdle;
public int getMaxActive() {
return maxActive;
public void setMaxActive(int maxActive) {
this.maxActive = maxActive;
public int getQueryTimeout() {
return queryTimeout;
public void setQueryTimeout(int queryTimeout) {
this.queryTimeout = queryTimeout;
public int getTransactionQueryTimeout() {
return transactionQueryTimeout;
public void setTransactionQueryTimeout(int transactionQueryTimeout) {
this.transactionQueryTimeout = transactionQueryTimeout;
public int getLoginTimeout() {
return loginTimeout;
public void setLoginTimeout(int loginTimeout) {
this.loginTimeout = loginTimeout;
public String getValidConnectionCheckerClassName() {
return validConnectionCheckerClassName;
public void setValidConnectionCheckerClassName(String validConnectionCheckerClassName) {
this.validConnectionCheckerClassName = validConnectionCheckerClassName;
public String getExceptionSorterClassName() {
return exceptionSorterClassName;
public void setExceptionSorterClassName(String exceptionSorterClassName) {
this.exceptionSorterClassName = exceptionSorterClassName;
public boolean isTestOnBorrow() {
return testOnBorrow;
public void setTestOnBorrow(boolean testOnBorrow) {
this.testOnBorrow = testOnBorrow;
public boolean isTestOnReturn() {
return testOnReturn;
public void setTestOnReturn(boolean testOnReturn) {
this.testOnReturn = testOnReturn;
public boolean isTestWhileIdle() {
return testWhileIdle;
public void setTestWhileIdle(boolean testWhileIdle) {
this.testWhileIdle = testWhileIdle;
public boolean isDefaultAutoCommit() {
return defaultAutoCommit;
public void setDefaultAutoCommit(boolean defaultAutoCommit) {
this.defaultAutoCommit = defaultAutoCommit;
public boolean isDefaultReadOnly() {
return defaultReadOnly;
public void setDefaultReadOnly(boolean defaultReadOnly) {
this.defaultReadOnly = defaultReadOnly;
public Integer getDefaultTransactionIsolation() {
return defaultTransactionIsolation;
public void setDefaultTransactionIsolation(Integer defaultTransactionIsolation) {
this.defaultTransactionIsolation = defaultTransactionIsolation;
public int getActiveCount() {
return activeCount;
public void setActiveCount(int activeCount) {
this.activeCount = activeCount;
public int getActivePeak() {
return activePeak;
public void setActivePeak(int activePeak) {
this.activePeak = activePeak;
public int getPoolingCount() {
return poolingCount;
public void setPoolingCount(int poolingCount) {
this.poolingCount = poolingCount;
public int getPoolingPeak() {
return poolingPeak;
public void setPoolingPeak(int poolingPeak) {
this.poolingPeak = poolingPeak;
public long getConnectCount() {
return connectCount;
public void setConnectCount(long connectCount) {
this.connectCount = connectCount;
public long getCloseCount() {
return closeCount;
public void setCloseCount(long closeCount) {
this.closeCount = closeCount;
public long getWaitThreadCount() {
return waitThreadCount;
public void setWaitThreadCount(long waitThreadCount) {
this.waitThreadCount = waitThreadCount;
public long getNotEmptyWaitCount() {
return notEmptyWaitCount;
public void setNotEmptyWaitCount(long notEmptyWaitCount) {
this.notEmptyWaitCount = notEmptyWaitCount;
public long getNotEmptyWaitNanos() {
return notEmptyWaitNanos;
public void setNotEmptyWaitNanos(long notEmptyWaitNanos) {
this.notEmptyWaitNanos = notEmptyWaitNanos;
public long getLogicConnectErrorCount() {
return logicConnectErrorCount;
public void setLogicConnectErrorCount(long logicConnectErrorCount) {
this.logicConnectErrorCount = logicConnectErrorCount;
public long getPhysicalConnectCount() {
return physicalConnectCount;
public void setPhysicalConnectCount(long physicalConnectCount) {
this.physicalConnectCount = physicalConnectCount;
public long getPhysicalCloseCount() {
return physicalCloseCount;
public void setPhysicalCloseCount(long physicalCloseCount) {
this.physicalCloseCount = physicalCloseCount;
public long getPhysicalConnectErrorCount() {
return physicalConnectErrorCount;
public void setPhysicalConnectErrorCount(long physicalConnectErrorCount) {
this.physicalConnectErrorCount = physicalConnectErrorCount;
public long getExecuteCount() {
return executeCount;
public void setExecuteCount(long executeCount) {
this.executeCount = executeCount;
public long getErrorCount() {
return errorCount;
public void setErrorCount(long errorCount) {
this.errorCount = errorCount;
public long getCommitCount() {
return commitCount;
public void setCommitCount(long commitCount) {
this.commitCount = commitCount;
public long getRollbackCount() {
return rollbackCount;
public void setRollbackCount(long rollbackCount) {
this.rollbackCount = rollbackCount;
public long getPstmtCacheHitCount() {
return pstmtCacheHitCount;
public void setPstmtCacheHitCount(long pstmtCacheHitCount) {
this.pstmtCacheHitCount = pstmtCacheHitCount;
public long getPstmtCacheMissCount() {
return pstmtCacheMissCount;
public void setPstmtCacheMissCount(long pstmtCacheMissCount) {
this.pstmtCacheMissCount = pstmtCacheMissCount;
public long getStartTransactionCount() {
return startTransactionCount;
public void setStartTransactionCount(long startTransactionCount) {
this.startTransactionCount = startTransactionCount;
public long[] getTransactionHistogram() {
return transactionHistogram;
public void setTransactionHistogram(long[] transactionHistogram) {
this.transactionHistogram = transactionHistogram;
public long[] getConnectionHoldTimeHistogram() {
return connectionHoldTimeHistogram;
public void setConnectionHoldTimeHistogram(long[] connectionHoldTimeHistogram) {
this.connectionHoldTimeHistogram = connectionHoldTimeHistogram;
public long getClobOpenCount() {
return clobOpenCount;
public void setClobOpenCount(long clobOpenCount) {
this.clobOpenCount = clobOpenCount;
public long getBlobOpenCount() {
return blobOpenCount;
public void setBlobOpenCount(long blobOpenCount) {
this.blobOpenCount = blobOpenCount;
public List<JdbcSqlStatValue> getSqlList() {
return sqlList;
public void setSqlList(List<JdbcSqlStatValue> sqlList) {
this.sqlList = sqlList;
public void setActivePeakTime(long activePeakTime) {
this.activePeakTime = activePeakTime;
public void setPoolingPeakTime(long poolingPeakTime) {
this.poolingPeakTime = poolingPeakTime;
protected String    sql;
protected long      id;
protected String    dataSource;
protected long      executeLastStartTime;
protected long      executeBatchSizeTotal;
protected int       executeBatchSizeMax;
protected long      executeSuccessCount;
protected long      executeSpanNanoTotal;
protected long      executeSpanNanoMax;
protected int       runningCount;
protected int       concurrentMax;
protected long      resultSetHoldTimeNano;
protected long      executeAndResultSetHoldTime;
protected String    name;
protected String    file;
protected String    dbType;
protected long      executeNanoSpanMaxOccurTime;
protected long      executeErrorCount;
protected Throwable executeErrorLast;
protected long      executeErrorLastTime;
protected long      updateCount;
protected long      updateCountMax;
protected long      fetchRowCount;
protected long      fetchRowCountMax;
protected long      inTransactionCount;
protected String    lastSlowParameters;
protected long      clobOpenCount;
protected long      blobOpenCount;
protected long      readStringLength;
protected long      readBytesLength;
protected long      inputStreamOpenCount;
protected long      readerOpenCount;
protected long      histogram_0_1;
protected long      histogram_1_10;
protected int       histogram_10_100;
protected int       histogram_100_1000;
protected int       histogram_1000_10000;
protected int       histogram_10000_100000;
protected int       histogram_100000_1000000;
protected int       histogram_1000000_more;
public String getSql() {
return sql;
public void setSql(String sql) {
this.sql = sql;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getDataSource() {
return dataSource;
public void setDataSource(String dataSource) {
this.dataSource = dataSource;
public long getExecuteLastStartTime() {
return executeLastStartTime;
public void setExecuteLastStartTime(long executeLastStartTime) {
this.executeLastStartTime = executeLastStartTime;
public long getExecuteBatchSizeTotal() {
return executeBatchSizeTotal;
public void setExecuteBatchSizeTotal(long executeBatchSizeTotal) {
this.executeBatchSizeTotal = executeBatchSizeTotal;
public int getExecuteBatchSizeMax() {
return executeBatchSizeMax;
public void setExecuteBatchSizeMax(int executeBatchSizeMax) {
this.executeBatchSizeMax = executeBatchSizeMax;
public long getExecuteSuccessCount() {
return executeSuccessCount;
public void setExecuteSuccessCount(long executeSuccessCount) {
this.executeSuccessCount = executeSuccessCount;
public long getExecuteSpanNanoTotal() {
return executeSpanNanoTotal;
public void setExecuteSpanNanoTotal(long executeSpanNanoTotal) {
this.executeSpanNanoTotal = executeSpanNanoTotal;
public long getExecuteSpanNanoMax() {
return executeSpanNanoMax;
public void setExecuteSpanNanoMax(long executeSpanNanoMax) {
this.executeSpanNanoMax = executeSpanNanoMax;
public int getRunningCount() {
return runningCount;
public void setRunningCount(int runningCount) {
this.runningCount = runningCount;
public int getConcurrentMax() {
return concurrentMax;
public void setConcurrentMax(int concurrentMax) {
this.concurrentMax = concurrentMax;
public long getResultSetHoldTimeNano() {
return resultSetHoldTimeNano;
public void setResultSetHoldTimeNano(long resultSetHoldTimeNano) {
this.resultSetHoldTimeNano = resultSetHoldTimeNano;
public long getExecuteAndResultSetHoldTime() {
return executeAndResultSetHoldTime;
public void setExecuteAndResultSetHoldTime(long executeAndResultSetHoldTime) {
this.executeAndResultSetHoldTime = executeAndResultSetHoldTime;
public String getName() {
return name;
public void setName(String name) {
this.name = name;
public String getFile() {
return file;
public void setFile(String file) {
this.file = file;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public long getExecuteNanoSpanMaxOccurTime() {
return executeNanoSpanMaxOccurTime;
public void setExecuteNanoSpanMaxOccurTime(long executeNanoSpanMaxOccurTime) {
this.executeNanoSpanMaxOccurTime = executeNanoSpanMaxOccurTime;
public long getExecuteErrorCount() {
return executeErrorCount;
public void setExecuteErrorCount(long executeErrorCount) {
this.executeErrorCount = executeErrorCount;
public Throwable getExecuteErrorLast() {
return executeErrorLast;
public void setExecuteErrorLast(Throwable executeErrorLast) {
this.executeErrorLast = executeErrorLast;
public long getExecuteErrorLastTime() {
return executeErrorLastTime;
public void setExecuteErrorLastTime(long executeErrorLastTime) {
this.executeErrorLastTime = executeErrorLastTime;
public long getUpdateCount() {
return updateCount;
public void setUpdateCount(long updateCount) {
this.updateCount = updateCount;
public long getUpdateCountMax() {
return updateCountMax;
public void setUpdateCountMax(long updateCountMax) {
this.updateCountMax = updateCountMax;
public long getFetchRowCount() {
return fetchRowCount;
public void setFetchRowCount(long fetchRowCount) {
this.fetchRowCount = fetchRowCount;
public long getFetchRowCountMax() {
return fetchRowCountMax;
public void setFetchRowCountMax(long fetchRowCountMax) {
this.fetchRowCountMax = fetchRowCountMax;
public long getInTransactionCount() {
return inTransactionCount;
public void setInTransactionCount(long inTransactionCount) {
this.inTransactionCount = inTransactionCount;
public String getLastSlowParameters() {
return lastSlowParameters;
public void setLastSlowParameters(String lastSlowParameters) {
this.lastSlowParameters = lastSlowParameters;
public long getClobOpenCount() {
return clobOpenCount;
public void setClobOpenCount(long clobOpenCount) {
this.clobOpenCount = clobOpenCount;
public long getBlobOpenCount() {
return blobOpenCount;
public void setBlobOpenCount(long blobOpenCount) {
this.blobOpenCount = blobOpenCount;
public long getReadStringLength() {
return readStringLength;
public void setReadStringLength(long readStringLength) {
this.readStringLength = readStringLength;
public long getReadBytesLength() {
return readBytesLength;
public void setReadBytesLength(long readBytesLength) {
this.readBytesLength = readBytesLength;
public long getInputStreamOpenCount() {
return inputStreamOpenCount;
public void setInputStreamOpenCount(long inputStreamOpenCount) {
this.inputStreamOpenCount = inputStreamOpenCount;
public long getReaderOpenCount() {
return readerOpenCount;
public void setReaderOpenCount(long readerOpenCount) {
this.readerOpenCount = readerOpenCount;
map.put("dbType", statValue.getDbType());
map.put("name", statValue.getName());
map.put("activeCount", statValue.getActiveCount());
map.put("activePeak", statValue.getActivePeak());
map.put("poolingCount", statValue.getPoolingCount());
if (statValue.getPoolingPeak() > 0) {
map.put("poolingPeak", statValue.getPoolingPeak());
map.put("connectCount", statValue.getConnectCount());
map.put("closeCount", statValue.getCloseCount());
if (statValue.getWaitThreadCount() > 0) {
map.put("waitThreadCount", statValue.getWaitThreadCount());
if (statValue.getNotEmptyWaitCount() > 0) {
map.put("notEmptyWaitCount", statValue.getNotEmptyWaitCount());
if (statValue.getLogicConnectErrorCount() > 0) {
map.put("logicConnectErrorCount", statValue.getLogicConnectErrorCount());
if (statValue.getPhysicalConnectCount() > 0) {
map.put("physicalConnectCount", statValue.getPhysicalConnectCount());
if (statValue.getPhysicalCloseCount() > 0) {
map.put("physicalCloseCount", statValue.getPhysicalCloseCount());
if (statValue.getPhysicalConnectErrorCount() > 0) {
map.put("physicalConnectErrorCount", statValue.getPhysicalConnectErrorCount());
if (statValue.getExecuteCount() > 0) {
map.put("executeCount", statValue.getExecuteCount());
if (statValue.getErrorCount() > 0) {
map.put("errorCount", statValue.getErrorCount());
if (statValue.getCommitCount() > 0) {
map.put("commitCount", statValue.getCommitCount());
if (statValue.getRollbackCount() > 0) {
map.put("rollbackCount", statValue.getRollbackCount());
if (statValue.getPstmtCacheHitCount() > 0) {
map.put("pstmtCacheHitCount", statValue.getPstmtCacheHitCount());
if (statValue.getPstmtCacheMissCount() > 0) {
map.put("pstmtCacheMissCount", statValue.getPstmtCacheMissCount());
if (statValue.getStartTransactionCount() > 0) {
map.put("startTransactionCount", statValue.getStartTransactionCount());
map.put("transactionHistogram", rtrim(statValue.getTransactionHistogram()));
if (statValue.getConnectCount() > 0) {
map.put("connectionHoldTimeHistogram", rtrim(statValue.getConnectionHoldTimeHistogram()));
if (statValue.getClobOpenCount() > 0) {
map.put("clobOpenCount", statValue.getClobOpenCount());
if (statValue.getBlobOpenCount() > 0) {
map.put("blobOpenCount", statValue.getBlobOpenCount());
for (JdbcSqlStatValue sqlStat : statValue.getSqlList()) {
tryImplementation("org.slf4j.Logger", "com.alibaba.druid.support.logging.SLF4JImpl");
Column column = this.getColumn(tableName, columnName);
if (column == null) {
column = new Column(tableName, columnName);
columns.add(column);
if (column != null) {
if (column != null) {
setColumn(x, column);
Column column;
column = addColumn(currentTable, ident);
column = handleUnkownColumn(ident);
if (column != null) {
setColumn(x, column);
private void setColumn(SQLExpr x, Column column) {
SQLObject current = x;
for (;;) {
SQLObject parent = current.getParent();
if (parent == null) {
if (parent instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock query = (SQLSelectQueryBlock) parent;
if (query.getWhere() == current) {
column.setWhere(true);
if (parent instanceof SQLSelectGroupByClause) {
SQLSelectGroupByClause groupBy = (SQLSelectGroupByClause) parent;
if (current == groupBy.getHaving()) {
column.setHaving(true);
} else if (groupBy.getItems().contains(current)) {
column.setGroupBy(true);
if (parent instanceof SQLSelectItem) {
column.setSelec(true);
if (parent instanceof SQLJoinTableSource) {
SQLJoinTableSource join = (SQLJoinTableSource) parent;
if (join.getCondition() == current) {
column.setJoin(true);
current = parent;
public Column getColumn(String tableName, String columnName) {
for (Column column : this.columns) {
if (StringUtils.equalsIgnoreCase(tableName, column.getTable())
&& StringUtils.equalsIgnoreCase(columnName, column.getName())) {
return column;
return null;
private boolean             where;
private boolean             select;
private boolean             groupBy;
private boolean             having;
private boolean             join;
public boolean isWhere() {
return where;
public void setWhere(boolean where) {
this.where = where;
public boolean isSelect() {
return select;
public void setSelec(boolean select) {
this.select = select;
public boolean isGroupBy() {
return groupBy;
public void setGroupBy(boolean groupBy) {
this.groupBy = groupBy;
public boolean isHaving() {
return having;
public boolean isJoin() {
return join;
public void setJoin(boolean join) {
this.join = join;
public void setHaving(boolean having) {
this.having = having;
public static boolean equalsIgnoreCase(String a, String b) {
if (a == null) {
return b == null;
return a.equalsIgnoreCase(b);
Assert.assertTrue(visitor.getColumn("users", "name").isSelect());
Assert.assertTrue(visitor.getColumn("usergroups", "name").isSelect());
Assert.assertTrue(visitor.getColumn("users", "groupId").isJoin());
Assert.assertTrue(visitor.getColumn("usergroups", "id").isJoin());
Assert.assertTrue(visitor.getColumn("users", "groupId").isWhere());
setObjectParameter(parameterIndex, x);
private void setObjectParameter(int parameterIndex, Object x) {
if (x == null) {
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
Class<?> clazz = x.getClass();
if (clazz == Byte.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TINYINT, x));
if (clazz == Short.class) {
setParameter(parameterIndex, new JdbcParameter(Types.SMALLINT, x));
if (clazz == Integer.class) {
setParameter(parameterIndex, new JdbcParameter(Types.INTEGER, x));
if (clazz == Long.class) {
setParameter(parameterIndex, new JdbcParameter(Types.BIGINT, x));
if (clazz == String.class) {
setParameter(parameterIndex, new JdbcParameter(Types.VARCHAR, x));
if (clazz == BigDecimal.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DECIMAL, x));
if (clazz == Float.class) {
setParameter(parameterIndex, new JdbcParameter(Types.FLOAT, x));
if (clazz == Double.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DOUBLE, x));
if (clazz == java.sql.Date.class || clazz == java.util.Date.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x));
if (clazz == java.sql.Timestamp.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
if (clazz == java.sql.Time.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x));
if (clazz == Boolean.class) {
setParameter(parameterIndex, new JdbcParameter(Types.BOOLEAN, x));
if (clazz == byte[].class) {
setParameter(parameterIndex, new JdbcParameter(TYPE.BYTES, x));
if (x instanceof InputStream) {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x));
if (x instanceof Reader) {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.CharacterInputStream, x));
if (x instanceof Clob) {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
if (x instanceof NClob) {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
if (x instanceof Blob) {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
case END:
Thread.sleep(2);
public class PreparedStatementProxyImplTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setInitialSize(1);
dataSource.setFilters("log4j");
protected void tearDown() throws Exception {
dataSource.close();
public void test_setObject() throws Exception {
String sql = "insert t values(?, ?, ?, ?, ?,  ?, ?, ?, ?, ?)";
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setObject(1, (byte) 1);
stmt.setObject(2, (short) 1);
stmt.setObject(3, (int) 1);
stmt.setObject(4, (long) 1);
stmt.setObject(5, (float) 1);
stmt.setObject(6, (double) 1);
stmt.setObject(7, new BigDecimal(1));
stmt.setObject(8, true);
stmt.setObject(9, "xxx");
stmt.setObject(10, new java.sql.Date(System.currentTimeMillis()));
stmt.setObject(11, new java.util.Date(System.currentTimeMillis()));
stmt.setObject(12, new java.sql.Timestamp(System.currentTimeMillis()));
stmt.setObject(13, new java.sql.Time(System.currentTimeMillis()));
stmt.execute();
PreparedStatementProxyImpl stmtProxy = stmt.unwrap(PreparedStatementProxyImpl.class);
Assert.assertNotNull(stmtProxy);
Assert.assertEquals(Types.TINYINT, stmtProxy.getParameters().get(1).getSqlType());
Assert.assertEquals(Types.SMALLINT, stmtProxy.getParameters().get(2).getSqlType());
Assert.assertEquals(Types.INTEGER, stmtProxy.getParameters().get(3).getSqlType());
Assert.assertEquals(Types.BIGINT, stmtProxy.getParameters().get(4).getSqlType());
Assert.assertEquals(Types.FLOAT, stmtProxy.getParameters().get(5).getSqlType());
Assert.assertEquals(Types.DOUBLE, stmtProxy.getParameters().get(6).getSqlType());
Assert.assertEquals(Types.DECIMAL, stmtProxy.getParameters().get(7).getSqlType());
Assert.assertEquals(Types.BOOLEAN, stmtProxy.getParameters().get(8).getSqlType());
Assert.assertEquals(Types.VARCHAR, stmtProxy.getParameters().get(9).getSqlType());
Assert.assertEquals(Types.DATE, stmtProxy.getParameters().get(10).getSqlType());
Assert.assertEquals(Types.DATE, stmtProxy.getParameters().get(11).getSqlType());
Assert.assertEquals(Types.TIMESTAMP, stmtProxy.getParameters().get(12).getSqlType());
Assert.assertEquals(Types.TIME, stmtProxy.getParameters().get(13).getSqlType());
stmt.close();
conn.close();
public class MySqlInsertTest_7 extends MysqlTest {
public void test_0() throws Exception {
String sql = "insert into Apply (applicant_id, applytime, applytype, approver_id, end, process, start) values (?, ?, ?, ?, ?, ?, ?)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(7, insertStmt.getColumns().size());
Assert.assertEquals(1, insertStmt.getValuesList().size());
Assert.assertEquals(7, insertStmt.getValuesList().get(0).getValues().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO Apply (applicant_id, applytime, applytype, approver_id, end" + 
"nt, process, start)" + 
"nVALUES (?, ?, ?, ?, ?" + 
"nt, ?, ?)", 
SQLUtils.toMySqlString(insertStmt));
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatementProxy.class) {
return (T) this;
return super.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == PreparedStatementProxy.class) {
return true;
return super.isWrapperFor(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == ResultSetProxy.class || iface == ResultSetProxyImpl.class) {
return (T) this;
return super.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == ResultSetProxy.class || iface == ResultSetProxyImpl.class) {
return true;
return super.isWrapperFor(iface);
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == StatementProxy.class) {
return (T) this;
return super.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == StatementProxy.class) {
return true;
return super.isWrapperFor(iface);
PreparedStatementProxy stmtProxy = stmt.unwrap(PreparedStatementProxy.class);
public class UnwrapTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(true);
dataSource.setInitialSize(1);
dataSource.setValidationQuery("select 1");
dataSource.setValidationQueryTimeout(10);
dataSource.setQueryTimeout(100);
dataSource.setFilters("log4j");
protected void tearDown() throws Exception {
dataSource.close();
public void test_unwrap() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
Assert.assertNotNull(conn.unwrap(DruidPooledConnection.class));
Assert.assertSame(conn, conn.unwrap(DruidPooledConnection.class));
Assert.assertTrue(conn.isWrapperFor(MockConnection.class));
Assert.assertNotNull(conn.unwrap(MockConnection.class));
PreparedStatement stmt = conn.prepareStatement("select ?");
Assert.assertTrue(stmt.isWrapperFor(Statement.class));
Assert.assertNotNull(stmt.unwrap(Statement.class));
Assert.assertTrue(stmt.isWrapperFor(PreparedStatement.class));
Assert.assertNotNull(stmt.unwrap(PreparedStatement.class));
Assert.assertTrue(stmt.isWrapperFor(StatementProxy.class));
Assert.assertNotNull(stmt.unwrap(StatementProxy.class));
Assert.assertTrue(stmt.isWrapperFor(PreparedStatementProxy.class));
Assert.assertNotNull(stmt.unwrap(PreparedStatementProxy.class));
Assert.assertTrue(stmt.isWrapperFor(PreparedStatementProxyImpl.class));
Assert.assertNotNull(stmt.unwrap(PreparedStatementProxyImpl.class));
Assert.assertTrue(stmt.isWrapperFor(MockPreparedStatement.class));
Assert.assertNotNull(stmt.unwrap(MockPreparedStatement.class));
stmt.setObject(1, "aaa");
ResultSet rs = stmt.executeQuery();
Assert.assertTrue(rs.isWrapperFor(ResultSet.class));
Assert.assertNotNull(rs.unwrap(ResultSet.class));
Assert.assertTrue(rs.isWrapperFor(ResultSetProxy.class));
Assert.assertNotNull(rs.unwrap(ResultSetProxy.class));
Assert.assertTrue(rs.isWrapperFor(ResultSetProxyImpl.class));
Assert.assertNotNull(rs.unwrap(ResultSetProxyImpl.class));
Assert.assertTrue(rs.isWrapperFor(MockResultSet.class));
Assert.assertNotNull(rs.unwrap(MockResultSet.class));
rs.close();
stmt.close();
conn.close();
public class UnwrapTest2 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(true);
dataSource.setInitialSize(1);
dataSource.setValidationQuery("select 1");
dataSource.setValidationQueryTimeout(10);
dataSource.setQueryTimeout(100);
dataSource.setFilters("log4j");
protected void tearDown() throws Exception {
dataSource.close();
public void test_unwrap() throws Exception {
Connection conn = dataSource.getConnection();
Assert.assertTrue(conn.isWrapperFor(DruidPooledConnection.class));
Assert.assertNotNull(conn.unwrap(DruidPooledConnection.class));
Assert.assertSame(conn, conn.unwrap(DruidPooledConnection.class));
Assert.assertTrue(conn.isWrapperFor(MockConnection.class));
Assert.assertNotNull(conn.unwrap(MockConnection.class));
Statement stmt = conn.createStatement();
Assert.assertTrue(stmt.isWrapperFor(Statement.class));
Assert.assertNotNull(stmt.unwrap(Statement.class));
Assert.assertTrue(stmt.isWrapperFor(StatementProxy.class));
Assert.assertNotNull(stmt.unwrap(StatementProxy.class));
Assert.assertTrue(stmt.isWrapperFor(StatementProxyImpl.class));
Assert.assertNotNull(stmt.unwrap(StatementProxyImpl.class));
Assert.assertTrue(stmt.isWrapperFor(MockStatement.class));
Assert.assertNotNull(stmt.unwrap(MockStatement.class));
ResultSet rs = stmt.executeQuery("select 1");
Assert.assertTrue(rs.isWrapperFor(ResultSet.class));
Assert.assertNotNull(rs.unwrap(ResultSet.class));
Assert.assertTrue(rs.isWrapperFor(ResultSetProxy.class));
Assert.assertNotNull(rs.unwrap(ResultSetProxy.class));
Assert.assertTrue(rs.isWrapperFor(ResultSetProxyImpl.class));
Assert.assertNotNull(rs.unwrap(ResultSetProxyImpl.class));
Assert.assertTrue(rs.isWrapperFor(MockResultSet.class));
Assert.assertNotNull(rs.unwrap(MockResultSet.class));
rs.close();
stmt.close();
conn.close();
final int COUNT = 1000 * 5;
public class JdbcSqlStatTest1 extends TestCase {
private JdbcDataSourceStat dataSourceStat = new JdbcDataSourceStat("", "");
public void test_0() throws Exception {
for (int i = 0; i < 3; ++i) {
long memoryStart = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
final int COUNT = 1024 * 1024;
for (int j = 0; j < COUNT; ++j) {
dataSourceStat.createSqlStat(Integer.toString(j));
long memoryEnd = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryStart));
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryEnd));
System.out.println("memory used : " + NumberFormat.getInstance().format(memoryEnd - memoryStart));
private void gc() {
for (int i = 0; i < 10; ++i) {
System.gc();
if (wallContext != null && i != 0) {
public class MySqlWallTest_having extends TestCase {
public void test_having() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(
"select id, count(*) from t group by id having 1 = 1"));
public void test_having_true_first() throws Exception {
Assert.assertTrue(WallUtils.isValidateMySql(
"select id, count(*) from t group by id having 1 = 1 AND count(*) > 2"));
public void test_having_false() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(
"select id, count(*) from t group by id having count(*) > 2 OR 1 = 1"));
void setConnectionProperties(String connectionProperties);
public class OracleExceptionSorter_userDefined_1 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
dataSource = new DruidDataSource();
dataSource.setExceptionSorter(new OracleExceptionSorter());
dataSource.setDriver(new OracleMockDriver());
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setPoolPreparedStatements(true);
dataSource.setMaxOpenPreparedStatements(100);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_userDefinedErrorCodes() throws Exception {
dataSource.init();
dataSource.setConnectionProperties("druid.oracle.fatalErrorCodes=1,2,3,a,");
OracleExceptionSorter sorter = (OracleExceptionSorter) dataSource.getExceptionSorter();
Assert.assertEquals(3, sorter.getFatalErrorCodes().size());
Assert.assertTrue(sorter.getFatalErrorCodes().contains(1));
Assert.assertTrue(sorter.getFatalErrorCodes().contains(2));
Assert.assertTrue(sorter.getFatalErrorCodes().contains(3));
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("xx", "xx", 1)));
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("xx", "xx", 2)));
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("xx", "xx", 3)));
Assert.assertFalse(sorter.isExceptionFatal(new SQLException("xx", "xx", 4)));
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("xx", "xx", 28)));
case 17401: 
case 17438: 
case 17442: 
if (statLogger != null) {
statLogger.configFromProperties(properties);
void configFromProperties(Properties properties);
public abstract class DruidDataSourceStatLoggerAdapter implements DruidDataSourceStatLogger {
public void log(DruidDataSourceStatValue statValue) {
public void configFromProperties(Properties properties) {
public class DruidDataSourceStatLoggerImpl extends DruidDataSourceStatLoggerAdapter {
public DruidDataSourceStatLoggerImpl() {
this.configFromProperties(System.getProperties());
public void configFromProperties(Properties properties) {
if (validConnectionChecker != null) {
validConnectionChecker.configFromProperties(properties);
public class MySQLValidConnectionCheckerTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
System.setProperty("druid.mysql.usePingMethod", "false");
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setDbType("mysql");
dataSource.setValidationQuery("select 1");
dataSource.setValidConnectionChecker(new MySqlValidConnectionChecker());
dataSource.setInitialSize(1);
dataSource.setTestOnBorrow(true);
protected void tearDown() throws Exception {
dataSource.close();
System.clearProperty("druid.mysql.usePingMethod");
public void test_connect() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
MySqlValidConnectionChecker checker = (MySqlValidConnectionChecker) dataSource.getValidConnectionChecker();
Assert.assertFalse(checker.isUsePingMethod());
dataSource.setConnectionProperties("druid.mysql.usePingMethod=true");
Assert.assertTrue(checker.isUsePingMethod());
Connection conn = dataSource.getConnection();
conn.close();
if (WallVisitorUtils.isWhereOrHaving(x) && isDeny(varName)) {
violations.add(new IllegalSQLObjectViolation(ErrorCode.VARIANT_DENY,
"variable not allow : " + x.getName(),
toSQL(x)));
if (WallVisitorUtils.isWhereOrHaving(x) && isDeny(varName)) {
boolean allow = true;
if (WallVisitorUtils.isWhereOrHaving(x) && isDeny(varName)) {
allow = false;
if (!allow) {
violations.add(new IllegalSQLObjectViolation(ErrorCode.VARIANT_DENY, "variable not allow : "
+ x.getName(), toSQL(x)));
public boolean isDeny(String varName) {
if (varName.startsWith("@@")) {
varName = varName.substring(2);
return config.getDenyVariants().contains(varName);
public final static String DRUID_STAT_SQL_MAX_SIZE             = "druid.stat.sql.MaxSize";
public final static String DRUID_TIME_BETWEEN_LOG_STATS_MILLIS = "druid.timeBetweenLogStatsMillis";
String property = properties.getProperty(Constants.DRUID_TIME_BETWEEN_LOG_STATS_MILLIS);
LOG.error("illegal property '" + Constants.DRUID_TIME_BETWEEN_LOG_STATS_MILLIS + "'", e);
@SuppressWarnings("unchecked")
public void fromJSON(String json) {
Map<String, Object> map = (Map<String, Object>) JSONUtils.parse(json);
fromJSON(map);
public void fromJSON(Map<String, Object> map) {
this.name = (String) map.get("name");
this.dbType = (String) map.get("dbType");
this.driverClassName = (String) map.get("driverClassName");
this.url = (String) map.get("url");
this.userName = (String) map.get("userName");
return returnJSONResult(RESULT_CODE_SUCCESS, getWallStatMap(parameters));
if (result != null) {
List<Map<String, Object>> tables = (List<Map<String, Object>>) result.get("tables");
if (tables != null) {
List<Map<String, Object>> sortedArray = comparatorOrderBy(tables, parameters);
result.put("tables", sortedArray);
sortedArray = comparatorOrderBy((List<Map<String, Object>>) result.get("functions"), parameters);
result.put("functions", sortedArray);
result = Collections.emptyMap();
if (expr != null) {
expr.setParent(this);
if (!(x.getParent() instanceof ValuesClause)) {
Object first = contentList.get(0);
assertThat(first, is(not(nullValue())));
public class DruidStatServiceTest2 extends TestCase {
public void test_getWallStatMap() throws Exception {
DruidStatService.getInstance().getWallStatMap(Collections.<String, String>emptyMap());
final WallSelectQueryContext wallSelectQueryContext = WallVisitorUtils.getWallSelectQueryContext();
if (wallSelectQueryContext != null) {
wallSelectQueryContext.setTrueLike(Boolean.TRUE);
WallVisitorUtils.initWallTopStatementContext();
@Override
public void endVisit(SQLUpdateStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
@Override
public void endVisit(SQLSelectStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
@Override
public void endVisit(SQLSelectStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
@Override
public void endVisit(SQLUpdateStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
final WallSelectQueryContext old = wallSelectQueryContextLocal.get();
wallSelectQueryContextLocal.set(new WallSelectQueryContext());
for (SQLSelectItem item : x.getSelectList()) {
item.setParent(x);
if (x.getInto() != null) {
checkReadOnly(visitor, x.getInto());
if (!visitor.getConfig().isSelectIntoAllow() && x.getInto() != null) {
addViolation(visitor, ErrorCode.SELECT_INTO_NOT_ALLOW, "select into not allow", x);
if (x.getFrom() != null) {
x.getFrom().setParent(x);
SQLExpr where = x.getWhere();
if (where != null) {
where.setParent(x);
checkCondition(visitor, x.getWhere());
if (Boolean.TRUE == getConditionValue(visitor, where, visitor.getConfig().isSelectWhereAlwayTrueCheck())) {
boolean isSimpleConstExpr = false;
SQLExpr first = getFirst(where);
if (first == where) {
isSimpleConstExpr = true;
} else if (first instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) first;
if (binaryOpExpr.getOperator() == SQLBinaryOperator.Equality
|| binaryOpExpr.getOperator() == SQLBinaryOperator.NotEqual) {
if (binaryOpExpr.getLeft() instanceof SQLIntegerExpr
&& binaryOpExpr.getRight() instanceof SQLIntegerExpr) {
isSimpleConstExpr = true;
final WallSelectQueryContext current = wallSelectQueryContextLocal.get();
if (!isSimpleConstExpr 
&& !(current != null && current.hasTrueLike()) 
addViolation(visitor, ErrorCode.ALWAY_TRUE, "select alway true condition not allow", x);
checkConditionForMultiTenant(visitor, x.getWhere(), x);
} finally {
wallSelectQueryContextLocal.set(old);
public static class WallSelectQueryContext {
private boolean trueLike = false;
public boolean hasTrueLike() {
return trueLike;
public void setTrueLike(boolean trueLike) {
this.trueLike = trueLike;
public static class WallTopStatementContext {
private boolean fromSysTable  = false;
private boolean fromSysSchema = false;
public boolean fromSysTable() {
return fromSysTable;
public void setFromSysTable(boolean fromSysTable) {
this.fromSysTable = fromSysTable;
public boolean fromSysSchema() {
return fromSysSchema;
public void setFromSysSchema(boolean fromSysSchema) {
this.fromSysSchema = fromSysSchema;
private static ThreadLocal<WallConditionContext>    wallConditionContextLocal    = new ThreadLocal<WallConditionContext>();
private static ThreadLocal<WallSelectQueryContext>  wallSelectQueryContextLocal  = new ThreadLocal<WallSelectQueryContext>();
private static ThreadLocal<WallTopStatementContext> wallTopStatementContextLocal = new ThreadLocal<WallTopStatementContext>();
public static WallTopStatementContext getWallTopStatementContext() {
return wallTopStatementContextLocal.get();
public static void clearWallTopStatementContext() {
wallTopStatementContextLocal.set(null);
public static void initWallTopStatementContext() {
wallTopStatementContextLocal.set(new WallTopStatementContext());
public static WallSelectQueryContext getWallSelectQueryContext() {
return wallSelectQueryContextLocal.get();
final WallTopStatementContext topStatementContext = wallTopStatementContextLocal.get();
if (topStatementContext != null && (topStatementContext.fromSysSchema || topStatementContext.fromSysTable)) {
final WallTopStatementContext topStatementContext = wallTopStatementContextLocal.get();
if (topStatementContext != null && (topStatementContext.fromSysSchema || topStatementContext.fromSysTable)) {
return true;
boolean topStatement = isTopSelectStatement(x) || isTopUpdateStatement(x);
boolean isWhereOrHaving = isWhereOrHaving(x);
if (!topStatement && isWhereOrHaving) {
if (topStatementContext != null) {
topStatementContext.setFromSysSchema(Boolean.TRUE);
while (parent != null) {
if (parent instanceof SQLSelectStatement || parent instanceof MySqlShowStatement) {
parent = parent.getParent();
if (parent == null) {
topSelectStatement = true;
if (parent instanceof SQLUnionQuery) {
SQLUnionQuery union = (SQLUnionQuery) parent;
if (union.getRight() == x) {
x = parent;
parent = x.getParent();
private static boolean isTopUpdateStatement(SQLObject x) {
boolean topUpdateStatement = false;
while (x != null) {
if (x instanceof SQLUpdateStatement) {
x = x.getParent();
if (x == null) {
topUpdateStatement = true;
x = x.getParent();
return topUpdateStatement;
final WallTopStatementContext topStatementContext = wallTopStatementContextLocal.get();
if (topStatementContext != null && (topStatementContext.fromSysSchema || topStatementContext.fromSysTable)) {
return true;
SQLExpr expr = x.getExpr();
boolean topStatement = isTopSelectStatement(x) || isTopUpdateStatement(x);
boolean isWhereOrHaving = isWhereOrHaving(x);
if (topStatement || !isWhereOrHaving) {
if (topStatementContext != null) {
topStatementContext.setFromSysTable(Boolean.TRUE);
return false;
public void setLogger(Log logger) {
if (logger == null) {
throw new IllegalArgumentException("logger can not be null");
this.logger = logger;
if (statValue.getActivePeak() > 0) {
public JakartaCommonsLoggingImpl(Log log) {
this.log = log;
public Log4jImpl(Logger log) {
this.log = log;
void setLogger(Log logger);
void setLoggerName(String loggerName);
public class DruidDataSourceStatLoggerAdapter implements DruidDataSourceStatLogger {
public void setLogger(Log logger) {
public void setLoggerName(String loggerName) {
public boolean isLogEnable() {
return logger.isInfoEnabled();
public void log(String value) {
logger.info(value);
if (isLogEnable()) {
log(text);
public SLF4JImpl(LocationAwareLogger log){
this.log = log;
if (statementList.size() == 0) {
return sql;
return (castToString(a)).compareTo(castToString(b)) < 0;
int parametersSize = statement.getParametersSize();
if (parametersSize == 0) {
List<Object> parameters = new ArrayList<Object>(parametersSize);
for (int i = 0; i < parametersSize; ++i) {
JdbcParameter jdbcParam = statement.getParameter(i);
for (int i = 0, parametersSize = statement.getParametersSize(); i < parametersSize; ++i) {
JdbcParameter parameter = statement.getParameter(i);
if (i != 0) {
if (parameter == null) {
for (int i = 0, parametersSize = statement.getParametersSize(); i < parametersSize; ++i) {
JdbcParameter parameter = statement.getParameter(i);
if (i != 0) {
if (parameter == null) {
public class StatFilter extends FilterEventAdapter implements StatFilterMBean {
private final static Log          LOG                        = LogFactory.getLog(StatFilter.class);
private static final String       SYS_PROP_LOG_SLOW_SQL      = "druid.stat.logSlowSql";
private static final String       SYS_PROP_SLOW_SQL_MILLIS   = "druid.stat.slowSqlMillis";
private static final String       SYS_PROP_MERGE_SQL         = "druid.stat.mergeSql";
public final static String        ATTR_NAME_CONNECTION_STAT  = "stat.conn";
public final static String        ATTR_NAME_STATEMENT_STAT   = "stat.stmt";
public final static String        ATTR_UPDATE_COUNT          = "stat.updteCount";
public final static String        ATTR_TRANSACTION           = "stat.tx";
public final static String        ATTR_RESULTSET_CLOSED      = "stat.rs.closed";
@Deprecated
protected final JdbcStatementStat statementStat              = JdbcStatManager.getInstance().getStatementStat();
@Deprecated
protected final JdbcResultSetStat resultSetStat              = JdbcStatManager.getInstance().getResultSetStat();
private boolean                   connectionStackTraceEnable = false;
protected long                    slowSqlMillis              = 3 * 1000;
protected boolean                 logSlowSql                 = false;
private String                    dbType;
private boolean                   mergeSql                   = false;
public StatFilter(){
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
public long getSlowSqlMillis() {
return slowSqlMillis;
public void setSlowSqlMillis(long slowSqlMillis) {
this.slowSqlMillis = slowSqlMillis;
public boolean isLogSlowSql() {
return logSlowSql;
public void setLogSlowSql(boolean logSlowSql) {
this.logSlowSql = logSlowSql;
public boolean isConnectionStackTraceEnable() {
return connectionStackTraceEnable;
public void setConnectionStackTraceEnable(boolean connectionStackTraceEnable) {
this.connectionStackTraceEnable = connectionStackTraceEnable;
public boolean isMergeSql() {
return mergeSql;
public void setMergeSql(boolean mergeSql) {
this.mergeSql = mergeSql;
@Deprecated
public String mergeSql(String sql) {
return this.mergeSql(sql, dbType);
public String mergeSql(String sql, String dbType) {
if (!mergeSql) {
return sql;
sql = ParameterizedOutputVisitorUtils.parameterize(sql, dbType);
} catch (Exception e) {
LOG.error("merge sql error, dbType " + dbType + ", sql : n" + sql, e);
return sql;
public synchronized void init(DataSourceProxy dataSource) {
if (this.dbType == null || this.dbType.trim().length() == 0) {
this.dbType = dataSource.getDbType();
configFromProperties(dataSource.getConnectProperties());
configFromProperties(System.getProperties());
public void configFromProperties(Properties properties) {
if (properties == null) {
String property = properties.getProperty(SYS_PROP_MERGE_SQL);
if ("true".equals(property)) {
this.mergeSql = true;
} else if ("false".equals(property)) {
this.mergeSql = false;
String property = properties.getProperty(SYS_PROP_SLOW_SQL_MILLIS);
if (property != null && property.trim().length() > 0) {
property = property.trim();
this.slowSqlMillis = Long.parseLong(property);
} catch (Exception e) {
LOG.error("property 'druid.stat.slowSqlMillis' format error");
String property = properties.getProperty(SYS_PROP_LOG_SLOW_SQL);
if ("true".equals(property)) {
this.logSlowSql = true;
} else if ("false".equals(property)) {
this.logSlowSql = false;
public ConnectionProxy connection_connect(FilterChain chain, Properties info) throws SQLException {
ConnectionProxy connection = null;
long startNano = System.nanoTime();
long startTime = System.currentTimeMillis();
long nanoSpan;
long nowTime = System.currentTimeMillis();
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getConnectionStat().beforeConnect();
connection = chain.connection_connect(info);
nanoSpan = System.nanoTime() - startNano;
} catch (SQLException ex) {
dataSourceStat.getConnectionStat().connectError(ex);
dataSourceStat.getConnectionStat().afterConnected(nanoSpan);
if (connection != null) {
JdbcConnectionStat.Entry statEntry = getConnectionInfo(connection);
dataSourceStat.getConnections().put(connection.getId(), statEntry);
statEntry.setConnectTime(new Date(startTime));
statEntry.setConnectTimespanNano(nanoSpan);
statEntry.setEstablishNano(System.nanoTime());
statEntry.setEstablishTime(nowTime);
statEntry.setConnectStackTrace(new Exception());
dataSourceStat.getConnectionStat().setActiveCount(dataSourceStat.getConnections().size());
return connection;
public void connection_close(FilterChain chain, ConnectionProxy connection) throws SQLException {
if (connection.getCloseCount() == 0) {
long nowNano = System.nanoTime();
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getConnectionStat().incrementConnectionCloseCount();
JdbcConnectionStat.Entry connectionInfo = getConnectionInfo(connection);
long aliveNanoSpan = nowNano - connectionInfo.getEstablishNano();
JdbcConnectionStat.Entry existsConnection = dataSourceStat.getConnections().remove(connection.getId());
if (existsConnection != null) {
dataSourceStat.getConnectionStat().afterClose(aliveNanoSpan);
chain.connection_close(connection);
public void connection_commit(FilterChain chain, ConnectionProxy connection) throws SQLException {
chain.connection_commit(connection);
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getConnectionStat().incrementConnectionCommitCount();
public void connection_rollback(FilterChain chain, ConnectionProxy connection) throws SQLException {
chain.connection_rollback(connection);
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getConnectionStat().incrementConnectionRollbackCount();
dataSourceStat.getConnectionStat().incrementConnectionRollbackCount();
public void connection_rollback(FilterChain chain, ConnectionProxy connection, Savepoint savepoint)
throws SQLException {
chain.connection_rollback(connection, savepoint);
JdbcDataSourceStat dataSourceStat = connection.getDirectDataSource().getDataSourceStat();
dataSourceStat.getConnectionStat().incrementConnectionRollbackCount();
public void statementCreateAfter(StatementProxy statement) {
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().incrementCreateCounter();
super.statementCreateAfter(statement);
public void statementPrepareCallAfter(CallableStatementProxy statement) {
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().incrementPrepareCallCount();
JdbcSqlStat sqlStat = createSqlStat(statement, statement.getSql());
statement.setSqlStat(sqlStat);
public void statementPrepareAfter(PreparedStatementProxy statement) {
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().incrementPrepareCounter();
JdbcSqlStat sqlStat = createSqlStat(statement, statement.getSql());
statement.setSqlStat(sqlStat);
public void statement_close(FilterChain chain, StatementProxy statement) throws SQLException {
chain.statement_close(statement);
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().incrementStatementCloseCounter();
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
if (context != null) {
context.setName(null);
context.setFile(null);
context.setSql(null);
protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {
internalBeforeStatementExecute(statement, sql);
protected void statementExecuteUpdateAfter(StatementProxy statement, String sql, int updateCount) {
internalAfterStatementExecute(statement, false, updateCount);
protected void statementExecuteQueryBefore(StatementProxy statement, String sql) {
internalBeforeStatementExecute(statement, sql);
protected void statementExecuteQueryAfter(StatementProxy statement, String sql, ResultSetProxy resultSet) {
internalAfterStatementExecute(statement, true);
protected void statementExecuteBefore(StatementProxy statement, String sql) {
internalBeforeStatementExecute(statement, sql);
protected void statementExecuteAfter(StatementProxy statement, String sql, boolean firstResult) {
internalAfterStatementExecute(statement, firstResult);
protected void statementExecuteBatchBefore(StatementProxy statement) {
final String sql = statement.getBatchSql();
final int batchSize = statement.getBatchSqlList().size();
JdbcSqlStat sqlStat = statement.getSqlStat();
if (sqlStat == null || sqlStat.isRemoved()) {
sqlStat = createSqlStat(statement, sql);
statement.setSqlStat(sqlStat);
if (sqlStat != null) {
sqlStat.addExecuteBatchCount(batchSize);
internalBeforeStatementExecute(statement, sql);
protected void statementExecuteBatchAfter(StatementProxy statement, int[] result) {
internalAfterStatementExecute(statement, false, result);
private final void internalBeforeStatementExecute(StatementProxy statement, String sql) {
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().beforeExecute();
final ConnectionProxy connection = statement.getConnectionProxy();
final JdbcConnectionStat.Entry connectionCounter = getConnectionInfo(connection);
statement.setLastExecuteStartNano();
connectionCounter.setLastSql(sql);
if (connectionStackTraceEnable) {
connectionCounter.setLastStatementStatckTrace(new Exception());
JdbcSqlStat sqlStat = statement.getSqlStat();
if (sqlStat == null || sqlStat.isRemoved()) {
sqlStat = createSqlStat(statement, sql);
statement.setSqlStat(sqlStat);
JdbcStatContext statContext = JdbcStatManager.getInstance().getStatContext();
if (statContext != null) {
sqlStat.setName(statContext.getName());
sqlStat.setFile(statContext.getFile());
boolean inTransaction = false;
inTransaction = !statement.getConnectionProxy().getAutoCommit();
} catch (SQLException e) {
LOG.error("getAutoCommit error", e);
if (sqlStat != null) {
sqlStat.setExecuteLastStartTime(System.currentTimeMillis());
sqlStat.incrementRunningCount();
if (inTransaction) {
sqlStat.incrementInTransactionCount();
StatFilterContext.getInstance().executeBefore(sql, inTransaction);
Profiler.enter(sql, Profiler.PROFILE_TYPE_SQL);
private final void internalAfterStatementExecute(StatementProxy statement, boolean firstResult,
int... updateCountArray) {
final long nowNano = System.nanoTime();
final long nanos = nowNano - statement.getLastExecuteStartNano();
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().afterExecute(nanos);
final JdbcSqlStat sqlStat = statement.getSqlStat();
if (sqlStat != null) {
sqlStat.incrementExecuteSuccessCount();
sqlStat.decrementRunningCount();
sqlStat.addExecuteTime(statement.getLastExecuteType(), firstResult, nanos);
statement.setLastExecuteTimeNano(nanos);
if ((!statement.isFirstResultSet()) && statement.getLastExecuteType() == StatementExecuteType.Execute) {
int updateCount = statement.getUpdateCount();
sqlStat.addUpdateCount(updateCount);
} catch (SQLException e) {
LOG.error("getUpdateCount error", e);
for (int updateCount : updateCountArray) {
sqlStat.addUpdateCount(updateCount);
sqlStat.addFetchRowCount(0);
StatFilterContext.getInstance().addUpdateCount(updateCount);
long millis = nanos / (1000 * 1000);
if (millis >= slowSqlMillis) {
String slowParameters = buildSlowParameters(statement);
sqlStat.setLastSlowParameters(slowParameters);
if (logSlowSql) {
LOG.error("slow sql " + millis + " millis. n" + statement.getLastExecuteSql() + "n"
+ slowParameters);
String sql = statement.getLastExecuteSql();
StatFilterContext.getInstance().executeAfter(sql, nanos, null);
Profiler.release(nanos);
protected void statement_executeErrorAfter(StatementProxy statement, String sql, Throwable error) {
ConnectionProxy connection = statement.getConnectionProxy();
JdbcConnectionStat.Entry connectionCounter = getConnectionInfo(connection);
long nanos = System.nanoTime() - statement.getLastExecuteStartNano();
JdbcDataSourceStat dataSourceStat = statement.getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getStatementStat().error(error);
dataSourceStat.getStatementStat().afterExecute(nanos);
connectionCounter.error(error);
JdbcSqlStat sqlStat = statement.getSqlStat();
if (sqlStat != null) {
sqlStat.error(error);
sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanos);
statement.setLastExecuteTimeNano(nanos);
StatFilterContext.getInstance().executeAfter(sql, nanos, error);
Profiler.release(nanos);
private String buildSlowParameters(StatementProxy statement) {
JSONWriter out = new JSONWriter();
out.writeArrayStart();
for (int i = 0, parametersSize = statement.getParametersSize(); i < parametersSize; ++i) {
JdbcParameter parameter = statement.getParameter(i);
if (i != 0) {
out.writeComma();
if (parameter == null) {
Object value = parameter.getValue();
if (value == null) {
out.writeNull();
} else if (value instanceof String) {
String text = (String) value;
if (text.length() > 100) {
out.writeString(text.substring(0, 97) + "...");
out.writeString(text);
} else if (value instanceof Number) {
out.writeObject(value);
} else if (value instanceof java.util.Date) {
out.writeObject(value);
} else if (value instanceof Boolean) {
out.writeObject(value);
} else if (value instanceof InputStream) {
out.writeString("<InputStream>");
} else if (value instanceof NClob) {
out.writeString("<NClob>");
} else if (value instanceof Clob) {
out.writeString("<Clob>");
} else if (value instanceof Blob) {
out.writeString("<Blob>");
out.writeString('<' + value.getClass().getName() + '>');
out.writeArrayEnd();
return out.toString();
protected void resultSetOpenAfter(ResultSetProxy resultSet) {
JdbcDataSourceStat dataSourceStat = resultSet.getStatementProxy().getConnectionProxy().getDirectDataSource().getDataSourceStat();
dataSourceStat.getResultSetStat().beforeOpen();
resultSet.setConstructNano();
StatFilterContext.getInstance().resultSet_open();
public void resultSet_close(FilterChain chain, ResultSetProxy resultSet) throws SQLException {
long nanos = System.nanoTime() - resultSet.getConstructNano();
int fetchRowCount = resultSet.getFetchRowCount();
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getResultSetStat().afterClose(nanos);
dataSourceStat.getResultSetStat().addFetchRowCount(fetchRowCount);
dataSourceStat.getResultSetStat().incrementCloseCounter();
StatFilterContext.getInstance().addFetchRowCount(fetchRowCount);
String sql = resultSet.getSql();
if (sql != null) {
JdbcSqlStat sqlStat = resultSet.getSqlStat();
if (sqlStat != null && resultSet.getCloseCount() == 0) {
sqlStat.addFetchRowCount(fetchRowCount);
long stmtExecuteNano = resultSet.getStatementProxy().getLastExecuteTimeNano();
sqlStat.addResultSetHoldTimeNano(stmtExecuteNano, nanos);
if (resultSet.getReadStringLength() > 0) {
sqlStat.addStringReadLength(resultSet.getReadStringLength());
if (resultSet.getReadBytesLength() > 0) {
sqlStat.addReadBytesLength(resultSet.getReadBytesLength());
if (resultSet.getOpenInputStreamCount() > 0) {
sqlStat.addInputStreamOpenCount(resultSet.getOpenInputStreamCount());
if (resultSet.getOpenReaderCount() > 0) {
sqlStat.addReaderOpenCount(resultSet.getOpenReaderCount());
chain.resultSet_close(resultSet);
StatFilterContext.getInstance().resultSet_close(nanos);
public JdbcConnectionStat.Entry getConnectionInfo(ConnectionProxy connection) {
JdbcConnectionStat.Entry counter = (JdbcConnectionStat.Entry) connection.getAttributes().get(ATTR_NAME_CONNECTION_STAT);
if (counter == null) {
String dataSourceName = connection.getDirectDataSource().getName();
connection.getAttributes().put(ATTR_NAME_CONNECTION_STAT,
new JdbcConnectionStat.Entry(dataSourceName, connection.getId()));
counter = (JdbcConnectionStat.Entry) connection.getAttributes().get(ATTR_NAME_CONNECTION_STAT);
return counter;
public JdbcSqlStat createSqlStat(StatementProxy statement, String sql) {
DataSourceProxy dataSource = statement.getConnectionProxy().getDirectDataSource();
JdbcDataSourceStat dataSourceStat = dataSource.getDataSourceStat();
JdbcStatContext context = JdbcStatManager.getInstance().getStatContext();
String contextSql = context != null ? context.getSql() : null;
if (contextSql != null && contextSql.length() > 0) {
return dataSourceStat.createSqlStat(contextSql);
String dbType = this.dbType;
if (dbType == null) {
dbType = dataSource.getDbType();
sql = mergeSql(sql, dbType);
return dataSourceStat.createSqlStat(sql);
public static StatFilter getStatFilter(DataSourceProxy dataSource) {
for (Filter filter : dataSource.getProxyFilters()) {
if (filter instanceof StatFilter) {
return (StatFilter) filter;
return null;
public void dataSource_releaseConnection(FilterChain chain, DruidPooledConnection conn) throws SQLException {
chain.dataSource_recycle(conn);
long nanos = System.nanoTime() - conn.getConnectedTimeNano();
long millis = nanos / (1000L * 1000L);
JdbcDataSourceStat dataSourceStat = chain.getDataSource().getDataSourceStat();
dataSourceStat.getConnectionHoldHistogram().record(millis);
StatFilterContext.getInstance().pool_connection_close(nanos);
public DruidPooledConnection dataSource_getConnection(FilterChain chain, DruidDataSource dataSource,
long maxWaitMillis) throws SQLException {
DruidPooledConnection conn = chain.dataSource_connect(dataSource, maxWaitMillis);
if (conn != null) {
conn.setConnectedTimeNano();
StatFilterContext.getInstance().pool_connection_open();
return conn;
public Clob resultSet_getClob(FilterChain chain, ResultSetProxy resultSet, int columnIndex) throws SQLException {
Clob clob = chain.resultSet_getClob(resultSet, columnIndex);
if (clob != null) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), resultSet, (ClobProxy) clob);
return clob;
public Clob resultSet_getClob(FilterChain chain, ResultSetProxy resultSet, String columnLabel) throws SQLException {
Clob clob = chain.resultSet_getClob(resultSet, columnLabel);
if (clob != null) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), resultSet, (ClobProxy) clob);
return clob;
public Blob callableStatement_getBlob(FilterChain chain, CallableStatementProxy statement, int parameterIndex)
throws SQLException {
Blob blob = chain.callableStatement_getBlob(statement, parameterIndex);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, blob);
return blob;
public Blob callableStatement_getBlob(FilterChain chain, CallableStatementProxy statement, String parameterName)
throws SQLException {
Blob blob = chain.callableStatement_getBlob(statement, parameterName);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, blob);
return blob;
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
Blob blob = chain.resultSet_getBlob(result, columnIndex);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, blob);
return blob;
public Blob resultSet_getBlob(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
Blob blob = chain.resultSet_getBlob(result, columnLabel);
if (blob != null) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, blob);
return blob;
public Clob callableStatement_getClob(FilterChain chain, CallableStatementProxy statement, int parameterIndex)
throws SQLException {
Clob clob = chain.callableStatement_getClob(statement, parameterIndex);
if (clob != null) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) clob);
return clob;
public Clob callableStatement_getClob(FilterChain chain, CallableStatementProxy statement, String parameterName)
throws SQLException {
Clob clob = chain.callableStatement_getClob(statement, parameterName);
if (clob != null) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) clob);
return clob;
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
Object obj = chain.resultSet_getObject(result, columnIndex);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
return obj;
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, int columnIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
Object obj = chain.resultSet_getObject(result, columnIndex, map);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
return obj;
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
Object obj = chain.resultSet_getObject(result, columnLabel);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
return obj;
public Object resultSet_getObject(FilterChain chain, ResultSetProxy result, String columnLabel,
java.util.Map<String, Class<?>> map) throws SQLException {
Object obj = chain.resultSet_getObject(result, columnLabel, map);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), result, (Blob) obj);
} else if (obj instanceof String) {
result.addReadStringLength(((String) obj).length());
return obj;
public Object callableStatement_getObject(FilterChain chain, CallableStatementProxy statement, int parameterIndex)
throws SQLException {
Object obj = chain.callableStatement_getObject(statement, parameterIndex);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
return obj;
public Object callableStatement_getObject(FilterChain chain, CallableStatementProxy statement, int parameterIndex,
java.util.Map<String, Class<?>> map) throws SQLException {
Object obj = chain.callableStatement_getObject(statement, parameterIndex, map);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
return obj;
public Object callableStatement_getObject(FilterChain chain, CallableStatementProxy statement, String parameterName)
throws SQLException {
Object obj = chain.callableStatement_getObject(statement, parameterName);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
return obj;
public Object callableStatement_getObject(FilterChain chain, CallableStatementProxy statement,
String parameterName, java.util.Map<String, Class<?>> map)
throws SQLException {
Object obj = chain.callableStatement_getObject(statement, parameterName, map);
if (obj instanceof Clob) {
clobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (ClobProxy) obj);
} else if (obj instanceof Blob) {
blobOpenAfter(chain.getDataSource().getDataSourceStat(), statement, (Blob) obj);
return obj;
private void blobOpenAfter(JdbcDataSourceStat dataSourceStat, ResultSetProxy rs, Blob blob) {
blobOpenAfter(dataSourceStat, rs.getStatementProxy(), blob);
private void clobOpenAfter(JdbcDataSourceStat dataSourceStat, ResultSetProxy rs, ClobProxy clob) {
clobOpenAfter(dataSourceStat, rs.getStatementProxy(), clob);
private void blobOpenAfter(JdbcDataSourceStat dataSourceStat, StatementProxy stmt, Blob blob) {
dataSourceStat.incrementBlobOpenCount();
if (stmt != null) {
JdbcSqlStat sqlStat = stmt.getSqlStat();
if (sqlStat != null) {
sqlStat.incrementBlobOpenCount();
StatFilterContext.getInstance().blob_open();
private void clobOpenAfter(JdbcDataSourceStat dataSourceStat, StatementProxy stmt, ClobProxy clob) {
dataSourceStat.incrementClobOpenCount();
if (stmt != null) {
JdbcSqlStat sqlStat = stmt.getSqlStat();
if (sqlStat != null) {
sqlStat.incrementClobOpenCount();
StatFilterContext.getInstance().clob_open();
public String resultSet_getString(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
String value = chain.resultSet_getString(result, columnIndex);
if (value != null) {
result.addReadStringLength(value.length());
return value;
public String resultSet_getString(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
String value = chain.resultSet_getString(result, columnLabel);
if (value != null) {
result.addReadStringLength(value.length());
return value;
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, int columnIndex) throws SQLException {
byte[] value = chain.resultSet_getBytes(result, columnIndex);
if (value != null) {
result.addReadBytesLength(value.length);
return value;
public byte[] resultSet_getBytes(FilterChain chain, ResultSetProxy result, String columnLabel) throws SQLException {
byte[] value = chain.resultSet_getBytes(result, columnLabel);
if (value != null) {
result.addReadBytesLength(value.length);
return value;
public InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
InputStream input = chain.resultSet_getBinaryStream(result, columnIndex);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
public InputStream resultSet_getBinaryStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
InputStream input = chain.resultSet_getBinaryStream(result, columnLabel);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
public InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
InputStream input = chain.resultSet_getAsciiStream(result, columnIndex);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
public InputStream resultSet_getAsciiStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
InputStream input = chain.resultSet_getAsciiStream(result, columnLabel);
if (input != null) {
result.incrementOpenInputStreamCount();
return input;
public Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, int columnIndex)
throws SQLException {
Reader reader = chain.resultSet_getCharacterStream(result, columnIndex);
if (reader != null) {
result.incrementOpenReaderCount();
return reader;
public Reader resultSet_getCharacterStream(FilterChain chain, ResultSetProxy result, String columnLabel)
throws SQLException {
Reader reader = chain.resultSet_getCharacterStream(result, columnLabel);
if (reader != null) {
result.incrementOpenReaderCount();
return reader;
public class PreparedStatementProxyImpl extends StatementProxyImpl implements PreparedStatementProxy {
protected final PreparedStatement statement;
protected final String            sql;
private JdbcParameter[]           parameters     = new JdbcParameter[16];
private int                       parametersSize = 0;
public PreparedStatementProxyImpl(ConnectionProxy connection, PreparedStatement statement, String sql, long id){
super(connection, statement, id);
this.statement = statement;
this.sql = sql;
public Map<Integer, JdbcParameter> getParameters() {
return null;
void setParameter(int jdbcIndex, JdbcParameter parameter) {
int index = jdbcIndex - 1;
if (jdbcIndex > parametersSize) {
parametersSize = jdbcIndex;
if (parametersSize >= parameters.length) {
parameters = Arrays.copyOf(parameters, parametersSize + 1);
parameters[index] = parameter;
public int getParametersSize() {
return parametersSize;
public JdbcParameter getParameter(int i) {
if (i > parametersSize) {
return null;
return this.parameters[i];
public String getSql() {
return this.sql;
public PreparedStatement getRawObject() {
return this.statement;
public void addBatch() throws SQLException {
createChain().preparedStatement_addBatch(this);
public void clearParameters() throws SQLException {
createChain().preparedStatement_clearParameters(this);
public String getBatchSql() {
return this.sql;
public boolean execute() throws SQLException {
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.Execute;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
firstResultSet = createChain().preparedStatement_execute(this);
return firstResultSet;
public ResultSet executeQuery() throws SQLException {
firstResultSet = true;
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteQuery;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
return createChain().preparedStatement_executeQuery(this);
public int executeUpdate() throws SQLException {
firstResultSet = false;
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteUpdate;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
updateCount = createChain().preparedStatement_executeUpdate(this);
return updateCount;
public ResultSetMetaData getMetaData() throws SQLException {
return createChain().preparedStatement_getMetaData(this);
public ParameterMetaData getParameterMetaData() throws SQLException {
return createChain().preparedStatement_getParameterMetaData(this);
public void setArray(int parameterIndex, Array x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.ARRAY, x));
createChain().preparedStatement_setArray(this, parameterIndex, x);
public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x));
createChain().preparedStatement_setAsciiStream(this, parameterIndex, x);
public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
createChain().preparedStatement_setAsciiStream(this, parameterIndex, x, length);
public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
createChain().preparedStatement_setAsciiStream(this, parameterIndex, x, length);
public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DECIMAL, x));
createChain().preparedStatement_setBigDecimal(this, parameterIndex, x);
public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x));
createChain().preparedStatement_setBinaryStream(this, parameterIndex, x);
public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
createChain().preparedStatement_setBinaryStream(this, parameterIndex, x, length);
public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
createChain().preparedStatement_setBinaryStream(this, parameterIndex, x, length);
public void setBlob(int parameterIndex, Blob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
createChain().preparedStatement_setBlob(this, parameterIndex, x);
public void setBlob(int parameterIndex, InputStream x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
createChain().preparedStatement_setBlob(this, parameterIndex, x);
public void setBlob(int parameterIndex, InputStream x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x, length));
createChain().preparedStatement_setBlob(this, parameterIndex, x, length);
public void setBoolean(int parameterIndex, boolean x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BOOLEAN, x));
createChain().preparedStatement_setBoolean(this, parameterIndex, x);
public void setByte(int parameterIndex, byte x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TINYINT, x));
createChain().preparedStatement_setByte(this, parameterIndex, x);
public void setBytes(int parameterIndex, byte[] x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.BYTES, x));
createChain().preparedStatement_setBytes(this, parameterIndex, x);
public void setCharacterStream(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x));
createChain().preparedStatement_setCharacterStream(this, parameterIndex, x);
public void setCharacterStream(int parameterIndex, Reader x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
createChain().preparedStatement_setCharacterStream(this, parameterIndex, x, length);
public void setCharacterStream(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.CharacterInputStream, x, length));
createChain().preparedStatement_setCharacterStream(this, parameterIndex, x, length);
public void setClob(int parameterIndex, Clob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
createChain().preparedStatement_setClob(this, parameterIndex, x);
public void setClob(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
createChain().preparedStatement_setClob(this, parameterIndex, x);
public void setClob(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x, length));
createChain().preparedStatement_setClob(this, parameterIndex, x, length);
public void setDate(int parameterIndex, Date x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x));
createChain().preparedStatement_setDate(this, parameterIndex, x);
public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x, cal));
createChain().preparedStatement_setDate(this, parameterIndex, x, cal);
public void setDouble(int parameterIndex, double x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.DOUBLE, x));
createChain().preparedStatement_setDouble(this, parameterIndex, x);
public void setFloat(int parameterIndex, float x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.FLOAT, x));
createChain().preparedStatement_setFloat(this, parameterIndex, x);
public void setInt(int parameterIndex, int x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.INTEGER, x));
createChain().preparedStatement_setInt(this, parameterIndex, x);
public void setLong(int parameterIndex, long x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.BIGINT, x));
createChain().preparedStatement_setLong(this, parameterIndex, x);
public void setNCharacterStream(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x));
createChain().preparedStatement_setNCharacterStream(this, parameterIndex, x);
public void setNCharacterStream(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.NCharacterInputStream, x, length));
createChain().preparedStatement_setNCharacterStream(this, parameterIndex, x, length);
public void setNClob(int parameterIndex, NClob x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
createChain().preparedStatement_setNClob(this, parameterIndex, x);
public void setNClob(int parameterIndex, Reader x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
createChain().preparedStatement_setNClob(this, parameterIndex, x);
public void setNClob(int parameterIndex, Reader x, long length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x, length));
createChain().preparedStatement_setNClob(this, parameterIndex, x, length);
public void setNString(int parameterIndex, String x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.NVARCHAR, x));
createChain().preparedStatement_setNString(this, parameterIndex, x);
public void setNull(int parameterIndex, int sqlType) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
createChain().preparedStatement_setNull(this, parameterIndex, sqlType);
public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(sqlType, null));
createChain().preparedStatement_setNull(this, parameterIndex, sqlType, typeName);
public void setObject(int parameterIndex, Object x) throws SQLException {
setObjectParameter(parameterIndex, x);
createChain().preparedStatement_setObject(this, parameterIndex, x);
private void setObjectParameter(int parameterIndex, Object x) {
if (x == null) {
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
Class<?> clazz = x.getClass();
if (clazz == Byte.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TINYINT, x));
if (clazz == Short.class) {
setParameter(parameterIndex, new JdbcParameter(Types.SMALLINT, x));
if (clazz == Integer.class) {
setParameter(parameterIndex, new JdbcParameter(Types.INTEGER, x));
if (clazz == Long.class) {
setParameter(parameterIndex, new JdbcParameter(Types.BIGINT, x));
if (clazz == String.class) {
setParameter(parameterIndex, new JdbcParameter(Types.VARCHAR, x));
if (clazz == BigDecimal.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DECIMAL, x));
if (clazz == Float.class) {
setParameter(parameterIndex, new JdbcParameter(Types.FLOAT, x));
if (clazz == Double.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DOUBLE, x));
if (clazz == java.sql.Date.class || clazz == java.util.Date.class) {
setParameter(parameterIndex, new JdbcParameter(Types.DATE, x));
if (clazz == java.sql.Timestamp.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
if (clazz == java.sql.Time.class) {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x));
if (clazz == Boolean.class) {
setParameter(parameterIndex, new JdbcParameter(Types.BOOLEAN, x));
if (clazz == byte[].class) {
setParameter(parameterIndex, new JdbcParameter(TYPE.BYTES, x));
if (x instanceof InputStream) {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.BinaryInputStream, x));
if (x instanceof Reader) {
setParameter(parameterIndex, new JdbcParameter(JdbcParameter.TYPE.CharacterInputStream, x));
if (x instanceof Clob) {
setParameter(parameterIndex, new JdbcParameter(Types.CLOB, x));
if (x instanceof NClob) {
setParameter(parameterIndex, new JdbcParameter(Types.NCLOB, x));
if (x instanceof Blob) {
setParameter(parameterIndex, new JdbcParameter(Types.BLOB, x));
setParameter(parameterIndex, new JdbcParameter(Types.OTHER, null));
public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x));
createChain().preparedStatement_setObject(this, parameterIndex, x, targetSqlType);
public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(targetSqlType, x, -1, null, scaleOrLength));
createChain().preparedStatement_setObject(this, parameterIndex, x, targetSqlType, scaleOrLength);
public void setRef(int parameterIndex, Ref x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.REF, x));
createChain().preparedStatement_setRef(this, parameterIndex, x);
public void setRowId(int parameterIndex, RowId x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.ROWID, x));
createChain().preparedStatement_setRowId(this, parameterIndex, x);
public void setSQLXML(int parameterIndex, SQLXML x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.SQLXML, x));
createChain().preparedStatement_setSQLXML(this, parameterIndex, x);
public void setShort(int parameterIndex, short x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.SMALLINT, x));
createChain().preparedStatement_setShort(this, parameterIndex, x);
public void setString(int parameterIndex, String x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.VARCHAR, x));
createChain().preparedStatement_setString(this, parameterIndex, x);
public void setTime(int parameterIndex, Time x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x));
createChain().preparedStatement_setTime(this, parameterIndex, x);
public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIME, x, cal));
createChain().preparedStatement_setTime(this, parameterIndex, x, cal);
public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
createChain().preparedStatement_setTimestamp(this, parameterIndex, x);
public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(Types.TIMESTAMP, x));
createChain().preparedStatement_setTimestamp(this, parameterIndex, x, cal);
public void setURL(int parameterIndex, URL x) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.URL, x));
createChain().preparedStatement_setURL(this, parameterIndex, x);
public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
setParameter(parameterIndex, new JdbcParameter(TYPE.UnicodeStream, x, length));
createChain().preparedStatement_setUnicodeStream(this, parameterIndex, x, length);
public String getLastExecuteSql() {
return this.sql;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == PreparedStatementProxy.class) {
return (T) this;
return super.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == PreparedStatementProxy.class) {
return true;
return super.isWrapperFor(iface);
public interface StatementProxy extends Statement, WrapperProxy {
ConnectionProxy getConnectionProxy();
Statement getRawObject();
List<String> getBatchSqlList();
String getBatchSql();
JdbcSqlStat getSqlStat();
StatementExecuteType getLastExecuteType();
void setSqlStat(JdbcSqlStat sqlStat);
String getLastExecuteSql();
long getLastExecuteStartNano();
void setLastExecuteStartNano(long lastExecuteStartNano);
void setLastExecuteStartNano();
long getLastExecuteTimeNano();
void setLastExecuteTimeNano(long nano);
void setLastExecuteTimeNano();
Map<Integer, JdbcParameter> getParameters();
int getParametersSize();
JdbcParameter getParameter(int i);
boolean isFirstResultSet();
public class StatementProxyImpl extends WrapperProxyImpl implements StatementProxy {
private final ConnectionProxy  connection;
private final Statement        statement;
protected String               lastExecuteSql;
protected long                 lastExecuteStartNano;
protected long                 lastExecuteTimeNano;
protected JdbcSqlStat          sqlStat;
protected boolean              firstResultSet;
protected ArrayList<String>    batchSqlList;
protected StatementExecuteType lastExecuteType;
protected Integer              updateCount = null;
private FilterChainImpl        filterChain = null;
public StatementProxyImpl(ConnectionProxy connection, Statement statement, long id){
super(statement, id);
this.connection = connection;
this.statement = statement;
public ConnectionProxy getConnectionProxy() {
return connection;
public Statement getRawObject() {
return this.statement;
public FilterChainImpl createChain() {
FilterChainImpl chain = this.filterChain;
if (chain == null) {
chain = new FilterChainImpl(this.getConnectionProxy().getDirectDataSource());
this.filterChain = null;
return chain;
public void recycleFilterChain(FilterChainImpl chain) {
chain.reset();
this.filterChain = chain;
public void addBatch(String sql) throws SQLException {
if (batchSqlList == null) {
batchSqlList = new ArrayList<String>();
createChain().statement_addBatch(this, sql);
batchSqlList.add(sql);
public void cancel() throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_cancel(this);
recycleFilterChain(chain);
public void clearBatch() throws SQLException {
if (batchSqlList == null) {
batchSqlList = new ArrayList<String>();
FilterChainImpl chain = createChain();
chain.statement_clearBatch(this);
recycleFilterChain(chain);
batchSqlList.clear();
public void clearWarnings() throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_clearWarnings(this);
recycleFilterChain(chain);
public void close() throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_close(this);
recycleFilterChain(chain);
public boolean execute(String sql) throws SQLException {
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.Execute;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql);
recycleFilterChain(chain);
return firstResultSet;
public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.Execute;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, autoGeneratedKeys);
recycleFilterChain(chain);
return firstResultSet;
public boolean execute(String sql, int[] columnIndexes) throws SQLException {
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.Execute;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, columnIndexes);
recycleFilterChain(chain);
return firstResultSet;
public boolean execute(String sql, String[] columnNames) throws SQLException {
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.Execute;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
firstResultSet = chain.statement_execute(this, sql, columnNames);
recycleFilterChain(chain);
return firstResultSet;
public int[] executeBatch() throws SQLException {
firstResultSet = false;
lastExecuteType = StatementExecuteType.ExecuteBatch;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
int[] updateCounts = chain.statement_executeBatch(this);
recycleFilterChain(chain);
if (updateCounts != null && updateCounts.length == 1) {
updateCount = updateCounts[0];
return updateCounts;
public ResultSet executeQuery(String sql) throws SQLException {
firstResultSet = true;
updateCount = null;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteQuery;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
ResultSet resultSet = chain.statement_executeQuery(this, sql);
recycleFilterChain(chain);
return resultSet;
public int executeUpdate(String sql) throws SQLException {
firstResultSet = false;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteUpdate;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql);
recycleFilterChain(chain);
return updateCount;
public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
firstResultSet = false;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteUpdate;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, autoGeneratedKeys);
recycleFilterChain(chain);
return updateCount;
public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
firstResultSet = false;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteUpdate;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, columnIndexes);
recycleFilterChain(chain);
return updateCount;
public int executeUpdate(String sql, String[] columnNames) throws SQLException {
firstResultSet = false;
lastExecuteSql = sql;
lastExecuteType = StatementExecuteType.ExecuteUpdate;
lastExecuteStartNano = -1L;
lastExecuteTimeNano = -1L;
FilterChainImpl chain = createChain();
updateCount = chain.statement_executeUpdate(this, sql, columnNames);
recycleFilterChain(chain);
return updateCount;
public Connection getConnection() throws SQLException {
FilterChainImpl chain = createChain();
Connection conn = chain.statement_getConnection(this);
recycleFilterChain(chain);
return conn;
public int getFetchDirection() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getFetchDirection(this);
recycleFilterChain(chain);
return value;
public int getFetchSize() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getFetchSize(this);
recycleFilterChain(chain);
return value;
public ResultSet getGeneratedKeys() throws SQLException {
FilterChainImpl chain = createChain();
ResultSet value = chain.statement_getGeneratedKeys(this);
recycleFilterChain(chain);
return value;
public int getMaxFieldSize() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getMaxFieldSize(this);
recycleFilterChain(chain);
return value;
public int getMaxRows() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getMaxRows(this);
recycleFilterChain(chain);
return value;
public boolean getMoreResults() throws SQLException {
updateCount = null;
FilterChainImpl chain = createChain();
boolean value = chain.statement_getMoreResults(this);
recycleFilterChain(chain);
return value;
public boolean getMoreResults(int current) throws SQLException {
updateCount = null;
FilterChainImpl chain = createChain();
boolean value = chain.statement_getMoreResults(this, current);
recycleFilterChain(chain);
return value;
public int getQueryTimeout() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getQueryTimeout(this);
recycleFilterChain(chain);
return value;
public ResultSet getResultSet() throws SQLException {
FilterChainImpl chain = createChain();
ResultSet value = chain.statement_getResultSet(this);
recycleFilterChain(chain);
return value;
public int getResultSetConcurrency() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetConcurrency(this);
recycleFilterChain(chain);
return value;
public int getResultSetHoldability() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetHoldability(this);
recycleFilterChain(chain);
return value;
public int getResultSetType() throws SQLException {
FilterChainImpl chain = createChain();
int value = chain.statement_getResultSetType(this);
recycleFilterChain(chain);
return value;
public int getUpdateCount() throws SQLException {
if (updateCount == null) {
FilterChainImpl chain = createChain();
updateCount = chain.statement_getUpdateCount(this);
recycleFilterChain(chain);
return updateCount;
public SQLWarning getWarnings() throws SQLException {
FilterChainImpl chain = createChain();
SQLWarning value = chain.statement_getWarnings(this);
recycleFilterChain(chain);
return value;
public boolean isClosed() throws SQLException {
FilterChainImpl chain = createChain();
boolean value = chain.statement_isClosed(this);
recycleFilterChain(chain);
return value;
public boolean isPoolable() throws SQLException {
FilterChainImpl chain = createChain();
boolean value = chain.statement_isPoolable(this);
recycleFilterChain(chain);
return value;
public void setCursorName(String name) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setCursorName(this, name);
recycleFilterChain(chain);
public void setEscapeProcessing(boolean enable) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setEscapeProcessing(this, enable);
recycleFilterChain(chain);
public void setFetchDirection(int direction) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setFetchDirection(this, direction);
recycleFilterChain(chain);
public void setFetchSize(int rows) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setFetchSize(this, rows);
recycleFilterChain(chain);
public void setMaxFieldSize(int max) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setMaxFieldSize(this, max);
recycleFilterChain(chain);
public void setMaxRows(int max) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setMaxRows(this, max);
recycleFilterChain(chain);
public void setPoolable(boolean poolable) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setPoolable(this, poolable);
recycleFilterChain(chain);
public void setQueryTimeout(int seconds) throws SQLException {
FilterChainImpl chain = createChain();
chain.statement_setQueryTimeout(this, seconds);
recycleFilterChain(chain);
public List<String> getBatchSqlList() {
if (batchSqlList == null) {
batchSqlList = new ArrayList<String>();
return batchSqlList;
public String getBatchSql() {
List<String> sqlList = getBatchSqlList();
StringBuffer buf = new StringBuffer();
for (String item : sqlList) {
if (buf.length() > 0) {
buf.append("n;n");
buf.append(item);
return buf.toString();
public String getLastExecuteSql() {
return lastExecuteSql;
public void closeOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public boolean isCloseOnCompletion() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Map<Integer, JdbcParameter> getParameters() {
return Collections.emptyMap();
public JdbcSqlStat getSqlStat() {
return sqlStat;
public void setSqlStat(JdbcSqlStat sqlStat) {
this.sqlStat = sqlStat;
public long getLastExecuteTimeNano() {
return lastExecuteTimeNano;
public void setLastExecuteTimeNano(long lastExecuteTimeNano) {
this.lastExecuteTimeNano = lastExecuteTimeNano;
public void setLastExecuteTimeNano() {
if (this.lastExecuteTimeNano <= 0 && this.lastExecuteStartNano > 0) {
this.lastExecuteTimeNano = System.nanoTime() - this.lastExecuteStartNano;
public long getLastExecuteStartNano() {
return lastExecuteStartNano;
public void setLastExecuteStartNano(long lastExecuteStartNano) {
this.lastExecuteStartNano = lastExecuteStartNano;
this.lastExecuteTimeNano = -1L;
public void setLastExecuteStartNano() {
if (lastExecuteStartNano <= 0) {
setLastExecuteStartNano(System.nanoTime());
public StatementExecuteType getLastExecuteType() {
return lastExecuteType;
public boolean isFirstResultSet() {
return firstResultSet;
@SuppressWarnings("unchecked")
public <T> T unwrap(Class<T> iface) throws SQLException {
if (iface == StatementProxy.class) {
return (T) this;
return super.unwrap(iface);
public boolean isWrapperFor(Class<?> iface) throws SQLException {
if (iface == StatementProxy.class) {
return true;
return super.isWrapperFor(iface);
public int getParametersSize() {
public JdbcParameter getParameter(int i) {
return null;
Assert.assertEquals(Types.TINYINT, stmtProxy.getParameter(0).getSqlType());
Assert.assertEquals(Types.SMALLINT, stmtProxy.getParameter(1).getSqlType());
Assert.assertEquals(Types.INTEGER, stmtProxy.getParameter(2).getSqlType());
Assert.assertEquals(Types.BIGINT, stmtProxy.getParameter(3).getSqlType());
Assert.assertEquals(Types.FLOAT, stmtProxy.getParameter(4).getSqlType());
Assert.assertEquals(Types.DOUBLE, stmtProxy.getParameter(5).getSqlType());
Assert.assertEquals(Types.DECIMAL, stmtProxy.getParameter(6).getSqlType());
Assert.assertEquals(Types.BOOLEAN, stmtProxy.getParameter(7).getSqlType());
Assert.assertEquals(Types.VARCHAR, stmtProxy.getParameter(8).getSqlType());
Assert.assertEquals(Types.DATE, stmtProxy.getParameter(9).getSqlType());
Assert.assertEquals(Types.DATE, stmtProxy.getParameter(10).getSqlType());
Assert.assertEquals(Types.TIMESTAMP, stmtProxy.getParameter(11).getSqlType());
Assert.assertEquals(Types.TIME, stmtProxy.getParameter(12).getSqlType());
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT user_name() FROM X;"));
return castToString(a).compareTo(castToString(b)) > 0;
int start = strValue.length() - intValue;
if (start < 0) {
start = 0;
String result = strValue.substring(start, strValue.length());
setLeft(left);
setRight(right);
if (valueExpr != null) {
valueExpr.setParent(this);
if (elseExpr != null) {
elseExpr.setParent(this);
public void addItem(Item item) {
if (item != null) {
item.setParent(this);
this.items.add(item);
setConditionExpr(conditionExpr);
setValueExpr(valueExpr);
if (conditionExpr != null) {
conditionExpr.setParent(this);
if (valueExpr != null) {
valueExpr.setParent(this);
caseExpr.addItem(caseItem);
if (itemValue == EVAL_VALUE_NULL) {
} else if (itemValue == null) {
return null;
leftValue = processValue(leftValue);
rightValue = processValue(rightValue);
@SuppressWarnings("rawtypes")
private static Object processValue(Object value) {
if (value instanceof List) {
List list = (List) value;
if (list.size() == 1) {
return processValue(list.get(0));
return value;
public class MergeStatFilterTest_tddl_3 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
TabularData sqlList = JdbcStatManager.getInstance().getSqlList();
if (sqlList.size() > 0) {
for (Object item : JdbcStatManager.getInstance().getSqlList().values()) {
String text = JSONUtils.toJSONString(item);
System.out.println(text);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("mergeStat");
dataSource.setDbType("mysql");
dataSource.setConnectionProperties("druid.useGloalDataSourceStat");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
public void test_merge() throws Exception {
for (int i = 1000; i < 2000; ++i) {
String tableName = "t_" + i;
Connection conn = dataSource.getConnection();
String sql = "update " + tableName + " SET a = ? WHERE b = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "aaa");
stmt.setInt(1, 2);
stmt.execute();
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getDataSourceStat().getSqlStatMap().size());
public class MergeStatFilterTest_tddl_4 extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
TabularData sqlList = JdbcStatManager.getInstance().getSqlList();
if (sqlList.size() > 0) {
for (Object item : JdbcStatManager.getInstance().getSqlList().values()) {
String text = JSONUtils.toJSONString(item);
System.out.println(text);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xx");
dataSource.setFilters("mergeStat");
dataSource.setDbType("mysql");
dataSource.setConnectionProperties("druid.useGloalDataSourceStat");
dataSource.setPoolPreparedStatements(true);
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
public void test_merge() throws Exception {
for (int i = 1000; i < 2000; ++i) {
String tableName = "t_" + i;
Connection conn = dataSource.getConnection();
String sql = "update " + tableName + " SET a = ? WHERE b = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, "aaa");
stmt.setInt(1, 2);
stmt.execute();
stmt.close();
conn.close();
Assert.assertEquals(1, dataSource.getDataSourceStat().getSqlStatMap().size());
@SuppressWarnings("deprecation")
setParameter(parameterIndex, createParameter(Types.ARRAY, x));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.AsciiInputStream, x));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.AsciiInputStream, x, length));
setParameter(parameterIndex, createParameter(x));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.BinaryInputStream, x));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
setParameter(parameterIndex, createParameter(JdbcParameter.TYPE.BinaryInputStream, x, length));
setParameter(parameterIndex, createParameter(Types.BLOB, x));
setParameter(parameterIndex, createParameter(Types.BLOB, x));
setParameter(parameterIndex, createParameter(Types.BLOB, x, length));
setParameter(parameterIndex, createParameter(Types.BOOLEAN, x));
setParameter(parameterIndex, createParameter(Types.TINYINT, x));
setParameter(parameterIndex, createParameter(TYPE.BYTES, x));
setParameter(parameterIndex, createParameter(TYPE.CharacterInputStream, x));
setParameter(parameterIndex, createParameter(TYPE.CharacterInputStream, x, length));
setParameter(parameterIndex, createParameter(TYPE.CharacterInputStream, x, length));
setParameter(parameterIndex, createParameter(Types.CLOB, x));
setParameter(parameterIndex, createParameter(Types.CLOB, x));
setParameter(parameterIndex, createParameter(Types.CLOB, x, length));
setParameter(parameterIndex, createParameter(x));
setParameter(parameterIndex, createParameter(Types.DATE, x, cal));
setParameter(parameterIndex, createParameter(Types.DOUBLE, x));
setParameter(parameterIndex, createParameter(Types.FLOAT, x));
setParameter(parameterIndex, createParemeter(x));
setParameter(parameterIndex, createParameter(x));
setParameter(parameterIndex, createParameter(TYPE.NCharacterInputStream, x));
setParameter(parameterIndex, createParameter(TYPE.NCharacterInputStream, x, length));
setParameter(parameterIndex, createParameter(Types.NCLOB, x));
setParameter(parameterIndex, createParameter(Types.NCLOB, x));
setParameter(parameterIndex, createParameter(Types.NCLOB, x, length));
setParameter(parameterIndex, createParameter(Types.NVARCHAR, x));
setParameter(parameterIndex, createParameterNull(sqlType));
setParameter(parameterIndex, createParameterNull(sqlType));
setParameter(parameterIndex, createParameterNull(Types.OTHER));
setParameter(parameterIndex, createParameter(Types.TINYINT, x));
setParameter(parameterIndex, createParameter(Types.SMALLINT, x));
setParameter(parameterIndex, createParemeter((Integer) x));
setParameter(parameterIndex, createParameter((Long) x));
setParameter(parameterIndex, createParameter((String) x));
setParameter(parameterIndex, createParameter((BigDecimal) x));
setParameter(parameterIndex, createParameter((java.util.Date) x));
setParameter(parameterIndex, createParameter((java.sql.Timestamp) x));
setParameter(parameterIndex, createParameter(Types.OTHER, null));
setParameter(parameterIndex, createParameter(targetSqlType, x));
setParameter(parameterIndex, createParameter(x, targetSqlType, scaleOrLength));
setParameter(parameterIndex, createParameter(Types.REF, x));
setParameter(parameterIndex, createParameter(Types.ROWID, x));
setParameter(parameterIndex, createParameter(Types.SQLXML, x));
setParameter(parameterIndex, createParameter(Types.SMALLINT, x));
setParameter(parameterIndex, createParameter(x));
setParameter(parameterIndex, createParameter(Types.TIME, x));
setParameter(parameterIndex, createParameter(Types.TIME, x, cal));
setParameter(parameterIndex, createParameter(x));
setParameter(parameterIndex, createParameter(Types.TIMESTAMP, x));
setParameter(parameterIndex, createParameter(TYPE.URL, x));
setParameter(parameterIndex, createParameter(TYPE.UnicodeStream, x, length));
private JdbcParameter createParemeter(int x) {
return new JdbcParameterInt(x);
private JdbcParameter createParameter(long x) {
return new JdbcParameterLong(x);
private JdbcParameter createParameterNull(int sqlType) {
return new JdbcParameterNull(sqlType);
private JdbcParameter createParameter(java.util.Date x) {
return new JdbcParameterDate(x);
private JdbcParameter createParameter(BigDecimal x) {
return new JdbcParameterDecimal(x);
private JdbcParameter createParameter(String x) {
return new JdbcParameterString(x);
private JdbcParameter createParameter(Timestamp x) {
return new JdbcParameterTimestamp(x);
private JdbcParameter createParameter(Object x, int targetSqlType, int scaleOrLength) {
return new JdbcParameterImpl(targetSqlType, x, -1, null, scaleOrLength);
private JdbcParameter createParameter(int sqlType, Object value, long length) {
return new JdbcParameterImpl(sqlType, value, length);
private JdbcParameter createParameter(int sqlType, Object value) {
return new JdbcParameterImpl(sqlType, value);
public JdbcParameter createParameter(int sqlType, Object value, Calendar calendar) {
return new JdbcParameterImpl(sqlType, value, calendar);
parameters = Arrays.copyOf(parameters, parametersSize + 4);
parameters = Arrays.copyOf(parameters, parametersSize + 16);
public final class JdbcParameterDate implements JdbcParameter {
public final class JdbcParameterDecimal implements JdbcParameter {
public final class JdbcParameterImpl implements JdbcParameter {
public final class JdbcParameterInt implements JdbcParameter {
public final class JdbcParameterLong implements JdbcParameter {
public final class JdbcParameterNull implements JdbcParameter {
public final class JdbcParameterString implements JdbcParameter {
public final class JdbcParameterTimestamp implements JdbcParameter {
private final Timestamp value;
public JdbcParameterTimestamp(Timestamp value){
statement = new CallableStatementProxyImpl(new ConnectionProxyImpl(null, null, null, 0), mockStmt, "", 1);
Clob clob = (Clob) chain.callableStatement_getObject(statement, 1, Collections.<String, Class<?>> emptyMap());
Clob clob = (Clob) chain.callableStatement_getObject(statement, "1", Collections.<String, Class<?>> emptyMap());
statement = new CallableStatementProxyImpl(new ConnectionProxyImpl(null, null, null, 0), mockStmt, "", 1);
public class CallableStatementProxyImplTest extends TestCase {
protected void tearDown() throws Exception {
DruidDriver.getProxyDataSources().clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getSqlList().size());
public void test_call() throws Exception {
DataSourceProxyConfig config = new DataSourceProxyConfig();
DataSourceProxy dataSource = new DataSourceProxyImpl(null, config);
FilterEventAdapter filter = new FilterEventAdapter() {
filter.init(dataSource);
config.getFilters().add(filter);
String sql = "CALL P_0(?, ?)";
CallableStatementProxyImpl rawCallStatement = new FakeCallableStatement(new ConnectionProxyImpl(null, null, null, 0), null, sql, 1001);
ConnectionProxy connection = new ConnectionProxyImpl(dataSource, null, new Properties(), 1001);
CallableStatementProxyImpl cstmt = new CallableStatementProxyImpl(connection, rawCallStatement, sql, 2001);
cstmt.registerOutParameter(1, Types.VARCHAR);
cstmt.registerOutParameter(1, Types.VARCHAR, "VARCHAR");
cstmt.registerOutParameter(1, Types.VARCHAR, 3);
cstmt.registerOutParameter("1", Types.VARCHAR);
cstmt.registerOutParameter("1", Types.VARCHAR, "VARCHAR");
cstmt.registerOutParameter("1", Types.VARCHAR, 3);
cstmt.setBoolean("1", true);
cstmt.setByte("1", (byte) 0);
cstmt.setShort("1", (short) 0);
cstmt.setInt("1", 0);
cstmt.setLong("1", 0);
cstmt.setFloat("1", 0);
cstmt.setDouble("1", 0);
cstmt.setBigDecimal("1", new BigDecimal("111"));
cstmt.setString("1", "X");
cstmt.setURL("1", null);
cstmt.setSQLXML("1", null);
cstmt.setBytes("1", null);
cstmt.setDate("1", null);
cstmt.setDate("1", null, Calendar.getInstance());
cstmt.setTime("1", null);
cstmt.setTime("1", null, Calendar.getInstance());
cstmt.setTimestamp("1", null);
cstmt.setTimestamp("1", null, Calendar.getInstance());
cstmt.setAsciiStream("1", null);
cstmt.setAsciiStream("1", null, 0);
cstmt.setAsciiStream("1", null, 0L);
cstmt.setBinaryStream("1", null);
cstmt.setBinaryStream("1", null, 0);
cstmt.setBinaryStream("1", null, 0L);
cstmt.setObject("1", null);
cstmt.setObject("1", null, Types.VARCHAR);
cstmt.setObject("1", null, Types.VARCHAR, 3);
cstmt.setCharacterStream("1", null);
cstmt.setCharacterStream("1", null, 0);
cstmt.setCharacterStream("1", null, 0L);
cstmt.setNull("1", Types.VARCHAR);
cstmt.setNull("1", Types.VARCHAR, "VARCHAR");
cstmt.setRowId("1", null);
cstmt.setNString("1", null);
cstmt.setNCharacterStream("1", null);
cstmt.setNCharacterStream("1", null, 0);
cstmt.setNClob("1", (NClob) null);
cstmt.setNClob("1", (Reader) null);
cstmt.setNClob("1", (Reader) null, 0);
cstmt.setClob("1", (Clob) null);
cstmt.setClob("1", (Reader) null);
cstmt.setClob("1", (Reader) null, 0);
cstmt.setBlob("1", (Blob) null);
cstmt.setBlob("1", (InputStream) null);
cstmt.setBlob("1", (InputStream) null, 0);
cstmt.setURL(1, null);
cstmt.setSQLXML(1, null);
cstmt.setArray(1, null);
cstmt.setNCharacterStream(1, null);
cstmt.setNCharacterStream(1, null, 0);
cstmt.setNClob(1, (NClob) null);
cstmt.setNClob(1, (Reader) null);
cstmt.setNClob(1, (Reader) null, 0);
cstmt.setNString(1, null);
cstmt.setObject(1, null);
cstmt.setRef(1, null);
cstmt.setRowId(1, null);
cstmt.setUnicodeStream(1, null, 0);
cstmt.getClob(1);
cstmt.getClob("1");
cstmt.cancel();
cstmt.getResultSet();
private static final class FakeCallableStatement extends CallableStatementProxyImpl {
private FakeCallableStatement(ConnectionProxy connection, CallableStatement statement, String sql, long id){
super(connection, statement, sql, id);
public ResultSet getResultSet() throws SQLException {
return null;
public void cancel() throws SQLException {
public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {
public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {
public void registerOutParameter(String parameterIndex, int sqlType, String typeName) throws SQLException {
public void registerOutParameter(String parameterIndex, int sqlType) throws SQLException {
public void registerOutParameter(String parameterIndex, int sqlType, int scale) throws SQLException {
public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {
public Clob getClob(int parameterIndex) throws SQLException {
return null;
public void setRowId(int parameterIndex, RowId x) throws SQLException {
public void setRef(int parameterIndex, Ref x) throws SQLException {
public void setObject(int parameterIndex, Object x) throws SQLException {
public void setNString(int parameterIndex, String x) throws SQLException {
public void setNCharacterStream(int parameterIndex, Reader x) throws SQLException {
public void setNCharacterStream(int parameterIndex, Reader x, long length) throws SQLException {
public void setNClob(int parameterIndex, NClob x) throws SQLException {
public void setNClob(int parameterIndex, Reader x) throws SQLException {
public void setNClob(int parameterIndex, Reader x, long length) throws SQLException {
public void setArray(int parameterIndex, Array x) throws SQLException {
public void setURL(int parameterIndex, URL x) throws SQLException {
public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
public java.net.URL getURL(int parameterIndex) throws SQLException {
return null;
public void setSQLXML(int parameterIndex, SQLXML x) throws SQLException {
public void setURL(String parameterName, java.net.URL val) throws SQLException {
public void setNull(String parameterName, int sqlType) throws SQLException {
public void setBoolean(String parameterName, boolean x) throws SQLException {
public void setByte(String parameterName, byte x) throws SQLException {
public void setShort(String parameterName, short x) throws SQLException {
public void setInt(String parameterName, int x) throws SQLException {
public void setLong(String parameterName, long x) throws SQLException {
public void setFloat(String parameterName, float x) throws SQLException {
public void setDouble(String parameterName, double x) throws SQLException {
public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {
public void setString(String parameterName, String x) throws SQLException {
public void setBytes(String parameterName, byte[] x) throws SQLException {
public void setDate(String parameterName, java.sql.Date x) throws SQLException {
public void setTime(String parameterName, java.sql.Time x) throws SQLException {
public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {
public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {
public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {
public void setObject(String parameterName, Object x) throws SQLException {
public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {
public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {
public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {
public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {
public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
public String getString(String parameterName) throws SQLException {
return null;
public boolean getBoolean(String parameterName) throws SQLException {
return true;
public byte getByte(String parameterName) throws SQLException {
public short getShort(String parameterName) throws SQLException {
public int getInt(String parameterName) throws SQLException {
public long getLong(String parameterName) throws SQLException {
public float getFloat(String parameterName) throws SQLException {
public double getDouble(String parameterName) throws SQLException {
public byte[] getBytes(String parameterName) throws SQLException {
return null;
public java.sql.Date getDate(String parameterName) throws SQLException {
return null;
public java.sql.Time getTime(String parameterName) throws SQLException {
return null;
public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {
return null;
public Object getObject(String parameterName) throws SQLException {
return null;
public BigDecimal getBigDecimal(String parameterName) throws SQLException {
return null;
public Object getObject(String parameterName, java.util.Map<String, Class<?>> map) throws SQLException {
return null;
public Ref getRef(String parameterName) throws SQLException {
return null;
public Blob getBlob(String parameterName) throws SQLException {
return null;
public Clob getClob(String parameterName) throws SQLException {
return null;
public Array getArray(String parameterName) throws SQLException {
return null;
public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {
return null;
public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {
return null;
public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {
return null;
public java.net.URL getURL(String parameterName) throws SQLException {
return null;
public RowId getRowId(int parameterIndex) throws SQLException {
return null;
public RowId getRowId(String parameterName) throws SQLException {
return null;
public void setRowId(String parameterName, RowId x) throws SQLException {
public void setNString(String parameterName, String value) throws SQLException {
public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {
public void setNClob(String parameterName, NClob value) throws SQLException {
public void setClob(String parameterName, Reader reader, long length) throws SQLException {
public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
public NClob getNClob(int parameterIndex) throws SQLException {
return null;
public NClob getNClob(String parameterName) throws SQLException {
return null;
public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
public SQLXML getSQLXML(int parameterIndex) throws SQLException {
return null;
public SQLXML getSQLXML(String parameterName) throws SQLException {
return null;
public String getNString(int parameterIndex) throws SQLException {
return null;
public String getNString(String parameterName) throws SQLException {
return null;
public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {
return null;
public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {
return null;
public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {
return null;
public java.io.Reader getCharacterStream(String parameterName) throws SQLException {
return null;
public void setBlob(String parameterName, Blob x) throws SQLException {
public void setClob(String parameterName, Clob x) throws SQLException {
public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {
public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {
public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {
public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {
public void setNCharacterStream(String parameterName, Reader value) throws SQLException {
public void setClob(String parameterName, Reader reader) throws SQLException {
public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
public void setNClob(String parameterName, Reader reader) throws SQLException {
private JdbcParameter createParameter(Object x, int sqlType, int scaleOrLength) {
if (x == null) {
return JdbcParameterNull.valueOf(sqlType);
return new JdbcParameterImpl(sqlType, x, -1, null, scaleOrLength);
if (value == null) {
return JdbcParameterNull.valueOf(sqlType);
if (value == null) {
return JdbcParameterNull.valueOf(sqlType);
if (value == null) {
return JdbcParameterNull.valueOf(sqlType);
if (stmt.isPooled()) {
if (stmt.isPooled() && holder.isPoolPreparedStatements()) {
private boolean pooled = false;
pooled = conn.getConnectionHolder().isPoolPreparedStatements();
if (pooled) {
defaultMaxFieldSize = stmt.getMaxFieldSize();
} catch (SQLException e) {
LOG.error("getMaxFieldSize error", e);
defaultMaxRows = stmt.getMaxRows();
} catch (SQLException e) {
LOG.error("getMaxRows error", e);
defaultQueryTimeout = stmt.getQueryTimeout();
} catch (SQLException e) {
LOG.error("getMaxRows error", e);
defaultFetchDirection = stmt.getFetchDirection();
} catch (SQLException e) {
LOG.error("getFetchDirection error", e);
defaultFetchSize = stmt.getFetchSize();
} catch (SQLException e) {
LOG.error("getFetchSize error", e);
if (pooled && !connectionClosed) {
public boolean isPooled() {
return pooled;
Assert.assertSame(raw, stmt.unwrap(MockPreparedStatement.class));
private DruidDataSource                dataSource = new DruidDataSource();
protected DruidPooledConnection        conn;
protected MockCallableStatement        raw;
MockConnection mockConn = new MockConnection();
DruidConnectionHolder connHolder = new DruidConnectionHolder(dataSource, mockConn);
conn = new DruidPooledConnection(connHolder);
stmt = new DruidPooledCallableStatement(conn, new PreparedStatementHolder(new PreparedStatementKey("", null,
null, 0, 0,
0), raw)) {
protected MockPreparedStatement        raw;
DruidDataSource                dataSource = new DruidDataSource();
MockConnection mockConn = new MockConnection();
DruidConnectionHolder connHolder = new DruidConnectionHolder(dataSource, mockConn);
DruidPooledConnection conn = new DruidPooledConnection(connHolder);
stmt = new DruidPooledPreparedStatement(conn, new PreparedStatementHolder(new PreparedStatementKey("", null,
null, 0, 0,
0), raw)) {
public final static int RevisionVersion = 21;
LOG.error("discard connection", sqlEx);
if (filters != null && filters.startsWith("!")) {
filters = filters.substring(1);
this.clearFilters();
this.addFilters(filters);
public void addFilters(String filters) throws SQLException {
public class ClearFilterTest extends TestCase {
public void test_filters() throws Exception {
DruidDataSource dataSource = new DruidDataSource();
Assert.assertEquals(0, dataSource.getProxyFilters().size());
dataSource.setFilters("encoding");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
dataSource.setFilters("!stat");
Assert.assertEquals(1, dataSource.getProxyFilters().size());
Assert.assertEquals(StatFilter.class.getName(), dataSource.getFilterClassNames().get(0));
dataSource.close();
public class MemTest {
public static void main(String[] args) throws Exception {
String sql = "SELECT UMID, HWID, MAC, GUID, RID , GMT_CREATE, GMT_MODIFIED FROM umid_rid " + 
"WHERE RID = ? " + 
"LIMIT 10";
SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, "mysql");
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
StringBuilder out = new StringBuilder();
SQLASTOutputVisitor visitor = ParameterizedOutputVisitorUtils.createParameterizedOutputVisitor(out, "mysql");
stmt.accept(visitor);
Thread.sleep(1000 * 1000);
public class DruidDataSourceFactoryTest0 extends TestCase {
public void test_factory_null() throws Exception {
DruidDataSourceFactory factory = new DruidDataSourceFactory();
Assert.assertNull(factory.getObjectInstance(null, null, null, null));
public void test_factory_null_1() throws Exception {
DruidDataSourceFactory factory = new DruidDataSourceFactory();
Assert.assertNull(factory.getObjectInstance(new Object(), null, null, null));
public class Slf4jFilterTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setFilters("slf4j");
dataSource.setDbType("mysql");
protected void tearDown() throws Exception {
JdbcUtils.close(dataSource);
public void test_slf4j() throws Exception {
dataSource.init();
Slf4jLogFilter filter = dataSource.unwrap(Slf4jLogFilter.class);
Assert.assertNotNull(filter);
Connection conn = dataSource.getConnection();
conn.close();
public class JtdsXAConnectionTest extends TestCase {
public void test_jtds() throws Exception {
Constructor<JtdsConnection> constrcutor = JtdsConnection.class.getDeclaredConstructor();
constrcutor.setAccessible(true);
JtdsConnection jtdsConn = constrcutor.newInstance();
JtdsXAConnection xaConn = new JtdsXAConnection(jtdsConn);
Assert.assertSame(jtdsConn, xaConn.getConnection());
JtdsXAResource xaResource = (JtdsXAResource) xaConn.getXAResource();
Assert.assertTrue(xaResource.isSameRM(xaResource));
Assert.assertFalse(xaResource.isSameRM(null));
Exception error = null;
xaResource.commit(null, true);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
xaResource.start(null, 0);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
xaResource.end(null, 0);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
xaResource.forget(null);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
xaResource.rollback(null);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
xaResource.recover(0);
Exception error = null;
xaResource.prepare(null);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
xaConn.close();
public class SqlMapSessionWrapperTest extends TestCase {
private ClassPathXmlApplicationContext context = null;
protected void setUp() throws Exception {
context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/ibatis/spring-config-ibatis.xml");
protected void tearDown() throws Exception {
context.close();
@SuppressWarnings("deprecation")
public void test_wrap() throws Exception {
SqlMapClientImpl client = (SqlMapClientImpl) context.getBean("master-sqlMapClient");
Assert.assertNotNull(client);
SqlMapSessionImpl session = new SqlMapSessionImpl(client);
SqlMapSessionWrapper wrapper = new SqlMapSessionWrapper(client, session);
wrapper.startTransaction();
wrapper.commitTransaction();
wrapper.getDataSource();
wrapper.getCurrentConnection();
wrapper.getUserConnection();
wrapper.close();
public class SLF4JImplTest extends TestCase {
public void test_0() throws Exception {
SLF4JImpl impl = new SLF4JImpl(DruidDataSource.class.getName());
impl.isDebugEnabled();
impl.isInfoEnabled();
impl.isWarnEnabled();
impl.debug("");
impl.debug("", new Exception());
impl.info("");
impl.warn("");
impl.warn("", new Exception());
impl.error("");
impl.error("", new Exception());
private final ByteArrayOutputStream out = new ByteArrayOutputStream();
byte[] outBytes = out.toByteArray();
System.arraycopy(outBytes, (int) (pos - 1), bytes, 0, length);
return new String(bytes, (int) (pos - 1), length);
private int            rowIndex = -1;
private List<Object[]> rows;
this(statement, new ArrayList<Object[]>());
public MockResultSet(Statement statement, List<Object[]> rows){
this.rows = rows;
return true;
public SybaseExceptionSorter() {
this.configFromProperties(System.getProperties());
String errorText = e.getMessage();
if (errorText == null) {
return false;
errorText = errorText.toUpperCase();
private SQLExpr            left;
private SQLExpr            right;
private SQLBinaryOperator  operator;
if (where != null) {
where.setParent(this);
if (lexer.token() == Token.COMMENT) {
if (lexer.token() == Token.COMMENT) {
map.put("COMMENT", Token.COMMENT);
if (lexer.token() == Token.COMMENT) {
statementList.add(this.parseComment());
continue;
SQLObject parent = x.getParent();
x.setParent(parent);
x.setParent(parent);
x.setParent(parent);
x.setParent(parent);
Object value = eval(dbType, sqlObject, Arrays.asList(parameters));
if (value == EVAL_VALUE_NULL) {
value = null;
return value;
double result = Math.cos(doubleValue);
double result = Math.sin(doubleValue);
double result = Math.log(doubleValue);
double result = Math.log10(doubleValue);
double result = Math.tan(doubleValue);
double result = Math.sqrt(doubleValue);
} else if ("power".equals(methodName) || "pow".equals(methodName)) {
if (val instanceof String) {
return Byte.parseByte((String) val);
if (a instanceof Double || b instanceof Double) {
return castToDouble(a) / (castToDouble(b));
if (a instanceof Float || b instanceof Float) {
return castToFloat(a) / (castToFloat(b));
if (a == EVAL_VALUE_NULL || b == EVAL_VALUE_NULL) {
return EVAL_VALUE_NULL;
private int debugCount;
public JakartaCommonsLoggingImpl(Log log){
debugCount++;
debugCount++;
debugCount++;
public int getDebugCount() {
return debugCount;
private int    debugCount;
debugCount++;
debugCount++;
debugCount = 0;
public int getDebugCount() {
return debugCount;
int getDebugCount();
private int                 debugCount;
public Log4jImpl(Logger log){
debugCount++;
debugCount++;
debugCount = 0;
public int getDebugCount() {
return debugCount;
private int    debugCount;
debugCount++;
debugCount++;
debugCount = 0;
public int getDebugCount() {
return debugCount;
private int                 debugCount;
debugCount++;
debugCount++;
public int getDebugCount() {
return debugCount;
debugCount = 0;
String threadName = nameStart + threadNo.getAndIncrement() + nameEnd;
Thread newThread = new Thread(r, threadName);
public class SQLServerWallTest_8 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new SQLServerWallProvider();
provider.getConfig().setMustParameterized(true);
Assert.assertFalse(provider.checkValid("select * from t where fid = 1"));
public class InformixExceptionSorterTest extends TestCase {
public void test_informix() throws Exception {
InformixExceptionSorter sorter = new InformixExceptionSorter();
Assert.assertEquals(false, sorter.isExceptionFatal(new SQLException()));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -710)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79716)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79730)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79734)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79735)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79736)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79756)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79757)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79758)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79759)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79760)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79788)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79811)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79812)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79836)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79837)));
Assert.assertEquals(true, sorter.isExceptionFatal(new SQLException("", "", -79879)));
Assert.assertEquals(false, sorter.isExceptionFatal(new SQLException("", "", 100)));
public class SybaseExceptionSorterTest extends TestCase {
public void test_false() throws Exception {
SybaseExceptionSorter sorter = new SybaseExceptionSorter();
Assert.assertFalse(sorter.isExceptionFatal(new SQLException()));
public void test_false_2() throws Exception {
SybaseExceptionSorter sorter = new SybaseExceptionSorter();
Assert.assertFalse(sorter.isExceptionFatal(new SQLException("xxx")));
public void test_true() throws Exception {
SybaseExceptionSorter sorter = new SybaseExceptionSorter();
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("JZ0C0")));
public void test_true_1() throws Exception {
SybaseExceptionSorter sorter = new SybaseExceptionSorter();
Assert.assertTrue(sorter.isExceptionFatal(new SQLException("JZ0C1")));
public class ValidConnectionCheckerAdapterTest extends TestCase {
public void test_adapter() throws Exception {
ValidConnectionCheckerAdapter adapter = new ValidConnectionCheckerAdapter();
adapter.configFromProperties(System.getProperties());
Assert.assertTrue(adapter.isValidConnection(null, null, 10));
public class SqlMapExecutorWrapperTest extends TestCase {
private ClassPathXmlApplicationContext context = null;
protected void setUp() throws Exception {
context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/ibatis/spring-config-ibatis.xml");
protected void tearDown() throws Exception {
context.close();
@SuppressWarnings("deprecation")
public void test_wrap() throws Exception {
SqlMapClientImpl client = (SqlMapClientImpl) context.getBean("master-sqlMapClient");
Assert.assertNotNull(client);
SqlMapClientWrapper wrapper = new SqlMapClientWrapper(client);
wrapper.getClient();
wrapper.startTransaction();
wrapper.endTransaction();
wrapper.startTransaction(Connection.TRANSACTION_NONE);
wrapper.endTransaction();
wrapper.setUserConnection(wrapper.getUserConnection());
wrapper.getCurrentConnection();
wrapper.getDataSource();
wrapper.openSession().close();
wrapper.openSession(wrapper.getCurrentConnection()).close();
wrapper.getSession();
wrapper.flushDataCache();
Exception error = null;
wrapper.flushDataCache(null);
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
wrapper.startTransaction();
wrapper.commitTransaction();
wrapper.getMappedStatement("Sequence.getValue");
wrapper.isEnhancementEnabled();
wrapper.isLazyLoadingEnabled();
wrapper.getSqlExecutor();
wrapper.getDelegate();
wrapper.getResultObjectFactory();
public class SQLCommentStatementTest extends TestCase {
public void test_0() throws Exception {
String sql = "COMMENT on table t1 IS 'xxx'";
SQLStatementParser parser = new SQLStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals("COMMENT ON TABLE t1 IS 'xxx'", text);
public void test_abs_int() throws Exception {
public void test_abs_long() throws Exception {
Assert.assertEquals(12L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(?)", 12L));
Assert.assertEquals(12L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(?)", -12L));
public class EvalMethodCosTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.cos(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "cos(1)"));
Assert.assertEquals(Math.cos(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "cos(1.001)"));
Assert.assertEquals(Math.cos(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "cos(0)"));
public class EvalMethodLog10Test extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.log10(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log10(1)"));
Assert.assertEquals(Math.log10(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log10(1.001)"));
Assert.assertEquals(Math.log10(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log10(0)"));
public class EvalMethodLogTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.log(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log(1)"));
Assert.assertEquals(Math.log(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log(1.001)"));
Assert.assertEquals(Math.log(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log(0)"));
public class EvalMethodPowerTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.pow(1, 2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "power(1, 2)"));
Assert.assertEquals(Math.pow(3, 4), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "power(3, 4)"));
Assert.assertEquals(Math.pow(4, 5), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "pow(4, 5)"));
public class EvalMethodRandom extends TestCase {
public void test_reverse() throws Exception {
Assert.assertNotNull(SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "rand()"));
public class EvalMethodSinTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.sin(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin(1)"));
Assert.assertEquals(Math.sin(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin(1.001)"));
Assert.assertEquals(Math.sin(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin(0)"));
Assert.assertEquals(Math.sin(2), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin(2)"));
public class EvalMethodSqrtTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.sqrt(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sqrt(1)"));
Assert.assertEquals(Math.sqrt(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sqrt(1.001)"));
Assert.assertEquals(Math.sqrt(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sqrt(0)"));
public class EvalMethodTanTest extends TestCase {
public void test_reverse() throws Exception {
Assert.assertEquals(Math.tan(1), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "tan(1)"));
Assert.assertEquals(Math.tan(1.001), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "tan(1.001)"));
Assert.assertEquals(Math.tan(0), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "tan(0)"));
public class EvalTest_add extends TestCase {
public void test_byte() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (byte) 1, (byte) 2));
public void test_byte_1() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (byte) 1, "2"));
public void test_byte_2() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (byte) 1, null));
public class EvalTest_add_long extends TestCase {
public void test_byte() throws Exception {
Assert.assertEquals(3L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (long) 1, (byte) 2));
public void test_byte_1() throws Exception {
Assert.assertEquals(3L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (long) 1, "2"));
public void test_byte_2() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (long) 1, null));
public class EvalTest_add_short extends TestCase {
public void test_byte() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (short) 1, (byte) 2));
public void test_byte_1() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (short) 1, "2"));
public void test_byte_2() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (short) 1, null));
public class EvalTest_div extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(0L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (long) 1, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(0, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (int) 1, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(0, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (short) 1, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(0, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (byte) 1, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(BigInteger.ZERO, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", BigInteger.ONE, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(new BigDecimal("0.5"), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", BigDecimal.ONE, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(0.5F, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (float) 1, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(0.5D, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (double) 1, (byte) 2));
public class EvalTest_gt extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (long) 1, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (int) 1, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (short) 1, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (byte) 1, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", BigInteger.ONE, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", BigDecimal.ONE, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", (float) 1, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", (double) 1, (byte) 2));
public void test_String() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", "1", "2"));
public class EvalTest_lt extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (long) 1, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (int) 1, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (short) 1, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (byte) 1, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", BigInteger.ONE, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", BigDecimal.ONE, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", (float) 1, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", (double) 1, (byte) 2));
public void test_String() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", "1", "2"));
public class EvalTest_lteq extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? <= ?", (long) 1, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? <= ?", (int) 1, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? <= ?", (short) 1, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? <= ?", (byte) 1, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<=?", BigInteger.ONE, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<=?", BigDecimal.ONE, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<=?", (float) 1, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<=?", (double) 1, (byte) 2));
public void test_String() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<=?", "1", "2"));
validate("SELECT * FROM T WHERE 1 = 0 AND ID = 5", "SELECT *nFROM TnWHERE 1 = 0ntAND ID = ?");
"SELECT *nFROM TnWHERE 1 = 0ntOR a.id = ?");
"SELECT *nFROM TnWHERE 1 = 0ntOR a.id = ?");
public class MySqlUpdateTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "UPDATE `z_code` SET (f1, f2) = (1, 2)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("z_code")));
Assert.assertTrue(visitor.getColumns().contains(new Column("z_code", "f1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("z_code", "f2")));
public class OracleSelectTest43 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT * FROM table(t_department)  " + 
"WHERE name IN ('0000','4444') " + 
"ORDER BY name ASC"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
public class PGExportParameterVisitorTest extends TestCase {
public void test_pg() throws Exception {
String sql = "select fname, count(*) from t where fid = 1 group by fname order by 1";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
List<Object> parameters = new ArrayList<Object>();
PGExportParameterVisitor visitor = new PGExportParameterVisitor(parameters);
stmt.accept(visitor);
Assert.assertEquals(1, parameters.size());
Assert.assertEquals(1, parameters.get(0));
public class PGExportParameterVisitorTest1 extends TestCase {
public void test_pg() throws Exception {
String sql = "select fname, count(*) from t where fid = 1 group by fname order by 1";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
PGExportParameterVisitor visitor = new PGExportParameterVisitor();
stmt.accept(visitor);
List<Object> parameters = visitor.getParameters();
Assert.assertEquals(1, parameters.size());
Assert.assertEquals(1, parameters.get(0));
public class MSSQLServerExportParameterVisitorTest extends TestCase {
public void test_sqlserver() throws Exception {
String sql = "select fname, count(*) from t where fid = 1 group by fname order by 1";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
List<Object> parameters = new ArrayList<Object>();
MSSQLServerExportParameterVisitor visitor = new MSSQLServerExportParameterVisitor(parameters);
stmt.accept(visitor);
Assert.assertEquals(1, parameters.size());
Assert.assertEquals(1, parameters.get(0));
public class SQLServerParameterizedOutputVisitorTest extends TestCase {
public void test_simple() throws Exception {
String sql = "select GEN_VAL " + 
"from ID_GENERATOR with (updlock, rowlock) " + 
"where GEN_NAME = 'T_USERS' AND FID = 3 AND FSTATE IN (1, 2, 3)"; 
String expect = "SELECT GEN_VAL" + 
"nFROM ID_GENERATOR WITH (updlock, rowlock)" + 
"nWHERE GEN_NAME = ?"
"ntAND FID = ?"
"ntAND FSTATE IN (?)";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = outputSqlServer(stmtList);
Assert.assertEquals(expect, text);
public static String outputSqlServer(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
SQLServerOutputVisitor visitor = new SQLServerParameterizedOutputVisitor(out);
for (SQLStatement stmt : stmtList) {
stmt.accept(visitor);
return out.toString();
public class DruidDataSourceFactoryTest extends TestCase {
public void test_facttory() throws Exception {
DruidDataSourceFactory factory = new DruidDataSourceFactory();
Properties properties = new Properties();
properties.setProperty("url", "jdbc:mock:xx");
factory.initialize(properties);
DruidDataSource dataSource = (DruidDataSource) factory.getDataSource();
dataSource.close();
public class JakartaCommonsLoggingImplTest extends TestCase {
public void test_0() throws Exception {
JakartaCommonsLoggingImpl impl = new JakartaCommonsLoggingImpl(DruidDataSource.class.getName());
impl.isDebugEnabled();
impl.isInfoEnabled();
impl.isWarnEnabled();
impl.debug("");
impl.debug("", new Exception());
impl.info("");
impl.warn("");
impl.warn("", new Exception());
impl.error("");
impl.error("", new Exception());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(2, impl.getErrorCount());
Assert.assertEquals(2, impl.getWarnCount());
Assert.assertEquals(1, impl.getInfoCount());
public class Jdk14LoggingImplTest extends TestCase {
public void test_0() throws Exception {
Jdk14LoggingImpl impl = new Jdk14LoggingImpl(DruidDataSource.class.getName());
impl.isDebugEnabled();
impl.isInfoEnabled();
impl.isWarnEnabled();
impl.debug("");
impl.debug("", new Exception());
impl.info("");
impl.warn("");
impl.warn("", new Exception());
impl.error("");
impl.error("", new Exception());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(2, impl.getErrorCount());
Assert.assertEquals(2, impl.getWarnCount());
Assert.assertEquals(1, impl.getInfoCount());
public class Log4jImplTest extends TestCase {
public void test_0() throws Exception {
Log4jImpl impl = new Log4jImpl(DruidDataSource.class.getName());
impl.isDebugEnabled();
impl.isInfoEnabled();
impl.isWarnEnabled();
impl.debug("");
impl.debug("", new Exception());
impl.info("");
impl.warn("");
impl.warn("", new Exception());
impl.error("");
impl.error("", new Exception());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(2, impl.getErrorCount());
Assert.assertEquals(2, impl.getWarnCount());
Assert.assertEquals(1, impl.getInfoCount());
public class NoLoggingImplTest extends TestCase {
public void test_0() throws Exception {
NoLoggingImpl impl = new NoLoggingImpl(DruidDataSource.class.getName());
impl.isDebugEnabled();
impl.isInfoEnabled();
impl.isWarnEnabled();
impl.debug("");
impl.debug("", new Exception());
impl.info("");
impl.warn("");
impl.warn("", new Exception());
impl.error("");
impl.error("", new Exception());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(2, impl.getErrorCount());
Assert.assertEquals(2, impl.getWarnCount());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(1, impl.getInfoCount());
Assert.assertEquals(2, impl.getErrorCount());
Assert.assertEquals(2, impl.getWarnCount());
Assert.assertEquals(1, impl.getInfoCount());
public class DruidLobHandlerTest extends TestCase {
public void test_0() throws Exception {
DruidLobHandler handler = new DruidLobHandler();
List<Object[]> rows = new ArrayList<Object[]>();
rows.add(new Object[] { null, new MockBlob(), new MockClob() });
MockResultSet rs = new MockResultSet(null, rows);
rs.next();
handler.getBlobAsBinaryStream(rs, 1);
handler.getBlobAsBinaryStream(rs, "1");
handler.getBlobAsBytes(rs, 1);
handler.getBlobAsBytes(rs, "1");
handler.getBlobAsBinaryStream(rs, 2);
handler.getBlobAsBinaryStream(rs, "2");
handler.getBlobAsBytes(rs, 2);
handler.getBlobAsBytes(rs, "2");
handler.getClobAsAsciiStream(rs, 1);
handler.getClobAsAsciiStream(rs, "1");
handler.getClobAsCharacterStream(rs, 1);
handler.getClobAsCharacterStream(rs, "1");
handler.getClobAsString(rs, 1);
handler.getClobAsString(rs, "1");
handler.getClobAsAsciiStream(rs, 3);
handler.getClobAsAsciiStream(rs, "3");
handler.getClobAsCharacterStream(rs, 3);
handler.getClobAsCharacterStream(rs, "3");
handler.getClobAsString(rs, 3);
handler.getClobAsString(rs, "3");
handler.getLobCreator();
public class ConcurrentIdentityHashMapTest2 extends TestCase {
public void test_0() throws Exception {
ConcurrentIdentityHashMap<Integer, Object> map = new ConcurrentIdentityHashMap<Integer, Object>();
map.put(Integer.valueOf(1), "");
Assert.assertEquals(map.get(Integer.valueOf(1)), "");
Assert.assertEquals(map.get(new Integer(1)), null);
Assert.assertTrue(map.containsValue(""));
Exception error = null;
map.containsValue(null);
} catch (NullPointerException ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
map.put(Integer.valueOf(1), null);
} catch (NullPointerException ex) {
error = ex;
Assert.assertNotNull(error);
Exception error = null;
map.putIfAbsent(Integer.valueOf(1), null);
} catch (NullPointerException ex) {
error = ex;
Assert.assertNotNull(error);
map.put(Integer.valueOf(1), "123");
Assert.assertEquals(map.get(Integer.valueOf(1)), "123");
Assert.assertEquals(map.get(new Integer(1)), null);
map.putIfAbsent(Integer.valueOf(1), "234");
Assert.assertEquals(map.get(Integer.valueOf(1)), "123");
Assert.assertEquals(map.get(new Integer(1)), null);
map.remove(new Integer(1));
Assert.assertEquals(map.get(Integer.valueOf(1)), "123");
Assert.assertFalse(map.isEmpty());
map.remove(Integer.valueOf(1));
Assert.assertEquals(map.get(Integer.valueOf(1)), null);
Assert.assertTrue(map.isEmpty());
public class ConcurrentIdentityHashMapTest3 extends TestCase {
public void test_0() throws Exception {
ConcurrentIdentityHashMap<Integer, Object> map = new ConcurrentIdentityHashMap<Integer, Object>(16, 0.75f, 2);
Integer[] keys = new Integer[10000];
for (int i = 0; i < keys.length; ++i) {
keys[i] = i;
for (int i = 0; i < keys.length; ++i) {
map.put(keys[i], "");
Assert.assertEquals(keys.length, map.size());
for (int i = 0; i < keys.length; ++i) {
map.put(keys[i], "");
for (Map.Entry<Integer, Object> entry : map.entrySet()) {
entry.getKey();
entry.getValue();
Assert.assertEquals(keys.length, map.size());
for (int i = 0; i < keys.length; ++i) {
map.remove(keys[i]);
Assert.assertEquals(0, map.size());
map.keys();
map.entrySet();
public class DaemonThreadFactoryTest extends TestCase  {
public void test_0 () throws Exception {
Runnable task = new Runnable() {
public void run() {
DaemonThreadFactory factory = new DaemonThreadFactory("test");
Assert.assertEquals("[test-1]", factory.newThread(task).getName());
Assert.assertEquals("[test-2]", factory.newThread(task).getName());
public class LocalResultSetTest extends TestCase {
public void test_0() throws Exception {
LocalResultSet rs = new LocalResultSet(null);
rs.getRows().add(new Object[1]);
rs.getRows().add(new Object[1]);
Assert.assertTrue(rs.next());
Assert.assertTrue(rs.next());
Assert.assertFalse(rs.next());
Assert.assertTrue(rs.previous());
Assert.assertFalse(rs.previous());
rs.getInt(1);
Assert.assertTrue(rs.wasNull());
rs.updateObject(1, 2);
Assert.assertEquals(2, rs.getInt(1));
Assert.assertFalse(rs.wasNull());
rs.close();
public class MySqlUtilsTest extends TestCase {
public void test_() throws Exception {
Constructor<ConnectionImpl> constructor = ConnectionImpl.class.getDeclaredConstructor();
constructor.setAccessible(true);
ConnectionImpl conn = constructor.newInstance();
MySqlUtils.createXAConnection(conn);
private ByteArrayOutputStream out = new ByteArrayOutputStream();
return out;
value.setPoolingCount(this.poolingCount);
value.setPoolingPeak(this.poolingPeak);
value.setPoolingPeakTime(this.poolingPeakTime);
value.setActiveCount(this.activeCount);
value.setActivePeak(this.activePeak);
value.setActivePeakTime(this.activePeakTime);
value.setConnectCount(this.connectCount);
value.setCloseCount(this.closeCount);
value.setWaitThreadCount(lock.getWaitQueueLength(notEmpty));
value.setNotEmptyWaitCount(this.notEmptyWaitCount);
value.setNotEmptyWaitNanos(this.notEmptyWaitNanos);
value.setName(this.getName());
value.setDbType(this.getDbType());
value.setDriverClassName(this.getDriverClassName());
value.setUrl(this.getUrl());
value.setUserName(this.getUsername());
value.setFilterClassNames(this.getFilterClassNames());
value.setInitialSize(this.getInitialSize());
value.setMinIdle(this.getMinIdle());
value.setMaxActive(this.getMaxActive());
value.setQueryTimeout(this.getQueryTimeout());
value.setTransactionQueryTimeout(this.getTransactionQueryTimeout());
value.setLoginTimeout(this.getLoginTimeout());
value.setValidConnectionCheckerClassName(this.getValidConnectionCheckerClassName());
value.setExceptionSorterClassName(this.getExceptionSorterClassName());
value.setTestOnBorrow(this.isTestOnBorrow());
value.setTestOnReturn(this.isTestOnReturn());
value.setTestWhileIdle(this.isTestWhileIdle());
value.setDefaultAutoCommit(this.isDefaultAutoCommit());
value.setDefaultReadOnly(this.isDefaultAutoCommit());
value.setDefaultTransactionIsolation(this.getDefaultTransactionIsolation());
value.setLogicConnectErrorCount(connectErrorCount.getAndSet(0));
value.setPhysicalConnectCount(createCount.getAndSet(0));
value.setPhysicalCloseCount(destroyCount.getAndSet(0));
value.setPhysicalConnectErrorCount(createErrorCount.getAndSet(0));
value.setExecuteCount(this.executeCount.getAndSet(0));
value.setErrorCount(errorCount.getAndSet(0));
value.setCommitCount(commitCount.getAndSet(0));
value.setRollbackCount(rollbackCount.getAndSet(0));
value.setPstmtCacheHitCount(cachedPreparedStatementHitCount.getAndSet(0));
value.setPstmtCacheMissCount(cachedPreparedStatementMissCount.getAndSet(0));
value.setStartTransactionCount(startTransactionCount.getAndSet(0));
value.setTransactionHistogram(this.getTransactionHistogram().toArrayAndReset());
value.setConnectionHoldTimeHistogram(this.getDataSourceStat().getConnectionHoldHistogram().toArrayAndReset());
value.setClobOpenCount(this.getDataSourceStat().getClobOpenCountAndReset());
value.setBlobOpenCount(this.getDataSourceStat().getBlobOpenCountAndReset());
value.setSqlSkipCount(this.getDataSourceStat().getSkipSqlCountAndReset());
value.setSqlList(this.getDataSourceStat().getSqlStatMapAndReset());
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((conditionExpr == null) ? 0 : conditionExpr.hashCode());
result = prime * result + ((valueExpr == null) ? 0 : valueExpr.hashCode());
return result;
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
Item other = (Item) obj;
if (conditionExpr == null) {
if (other.conditionExpr != null) return false;
} else if (!conditionExpr.equals(other.conditionExpr)) return false;
if (valueExpr == null) {
if (other.valueExpr != null) return false;
} else if (!valueExpr.equals(other.valueExpr)) return false;
return true;
this.setSubQuery(subQuery);
this.setSubQuery(subQuery);
if (subQuery != null) {
subQuery.setParent(this);
this.subQuery = subQuery;
private static final long       serialVersionUID = 1L;
protected SQLSelectQuery        query;
protected SQLOrderBy            orderBy;
public SQLSelect(SQLSelectQuery query){
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((orderBy == null) ? 0 : orderBy.hashCode());
result = prime * result + ((query == null) ? 0 : query.hashCode());
result = prime * result + ((withSubQuery == null) ? 0 : withSubQuery.hashCode());
return result;
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
SQLSelect other = (SQLSelect) obj;
if (orderBy == null) {
if (other.orderBy != null) return false;
} else if (!orderBy.equals(other.orderBy)) return false;
if (query == null) {
if (other.query != null) return false;
} else if (!query.equals(other.query)) return false;
if (withSubQuery == null) {
if (other.withSubQuery != null) return false;
} else if (!withSubQuery.equals(other.withSubQuery)) return false;
return true;
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + distionOption;
result = prime * result + ((from == null) ? 0 : from.hashCode());
result = prime * result + ((groupBy == null) ? 0 : groupBy.hashCode());
result = prime * result + ((into == null) ? 0 : into.hashCode());
result = prime * result + ((selectList == null) ? 0 : selectList.hashCode());
result = prime * result + ((where == null) ? 0 : where.hashCode());
return result;
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
SQLSelectQueryBlock other = (SQLSelectQueryBlock) obj;
if (distionOption != other.distionOption) return false;
if (from == null) {
if (other.from != null) return false;
} else if (!from.equals(other.from)) return false;
if (groupBy == null) {
if (other.groupBy != null) return false;
} else if (!groupBy.equals(other.groupBy)) return false;
if (into == null) {
if (other.into != null) return false;
} else if (!into.equals(other.into)) return false;
if (selectList == null) {
if (other.selectList != null) return false;
} else if (!selectList.equals(other.selectList)) return false;
if (where == null) {
if (other.where != null) return false;
} else if (!where.equals(other.where)) return false;
return true;
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + (bigResult ? 1231 : 1237);
result = prime * result + (bufferResult ? 1231 : 1237);
result = prime * result + ((cache == null) ? 0 : cache.hashCode());
result = prime * result + (calcFoundRows ? 1231 : 1237);
result = prime * result + (forUpdate ? 1231 : 1237);
result = prime * result + (hignPriority ? 1231 : 1237);
result = prime * result + ((hints == null) ? 0 : hints.hashCode());
result = prime * result + ((limit == null) ? 0 : limit.hashCode());
result = prime * result + (lockInShareMode ? 1231 : 1237);
result = prime * result + ((orderBy == null) ? 0 : orderBy.hashCode());
result = prime * result + ((procedureArgumentList == null) ? 0 : procedureArgumentList.hashCode());
result = prime * result + ((procedureName == null) ? 0 : procedureName.hashCode());
result = prime * result + (smallResult ? 1231 : 1237);
result = prime * result + (straightJoin ? 1231 : 1237);
return result;
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
MySqlSelectQueryBlock other = (MySqlSelectQueryBlock) obj;
if (bigResult != other.bigResult) return false;
if (bufferResult != other.bufferResult) return false;
if (cache == null) {
if (other.cache != null) return false;
} else if (!cache.equals(other.cache)) return false;
if (calcFoundRows != other.calcFoundRows) return false;
if (forUpdate != other.forUpdate) return false;
if (hignPriority != other.hignPriority) return false;
if (hints == null) {
if (other.hints != null) return false;
} else if (!hints.equals(other.hints)) return false;
if (limit == null) {
if (other.limit != null) return false;
} else if (!limit.equals(other.limit)) return false;
if (lockInShareMode != other.lockInShareMode) return false;
if (orderBy == null) {
if (other.orderBy != null) return false;
} else if (!orderBy.equals(other.orderBy)) return false;
if (procedureArgumentList == null) {
if (other.procedureArgumentList != null) return false;
} else if (!procedureArgumentList.equals(other.procedureArgumentList)) return false;
if (procedureName == null) {
if (other.procedureName != null) return false;
} else if (!procedureName.equals(other.procedureName)) return false;
if (smallResult != other.smallResult) return false;
if (straightJoin != other.straightJoin) return false;
return true;
mysqlVisitor.endVisit(this);
public class MySqlTableIndex extends MySqlObjectImpl implements SQLTableElement {
public void accept0(MySqlASTVisitor visitor) {
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
visitor.endVisit(this);
tableReference.setOnly(true);
if (!isPrintPostSemi()) {
if (val == null || val == EVAL_VALUE_NULL) {
if (val == null || val == EVAL_VALUE_NULL) {
if (val == null || val == EVAL_VALUE_NULL) {
Double doubleA = castToDouble(a);
Double doubleB = castToDouble(b);
if (doubleA == null || doubleB == null) {
return null;
return doubleA / doubleB;
Float floatA = castToFloat(a);
Float floatB = castToFloat(b);
if (floatA == null || floatB == null) {
return null;
return floatA / floatB;
Short shortA = castToShort(a);
Short shortB = castToShort(b);
if (shortA == null || shortB == null) {
return null;
return shortA * shortB;
if (text == null) {
writeNull();
Class<?> clazz = null;
clazz = classLoader.loadClass(driverClassName);
if (clazz == null) {
ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
if (contextLoader != null) {
clazz = contextLoader.loadClass(driverClassName);
} catch (ClassNotFoundException e) {
if (clazz == null) {
clazz = Class.forName(driverClassName);
} catch (ClassNotFoundException e) {
throw new SQLException(e.getMessage(), e);
return (Driver) clazz.newInstance();
String C_TEXT = new String(param1.getBytes(SERVER_ENCODING), CLIENT_ENCODING);
Assert.assertEquals(PARAM_VALUE, C_TEXT);
rs.next();
Assert.assertEquals(text, rs.getString(1));
Assert.assertEquals(text, rs.getString("1"));
Assert.assertEquals(text, rs.getObject(1));
Assert.assertEquals(text, rs.getObject("1"));
Assert.assertEquals(text, rs.getObject(1, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getObject("1", Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getString(2));
Assert.assertEquals(text, rs.getString("2"));
Assert.assertEquals(text, rs.getObject(2));
Assert.assertEquals(text, rs.getObject("2"));
Assert.assertEquals(text, rs.getObject(2, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getObject("2", Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getString(3));
Assert.assertEquals(text, rs.getString("3"));
Assert.assertEquals(text, rs.getObject(3));
Assert.assertEquals(text, rs.getObject("3"));
Assert.assertEquals(text, rs.getObject(3, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getObject("3", Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getString(4));
Assert.assertEquals(text, rs.getString("4"));
Assert.assertEquals(text, rs.getObject(4));
Assert.assertEquals(text, rs.getObject("4"));
Assert.assertEquals(text, rs.getObject(4, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(text, rs.getObject("4", Collections.<String,Class<?>>emptyMap()));
stmt.registerOutParameter(2, Types.VARCHAR);
stmt.registerOutParameter(3, Types.CLOB);
raw.getOutParameters().add(param1);
raw.getOutParameters().add(param1);
Assert.assertEquals(C_TEXT, stmt.getString(4));
Assert.assertEquals(C_TEXT, stmt.getString("4"));
Assert.assertEquals(C_TEXT, stmt.getObject(4));
Assert.assertEquals(C_TEXT, stmt.getObject("4"));
Assert.assertEquals(C_TEXT, stmt.getObject(4, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(C_TEXT, stmt.getObject("4", Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(C_TEXT, stmt.getString(5));
Assert.assertEquals(C_TEXT, stmt.getString("5"));
Assert.assertEquals(C_TEXT, stmt.getObject(5));
Assert.assertEquals(C_TEXT, stmt.getObject("5"));
Assert.assertEquals(C_TEXT, stmt.getObject(5, Collections.<String,Class<?>>emptyMap()));
Assert.assertEquals(C_TEXT, stmt.getObject("5", Collections.<String,Class<?>>emptyMap()));
stmt.setObject(1, C_TEXT);
Assert.assertEquals(param1, raw.getParameters().get(0));
stmt.setObject(2, new StringReader(C_TEXT));
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(1)));
stmt.setCharacterStream(3, new StringReader(C_TEXT));
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(2)));
stmt.setCharacterStream(4, new StringReader(C_TEXT), C_TEXT.length());
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(3)));
stmt.setCharacterStream(5, new StringReader(C_TEXT), (long) C_TEXT.length());
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(4)));
stmt.setObject(6, C_TEXT, Types.VARCHAR);
Assert.assertEquals(param1, raw.getParameters().get(5));
stmt.setObject(7, new StringReader(C_TEXT), Types.VARCHAR);
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(6)));
stmt.setObject(8, C_TEXT, Types.VARCHAR, 0);
Assert.assertEquals(param1, raw.getParameters().get(7));
stmt.setObject(9, new StringReader(C_TEXT), Types.VARCHAR, 0);
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(8)));
stmt.setObject(10, 1, Types.INTEGER);
Assert.assertEquals(1, raw.getParameters().get(9));
stmt.setObject(11, 2, Types.INTEGER, 0);
Assert.assertEquals(2, raw.getParameters().get(10));
stmt.setObject(12, 3);
Assert.assertEquals(3, raw.getParameters().get(11));
stmt.setObject("13", C_TEXT, Types.VARCHAR);
Assert.assertEquals(param1, raw.getParameters().get(12));
stmt.setObject("14", new StringReader(C_TEXT), Types.VARCHAR);
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(13)));
stmt.setObject("15", C_TEXT, Types.VARCHAR, 0);
Assert.assertEquals(param1, raw.getParameters().get(14));
stmt.setObject("16", new StringReader(C_TEXT), Types.VARCHAR, 0);
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(15)));
stmt.setObject("17", 1, Types.INTEGER);
Assert.assertEquals(1, raw.getParameters().get(16));
stmt.setObject("18", 2, Types.INTEGER, 0);
Assert.assertEquals(2, raw.getParameters().get(17));
stmt.setObject("19", 3);
Assert.assertEquals(3, raw.getParameters().get(18));
stmt.setCharacterStream("20", new StringReader(C_TEXT));
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(19)));
stmt.setCharacterStream("21", new StringReader(C_TEXT), C_TEXT.length());
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(20)));
stmt.setCharacterStream("22", new StringReader(C_TEXT), (long) C_TEXT.length());
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(21)));
stmt.setObject("23", C_TEXT);
Assert.assertEquals(param1, raw.getParameters().get(22));
stmt.setObject("24", new StringReader(C_TEXT));
Assert.assertEquals(param1, IOUtils.read((Reader) raw.getParameters().get(23)));
stmt.setObject("25", 1, Types.INTEGER);
Assert.assertEquals(1, raw.getParameters().get(24));
stmt.setObject("26", 2, Types.INTEGER, 0);
Assert.assertEquals(2, raw.getParameters().get(25));
stmt.setObject("27", 3);
Assert.assertEquals(3, raw.getParameters().get(26));
private String                value;
private MockResultSetMetaData meta = new MockResultSetMetaData();
ColumnMetaData column = new ColumnMetaData();
column.setColumnType(Types.VARCHAR);
meta.getColumns().add(column);
ColumnMetaData column = new ColumnMetaData();
column.setColumnType(Types.LONGVARCHAR);
meta.getColumns().add(column);
ColumnMetaData column = new ColumnMetaData();
column.setColumnType(Types.CHAR);
meta.getColumns().add(column);
ColumnMetaData column = new ColumnMetaData();
column.setColumnType(Types.CLOB);
meta.getColumns().add(column);
public ResultSetMetaData getMetaData() {
return meta;
dataSource.setFilters("log4j,slf4j");
public class Slf4jLogFilterTest extends TestCase {
public void test_slf4j() throws Exception {
Slf4jLogFilter filter = new Slf4jLogFilter();
Assert.assertEquals("druid.sql.DataSource", filter.getDataSourceLoggerName());
Assert.assertEquals("druid.sql.Connection", filter.getConnectionLoggerName());
Assert.assertEquals("druid.sql.Statement", filter.getStatementLoggerName());
Assert.assertEquals("druid.sql.ResultSet", filter.getResultSetLoggerName());
filter.setDataSourceLoggerName("x.sql.DataSource");
filter.setConnectionLoggerName("x.sql.Connection");
filter.setStatementLoggerName("x.sql.Statement");
filter.setResultSetLoggerName("x.sql.ResultSet");
Assert.assertEquals("x.sql.DataSource", filter.getDataSourceLoggerName());
Assert.assertEquals("x.sql.Connection", filter.getConnectionLoggerName());
Assert.assertEquals("x.sql.Statement", filter.getStatementLoggerName());
Assert.assertEquals("x.sql.ResultSet", filter.getResultSetLoggerName());
filter.setDataSourceLogger(LoggerFactory.getLogger("y.sql.DataSource"));
filter.setConnectionLogger(LoggerFactory.getLogger("y.sql.Connection"));
filter.setStatementLogger(LoggerFactory.getLogger("y.sql.Statement"));
filter.setResultSetLogger(LoggerFactory.getLogger("y.sql.ResultSet"));
Assert.assertEquals("y.sql.DataSource", filter.getDataSourceLoggerName());
Assert.assertEquals("y.sql.Connection", filter.getConnectionLoggerName());
Assert.assertEquals("y.sql.Statement", filter.getStatementLoggerName());
Assert.assertEquals("y.sql.ResultSet", filter.getResultSetLoggerName());
filter.isDataSourceLogEnabled();
filter.isConnectionLogEnabled();
filter.isConnectionLogErrorEnabled();
filter.isStatementLogEnabled();
filter.isStatementLogErrorEnabled();
filter.isResultSetLogEnabled();
filter.isResultSetLogErrorEnabled();
dataSource.getCompositeData();
dataSource.getProperties();
dataSource.getDataSourceMBeanDomain();
public class SqlMapClientWrapperTest extends TestCase {
private ClassPathXmlApplicationContext context = null;
protected void setUp() throws Exception {
context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/ibatis/spring-config-ibatis.xml");
DataSource dataSource = (DataSource) context.getBean("dataSource");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE sequence_seed (value INTEGER, name VARCHAR(50))");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE t_User (id BIGINT, name VARCHAR(50))");
stmt.close();
conn.close();
protected void tearDown() throws Exception {
DataSource dataSource = (DataSource) context.getBean("dataSource");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE sequence_seed");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE t_User");
stmt.close();
conn.close();
context.close();
public void test_wrap() throws Exception {
SqlMapClientImpl client = (SqlMapClientImpl) context.getBean("master-sqlMapClient");
Assert.assertNotNull(client);
SqlMapClientWrapper wrapper = new SqlMapClientWrapper(client);
wrapper.insert("User.insert", new User(12345678, "aaa"));
Exception error = null;
wrapper.insert("User.insert");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
wrapper.update("User.update", new User(12345678, "bbb"));
Exception error = null;
wrapper.update("User.update");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Assert.assertNotNull((User) wrapper.queryForObject("User.select"));
Assert.assertNotNull((User) wrapper.queryForObject("User.select", Collections.emptyMap()));
Assert.assertNotNull((User) wrapper.queryForObject("User.select", Collections.emptyMap(), new User()));
Assert.assertEquals(1, wrapper.queryForList("User.select").size());
Assert.assertEquals(1, wrapper.queryForList("User.select", Collections.emptyMap()).size());
Assert.assertEquals(1, wrapper.queryForList("User.select", Collections.emptyMap(), 0, 2).size());
wrapper.queryWithRowHandler("User.select", new RowHandler() {
public void handleRow(Object valueObject) {
wrapper.queryWithRowHandler("User.select", Collections.emptyMap(), new RowHandler() {
public void handleRow(Object valueObject) {
Assert.assertEquals(1, wrapper.queryForPaginatedList("User.select", 10).size());
Assert.assertEquals(1, wrapper.queryForPaginatedList("User.select", Collections.emptyMap(), 10).size());
Assert.assertNotNull(wrapper.queryForMap("User.select", Collections.emptyMap(), "id"));
Assert.assertNotNull(wrapper.queryForMap("User.select", Collections.emptyMap(), "id", "name"));
wrapper.delete("User.delete", 12345678L);
Exception error = null;
wrapper.delete("User.delete");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
wrapper.startBatch();
wrapper.executeBatch();
wrapper.executeBatchDetailed();
public class SqlMapExecutorWrapperTest_2 extends TestCase {
private ClassPathXmlApplicationContext context = null;
protected void setUp() throws Exception {
context = new ClassPathXmlApplicationContext("com/alibaba/druid/pool/ibatis/spring-config-ibatis.xml");
DataSource dataSource = (DataSource) context.getBean("dataSource");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE sequence_seed (value INTEGER, name VARCHAR(50))");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("CREATE TABLE t_User (id BIGINT, name VARCHAR(50))");
stmt.close();
conn.close();
protected void tearDown() throws Exception {
DataSource dataSource = (DataSource) context.getBean("dataSource");
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE sequence_seed");
stmt.close();
conn.close();
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
stmt.execute("DROP TABLE t_User");
stmt.close();
conn.close();
context.close();
public void test_wrap() throws Exception {
SqlMapClientImpl client = (SqlMapClientImpl) context.getBean("master-sqlMapClient");
Assert.assertNotNull(client);
SqlMapExecutorWrapper wrapper = new SqlMapExecutorWrapper(client, client);
wrapper.insert("User.insert", new User(12345678, "aaa"));
Exception error = null;
wrapper.insert("User.insert");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
wrapper.update("User.update", new User(12345678, "bbb"));
Exception error = null;
wrapper.update("User.update");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
Assert.assertNotNull((User) wrapper.queryForObject("User.select"));
Assert.assertNotNull((User) wrapper.queryForObject("User.select", Collections.emptyMap()));
Assert.assertNotNull((User) wrapper.queryForObject("User.select", Collections.emptyMap(), new User()));
Assert.assertEquals(1, wrapper.queryForList("User.select").size());
Assert.assertEquals(1, wrapper.queryForList("User.select", Collections.emptyMap()).size());
Assert.assertEquals(1, wrapper.queryForList("User.select", Collections.emptyMap(), 0, 2).size());
wrapper.queryWithRowHandler("User.select", new RowHandler() {
public void handleRow(Object valueObject) {
wrapper.queryWithRowHandler("User.select", Collections.emptyMap(), new RowHandler() {
public void handleRow(Object valueObject) {
Assert.assertEquals(1, wrapper.queryForPaginatedList("User.select", 10).size());
Assert.assertEquals(1, wrapper.queryForPaginatedList("User.select", Collections.emptyMap(), 10).size());
Assert.assertNotNull(wrapper.queryForMap("User.select", Collections.emptyMap(), "id"));
Assert.assertNotNull(wrapper.queryForMap("User.select", Collections.emptyMap(), "id", "name"));
wrapper.delete("User.delete", 12345678L);
Exception error = null;
wrapper.delete("User.delete");
} catch (Exception ex) {
error = ex;
Assert.assertNotNull(error);
wrapper.startBatch();
wrapper.executeBatch();
wrapper.executeBatchDetailed();
public class EqualTest extends TestCase {
public void test_exits() throws Exception {
String sql = "fstate in (select state from t_status)";
String sql_c = "fstate_c in (select state from t_status)";
SQLInSubQueryExpr exprA, exprB, exprC;
MySqlExprParser parser = new MySqlExprParser(sql);
exprA = (SQLInSubQueryExpr) parser.expr();
MySqlExprParser parser = new MySqlExprParser(sql);
exprB = (SQLInSubQueryExpr) parser.expr();
MySqlExprParser parser = new MySqlExprParser(sql_c);
exprC = (SQLInSubQueryExpr) parser.expr();
Assert.assertEquals(exprA, exprB);
Assert.assertNotEquals(exprA, exprC);
Assert.assertTrue(exprA.equals(exprA));
Assert.assertFalse(exprA.equals(new Object()));
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
public class EqualTest2 extends TestCase {
public void test_exits() throws Exception {
String sql = "INTERVAL '30.12345' SECOND(2, 4)";
String sql_c = "INTERVAL '30.12345' SECOND(2, 3)";
OracleIntervalExpr exprA, exprB, exprC;
OracleExprParser parser = new OracleExprParser(sql);
exprA = (OracleIntervalExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql);
exprB = (OracleIntervalExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql_c);
exprC = (OracleIntervalExpr) parser.expr();
Assert.assertEquals(exprA, exprB);
Assert.assertNotEquals(exprA, exprC);
Assert.assertTrue(exprA.equals(exprA));
Assert.assertFalse(exprA.equals(new Object()));
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
public class EqualTest_OracleDate extends TestCase {
public void test_eq() throws Exception {
OracleDateExpr exprA = new OracleDateExpr();
OracleDateExpr exprB = new OracleDateExpr();
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
Assert.assertEquals(exprA, exprB);
public class EqualTest_between extends TestCase {
public void test_exits() throws Exception {
String sql = "x between 1 AND 2";
String sql_c = "x between 1 AND 3";
SQLBetweenExpr exprA, exprB, exprC;
OracleExprParser parser = new OracleExprParser(sql);
exprA = (SQLBetweenExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql);
exprB = (SQLBetweenExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql_c);
exprC = (SQLBetweenExpr) parser.expr();
Assert.assertEquals(exprA, exprB);
Assert.assertNotEquals(exprA, exprC);
Assert.assertTrue(exprA.equals(exprA));
Assert.assertFalse(exprA.equals(new Object()));
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
Assert.assertEquals(new SQLBetweenExpr(), new SQLBetweenExpr());
Assert.assertEquals(new SQLBetweenExpr().hashCode(), new SQLBetweenExpr().hashCode());
public class EqualTest_case extends TestCase {
public void test_exits() throws Exception {
String sql = "case x when 1 then 0 else 2 end";
String sql_c = "case x when 2 then 0 else 2 end";
SQLCaseExpr exprA, exprB, exprC;
OracleExprParser parser = new OracleExprParser(sql);
exprA = (SQLCaseExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql);
exprB = (SQLCaseExpr) parser.expr();
OracleExprParser parser = new OracleExprParser(sql_c);
exprC = (SQLCaseExpr) parser.expr();
Assert.assertEquals(exprA, exprB);
Assert.assertNotEquals(exprA, exprC);
Assert.assertTrue(exprA.equals(exprA));
Assert.assertFalse(exprA.equals(new Object()));
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
Assert.assertEquals(new SQLCaseExpr(), new SQLCaseExpr());
Assert.assertEquals(new SQLCaseExpr().hashCode(), new SQLCaseExpr().hashCode());
public class EqualTest_groupSet extends TestCase {
public void test_eq() throws Exception {
GroupingSetExpr exprA = new GroupingSetExpr();
GroupingSetExpr exprB = new GroupingSetExpr();
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
Assert.assertEquals(exprA, exprB);
public class EqualTest_mysqlMatch extends TestCase {
public void test_exits() throws Exception {
String sql = "MATCH (f1, f2) AGAINST (f3 IN BOOLEAN MODE)";
String sql_c = "MATCH (f1, f2) AGAINST (f4 IN BOOLEAN MODE)";
MySqlMatchAgainstExpr exprA, exprB, exprC;
MySqlExprParser parser = new MySqlExprParser(sql);
exprA = (MySqlMatchAgainstExpr) parser.expr();
MySqlExprParser parser = new MySqlExprParser(sql);
exprB = (MySqlMatchAgainstExpr) parser.expr();
MySqlExprParser parser = new MySqlExprParser(sql_c);
exprC = (MySqlMatchAgainstExpr) parser.expr();
Assert.assertEquals(exprA, exprB);
Assert.assertNotEquals(exprA, exprC);
Assert.assertTrue(exprA.equals(exprA));
Assert.assertFalse(exprA.equals(new Object()));
Assert.assertEquals(exprA.hashCode(), exprB.hashCode());
Assert.assertEquals(new MySqlMatchAgainstExpr(), new MySqlMatchAgainstExpr());
Assert.assertEquals(new MySqlMatchAgainstExpr().hashCode(), new MySqlMatchAgainstExpr().hashCode());
public class SQLASTVisitorAdapterTest extends TestCase {
public void test_adapter() throws Exception {
SQLASTVisitorAdapter adapter = new SQLASTVisitorAdapter();
new SQLBinaryOpExpr().accept(adapter);
new SQLInListExpr().accept(adapter);
new SQLSelectQueryBlock().accept(adapter);
new SQLDropTableStatement().accept(adapter);
new SQLCreateTableStatement().accept(adapter);
new SQLDeleteStatement().accept(adapter);
new SQLCurrentOfCursorExpr ().accept(adapter);
new SQLInsertStatement ().accept(adapter);
new SQLUpdateStatement ().accept(adapter);
new NotNullConstraint ().accept(adapter);
new SQLMethodInvokeExpr ().accept(adapter);
new SQLCallStatement ().accept(adapter);
new SQLSomeExpr ().accept(adapter);
new SQLAnyExpr ().accept(adapter);
new SQLAllExpr ().accept(adapter);
new SQLDefaultExpr ().accept(adapter);
new SQLCommentStatement ().accept(adapter);
new SQLDropViewStatement ().accept(adapter);
new SQLSavePointStatement ().accept(adapter);
new SQLReleaseSavePointStatement ().accept(adapter);
new SQLCreateDatabaseStatement ().accept(adapter);
new SQLAlterTableDropIndex ().accept(adapter);
new SQLAlterTableAddPrimaryKey ().accept(adapter);
new SQLOver ().accept(adapter);
new SQLWithSubqueryClause().accept(adapter);
new SQLAlterTableAlterColumn ().accept(adapter);
new SQLAlterTableStatement ().accept(adapter);
new SQLAlterTableDisableConstraint ().accept(adapter);
new SQLAlterTableEnableConstraint ().accept(adapter);
new SQLColumnCheck ().accept(adapter);
new SQLExprHint ().accept(adapter);
new SQLAlterTableDropConstraint ().accept(adapter);
public void test_abs_decimal() throws Exception {
Assert.assertEquals(new BigDecimal("12"), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(?)", new BigDecimal("12")));
Assert.assertEquals(new BigDecimal("12"), SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(?)", new BigDecimal("-12")));
public void test_abs_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "abs(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "asin()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "asin(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan2()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan2(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_abs_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "atan(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ceil()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "ceil(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "cos()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "cos(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log10()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log10(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "log(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "pow()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "pow(a,b)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sin(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sqrt()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "sqrt(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "tan()", 12L);
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_error_1() throws Exception {
Exception error = null;
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "tan(a)");
} catch (Exception e) {
error = e;
Assert.assertNotNull(error);
public void test_byte_3() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", "2", (byte) 1));
public void test_add() throws Exception {
public void test_add_1() throws Exception {
public void test_add_2() throws Exception {
public void test_add_3() throws Exception {
Assert.assertEquals(3L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", (byte) 2, (long) 1));
public void test_add_4() throws Exception {
Assert.assertEquals(3L, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", "2", (long) 1));
public void test_add_5() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", null, (long) 1));
public void test_byte_3() throws Exception {
Assert.assertEquals(3, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? + ?", "2", (short) 1));
Assert.assertEquals(BigInteger.ZERO,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", BigInteger.ONE, (byte) 2));
Assert.assertEquals(new BigDecimal("0.5"),
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", BigDecimal.ONE, (byte) 2));
public void test_double_zero() throws Exception {
Assert.assertEquals(Double.POSITIVE_INFINITY,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (double) 1, 0));
public void test_double_zero_1() throws Exception {
Assert.assertEquals(Double.NEGATIVE_INFINITY,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (double) -1D, 0));
public void test_double_zero_2() throws Exception {
Assert.assertEquals(Double.NaN,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (double) 0D, 0));
public void test_double_null() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (double) 1, null));
public void test_double_null_1() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", null, (double) 1));
public void test_float_zero() throws Exception {
Assert.assertEquals(Float.POSITIVE_INFINITY,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (float) 1, 0));
public void test_float_zero_1() throws Exception {
Assert.assertEquals(Float.NEGATIVE_INFINITY,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (float) -1F, 0));
public void test_float_zero_2() throws Exception {
Assert.assertEquals(Float.NaN,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (float) 0F, 0));
public void test_float_null() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", (float) 1, null));
public void test_float_null_1() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?/?", null, (float) 1));
public void test_Date() throws Exception {
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?",
new Date(System.currentTimeMillis() - 10),
new Date(System.currentTimeMillis())));
public class EvalTest_gt_true extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (long) 10, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (int) 10, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (short) 10, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (byte) 10, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", BigInteger.TEN, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", BigDecimal.TEN, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", (float) 3, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", (double) 3, (byte) 2));
public void test_String() throws Exception {
Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", "3", "2"));
public void test_Date() throws Exception {
Assert.assertEquals(true,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?",
new Date(System.currentTimeMillis()),
new Date(System.currentTimeMillis() - 10)));
public void test_Date() throws Exception {
Assert.assertEquals(true,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?",
new Date(System.currentTimeMillis() - 10),
new Date(System.currentTimeMillis())));
public class EvalTest_lt_false extends TestCase {
public void test_long() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (long) 10, (byte) 2));
public void test_int() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (int) 10, (byte) 2));
public void test_short() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (short) 10, (byte) 2));
public void test_byte() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? < ?", (byte) 10, (byte) 2));
public void test_BigInteger() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", BigInteger.TEN, (byte) 2));
public void test_BigDecimal() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", BigDecimal.TEN, (byte) 2));
public void test_float() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", (float) 3, (byte) 2));
public void test_double() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", (double) 3, (byte) 2));
public void test_String() throws Exception {
Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?", "3", "2"));
public void test_Date() throws Exception {
Assert.assertEquals(false,
SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?<?",
new Date(System.currentTimeMillis()),
new Date(System.currentTimeMillis() - 10)));
public class EvalTest_multi_short extends TestCase {
public void test_byte() throws Exception {
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?", (short) 1, (byte) 2));
public void test_byte_1() throws Exception {
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?", (short) 1, "2"));
public void test_byte_2() throws Exception {
Assert.assertEquals(null, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?", (short) 1, null));
public void test_byte_3() throws Exception {
Assert.assertEquals(2, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? * ?", "2", (short) 1));
public class MySqlASTVisitorAdapterTest extends TestCase {
public void test_adapter() throws Exception {
MySqlASTVisitorAdapter adapter = new MySqlASTVisitorAdapter();
new MySqlBooleanExpr().accept(adapter);
new Limit().accept(adapter);
new MySqlTableIndex().accept(adapter);
new MySqlKey().accept(adapter);
new MySqlPrimaryKey().accept(adapter);
new MySqlIntervalExpr().accept(adapter);
new MySqlBinaryExpr().accept(adapter);
new MySqlPrepareStatement().accept(adapter);
new MySqlExecuteStatement().accept(adapter);
new MySqlDeleteStatement().accept(adapter);
new MySqlInsertStatement().accept(adapter);
new MySqlLoadXmlStatement().accept(adapter);
new MySqlReplaceStatement().accept(adapter);
new MySqlSelectGroupBy().accept(adapter);
new MySqlStartTransactionStatement().accept(adapter);
new MySqlRollbackStatement().accept(adapter);
new MySqlShowColumnsStatement().accept(adapter);
new MySqlShowTablesStatement().accept(adapter);
new MySqlShowDatabasesStatement().accept(adapter);
new MySqlShowWarningsStatement().accept(adapter);
new MySqlShowStatusStatement().accept(adapter);
new CobarShowStatus().accept(adapter);
new MySqlKillStatement().accept(adapter);
new MySqlBinlogStatement().accept(adapter);
new MySqlResetStatement().accept(adapter);
new MySqlCreateUserStatement().accept(adapter);
new UserSpecification().accept(adapter);
new MySqlDropUser().accept(adapter);
new MySqlDropTableStatement().accept(adapter);
new MySqlPartitionByKey().accept(adapter);
new MySqlOutFileExpr().accept(adapter);
new MySqlUpdateStatement().accept(adapter);
new MySqlSetTransactionIsolationLevelStatement().accept(adapter);
new MySqlSetNamesStatement().accept(adapter);
new MySqlShowMasterLogsStatement().accept(adapter);
new MySqlSetCharSetStatement().accept(adapter);
new MySqlShowAuthorsStatement().accept(adapter);
new MySqlShowCollationStatement().accept(adapter);
new MySqlShowBinLogEventsStatement().accept(adapter);
new MySqlShowCharacterSetStatement().accept(adapter);
new MySqlShowContributorsStatement().accept(adapter);
new MySqlShowCreateDatabaseStatement().accept(adapter);
new MySqlShowCreateEventStatement().accept(adapter);
new MySqlShowCreateFunctionStatement().accept(adapter);
new MySqlShowCreateProcedureStatement().accept(adapter);
new MySqlShowCreateTableStatement().accept(adapter);
new MySqlShowCreateTriggerStatement().accept(adapter);
new MySqlShowCreateViewStatement().accept(adapter);
new MySqlShowEngineStatement().accept(adapter);
new MySqlShowEnginesStatement().accept(adapter);
new MySqlShowErrorsStatement().accept(adapter);
new MySqlShowEventsStatement().accept(adapter);
new MySqlShowFunctionCodeStatement().accept(adapter);
new MySqlShowFunctionStatusStatement().accept(adapter);
new MySqlShowGrantsStatement().accept(adapter);
new MySqlUserName().accept(adapter);
new MySqlShowIndexesStatement().accept(adapter);
new MySqlShowKeysStatement().accept(adapter);
new MySqlShowMasterStatusStatement().accept(adapter);
new MySqlShowOpenTablesStatement().accept(adapter);
new MySqlShowBinaryLogsStatement().accept(adapter);
new MySqlShowPluginsStatement().accept(adapter);
new MySqlShowPrivilegesStatement().accept(adapter);
new MySqlShowProcedureCodeStatement().accept(adapter);
new MySqlShowProcedureStatusStatement().accept(adapter);
new MySqlShowProcessListStatement().accept(adapter);
new MySqlShowProfileStatement().accept(adapter);
new MySqlShowSlaveHostsStatement().accept(adapter);
new MySqlShowRelayLogEventsStatement().accept(adapter);
new MySqlShowSlaveStatusStatement().accept(adapter);
new MySqlShowTableStatusStatement().accept(adapter);
new MySqlShowTriggersStatement().accept(adapter);
new MySqlAlterTableStatement().accept(adapter);
new MySqlRenameTableStatement().accept(adapter);
new MySqlDropViewStatement().accept(adapter);
new MySqlUnionQuery().accept(adapter);
new MySqlUseIndexHint().accept(adapter);
new MySqlIgnoreIndexHint().accept(adapter);
new MySqlLockTableStatement().accept(adapter);
new MySqlUnlockTablesStatement().accept(adapter);
new MySqlForceIndexHint().accept(adapter);
new MySqlAlterTableChangeColumn().accept(adapter);
new MySqlAlterTableCharacter().accept(adapter);
new MySqlAlterTableAddIndex().accept(adapter);
new MySqlAlterTableOption().accept(adapter);
new MySqlCreateTableStatement().accept(adapter);
new MySqlHelpStatement().accept(adapter);
new MySqlCharExpr().accept(adapter);
new MySqlAlterTableAddUnique().accept(adapter);
new MySqlUnique().accept(adapter);
new MySqlForeignKey().accept(adapter);
new MySqlAlterTableModifyColumn().accept(adapter);
new MySqlAlterTableDiscardTablespace().accept(adapter);
new MySqlAlterTableImportTablespace().accept(adapter);
new TableSpaceOption().accept(adapter);
new MySqlPartitionByHash ().accept(adapter);
new MySqlPartitionByRange ().accept(adapter);
new MySqlPartitioningDef ().accept(adapter);
new LessThanValues ().accept(adapter);
new InValues ().accept(adapter);
new MySqlPartitionByList ().accept(adapter);
public class MySqlCreateTableTest46 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE lookup" + 
"  (id INT, INDEX USING BTREE (id))" + 
"  STATS_PERSISTENT 1;"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("lookup")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE lookup (" + 
"ntid INT, " + 
"ntINDEX USING BTREE(id)" + 
"n) STATS_PERSISTENT = 1", output);
public void test_where() throws Exception {
String sql = "SHOW STATUS WHERE X LIKE 'Key%'";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SHOW STATUS WHERE X LIKE 'Key%';", text);
public void test_corba() throws Exception {
String sql = "SHOW COBAR_STATUS";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SHOW COBAR_STATUS;", text);
"SELECT ALL * FROM t_department  " + 
SQLStatement stmt = statementList.get(0);
stmt.accept(visitor);
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT ALL *" + 
"nFROM t_department" + 
"nWHERE name IN ('0000', '4444')" + 
"nORDER BY name ASC;" + 
"n", text);
public class OracleSelectTest44 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT UNIQUE  * FROM ONLY (t_department)  " + 
"WHERE name IN ('0000','4444') " + 
"ORDER BY name ASC"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT UNIQUE *" + 
"nFROM ONLY (t_department)" + 
"nWHERE name IN ('0000', '4444')" + 
"nORDER BY name ASC;" + 
"n", text);
String expected = "WITHn" 
+ "tdept_costsn" 
+ "tASn" 
+ "t(n"
+ "ttSELECT department_name, SUM(salary) AS dept_totaln" 
+ "ttFROM employees e, departments dn"
+ "ttWHERE e.department_id = d.department_idn" 
+ "ttGROUP BY department_namen" 
+ "t), n" 
+ "tavg_costn" 
+ "tASn"
+ "t(n" 
+ "ttSELECT SUM(dept_total) / COUNT(*) AS avgn" 
+ "ttFROM dept_costsn" 
+ "t)n" 
+ "SELECT *n" 
+ "FROM dept_costsn" 
+ "WHERE dept_total > (n" 
+ "tSELECT avgn" 
+ "tFROM avg_costn" 
+ "t)n" 
+ "ORDER BY department_name;n";
public class OracleASTVisitorAdapterTest extends TestCase {
public void test_adapter() throws Exception {
OracleASTVisitorAdapter adapter = new OracleASTVisitorAdapter();
new OracleConstraintState().accept(adapter);
new OraclePLSQLCommitStatement().accept(adapter);
new OracleAnalytic().accept(adapter);
new OracleAnalyticWindowing().accept(adapter);
new OracleDateExpr().accept(adapter);
new OracleDbLinkExpr().accept(adapter);
new OracleExtractExpr().accept(adapter);
new OracleSelectForUpdate().accept(adapter);
new OracleSelectHierachicalQueryClause().accept(adapter);
new OracleSelectPivot.Item().accept(adapter);
new OracleSelectPivot().accept(adapter);
new CheckOption().accept(adapter);
new ReadOnly().accept(adapter);
new OracleSelectUnPivot().accept(adapter);
new OracleTimestampExpr().accept(adapter);
new PartitionExtensionClause().accept(adapter);
new VersionsFlashbackQueryClause().accept(adapter);
new VersionsFlashbackQueryClause().accept(adapter);
new AsOfFlashbackQueryClause().accept(adapter);
new GroupingSetExpr().accept(adapter);
new OracleWithSubqueryEntry().accept(adapter);
new OracleFileSpecification().accept(adapter);
new OracleAlterTablespaceAddDataFile().accept(adapter);
new OracleAlterTablespaceStatement().accept(adapter);
new OracleCreateSequenceStatement().accept(adapter);
new OracleRangeValuesClause().accept(adapter);
new OraclePartitionByRangeClause().accept(adapter);
new OracleLoopStatement().accept(adapter);
new OracleIntervalExpr().accept(adapter);
new OracleDeleteStatement().accept(adapter);
new OracleUpdateStatement().accept(adapter);
new SampleClause().accept(adapter);
new OracleSelectTableReference().accept(adapter);
new SearchClause().accept(adapter);
new CycleClause().accept(adapter);
new OracleBinaryFloatExpr().accept(adapter);
new OracleBinaryDoubleExpr().accept(adapter);
new OracleCursorExpr().accept(adapter);
new OracleIsSetExpr().accept(adapter);
new ReturnRowsClause().accept(adapter);
new ModelClause().accept(adapter);
new MainModelClause().accept(adapter);
new ModelColumnClause().accept(adapter);
new QueryPartitionClause().accept(adapter);
new ModelColumn().accept(adapter);
new ModelRulesClause().accept(adapter);
new CellAssignmentItem().accept(adapter);
new CellAssignment().accept(adapter);
new OracleMergeStatement().accept(adapter);
new MergeUpdateClause().accept(adapter);
new MergeInsertClause().accept(adapter);
new OracleErrorLoggingClause().accept(adapter);
new OracleReturningClause().accept(adapter);
new OracleInsertStatement().accept(adapter);
new InsertIntoClause().accept(adapter);
new OracleMultiInsertStatement().accept(adapter);
new ConditionalInsertClause().accept(adapter);
new ConditionalInsertClauseItem().accept(adapter);
new OracleSelectQueryBlock().accept(adapter);
new OracleBlockStatement().accept(adapter);
new OracleLockTableStatement().accept(adapter);
new OracleAlterSessionStatement().accept(adapter);
new OracleExprStatement().accept(adapter);
new OracleDatetimeExpr().accept(adapter);
new OracleExceptionStatement().accept(adapter);
new OracleExceptionStatement.Item().accept(adapter);
new OracleArgumentExpr().accept(adapter);
new OracleSetTransactionStatement().accept(adapter);
new OracleGrantStatement().accept(adapter);
new OracleDropSequenceStatement().accept(adapter);
new OracleDataTypeIntervalDay().accept(adapter);
new OracleDataTypeIntervalYear().accept(adapter);
new OracleDataTypeTimestamp().accept(adapter);
new OracleDropDatabaseLinkStatement().accept(adapter);
new OracleCreateDatabaseDbLinkStatement().accept(adapter);
new OracleCreateProcedureStatement().accept(adapter);
new OracleSavePointStatement().accept(adapter);
new OracleFetchStatement().accept(adapter);
new OracleExitStatement().accept(adapter);
new OracleExplainStatement().accept(adapter);
new OracleAlterProcedureStatement().accept(adapter);
new OracleAlterTableDropPartition().accept(adapter);
new OracleAlterTableTruncatePartition().accept(adapter);
new OracleAlterTableStatement().accept(adapter);
new OracleAlterTableSplitPartition.TableSpaceItem().accept(adapter);
new OracleAlterTableSplitPartition.UpdateIndexesClause().accept(adapter);
new OracleAlterTableSplitPartition.NestedTablePartitionSpec().accept(adapter);
new OracleAlterTableSplitPartition().accept(adapter);
new OracleAlterTableModify().accept(adapter);
new OracleCreateIndexStatement().accept(adapter);
new OracleAlterIndexStatement().accept(adapter);
new OracleForStatement().accept(adapter);
new OracleAlterIndexStatement().accept(adapter);
new Else().accept(adapter);
new ElseIf().accept(adapter);
new OracleIfStatement().accept(adapter);
new OracleRangeExpr().accept(adapter);
new OracleAlterTableAddConstaint().accept(adapter);
new OraclePrimaryKey().accept(adapter);
new OracleCreateTableStatement().accept(adapter);
new OracleAlterTableRenameTo().accept(adapter);
new OracleStorageClause().accept(adapter);
new OracleGotoStatement().accept(adapter);
new OracleLabelStatement().accept(adapter);
new OracleParameter().accept(adapter);
new OracleCommitStatement().accept(adapter);
new OracleAlterTriggerStatement().accept(adapter);
new OracleAlterSynonymStatement().accept(adapter);
new AsOfSnapshotClause().accept(adapter);
new OracleAlterViewStatement().accept(adapter);
new OracleAlterTableMoveTablespace().accept(adapter);
new OracleSizeExpr().accept(adapter);
public class PGASTVisitorAdapterTest extends TestCase {
public void test_adapter() throws Exception {
PGASTVisitorAdapter adapter = new PGASTVisitorAdapter();
new WindowClause().accept(adapter);
new FetchClause ().accept(adapter);
new ForClause ().accept(adapter);
new PGWithQuery ().accept(adapter);
new PGWithClause ().accept(adapter);
new PGTruncateStatement ().accept(adapter);
new PGDeleteStatement ().accept(adapter);
new PGParameter ().accept(adapter);
new PGFunctionTableSource ().accept(adapter);
public class DruidLobCreatorTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setInitialSize(1);
protected void tearDown() throws Exception {
dataSource.close();
public void test_lobCreator() throws Exception {
DruidLobCreator lobCreator = new DruidLobCreator();
Connection conn = dataSource.getConnection();
PreparedStatement ps = conn.prepareStatement("select 1");
lobCreator.setBlobAsBytes(ps, 1, new byte[0]);
lobCreator.setBlobAsBinaryStream(ps, 2, new ByteArrayInputStream(new byte[0]), 0);
lobCreator.setClobAsAsciiStream(ps, 3, new ByteArrayInputStream(new byte[0]), 0);
lobCreator.setClobAsCharacterStream(ps, 4, new StringReader(""), 0);
lobCreator.setClobAsString(ps, 5, "");
ps.close();
conn.close();
for (int i = 0; i < keys.length; ++i) {
map.replace(keys[i], "", "a");
for (int i = 0; i < keys.length; ++i) {
map.replace(keys[i], "", "b");
for (int i = 0; i < keys.length; ++i) {
map.replace(keys[i], "");
Assert.assertEquals(keys.length, map.size());
map.keys();
map.keys().hasMoreElements();
map.keys().nextElement();
map.size();
map.clear();
map.isEmpty();
map.entrySet().size();
map.entrySet().isEmpty();
map.entrySet().remove(null);
map.entrySet().clear();
map.entrySet().contains("");
map.values().size();
map.values().isEmpty();
map.values().remove(null);
map.values().clear();
map.values().contains("");
map.keySet().size();
map.keySet().isEmpty();
map.keySet().remove(null);
map.keySet().clear();
map.keySet().contains("");
public class JSONWriterTest extends TestCase {
public void test_intArray() throws Exception {
JSONWriter writer = new JSONWriter();
writer.writeObject(new int[] { 1, 2, 3 });
Assert.assertEquals("[1,2,3]", writer.toString());
public void test_throwable() throws Exception {
JSONWriter writer = new JSONWriter();
writer.writeObject(new Throwable() {
public void printStackTrace(PrintWriter s) {
Assert.assertEquals("{"Class":"com.alibaba.druid.bvt.utils.JSONWriterTest$1","Message":null,"StackTrace":""}",
writer.toString());
public class JdbcUtilsTest1 extends TestCase {
public void test_jdbc() throws Exception {
Assert.assertTrue(JdbcUtils.createDriver(MockDriver.class.getName()) instanceof MockDriver);
public void test_jdbc_1() throws Exception {
class MyClassLoader extends ClassLoader {
MyClassLoader classLoader = new MyClassLoader();
Assert.assertTrue(JdbcUtils.createDriver(classLoader, MockDriver.class.getName()) instanceof MockDriver);
public void test_jdbc_2() throws Exception {
class MyClassLoader extends ClassLoader {
public Class<?> loadClass(String name) throws ClassNotFoundException {
return null;
MyClassLoader classLoader = new MyClassLoader();
ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(classLoader);
Assert.assertTrue(JdbcUtils.createDriver(classLoader, MockDriver.class.getName()) instanceof MockDriver);
Thread.currentThread().setContextClassLoader(contextLoader);
public void test_jdbc_3() throws Exception {
class MyClassLoader extends ClassLoader {
public Class<?> loadClass(String name) throws ClassNotFoundException {
return null;
MyClassLoader classLoader = new MyClassLoader();
ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(null);
Assert.assertTrue(JdbcUtils.createDriver(classLoader, MockDriver.class.getName()) instanceof MockDriver);
Thread.currentThread().setContextClassLoader(contextLoader);
public User(){
public User(long id, String name){
this.id = id;
this.name = name;
configFromProperties(System.getProperties());
public void configFromProperties(Properties properties) {
String prop = properties.getProperty("druid.log.conn");
if ("false".equals(prop)) {
connectionLogEnabled = false;
} else if ("true".equals(prop)) {
connectionLogEnabled = true;
String prop = properties.getProperty("druid.log.stmt");
if ("false".equals(prop)) {
} else if ("true".equals(prop)) {
statementLogEnabled = true;
String prop = properties.getProperty("druid.log.rs");
if ("false".equals(prop)) {
} else if ("true".equals(prop)) {
resultSetLogEnabled = true;
String prop = properties.getProperty("druid.log.stmt.executableSql");
if ("true".equals(prop)) {
} else if ("false".equals(prop)) {
statementExecutableSqlLogEnable = false;
public class LogFilterTest4 extends TestCase {
public void test_properties() throws Exception {
LogFilter filter = new Log4jFilter();
Assert.assertEquals(true, filter.isConnectionLogEnabled());
Assert.assertEquals(true, filter.isStatementLogEnabled());
Assert.assertEquals(false, filter.isStatementExecutableSqlLogEnable());
Assert.assertEquals(true, filter.isResultSetLogEnabled());
public void test_properties_1() throws Exception {
System.setProperty("druid.log.conn", "false");
System.setProperty("druid.log.stmt", "false");
System.setProperty("druid.log.rs", "false");
System.setProperty("druid.log.stmt.executableSql", "true");
LogFilter filter = new Log4jFilter();
Assert.assertEquals(false, filter.isConnectionLogEnabled());
Assert.assertEquals(false, filter.isStatementLogEnabled());
Assert.assertEquals(true, filter.isStatementExecutableSqlLogEnable());
Assert.assertEquals(false, filter.isResultSetLogEnabled());
Properties properties = new Properties();
properties.setProperty("druid.log.conn", "true");
properties.setProperty("druid.log.stmt", "true");
properties.setProperty("druid.log.rs", "true");
properties.setProperty("druid.log.stmt.executableSql", "false");
filter.configFromProperties(properties);
Assert.assertEquals(true, filter.isConnectionLogEnabled());
Assert.assertEquals(true, filter.isStatementLogEnabled());
Assert.assertEquals(false, filter.isStatementExecutableSqlLogEnable());
Assert.assertEquals(true, filter.isResultSetLogEnabled());
} finally {
System.clearProperty("druid.log.conn");
System.clearProperty("druid.log.stmt");
System.clearProperty("druid.log.rs");
System.clearProperty("druid.log.stmt.executableSql");
public static String formatColumnToDateType(String columnName,String tableAlias,String pattern,String dbType){
StringBuilder sql = new StringBuilder();
if(!StringUtils.isEmpty(columnName)){
if(StringUtils.isEmpty(dbType))    dbType = JdbcConstants.MYSQL;
String formatMethod = "";
if(MYSQL.equalsIgnoreCase(dbType)){
formatMethod = "STR_TO_DATE";
if(StringUtils.isEmpty(pattern)) pattern = "%Y-%m-%d %H:%i:%s";
}else if(ORACLE.equalsIgnoreCase(dbType)){
formatMethod = "TO_DATE";
if(StringUtils.isEmpty(pattern)) pattern = "yyyy-mm-dd hh24:mi:ss";
sql.append(formatMethod).append("(");
if(!StringUtils.isEmpty(tableAlias))
sql.append(tableAlias).append(".");
sql.append(columnName).append(",");
sql.append("'");
sql.append(pattern);
sql.append("')");
return sql.toString();
public void test_formatColumnToDateType(){
String colunExp = JdbcUtils.formatColumnToDateType("gmt_create","oo","",JdbcConstants.ORACLE);
Assert.assertEquals("TO_DATE(oo.gmt_create,'yyyy-mm-dd hh24:mi:ss')", colunExp);
String colunExp2 = JdbcUtils.formatColumnToDateType("gmt_create","oo","",JdbcConstants.MYSQL);
Assert.assertEquals("STR_TO_DATE(oo.gmt_create,'%Y-%m-%d %H:%i:%s')", colunExp2);
public static String formatStrToDateColumn(String columnName,String tableAlias,String pattern,String dbType){
String colunExp = JdbcUtils.formatStrToDateColumn("gmt_create","oo","",JdbcConstants.ORACLE);
String colunExp2 = JdbcUtils.formatStrToDateColumn("gmt_create","oo","",JdbcConstants.MYSQL);
public static String buildToDate(String columnName,String tableAlias,String pattern,String dbType){
StringBuilder sql = new StringBuilder();
if(StringUtils.isEmpty(columnName))
return "";
if(StringUtils.isEmpty(dbType))    dbType = JdbcConstants.MYSQL;
String formatMethod = "";
if(JdbcConstants.MYSQL.equalsIgnoreCase(dbType)){
formatMethod = "STR_TO_DATE";
if(StringUtils.isEmpty(pattern)) pattern = "%Y-%m-%d %H:%i:%s";
}else if(JdbcConstants.ORACLE.equalsIgnoreCase(dbType)){
formatMethod = "TO_DATE";
if(StringUtils.isEmpty(pattern)) pattern = "yyyy-mm-dd hh24:mi:ss";
}else{
return "";
sql.append(formatMethod).append("(");
if(!StringUtils.isEmpty(tableAlias))
sql.append(tableAlias).append(".");
sql.append(columnName).append(",");
sql.append("'");
sql.append(pattern);
sql.append("')");
return sql.toString();
case COMMENT:
public static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "STDDEV", "SUM" };
this.aggregateFunctions = AGGREGATE_FUNCTIONS;
protected SQLAggregateExpr parseAggregateExprRest(SQLAggregateExpr aggregateExpr) {
if (lexer.token() == Token.ORDER) {
SQLOrderBy orderBy = this.parseOrderBy();
aggregateExpr.putAttribute("ORDER BY", orderBy);
if (identifierEquals("SEPARATOR")) {
lexer.nextToken();
SQLExpr seperator = this.primary();
aggregateExpr.putAttribute("SEPARATOR", seperator);
return aggregateExpr;
&& (!varName.startsWith(":"))) {
protected void visitAggreateRest(SQLAggregateExpr aggregateExpr) {
SQLOrderBy value = (SQLOrderBy) aggregateExpr.getAttribute("ORDER BY");
if (value != null) {
print(" ");
((SQLObject) value).accept(this);
Object value = aggregateExpr.getAttribute("SEPARATOR");
if (value != null) {
print(" SEPARATOR ");
((SQLObject) value).accept(this);
this.aggregateFunctions = AGGREGATE_FUNCTIONS;
this(new OracleLexer(text));
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "ROW_NUMBER" };
this(new PGLexer(sql));
this.aggregateFunctions = AGGREGATE_FUNCTIONS;
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "MAX", "MIN", "ROW_NUMBER", "STDDEV", "SUM" };
this.aggregateFunctions = AGGREGATE_FUNCTIONS;
public SQLServerExprParser(String sql){
this(new SQLServerLexer(sql));
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM" };
protected String[]           aggregateFunctions  = AGGREGATE_FUNCTIONS;
exprList(aggregateExpr.getArguments(), aggregateExpr);
parseAggregateExprRest(aggregateExpr);
protected SQLAggregateExpr parseAggregateExprRest(SQLAggregateExpr aggregateExpr) {
return aggregateExpr;
visitAggreateRest(x);
protected void visitAggreateRest(SQLAggregateExpr aggregateExpr) {
public class MySqlSelectTest_12 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT COUNT(*) a FROM (select nickname,mobile,comment,createdate from ub_userdiscuss order by discuss_id desc) b  ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(1, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ub_userdiscuss")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT COUNT(*) AS a" + 
"nFROM (SELECT nickname, mobile, comment, createdate" + 
"ntFROM ub_userdiscuss" + 
"ntORDER BY discuss_id DESC" + 
"nt) b", 
public class MySqlSelectTest_group_concat extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT GROUP_CONCAT(ext_customer_id Separator '.') " 
+ "from ad_texts " 
+ "where customer_id=13001 " 
+ "and description1 like '%%' " 
+ "order by id asc;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNotNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertEquals(1, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ad_texts")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT GROUP_CONCAT(ext_customer_id SEPARATOR '.')" 
+ "nFROM ad_texts" 
+ "nWHERE customer_id = 13001" 
+ "ntAND description1 LIKE '%%'" 
+ "nORDER BY id ASC", 
public class MySqlSelectTest_group_concat_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT student_name, " 
+ "GROUP_CONCAT(DISTINCT test_score " 
+ "    ORDER BY test_score DESC SEPARATOR ' ') " 
+ "FROM student " 
+ "GROUP BY student_name";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("student")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT student_name, GROUP_CONCAT(DISTINCT test_score ORDER BY test_score DESC SEPARATOR ' ')" 
+ "nFROM student" 
+ "nGROUP BY student_name", 
public final static int RevisionVersion = 22;
final int errorCode = e.getErrorCode();
SQLException exception = new SQLException("", "", -9000);
Assert.assertTrue(sorter.isExceptionFatal(exception));
com.mysql.jdbc.ConnectionImpl mysqlConn = (com.mysql.jdbc.ConnectionImpl)physicalConn;
if(mysqlConn.getPinGlobalTxToPhysicalConnection()) {
if (!Util.isJdbc4()) {
return new SuspendableXAConnection(mysqlConn);
return new com.mysql.jdbc.jdbc2.optional.JDBC4SuspendableXAConnection(mysqlConn);
return new MysqlXAConnection(mysqlConn, false);
Assert.assertFalse(provider.checkValid(
public final static int RevisionVersion = 23;
private String          lastSql;
public String getLastSql() {
return lastSql;
public void setLastSql(String lastSql) {
this.lastSql = lastSql;
mockConnection.setLastSql(sql);
public void setConnectionInitSqls(Collection<? extends Object> connectionInitSqls) {
for (Object o : connectionInitSqls) {
if (o == null) {
String s = o.toString();
s = s.trim();
if (s.length() == 0) {
if (newVal == null) {
newVal = new ArrayList<String>();
newVal.add(s);
Collection<String> initSqls = getConnectionInitSqls();
if (initSqls.size() == 0) {
Statement stmt = null;
stmt = conn.createStatement();
for (String sql : initSqls) {
if (sql == null) {
stmt.execute(sql);
} finally {
JdbcUtils.close(stmt);
public class DruidDataSourceTest_initSql extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
List<Object> sqlList = new ArrayList<Object>();
sqlList.add("select 123");
sqlList.add(null);
sqlList.add("");
dataSource.setConnectionInitSqls(sqlList);
protected void tearDown() throws Exception {
dataSource.close();
public void testDefault() throws Exception {
Connection conn = dataSource.getConnection();
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertEquals("select 123", mockConn.getLastSql());
conn.close();
public class DruidDataSourceTest_initSql_factory extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
Properties properties = new Properties();
properties.put(DruidDataSourceFactory.PROP_URL, "jdbc:mock:xxx");
properties.put(DruidDataSourceFactory.PROP_INITCONNECTIONSQLS, ";;select 123");
dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
protected void tearDown() throws Exception {
dataSource.close();
public void testDefault() throws Exception {
Connection conn = dataSource.getConnection();
MockConnection mockConn = conn.unwrap(MockConnection.class);
Assert.assertEquals("select 123", mockConn.getLastSql());
conn.close();
public class DruidDataSourceTest_initSqls extends TestCase {
val.setId(id);
protected final AtomicLong connectionIdSeed  = new AtomicLong(10000);
protected final AtomicLong statementIdSeed   = new AtomicLong(20000);
protected final AtomicLong resultSetIdSeed   = new AtomicLong(50000);
protected final AtomicLong transactionIdSeed = new AtomicLong(60000);
if (this.id > 1) {
long delta = (this.id - 1) * 100000;
this.connectionIdSeed.addAndGet(delta);
this.statementIdSeed.addAndGet(delta);
this.resultSetIdSeed.addAndGet(delta);
this.transactionIdSeed.addAndGet(delta);
final long currentTimeMillis = System.currentTimeMillis();
long idleMillis = currentTimeMillis - connection.getLastActiveTimeMillis();
if (LOG.isDebugEnabled()) {
long idleMillis = System.currentTimeMillis() - item.getLastActiveTimeMillis();
LOG.debug("connection destroyed. idleMillis : " + idleMillis);
public class LastActiveTest_0 extends TestCase {
private DruidDataSource dataSource;
private Field           field;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.setFilters("stat");
dataSource.setMinIdle(0);
dataSource.setMaxActive(100);
dataSource.init();
field = DruidPooledConnection.class.getDeclaredField("holder");
field.setAccessible(true);
protected void tearDown() throws Exception {
dataSource.close();
public void test_0() throws Exception {
long t0, t1;
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
t0 = getLastActiveTime(conn);
PreparedStatement stmt = conn.prepareStatement("select 1");
Thread.sleep(2);
stmt.execute();
stmt.close();
conn.close();
Thread.sleep(1000);
DruidPooledConnection conn = (DruidPooledConnection) dataSource.getConnection();
t1 = getLastActiveTime(conn);
PreparedStatement stmt = conn.prepareStatement("select 1");
Thread.sleep(2);
stmt.execute();
stmt.close();
conn.close();
Assert.assertNotEquals(t0, t1);
private long getLastActiveTime(DruidPooledConnection conn) throws IllegalAccessException {
DruidConnectionHolder holder = (DruidConnectionHolder) field.get(conn);
return holder.getLastActiveTimeMillis();
public class MySqlUpdateTest_3 extends MysqlTest {
public void test_0() throws Exception {
String sql = "update scheme.table set col_1 = 1, col2 = '2' " 
+ "where col_3 = 3 and (length(col_4) > 4 or col_5 <> '5')";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("scheme.table")));
Assert.assertTrue(visitor.getColumns().contains(new Column("scheme.table", "col_1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("scheme.table", "col2")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("UPDATE scheme.table" 
+ "nSET col_1 = 1, col2 = '2'"
+ "nWHERE col_3 = 3" 
+ "ntAND (length(col_4) > 4" 
+ "nttOR col_5 <> '5')", 
if (minEvictableIdleTimeMillis < 1000 * 30) {
LOG.error("minEvictableIdleTimeMillis should be greater than 30000");
if ("0:0:0:0:0:0:0:1".equals(remoteAddress)) {
return true;
return false;
if (text == null) {
@Override
public boolean visit(SQLDropIndexStatement x) {
setMode(x, Mode.DropIndex);
SQLName name = (SQLName) x.getTableName().getExpr();
String ident = name.toString();
setCurrentTable(ident);
TableStat stat = getTableStat(ident);
stat.incrementDropIndexCount();
Map<String, String> aliasMap = getAliasMap();
if (aliasMap != null) {
aliasMap.put(ident, ident);
return false;
int dropIndexCount   = 0;
public int getDropIndexCount() {
return dropIndexCount;
public void incrementDropIndexCount() {
this.dropIndexCount++;
if (dropIndexCount > 0) {
buf.append("DropIndex");
Drop(128), DropIndex(256); 
public class StatTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:h2:mem:test;");
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
dataSource.close();
public void test_0() throws Exception {
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("select * from INFORMATION_SCHEMA.SETTINGS");
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
DruidDataSourceStatValue dataSourceStatValue = dataSource.getStatValueAndReset();
Assert.assertEquals(1, dataSourceStatValue.getSqlList().size());
JdbcSqlStatValue sqlStat = dataSourceStatValue.getSqlList().get(0);
Assert.assertNotNull(sqlStat.getExecuteLastStartTime());
Assert.assertNotNull(sqlStat.getExecuteNanoSpanMaxOccurTime());
Assert.assertTrue(sqlStat.getExecuteMillisMax() > 0);
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("select * from INFORMATION_SCHEMA.SETTINGS");
ResultSet rs = stmt.executeQuery();
rs.close();
stmt.close();
conn.close();
String json = DruidStatService.getInstance().service("/sql-" + sqlStat.getId() + ".json");
Map map = (Map) JSONUtils.parse(json);
System.out.println(json);
public class MySqlDropIndexTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "drop index index_name on table_name ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLDropIndexStatement stmt = (SQLDropIndexStatement) statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("table_name")));
TableStat tableStat = visitor.getTables().get(new TableStat.Name("table_name"));
Assert.assertEquals(1, tableStat.getDropIndexCount());
if (reset) {
executeLastStartTime = 0;
if (reset) {
executeNanoSpanMaxOccurTime = 0;
if (reset) {
executeErrorLast = null;
if (reset) {
executeErrorLastTime = 0;
if (reset) {
lastSlowParameters = null;
dataSource.setFilters("mergeStat");
if (realDriverClassName.equals(JdbcConstants.MYSQL_DRIVER)) {
} else if (realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER)) {
} else if (realDriverClassName.equals(JdbcConstants.DB2_DRIVER)) {
this.exceptionSorter = new DB2ExceptionSorter();
public class DB2ExceptionSorter implements ExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
int errorCode = e.getErrorCode();
switch (errorCode) { 
return true;
return false;
public void configFromProperties(Properties properties) {
String sqlState = e.getSQLState();
if (sqlState != null && sqlState.startsWith("08")) { 
return true;
switch (errorCode) {
case -512: 
case -514: 
case -516: 
case -518: 
case -525: 
case -909: 
case -918: 
case -924: 
} else if (realDriverClassName.contains("DB2")) {
public final static int RevisionVersion = 24;
public static final String           PARAM_NAME_REAL_IP_HEADER         = "realIpHeader";
private String                       realIpHeader;
String ip = getRemoteAddress(request);
protected String getRemoteAddress(HttpServletRequest request) {
String ip = null;
if (this.realIpHeader != null && this.realIpHeader.length() != 0) {
ip = request.getHeader(realIpHeader);
if (ip == null || ip.length() == 0) {
ip = DruidWebUtils.getRemoteAddr(request);
return ip;
String param = config.getInitParameter(PARAM_NAME_REAL_IP_HEADER);
if (param != null) {
param = param.trim();
if (param.length() != 0) {
this.realIpHeader = param;
+ "nFROM DSN81010.EMP"
+ "nFETCH FIRST 5 ROWS ONLY", 
SQLExpr left = x.getLeft();
SQLExpr right = x.getRight();
if (left instanceof SQLLiteralExpr && right instanceof SQLLiteralExpr) {
left.putAttribute(ATTR_PARAMS_SKIP, true);
right.putAttribute(ATTR_PARAMS_SKIP, true);
if (right instanceof SQLLiteralExpr) {
if ((left instanceof SQLBinaryOpExpr) && (right instanceof SQLBinaryOpExpr)) {
SQLBinaryOpExpr leftBinary = (SQLBinaryOpExpr) x.getLeft();
SQLBinaryOpExpr rightBinary = (SQLBinaryOpExpr) x.getRight();
if (mergeEqual(leftBinary, rightBinary)) {
return leftBinary;
if (isLiteralExpr(leftBinary.getLeft()) && leftBinary.getOperator() == SQLBinaryOperator.BooleanOr) {
if (mergeEqual(leftBinary.getRight(), right)) {
return leftBinary;
ClassLoader ctxClassLoader = Thread.currentThread().getContextClassLoader();
if (ctxClassLoader != null) {
for (Enumeration<URL> e = ctxClassLoader.getResources("META-INF/druid-driver.properties"); e.hasMoreElements();) {
URL url = e.nextElement();
Properties property = new Properties();
InputStream is = null;
is = url.openStream();
property.load(is);
} finally {
JdbcUtils.close(is);
driverUrlMapping.putAll(property);
ClassLoader ctxClassLoader = Thread.currentThread().getContextClassLoader();
if (ctxClassLoader != null) {
clazz = ctxClassLoader.loadClass(className);
} catch (ClassNotFoundException e) {
public boolean visit(DB2SelectQueryBlock x) {
WallVisitorUtils.checkSelelct(this, x);
return true;
public class Bug_for_wdw1206 extends TestCase {
private ClassLoader     ctxClassLoader;
private DruidDataSource dataSource;
protected void setUp() throws Exception {
ctxClassLoader = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(null);
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setPoolPreparedStatements(false);
dataSource.setTestOnBorrow(true);
dataSource.setFilters("stat");
protected void tearDown() throws Exception {
Thread.currentThread().setContextClassLoader(ctxClassLoader);
JdbcUtils.close(dataSource);
public void test_nullCtxClassLoader() throws Exception {
Connection conn = dataSource.getConnection();
conn.close();
@SuppressWarnings("rawtypes")
public class LogFactory {
private static Constructor logConstructor;
tryImplementation("org.slf4j.Logger", "com.alibaba.druid.support.logging.SLF4JImpl");
tryImplementation("org.apache.log4j.Logger", "com.alibaba.druid.support.logging.Log4jImpl");
tryImplementation("java.util.logging.Logger", "com.alibaba.druid.support.logging.Jdk14LoggingImpl");
tryImplementation("org.apache.commons.logging.LogFactory",
"com.alibaba.druid.support.logging.JakartaCommonsLoggingImpl");
if (logConstructor == null) {
logConstructor = NoLoggingImpl.class.getConstructor(String.class);
} catch (Exception e) {
throw new IllegalStateException(e.getMessage(), e);
@SuppressWarnings("unchecked")
private static void tryImplementation(String testClassName, String implClassName) {
if (logConstructor != null) {
Resources.classForName(testClassName);
Class implClass = Resources.classForName(implClassName);
logConstructor = implClass.getConstructor(new Class[] { String.class });
Class<?> declareClass = logConstructor.getDeclaringClass();
if (!Log.class.isAssignableFrom(declareClass)) {
logConstructor = null;
logConstructor.newInstance(LogFactory.class.getName());
} catch (Throwable t) {
logConstructor = null;
} catch (Throwable t) {
public static Log getLog(Class clazz) {
return getLog(clazz.getName());
public static Log getLog(String loggerName) {
return (Log) logConstructor.newInstance(new Object[] { loggerName });
} catch (Throwable t) {
throw new RuntimeException("Error creating logger for logger '" + loggerName + "'.  Cause: " + t, t);
@SuppressWarnings("unchecked")
public static synchronized void selectLog4JLogging() {
Resources.classForName("org.apache.log4j.Logger");
Class implClass = Resources.classForName("com.alibaba.druid.support.logging.Log4jImpl");
logConstructor = implClass.getConstructor(new Class[] { String.class });
} catch (Throwable t) {
@SuppressWarnings("unchecked")
public static synchronized void selectJavaLogging() {
Resources.classForName("java.util.logging.Logger");
Class implClass = Resources.classForName("com.alibaba.druid.support.logging.Jdk14LoggingImpl");
logConstructor = implClass.getConstructor(new Class[] { String.class });
} catch (Throwable t) {
aggregateExpr.setOver(new SQLOver(orderBy));
select.setOrderBy(null);
tryImplementation("java.util.logging.Logger", "com.alibaba.druid.support.logging.Jdk14LoggingImpl");
+ "nFROM (SELECT *, ROW_NUMBER() OVER () AS ROWNUM"
+ "nFROM (SELECT *, ROW_NUMBER() OVER () AS ROWNUM"
public String toString() {
return SQLUtils.toOracleString(this);
public abstract class SQLStatementImpl extends SQLObjectImpl implements SQLStatement {
private static final long serialVersionUID = 1L;
public SQLStatementImpl(){
public String toString() {
return SQLUtils.toSQLString(this);
protected void accept0(SQLASTVisitor visitor) {
throw new UnsupportedOperationException(this.getClass().getName());
public class OracleMergeTest7 extends OracleTest {
public void test_0() throws Exception {
String sql = "MERGE INTO copy_emp c " + 
"USING employees e " + 
"ON (c.employee_id=e.employee_id) " + 
"WHEN MATCHED THEN " + 
"UPDATE SET " + 
"c.first_name=e.first_name, " + 
"c.last_name=e.last_name, " + 
"c.department_id=e.department_id " + 
"WHEN NOT MATCHED THEN " + 
"INSERT VALUES(e.employee_id,e.first_name,e.last_name," + 
"e.email,e.phone_number,e.hire_date,e.job_id, " + 
"e.salary,e.commission_pct,e.manager_id,e.department_id)";
SQLStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
OracleMergeStatement mergeStatement = (OracleMergeStatement) stmtList.get(0);
String result = SQLUtils.toOracleString(mergeStatement);
Assert.assertEquals("MERGE INTO copy_emp c" 
+ "nUSING employees e ON c.employee_id = e.employee_id" 
+ "nWHEN MATCHED THEN UPDATE SET c.first_name = e.first_name, c.last_name = e.last_name, c.department_id = e.department_id" 
+ "nWHEN NOT MATCHED THEN INSERT VALUES (e.employee_id, e.first_name, e.last_name, e.email, e.phone_number, e.hire_date, e.job_id, e.salary, e.commission_pct, e.manager_id, e.department_id)",
SQLBinaryOpExpr gt = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), 
SQLBinaryOperator.GreaterThan, 
new SQLNumberExpr(offset));
SQLBinaryOpExpr lteq = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), 
SQLBinaryOperator.LessThanOrEqual, 
new SQLNumberExpr(count + offset));
SQLBinaryOpExpr pageCondition = new SQLBinaryOpExpr(gt, SQLBinaryOperator.BooleanAnd, lteq);
DB2SelectQueryBlock countQueryBlock = new DB2SelectQueryBlock();
countQueryBlock.getSelectList().add(new SQLSelectItem(new SQLPropertyExpr(new SQLIdentifierExpr("XX"), "*")));
SQLAggregateExpr aggregateExpr = new SQLAggregateExpr("ROW_NUMBER");
SQLOrderBy orderBy = select.getOrderBy();
aggregateExpr.setOver(new SQLOver(orderBy));
select.setOrderBy(null);
countQueryBlock.getSelectList().add(new SQLSelectItem(aggregateExpr, "ROWNUM"));
countQueryBlock.setFrom(new SQLSubqueryTableSource(select, "XX"));
if (offset <= 0) {
return SQLUtils.toSQLString(countQueryBlock, dbType);
DB2SelectQueryBlock offsetQueryBlock = new DB2SelectQueryBlock();
offsetQueryBlock.getSelectList().add(new SQLSelectItem(new SQLAllColumnExpr()));
offsetQueryBlock.setFrom(new SQLSubqueryTableSource(new SQLSelect(countQueryBlock), "XXX"));
offsetQueryBlock.setWhere(pageCondition);
return SQLUtils.toSQLString(offsetQueryBlock, dbType);
SQLBinaryOpExpr gt = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), 
SQLBinaryOperator.GreaterThan, 
new SQLNumberExpr(offset));
SQLBinaryOpExpr lteq = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), 
SQLBinaryOperator.LessThanOrEqual, 
new SQLNumberExpr(count + offset));
SQLBinaryOpExpr pageCondition = new SQLBinaryOpExpr(gt, SQLBinaryOperator.BooleanAnd, lteq);
SQLServerSelectQueryBlock countQueryBlock = new SQLServerSelectQueryBlock();
SQLServerSelectQueryBlock countQueryBlock = new SQLServerSelectQueryBlock();
countQueryBlock.getSelectList().add(new SQLSelectItem(new SQLPropertyExpr(new SQLIdentifierExpr("XX"), "*")));
SQLAggregateExpr aggregateExpr = new SQLAggregateExpr("ROW_NUMBER");
SQLOrderBy orderBy = select.getOrderBy();
aggregateExpr.setOver(new SQLOver(orderBy));
select.setOrderBy(null);
countQueryBlock.getSelectList().add(new SQLSelectItem(aggregateExpr, "ROWNUM"));
countQueryBlock.setFrom(new SQLSubqueryTableSource(select, "XX"));
if (offset <= 0) {
return SQLUtils.toSQLString(countQueryBlock, dbType);
SQLServerSelectQueryBlock offsetQueryBlock = new SQLServerSelectQueryBlock();
offsetQueryBlock.getSelectList().add(new SQLSelectItem(new SQLAllColumnExpr()));
offsetQueryBlock.setFrom(new SQLSubqueryTableSource(new SQLSelect(countQueryBlock), "XXX"));
offsetQueryBlock.setWhere(pageCondition);
return SQLUtils.toSQLString(offsetQueryBlock, dbType);
public class PagerUtilsTest_Limit_SQLServer_1 extends TestCase {
public void test_db2_union() throws Exception {
String sql = "select * from t1 union select * from t2";
String result = PagerUtils.limit(sql, JdbcConstants.SQL_SERVER, 20, 10);
Assert.assertEquals("SELECT *" 
+ "nFROM (SELECT XX.*, ROW_NUMBER() OVER () AS ROWNUM" 
+ "ntFROM (SELECT *" 
+ "nttFROM t1" 
+ "nttUNION" 
+ "nttSELECT *" 
+ "nttFROM t2" 
+ "ntt) XX" 
+ "nt) XXX" 
+ "nWHERE ROWNUM > 20" 
+ "ntAND ROWNUM <= 30", result);
public class PagerUtilsTest_Limit_db2_1 extends TestCase {
public void test_db2_union() throws Exception {
String sql = "select * from t1 union select * from t2";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 20, 10);
Assert.assertEquals("SELECT *" 
+ "nFROM (SELECT XX.*, ROW_NUMBER() OVER () AS ROWNUM" 
+ "ntFROM (SELECT *" 
+ "nttFROM t1" 
+ "nttUNION" 
+ "nttSELECT *" 
+ "nttFROM t2" 
+ "ntt) XX" 
+ "nt) XXX" 
+ "nWHERE ROWNUM > 20" 
+ "ntAND ROWNUM <= 30", result);
aggregateExpr.setOver(new SQLOver(orderBy));
select.setOrderBy(null);
countQueryBlock.setTop(new SQLServerTop(new SQLNumberExpr(count)));
SQLAggregateExpr aggregateExpr = new SQLAggregateExpr("ROW_NUMBER");
SQLOrderBy orderBy = select.getOrderBy();
aggregateExpr.setOver(new SQLOver(orderBy));
select.setOrderBy(null);
countQueryBlock.getSelectList().add(new SQLSelectItem(aggregateExpr, "ROWNUM"));
public class PagerUtilsTest_Limit_SQLServer_2 extends TestCase {
public void test_db2_union() throws Exception {
String sql = "select * from t1 union select * from t2";
String result = PagerUtils.limit(sql, JdbcConstants.SQL_SERVER, 0, 10);
Assert.assertEquals("SELECT TOP 10 XX.*" 
+ "nFROM (SELECT *" 
+ "ntFROM t1" 
+ "ntUNION" 
+ "ntSELECT *" 
+ "ntFROM t2" 
+ "nt) XX", result);
public class PagerUtilsTest_Limit_SQLServer_3 extends TestCase {
public void test_db2_union() throws Exception {
String sql = "select * from t1 where id > 1";
String result = PagerUtils.limit(sql, JdbcConstants.SQL_SERVER, 0, 10);
Assert.assertEquals("SELECT TOP 10 *" 
+ "nFROM t1" 
+ "nWHERE id > 1", result);
public class PagerUtilsTest_Limit_SQLServer_4 extends TestCase {
public void test_db2_union() throws Exception {
String sql = "select * from t1 where id > 1";
String result = PagerUtils.limit(sql, JdbcConstants.SQL_SERVER, 100, 10);
Assert.assertEquals("SELECT *" 
+ "nFROM (SELECT *, ROW_NUMBER() OVER () AS ROWNUM" 
+ "ntFROM t1" 
+ "ntWHERE id > 1" 
+ "nt) XX" 
+ "nWHERE ROWNUM > 100" 
+ "ntAND ROWNUM <= 110", result);
public synchronized void init(DataSourceProxy dataSource) {
SQLSubqueryTableSource fromSubquery = new SQLSubqueryTableSource(select);
fromSubquery.setAlias("ALIAS_COUNT_TABLE");
countSelectQuery.setFrom(fromSubquery);
public class PagerUtilsTest_Count_MySql_0 extends TestCase {
public void test_mysql_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt) ALIAS_COUNT_TABLE", result);
public void test_mysql_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt) ALIAS_COUNT_TABLE", result);
public class PagerUtilsTest_Count_Oracle_0 extends TestCase {
public void test_oracle_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt) ALIAS_COUNT_TABLE", result);
public void test_oracle_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt) ALIAS_COUNT_TABLE", result);
public class PagerUtilsTest_Count_PG_0 extends TestCase {
public void test_pg_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt) ALIAS_COUNT_TABLE", result);
public void test_pg_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt) ALIAS_COUNT_TABLE", result);
public class PagerUtilsTest_Count_SQLServer_0 extends TestCase {
public void test_sqlserver_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt) ALIAS_COUNT_TABLE", result);
public void test_sqlserver_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt) ALIAS_COUNT_TABLE", result);
public class PagerUtilsTest_Limit_db2_0 extends TestCase {
public void test_mysql_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 0, 10);
Assert.assertEquals("SELECT *" + 
"nFROM t" + 
"nFETCH FIRST 10 ROWS ONLY", result);
public void test_mysql_1() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 10, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT *, ROW_NUMBER() OVER () AS ROWNUM"
+ "ntFROM t"
+ "nt) XX"
+ "nWHERE ROWNUM > 10"
+ "ntAND ROWNUM <= 20", result);
public void test_mysql_2() throws Exception {
String sql = "select * from t where age > 100";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 20, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT *, ROW_NUMBER() OVER () AS ROWNUM"
+ "ntFROM t"
+ "ntWHERE age > 100"
+ "nt) XX"
+ "nWHERE ROWNUM > 20"
+ "ntAND ROWNUM <= 30", result);
public void test_mysql_3() throws Exception {
String sql = "select id, name, salary from t order by id, name";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 20, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT id, name, salary, ROW_NUMBER() OVER (ORDER BY id, name) AS ROWNUM"
+ "ntFROM t"
+ "nt) XX"
+ "nWHERE ROWNUM > 20"
+ "ntAND ROWNUM <= 30", result);
countSelectQuery.setFrom(new SQLSubqueryTableSource(select));
public class PagerUtilsTest_Count_MySql_0 extends TestCase {
public void test_mysql_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_mysql_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_mysql_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.MYSQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Count_Oracle_0 extends TestCase {
public void test_oracle_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_oracle_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_oracle_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.ORACLE);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Count_PG_0 extends TestCase {
public void test_pg_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_pg_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_pg_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.POSTGRESQL);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Count_SQLServer_0 extends TestCase {
public void test_sqlserver_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_1() throws Exception {
String sql = "select id, name from t";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_2() throws Exception {
String sql = "select id, name from t order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM t", result);
public void test_sqlserver_group_0() throws Exception {
String sql = "select type, count(*) from t group by type";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)" + 
"nFROM (SELECT type, COUNT(*)" + 
"ntFROM t" + 
"ntGROUP BY type" + 
"nt)", result);
public void test_sqlserver_union_0() throws Exception {
String sql = "select id, name from t1 union select id, name from t2 order by id";
String result = PagerUtils.count(sql, JdbcConstants.SQL_SERVER);
Assert.assertEquals("SELECT COUNT(*)n" + 
"FROM (SELECT id, name" + 
"ntFROM t1" + 
"ntUNION" + 
"ntSELECT id, name" + 
"ntFROM t2" + 
"nt)", result);
public class PagerUtilsTest_Limit_db2_0 extends TestCase {
public void test_mysql_0() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 0, 10);
Assert.assertEquals("SELECT *" + 
"nFROM t" + 
"nFETCH FIRST 10 ROWS ONLY", result);
public void test_mysql_1() throws Exception {
String sql = "select * from t";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 10, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT *, ROW_NUMBER() AS ROWNUM"
+ "ntFROM t"
+ "nt) XX"
+ "nWHERE ROWNUM > 10"
+ "ntAND ROWNUM <= 20", result);
public void test_mysql_2() throws Exception {
String sql = "select * from t where age > 100";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 20, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT *, ROW_NUMBER() AS ROWNUM"
+ "ntFROM t"
+ "ntWHERE age > 100"
+ "nt) XX"
+ "nWHERE ROWNUM > 20"
+ "ntAND ROWNUM <= 30", result);
public void test_mysql_3() throws Exception {
String sql = "select id, name, salary from t order by id, name";
String result = PagerUtils.limit(sql, JdbcConstants.DB2, 20, 10);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT id, name, salary, ROW_NUMBER() OVER (ORDER BY id, name) AS ROWNUM"
+ "ntFROM t"
+ "nt) XX"
+ "nWHERE ROWNUM > 20"
+ "ntAND ROWNUM <= 30", result);
SQLSubqueryTableSource fromSubquery = new SQLSubqueryTableSource(select);
fromSubquery.setAlias("ALIAS_COUNT");
countSelectQuery.setFrom(fromSubquery);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
"nt) ALIAS_COUNT", result);
public class CharTypes {
private final static boolean[] hexFlags = new boolean[256];
for (char c = 0; c < hexFlags.length; ++c) {
if (c >= 'A' && c <= 'F') {
hexFlags[c] = true;
} else if (c >= 'a' && c <= 'f') {
hexFlags[c] = true;
} else if (c >= '0' && c <= '9') {
hexFlags[c] = true;
public static boolean isHex(char c) {
return c < 256 && hexFlags[c];
public static boolean isDigit(char c) {
return c >= '0' && c <= '9';
private final static boolean[] firstIdentifierFlags = new boolean[256];
for (char c = 0; c < firstIdentifierFlags.length; ++c) {
if (c >= 'A' && c <= 'Z') {
firstIdentifierFlags[c] = true;
} else if (c >= 'a' && c <= 'z') {
firstIdentifierFlags[c] = true;
firstIdentifierFlags['`'] = true;
firstIdentifierFlags['_'] = true;
firstIdentifierFlags['$'] = true;
public static boolean isFirstIdentifierChar(char c) {
return c > firstIdentifierFlags.length || firstIdentifierFlags[c];
private final static boolean[] identifierFlags = new boolean[256];
for (char c = 0; c < identifierFlags.length; ++c) {
if (c >= 'A' && c <= 'Z') {
identifierFlags[c] = true;
} else if (c >= 'a' && c <= 'z') {
identifierFlags[c] = true;
} else if (c >= '0' && c <= '9') {
identifierFlags[c] = true;
identifierFlags['_'] = true;
identifierFlags['$'] = true;
identifierFlags['#'] = true;
public static boolean isIdentifierChar(char c) {
return c > identifierFlags.length || identifierFlags[c];
private final static boolean[] whitespaceFlags = new boolean[256];
whitespaceFlags[' '] = true;
whitespaceFlags['n'] = true;
whitespaceFlags['r'] = true;
whitespaceFlags['t'] = true;
whitespaceFlags['f'] = true;
whitespaceFlags['b'] = true;
whitespaceFlags[160] = true; 
public static boolean isWhitespace(char c) {
return (c <= whitespaceFlags.length && whitespaceFlags[c]) 
|| c == ''; 
public class OracleSelectTest45 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT T1.BC_ID AS BCID,SUM(PRODUCT_NUM) AS COUNT " 
+ "FROM MT_PRODUCT_ORDER T1 ,MT_ORDER T2 " 
+ "WHERE T1.MT_ORDER_ID= T2.MT_ORDER_ID " 
+ "AND T2.PUBLISH_TIME>= ? " 
+ "AND T1.STATES = '0' AND T2.STATES = '0' " 
+ "AND REFUND_STATE = '0' " 
+ "AND PRODUCT_ORDER_STATE >= 300 " 
+ "AND BC_ID in (?) " 
+ "GROUP BY BC_ID"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(10, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT T1.BC_ID AS BCID, SUM(PRODUCT_NUM) AS COUNT"
+ "nFROM MT_PRODUCT_ORDER T1, MT_ORDER T2"
+ "nWHERE T1.MT_ORDER_ID = T2.MT_ORDER_ID"
+ "ntAND T2.PUBLISH_TIME >= ?"
+ "ntAND T1.STATES = '0'"
+ "ntAND T2.STATES = '0'"
+ "ntAND REFUND_STATE = '0'"
+ "ntAND PRODUCT_ORDER_STATE >= 300"
+ "ntAND BC_ID IN (?)"
+ "nGROUP BY BC_ID;n", text);
print("SELECT ");
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
print("*/ ");
public class OracleHintTest extends TestCase {
public void test_hint1() throws Exception {
String sql = "SELECT +leading(e) index(e ORD_ORDER_ITEM_GS_BS_DI_IND) distinct e.id from ord_order_item e where e.F1 = Date '2011-10-01'";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
StringBuilder out = new StringBuilder();
stmt.accept(new OracleOutputVisitor(out, true));
String newSQL = out.toString();
Assert.assertEquals("SELECT +leading(e) index(e ORD_ORDER_ITEM_GS_BS_DI_IND) DISTINCT e.idnFROM ord_order_item enWHERE e.F1 = DATE '2011-10-01';n", newSQL);
public void test_hint2() throws Exception {
String sql = "SELECT +leading(e) index(e ORD_ORDER_ITEM_GS_BS_DI_IND) distinct e.id from ord_order_item e where e.F1 = Date '2011-10-01'";
String countSQL = PagerUtils.count(sql, JdbcUtils.ORACLE);
Assert.assertEquals("SELECT +leading(e) index(e ORD_ORDER_ITEM_GS_BS_DI_IND) DISTINCT COUNT(*)nFROM ord_order_item enWHERE e.F1 = DATE '2011-10-01'", countSQL);
public class DB2ParameterizedOutputVisitor extends DB2OutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
printValuesList(x);
protected void printValuesList(MySqlInsertStatement x) {
print("VALUES ");
if (x.getValuesList().size() > 1) {
incrementIndent();
for (int i = 0, size = x.getValuesList().size(); i < size; ++i) {
if (i != 0) {
print(",");
println();
x.getValuesList().get(i).accept(this);
if (x.getValuesList().size() > 1) {
decrementIndent();
public class MySqlParameterizedOutputVisitor extends MySqlOutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public MySqlParameterizedOutputVisitor(){
this(new StringBuilder());
public MySqlParameterizedOutputVisitor(Appendable appender){
super(appender);
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
public boolean visit(SQLInListExpr x) {
return ParameterizedOutputVisitorUtils.visit(this, x);
public boolean visit(SQLIdentifierExpr x) {
final String name = x.getName();
if (x.getParent() instanceof SQLExprTableSource || x.getParent() instanceof SQLPropertyExpr) {
int pos = name.lastIndexOf('_');
if (pos != -1 && pos != name.length()) {
boolean isNumber = true;
for (int i = pos + 1; i < name.length(); ++i) {
char ch = name.charAt(i);
if (ch < '0' || ch > '9') {
isNumber = false;
if (isNumber) {
String realName = name.substring(0, pos);
print(realName);
incrementReplaceCunt();
return false;
int numberCount = 0;
for (int i = name.length() - 1; i >= 0; --i) {
char ch = name.charAt(i);
if (ch < '0' || ch > '9') {
numberCount++;
if (numberCount > 1) {
int numPos = name.length() - numberCount;
String realName = name.substring(0, numPos);
print(realName);
incrementReplaceCunt();
return false;
print(name);
return false;
public boolean visit(SQLBinaryOpExpr x) {
x = ParameterizedOutputVisitorUtils.merge(x);
return super.visit(x);
public boolean visit(SQLNullExpr x) {
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLIntegerExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLNumberExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLCharExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLNCharExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
protected void printValuesList(MySqlInsertStatement x) {
print("VALUES ");
incrementIndent();
x.getValuesList().get(0).accept(this);
decrementIndent();
public class OracleParameterizedOutputVisitor extends OracleOutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public OracleParameterizedOutputVisitor(){
this(new StringBuilder());
public OracleParameterizedOutputVisitor(Appendable appender){
super(appender);
public OracleParameterizedOutputVisitor(Appendable appender, boolean printPostSemi){
super(appender, printPostSemi);
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
public boolean visit(SQLInListExpr x) {
return ParameterizedOutputVisitorUtils.visit(this, x);
public boolean visit(SQLBinaryOpExpr x) {
x = ParameterizedOutputVisitorUtils.merge(x);
return super.visit(x);
public boolean visit(SQLNullExpr x) {
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLIntegerExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLNumberExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLCharExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public boolean visit(SQLNCharExpr x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return super.visit(x);
print('?');
incrementReplaceCunt();
return false;
public class PGParameterizedOutputVisitor extends PGOutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public PGParameterizedOutputVisitor(){
this(new StringBuilder());
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
public class SQLServerParameterizedOutputVisitor extends SQLServerOutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
public class ParameterizedOutputVisitor extends SQLASTOutputVisitor implements ParameterizedVisitor {
private int replaceCount;
public int getReplaceCount() {
return this.replaceCount;
public void incrementReplaceCunt() {
replaceCount++;
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
incrementReplaceCunt();
public interface ParameterizedVisitor extends SQLASTVisitor {
int getReplaceCount();
void incrementReplaceCunt();
String mergedSql;
mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, dbType);
} catch (Exception ex) {
mergedSql = sql;
String mergedSql;
mergedSql = ParameterizedOutputVisitorUtils.parameterize(sql, dbType);
} catch (Exception ex) {
mergedSql = sql;
public class MySqlParameterizedOutputVisitorTest extends TestCase {
public void test_0() throws Exception {
validate("SELECT * FROM T WHERE ID IN (?, ?, ?)", "SELECT *nFROM TnWHERE ID IN (?)");
validate("SELECT * FROM T WHERE ID = 5", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE 1 = 0 AND ID = 5", "SELECT *nFROM TnWHERE 1 = 0ntAND ID = ?");
validate("SELECT * FROM T WHERE ID = ? OR ID = ?", "SELECT *nFROM TnWHERE ID = ?");
validate("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
validate("SELECT * FROM T WHERE 1 = 0 OR a.id = ? OR a.id = ? OR a.id = ? OR a.id = ?",
"SELECT *nFROM TnWHERE 1 = 0ntOR a.id = ?");
validateOracle("SELECT * FROM T WHERE 1 = 0 OR a.id = ? OR a.id = ? OR a.id = ? OR a.id = ?",
"SELECT *nFROM TnWHERE 1 = 0ntOR a.id = ?");
validateOracle("SELECT * FROM T WHERE A.ID = ? OR A.ID = ?", "SELECT *nFROM TnWHERE A.ID = ?");
validate("INSERT INTO T (F1, F2) VALUES(?, ?), (?, ?), (?, ?)", "INSERT INTO T (F1, F2)nVALUES (?, ?)");
validate("update net_device d, sys_user u set d.resp_user_id=u.id where d.resp_user_login_name=u.username and d.id in (42354)", 
"UPDATE net_device d, sys_user unSET d.resp_user_id = u.idnWHERE d.resp_user_login_name = u.usernamentAND d.id IN (?)");
void validate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
Assert.assertEquals(expect, out.toString());
void validateOracle(String sql, String expect) {
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
OracleParameterizedOutputVisitor visitor = new OracleParameterizedOutputVisitor(out, false);
statemen.accept(visitor);
Assert.assertEquals(expect, out.toString());
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
public ParameterizedOutputVisitor(){
this(new StringBuilder());
x = ParameterizedOutputVisitorUtils.merge(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
return ParameterizedOutputVisitorUtils.visit(this, x);
public static boolean visit(ParameterizedVisitor v, SQLInListExpr x) {
public static boolean visit(ParameterizedVisitor v, SQLIntegerExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
public static boolean visit(ParameterizedVisitor v, SQLNumberExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
public static boolean visit(ParameterizedVisitor v, SQLCharExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
public static boolean visit(ParameterizedVisitor v, SQLNCharExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
public static SQLBinaryOpExpr merge(ParameterizedVisitor v, SQLBinaryOpExpr x) {
if (x.getOperator() == SQLBinaryOperator.Equality 
|| x.getOperator() == SQLBinaryOperator.NotEqual) {
x = new SQLBinaryOpExpr(x.getLeft(), x.getOperator(), merge(v, (SQLBinaryOpExpr) x.getRight()));
x = new SQLBinaryOpExpr(merge(v, (SQLBinaryOpExpr) x.getLeft()), x.getOperator(), x.getRight());
if (isLiteralExpr(leftBinary.getLeft()) 
&& leftBinary.getOperator() == SQLBinaryOperator.BooleanOr) {
void print(char value);
void print(String text);
ParameterizedVisitor visitor = createParameterizedOutputVisitor(out, dbType);
if (visitor.getReplaceCount() == 0) {
return sql;
public static ParameterizedVisitor createParameterizedOutputVisitor(Appendable out, String dbType) {
List<SQLExpr> targetList = x.getTargetList();
boolean changed = true;
if (targetList.size() == 1 && targetList.get(0) instanceof SQLVariantRefExpr) {
changed = false;
if (changed) {
v.incrementReplaceCunt();
v.incrementReplaceCunt();
SQLExpr mergedRight = merge(v, (SQLBinaryOpExpr) x.getRight());
if (mergedRight != x.getRight()) {
x = new SQLBinaryOpExpr(x.getLeft(), x.getOperator(), mergedRight);
v.incrementReplaceCunt();
SQLExpr mergedLeft = merge(v, (SQLBinaryOpExpr) x.getLeft());
if (mergedLeft != x.getLeft()) {
x = new SQLBinaryOpExpr(mergedLeft, x.getOperator(), x.getRight());
v.incrementReplaceCunt();
v.incrementReplaceCunt();
v.incrementReplaceCunt();
public class MySqlParameterizedOutputVisitorTest_1 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT * FROM T WHERE ID IN (?)";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.ORACLE), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.DB2), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.SQL_SERVER), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.POSTGRESQL), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.H2), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.DERBY), sql);
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.HSQL), sql);
printAndAccept(x.getHints(), ", ");
print(' ');
print("*/");
private LRUCache<String, WallSqlStat>                 whiteMergedList;
private LRUCache<String, WallSqlStat>                 blackMergedList;
if (whiteMergedList == null) {
whiteMergedList = new LRUCache<String, WallSqlStat>(whiteSqlMaxSize);
wallStat = whiteMergedList.get(mergedSql);
whiteMergedList.put(mergedSql, wallStat);
if (blackMergedList == null) {
blackMergedList = new LRUCache<String, WallSqlStat>(blackSqlMaxSize);
wallStat = blackMergedList.get(mergedSql);
blackMergedList.put(mergedSql, wallStat);
if (whiteMergedList != null) {
hashSet.addAll(whiteMergedList.keySet());
if (blackMergedList != null) {
hashSet.addAll(blackMergedList.keySet());
if (whiteMergedList != null) {
whiteMergedList = null;
if (blackMergedList != null) {
blackMergedList = null;
final WallSelectQueryContext old = wallSelectQueryContextLocal.get();
wallSelectQueryContextLocal.set(new WallSelectQueryContext());
if (Boolean.TRUE == getConditionValue(visitor, x, visitor.getConfig().isSelectHavingAlwayTrueCheck())) {
boolean isSimpleConstExpr = false;
if (x instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) x;
if (binaryOpExpr.getOperator() == SQLBinaryOperator.Equality
|| binaryOpExpr.getOperator() == SQLBinaryOperator.NotEqual) {
if (binaryOpExpr.getLeft() instanceof SQLIntegerExpr
&& binaryOpExpr.getRight() instanceof SQLIntegerExpr) {
isSimpleConstExpr = true;
final WallSelectQueryContext current = wallSelectQueryContextLocal.get();
if (!isSimpleConstExpr && !(current != null && current.hasTrueLike())) {
addViolation(visitor, ErrorCode.ALWAY_TRUE, "having alway true condition not allow", x);
} finally {
wallSelectQueryContextLocal.set(old);
private boolean fromSysTable    = false;
private boolean fromSysSchema   = false;
private boolean fromPermitTable = false;
public boolean fromPermitTable() {
return fromPermitTable;
public void setFromPermitTable(boolean fromPermitTable) {
this.fromPermitTable = fromPermitTable;
if (isWhereOrHaving(x)) {
if ((x.getParent() instanceof SQLExpr) || (x.getParent() instanceof Item)) {
if (isInTableSource(x) && !visitor.getProvider().checkDenySchema(owner)) {
private static boolean isInTableSource(SQLObject x) {
for (;;) {
if (x instanceof SQLExpr) {
x = x.getParent();
if (x instanceof SQLExprTableSource) {
return true;
return false;
boolean isWhereQueryExpr = false;
isWhereQueryExpr = isWhereOrHaving(parent);
} else if (isWhereQueryExpr && parent instanceof SQLSelectQueryBlock) {
if (visitor.isDenyTable(tableName)
&& !(topStatementContext != null && topStatementContext.fromPermitTable())) {
if (visitor.getConfig().getPermitTables().contains(tableName)) {
if (isFirstSelectTableSource(x)) {
if (topStatementContext != null) {
topStatementContext.setFromPermitTable(Boolean.TRUE);
return false;
sqlStat.addUpdateCount(updateCount);
sqlStat.addAndFetchRowCount(fetchRowCount);
private volatile long                            fetchRowCount;
private volatile long                            updateCount;
final static AtomicLongFieldUpdater<WallSqlStat> executeCountUpdater  = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"executeCount");
final static AtomicLongFieldUpdater<WallSqlStat> fetchRowCountUpdater = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"fetchRowCount");
final static AtomicLongFieldUpdater<WallSqlStat> updateCountUpdater   = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"updateCount");
public long incrementAndGetFetchRowCount() {
return fetchRowCountUpdater.incrementAndGet(this);
public long addAndFetchRowCount(long delta) {
return fetchRowCountUpdater.addAndGet(this, delta);
return fetchRowCount;
public long getUpdateCount() {
return updateCount;
public void addUpdateCount(long delta) {
updateCountUpdater.addAndGet(this, delta);
statValue.setFetchRowCount(get(this, fetchRowCountUpdater, reset));
statValue.setUpdateCount(get(this, updateCountUpdater, reset));
private long    fetchRowCount;
private long    updateCount;
public long getFetchRowCount() {
return fetchRowCount;
public void setFetchRowCount(long fetchRowCount) {
this.fetchRowCount = fetchRowCount;
public long getUpdateCount() {
return updateCount;
public void setUpdateCount(long updateCount) {
this.updateCount = updateCount;
if (fetchRowCount > 0) {
sqlStatMap.put("fetchRowCount", fetchRowCount);
if (updateCount > 0) {
sqlStatMap.put("updateCount", updateCount);
if (violationMessage != null) {
sqlStatMap.put("violationMessage", violationMessage);
map.put("name", name);
if (pos != -1 && pos != name.length() - 1) {
public class MySqlParameterizedOutputVisitorTest_4 extends TestCase {
public void test_0() throws Exception {
String sql = "select user0_.id as id0_, user0_.email as email0_, " 
+ "user0_.login_name as login3_0_, user0_.name as name0_, "
+ "user0_.password as password0_ " 
+ "from acct_user user0_ "
+ "where user0_.login_name=? limit ?";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
validationQueryCheck();
case MODEL:
sqlExpr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextToken();
return  primaryRest(sqlExpr);
public class OracleSelectTest47 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select * from abc where model=?"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT *" 
+ "nFROM abc" 
+ "nWHERE model = ?;" 
+ "n", text);
} else if (lexer.token() == Token.IDENTIFIER) {
SQLAlterTableDropColumnItem item = new SQLAlterTableDropColumnItem();
item.setColumnName(this.exprParser.name());
stmt.getItems().add(item);
public class MySqlAlterTableDrop_Test extends TestCase {
public void test_alter_first() throws Exception {
String sql = "ALTER TABLE `rules` DROP `enabled`";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE `rules`" 
+ "ntDROP COLUMN `enabled`", output);
SQLExpr arg = this.expr();
arg.setParent(charType);
charType.getArguments().add(arg);
exprList(dataType.getArguments(), dataType);
SQLObject parent = x.getParent();
if (parent instanceof SQLDataType) {
return SQLASTOutputVisitorUtils.visit(v, x);
SQLObject parent = x.getParent();
if (parent instanceof SQLDataType) {
return SQLASTOutputVisitorUtils.visit(v, x);
public interface ParameterizedVisitor extends SQLPrintableVisitor {
public class SQLASTOutputVisitor extends SQLASTVisitorAdapter implements SQLPrintableVisitor {
return SQLASTOutputVisitorUtils.visit(this, x);
return SQLASTOutputVisitorUtils.visit(this, x);
public class SQLASTOutputVisitorUtils {
public static boolean visit(SQLPrintableVisitor visitor, SQLIntegerExpr x) {
visitor.print(x.getNumber().toString());
return false;
public static boolean visit(SQLPrintableVisitor visitor, SQLNumberExpr x) {
visitor.print(x.getNumber().toString());
return false;
public interface SQLPrintableVisitor extends SQLASTVisitor {
void print(char value);
void print(String text);
public class MySqlParameterizedOutputVisitorTest_5 extends TestCase {
public void test_0() throws Exception {
String sql = "ALTER TABLE `action_plans` ADD `kee` varchar(100)";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public void test_1() throws Exception {
String sql = "CREATE TABLE `snapshot_data` (`id` int(11) DEFAULT NULL auto_increment PRIMARY KEY, `snapshot_id` integer, `resource_id` integer, `snapshot_data` mediumtext, `data_type` varchar(50), `created_at` datetime, `updated_at` datetime) ENGINE=InnoDB CHARACTER SET utf8 COLLATE utf8_bin";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public void test_2() throws Exception {
String sql = "ALTER TABLE `active_rule_changes` ADD `username` varchar(200)";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public void test_3() throws Exception {
String sql = "CREATE TABLE `issue_changes` (`id` int(11) DEFAULT NULL auto_increment PRIMARY KEY, `kee` varchar(50), `issue_key` varchar(50) NOT NULL, `user_login` varchar(40), `change_type` varchar(20), `change_data` mediumtext, `created_at` datetime, `updated_at` datetime) ENGINE=InnoDB CHARACTER SET utf8 COLLATE utf8_bin";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public interface ParameterizedVisitor extends PrintableVisitor {
public interface PrintableVisitor extends SQLASTVisitor {
void print(char value);
void print(String text);
public class SQLASTOutputVisitor extends SQLASTVisitorAdapter implements PrintableVisitor {
public static boolean visit(PrintableVisitor visitor, SQLIntegerExpr x) {
public static boolean visit(PrintableVisitor visitor, SQLNumberExpr x) {
List<Map<String, Object>> functions = (List<Map<String, Object>>) result.get("functions");
if (functions != null) {
List<Map<String, Object>> sortedArray = comparatorOrderBy(functions, parameters);
StringBuffer buf = new StringBuffer();
output(buf);
return buf.toString();
public static final long                           DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = 60 * 1000L;
public static final long                           DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS = 300 * 1000;
public class SQLAlterTableRenameColumn extends SQLObjectImpl implements SQLAlterTableItem {
private static final long serialVersionUID = 1L;
private SQLName           column;
private SQLName           to;
public SQLAlterTableRenameColumn(){
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, column);
acceptChild(visitor, to);
visitor.endVisit(this);
public SQLName getColumn() {
return column;
public void setColumn(SQLName column) {
this.column = column;
public SQLName getTo() {
return to;
public void setTo(SQLName to) {
this.to = to;
if (lexer.token() == Token.INDEX) {
SQLStatement stmt = parseDropIndex();
statementList.add(stmt);
continue;
} else if (lexer.token() == Token.IDENTIFIER) {
SQLAlterTableAddColumn item = parseAlterTableAddColumn();
stmt.getItems().add(item);
OracleAlterTableModify item = new OracleAlterTableModify();
SQLColumnDefinition columnDef = this.exprParser.parseColumn();
item.getColumns().add(columnDef);
stmt.getItems().add(item);
private SQLAlterTableItem parseAlterTableRename() {
if (lexer.token() == Token.COLUMN) {
lexer.nextToken();
SQLAlterTableRenameColumn renameColumn = new SQLAlterTableRenameColumn();
renameColumn.setColumn(this.exprParser.name());
accept(Token.TO);
renameColumn.setTo(this.exprParser.name());
return renameColumn;
} else if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLAlterTableDropColumnItem item = new SQLAlterTableDropColumnItem();
this.exprParser.names(item.getColumns());
stmt.getItems().add(item);
accept(Token.RPAREN);
} else if (lexer.token() == Token.COLUMN) {
lexer.nextToken();
SQLAlterTableDropColumnItem item = new SQLAlterTableDropColumnItem();
this.exprParser.names(item.getColumns());
stmt.getItems().add(item);
public boolean visit(SQLAlterTableRenameColumn x) {
print("RENAME COLUMN ");
x.getColumn().accept(this);
print(" TO ");
x.getTo().accept(this);
return false;
boolean visit(SQLAlterTableRenameColumn x);
void endVisit(SQLAlterTableRenameColumn x);
public boolean visit(SQLAlterTableRenameColumn x) {
return true;
public void endVisit(SQLAlterTableRenameColumn x) {
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
|| x instanceof SQLCreateViewStatement 
|| x instanceof OracleCreateSequenceStatement 
public class OracleWallTest2 extends TestCase {
public void test_true() throws Exception {
Assert.assertTrue(WallUtils.isValidateOracle("CREATE SEQUENCE projects_seq START WITH 10000"));
public class OracleWallTest3 extends TestCase {
public void test_true() throws Exception {
String sql = 
"select sequence_name from all_sequences  " 
+ "union select synonym_name" 
+ "   from all_synonyms us, all_sequences asq" 
+ "  where asq.sequence_name = us.table_name" 
+ "    and asq.sequence_owner = us.table_owner"; 
Assert.assertTrue(WallUtils.isValidateOracle(sql));
public class OracleAlterTableTest14 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE measure_data MODIFY measure_id NUMBER(38)";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("measure_data")));
Assert.assertEquals(1, visitor.getColumns().size());
public class OracleAlterTableTest15 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE extensions ADD core NUMBER(1)";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("extensions")));
Assert.assertEquals(1, visitor.getColumns().size());
public class OracleAlterTableTest16 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE extensions DROP COLUMN category";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("extensions")));
Assert.assertEquals(1, visitor.getColumns().size());
public class OracleAlterTableTest17 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE rules RENAME COLUMN temp_plugin_config_key to plugin_config_key";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("rules")));
Assert.assertEquals(2, visitor.getColumns().size());
public class OracleAlterTableTest18 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE project_measures DROP (diff_value_1, diff_value_2, diff_value_3)";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("project_measures")));
Assert.assertEquals(3, visitor.getColumns().size());
public class OracleCreateSequenceTest_1 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"CREATE SEQUENCE projects_seq START WITH 10000";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class OracleDropIndexTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP INDEX async_m_s_snapshot_id";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals("DROP INDEX async_m_s_snapshot_id",
SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
public class OracleSelectTest48 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select sequence_name from all_sequences  " 
+ "union select synonym_name" 
+ "   from all_synonyms us, all_sequences asq" 
+ "  where asq.sequence_name = us.table_name" 
+ "    and asq.sequence_owner = us.table_owner"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT sequence_name" 
+ "nFROM all_sequences" 
+ "nUNION" 
+ "nSELECT synonym_name" 
+ "nFROM all_synonyms us, all_sequences asq" 
+ "nWHERE asq.sequence_name = us.table_name" 
+ "ntAND asq.sequence_owner = us.table_owner;" 
+ "n", text);
dataSource.setUrl("jdbc:oracle:thin:@localhost:1521:sonardb");
dataSource.setUsername("sonar");
WallVisitorUtils.initWallTopStatementContext();
public void endVisit(SQLSelectStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
public void endVisit(SQLInsertStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
WallVisitorUtils.initWallTopStatementContext();
public void endVisit(SQLUpdateStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
@Override
public void endVisit(SQLSelectStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
@Override
public void endVisit(OracleInsertStatement x) {
endVisit((SQLInsertStatement) x);
@Override
public void endVisit(SQLInsertStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
@Override
public void endVisit(OracleMultiInsertStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
@Override
public void endVisit(OracleDeleteStatement x) {
endVisit((SQLDeleteStatement) x);
@Override
public void endVisit(SQLDeleteStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
public void endVisit(SQLSelectStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
public void endVisit(SQLInsertStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
public void endVisit(SQLDeleteStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
public void endVisit(SQLUpdateStatement x) {
WallVisitorUtils.clearWallTopStatementContext();
if (lexer.token() == Token.TABLESPACE) {
} else if (lexer.token() == Token.DISABLE) {
} else if (lexer.token() == Token.ENABLE) {
accept(Token.TABLESPACE);
accept(Token.TABLESPACE);
private static final long       serialVersionUID  = 1L;
private SQLName                 tablespace;
private SQLSelect               select;
private boolean                 inMemoryMetadata;
private boolean                 cursorSpecificSegment;
private Boolean                 parallel;
private OracleStorageClause     storage;
private boolean                 organizationIndex = false;
private SQLExpr                 ptcfree;
private SQLExpr                 pctused;
private SQLExpr                 initrans;
private SQLExpr                 maxtrans;
private Boolean                 logging;
private Boolean                 compress;
private boolean                 onCommit;
private boolean                 preserveRows;
private Boolean                 cache;
private SQLPartitioningClause   partitioning;
private DeferredSegmentCreation deferredSegmentCreation;
public DeferredSegmentCreation getDeferredSegmentCreation() {
return deferredSegmentCreation;
public void setDeferredSegmentCreation(DeferredSegmentCreation deferredSegmentCreation) {
this.deferredSegmentCreation = deferredSegmentCreation;
public static enum DeferredSegmentCreation {
IMMEDIATE, DEFERRED
private static final long      serialVersionUID = 1L;
private SQLName                name;
private List<SQLExpr>          columns          = new ArrayList<SQLExpr>();
private OracleUsingIndexClause using;
acceptChild(visitor, using);
public OracleUsingIndexClause getUsing() {
return using;
public void setUsing(OracleUsingIndexClause using) {
this.using = using;
@SuppressWarnings("serial")
public class OracleUsingIndexClause extends OracleSQLObjectImpl {
private SQLName index;
private SQLName tablespace;
private SQLExpr ptcfree;
private SQLExpr pctused;
private SQLExpr initrans;
private SQLExpr maxtrans;
private Boolean enable            = null;
private boolean computeStatistics = false;
public OracleUsingIndexClause(){
public void accept0(OracleASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, index);
acceptChild(visitor, tablespace);
visitor.endVisit(this);
public Boolean getEnable() {
return enable;
public void setEnable(Boolean enable) {
this.enable = enable;
public boolean isComputeStatistics() {
return computeStatistics;
public void setComputeStatistics(boolean computeStatistics) {
this.computeStatistics = computeStatistics;
public SQLName getIndex() {
return index;
public void setIndex(SQLName index) {
this.index = index;
public SQLName getTablespace() {
return tablespace;
public void setTablespace(SQLName tablespace) {
this.tablespace = tablespace;
public SQLExpr getPtcfree() {
return ptcfree;
public void setPtcfree(SQLExpr ptcfree) {
this.ptcfree = ptcfree;
public SQLExpr getPctused() {
return pctused;
public void setPctused(SQLExpr pctused) {
this.pctused = pctused;
public SQLExpr getInitrans() {
return initrans;
public void setInitrans(SQLExpr initrans) {
this.initrans = initrans;
public SQLExpr getMaxtrans() {
return maxtrans;
public void setMaxtrans(SQLExpr maxtrans) {
this.maxtrans = maxtrans;
if (lexer.token() == Token.TABLESPACE) {
} else if (lexer.token() == Token.PCTFREE) {
} else if (lexer.token() == Token.INITRANS) {
} else if (lexer.token() == Token.MAXTRANS) {
} else if (lexer.token() == Token.SEGMENT) {
lexer.nextToken();
accept(Token.CREATION);
if (lexer.token() == Token.IMMEDIATE) {
stmt.setDeferredSegmentCreation(DeferredSegmentCreation.IMMEDIATE);
accept(Token.DEFERRED);
stmt.setDeferredSegmentCreation(DeferredSegmentCreation.DEFERRED);
continue;
case PCTFREE:
case INITRANS:
case MAXTRANS:
case SEGMENT:
case CREATION:
case IMMEDIATE:
case DEFERRED:
OracleUsingIndexClause using = new OracleUsingIndexClause();
for (;;) {
if (lexer.token() == Token.TABLESPACE) {
lexer.nextToken();
using.setTablespace(this.name());
continue;
} else if (lexer.token() == Token.PCTFREE) {
lexer.nextToken();
using.setPtcfree(this.expr());
continue;
} else if (lexer.token() == Token.INITRANS) {
lexer.nextToken();
using.setInitrans(this.expr());
continue;
} else if (lexer.token() == Token.MAXTRANS) {
lexer.nextToken();
using.setMaxtrans(this.expr());
continue;
} else if (lexer.token() == Token.COMPUTE) {
lexer.nextToken();
acceptIdentifier("STATISTICS");
using.setComputeStatistics(true);
continue;
} else if (lexer.token() == Token.ENABLE) {
lexer.nextToken();
using.setEnable(true);
continue;
} else if (lexer.token() == Token.DISABLE) {
lexer.nextToken();
using.setEnable(false);
continue;
} else if (lexer.token() == Token.IDENTIFIER) {
using.setTablespace(this.name());
primaryKey.setUsing(using);
if (lexer.token() == Token.ENABLE) {
map.put("PCTFREE", Token.PCTFREE);
map.put("INITRANS", Token.INITRANS);
map.put("MAXTRANS", Token.MAXTRANS);
map.put("SEGMENT", Token.SEGMENT);
map.put("CREATION", Token.CREATION);
map.put("IMMEDIATE", Token.IMMEDIATE);
map.put("DEFERRED", Token.DEFERRED);
} else if (lexer.token() == Token.IMMEDIATE) {
if (lexer.token() == Token.ENABLE) {
} else if (lexer.token() == Token.DISABLE) {
if (lexer.token() == Token.ENABLE) {
} else if (lexer.token() == Token.DISABLE) {
if (lexer.token() == Token.ENABLE) {
} else if (lexer.token() == Token.DISABLE) {
} else if (lexer.token() == Token.TABLESPACE) {
if (lexer.token() == Token.TABLESPACE) {
} else if (lexer.token() == Token.DISABLE) {
} else if (lexer.token() == Token.ENABLE) {
if (lexer.token() == Token.TABLESPACE) {
if (lexer.token() == Token.TABLESPACE) {
boolean visit(OracleUsingIndexClause x);
void endVisit(OracleUsingIndexClause x);
@Override
public boolean visit(OracleUsingIndexClause x) {
return true;
@Override
public void endVisit(OracleUsingIndexClause x) {
if (x.getUsing() != null) {
print(" ");
x.getUsing().accept(this);
if (x.getPtcfree() != null) {
print(" PCTFREE ");
x.getPtcfree().accept(this);
if (x.getInitrans() != null) {
print(" INITRANS ");
x.getInitrans().accept(this);
if (x.getMaxtrans() != null) {
print(" MAXTRANS ");
x.getMaxtrans().accept(this);
if (x.getTablespace() != null) {
print(" TABLESPACE ");
x.getTablespace().accept(this);
@Override
public boolean visit(OracleUsingIndexClause x) {
print("USING INDEX");
if (x.getIndex() != null) {
print(' ');
x.getIndex().accept(this);
if (x.getPtcfree() != null) {
print(" PCTFREE ");
x.getPtcfree().accept(this);
if (x.getInitrans() != null) {
print(" INITRANS ");
x.getInitrans().accept(this);
if (x.getMaxtrans() != null) {
print(" MAXTRANS ");
x.getMaxtrans().accept(this);
if (x.isComputeStatistics()) {
print(" COMPUTE STATISTICS");
if (x.getTablespace() != null) {
print(" TABLESPACE ");
x.getTablespace().accept(this);
if (x.getEnable() != null) {
if (x.getEnable().booleanValue()) {
print(" ENABLE");
print(" DISABLE");
return false;
@Override
public void endVisit(OracleUsingIndexClause x) {
@Override
public boolean visit(OracleUsingIndexClause x) {
return false;
@Override
public void endVisit(OracleUsingIndexClause x) {
map.put("ENABLE", Token.ENABLE);
map.put("DISABLE", Token. DISABLE);
map.put("TABLESPACE", Token.TABLESPACE);
map.put("COMPUTE", Token.COMPUTE);
} else if (lexer.token() == Token.TABLESPACE) {
throw new ParserException("TODO " + lexer.token());
case COMPUTE:
case ENABLE:
case DISABLE:
} else if (lexer.token() == Token.DISABLE) {
} else if (lexer.token() == Token.ENABLE) {
TABLESPACE("TABLESPACE"),
PCTFREE("PCTFREE"),
INITRANS("INITRANS"),
MAXTRANS("MAXTRANS"),
ENABLE("ENABLE"),
DISABLE("DISABLE"),
SEGMENT("SEGMENT"),
CREATION("CREATION"),
IMMEDIATE("IMMEDIATE"),
DEFERRED("DEFERRED"),
COMPUTE("COMPUTE"),
"ALTER TABLE ws_i18n_translate_item ADD CONSTRAINT ws_i18n_translate_item_pk "
+ "PRIMARY KEY (id) USING INDEX ws_i18n_translate_item_pk";
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("ws_i18n_translate_item", "id")));
public class OracleCreateTableTest18 extends OracleTest {
public void test_types() throws Exception {
String sql = 
"  CREATE TABLE "SONAR"."AUTHORS" " 
+ "   (    "ID" NUMBER(38,0) NOT NULL ENABLE, " 
+ "    "PERSON_ID" NUMBER(38,0) NOT NULL ENABLE, " 
+ "    "LOGIN" VARCHAR2(100 BYTE), " 
+ "    "CREATED_AT" TIMESTAMP (6), " 
+ "    "UPDATED_AT" TIMESTAMP (6), " 
+ "     PRIMARY KEY ("ID")" 
+ "  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS " 
+ "  TABLESPACE "USERS"  ENABLE" 
+ "   ) SEGMENT CREATION DEFERRED " 
+ "  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 " 
+ " NOCOMPRESS LOGGING" 
+ "  TABLESPACE "USERS" ;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TABLE "SONAR"."AUTHORS" (" 
+ "nt"ID" NUMBER(38, 0) NOT NULL ENABLE," 
+ "nt"PERSON_ID" NUMBER(38, 0) NOT NULL ENABLE," 
+ "nt"LOGIN" VARCHAR2(100 BYTE)," 
+ "nt"CREATED_AT" TIMESTAMP(6)," 
+ "nt"UPDATED_AT" TIMESTAMP(6)," 
+ "ntPRIMARY KEY ("ID") USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS TABLESPACE "USERS" ENABLE" 
+ "n) PCTFREE 10 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING TABLESPACE "USERS"", 
SQLUtils.toSQLString(statement, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("SONAR.AUTHORS", "ID")));
Assert.assertTrue(0F == stmt.getFloat(1));
Assert.assertTrue(0F == stmt.getFloat("1"));
Assert.assertTrue(0D == stmt.getDouble(1));
Assert.assertTrue(0D == stmt.getDouble("1"));
public class SQLDropSequenceStatement extends SQLStatementImpl implements SQLDDLStatement {
private SQLName name;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
this.name = name;
private boolean                    purge;
protected boolean                  cascade      = false;
protected boolean                  restrict     = false;
protected boolean                  ifExists     = false;
private boolean                    temporary    = false;
public boolean isPurge() {
return purge;
public void setPurge(boolean purge) {
this.purge = purge;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
public boolean isCascade() {
return cascade;
public void setCascade(boolean cascade) {
this.cascade = cascade;
public boolean isRestrict() {
return restrict;
public void setRestrict(boolean restrict) {
this.restrict = restrict;
public boolean isTemporary() {
return temporary;
public void setTemporary(boolean temporary) {
this.temporary = temporary;
public class SQLDropTriggerStatement extends SQLStatementImpl implements SQLDDLStatement {
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public class SQLDropUserStatement extends SQLStatementImpl implements SQLDDLStatement {
protected void accept0(SQLASTVisitor visitor) {
protected boolean                  cascade      = false;
protected boolean                  restrict     = false;
protected boolean                  ifExists     = false;
public boolean isCascade() {
return cascade;
public void setCascade(boolean cascade) {
this.cascade = cascade;
public boolean isRestrict() {
return restrict;
public void setRestrict(boolean restrict) {
this.restrict = restrict;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
protected List<SQLExprTableSource> tableSources     = new ArrayList<SQLExprTableSource>(2);
private boolean                    purgeSnapshotLog = false;
private boolean                    only;
private Boolean                    restartIdentity;
private Boolean                    cascade;
public boolean isPurgeSnapshotLog() {
return purgeSnapshotLog;
public void setPurgeSnapshotLog(boolean purgeSnapshotLog) {
this.purgeSnapshotLog = purgeSnapshotLog;
public boolean isOnly() {
return only;
public void setOnly(boolean only) {
this.only = only;
public Boolean getRestartIdentity() {
return restartIdentity;
public void setRestartIdentity(Boolean restartIdentity) {
this.restartIdentity = restartIdentity;
public Boolean getCascade() {
return cascade;
public void setCascade(Boolean cascade) {
this.cascade = cascade;
if (lexer.token() == Token.USER) {
accept(Token.USER);
if (lexer.token() == Token.TRIGGER) {
public class OracleDropDbLinkStatement extends OracleStatementImpl {
private boolean isPublic;
return isPublic;
this.isPublic = value;
map.put("PURGE", Token.PURGE);
OracleDropDbLinkStatement stmt = new OracleDropDbLinkStatement();
if (lexer.token() == Token.VIEW) {
SQLStatement stmt = parseDropView(false);
statementList.add(stmt);
if (lexer.token() == Token.SEQUENCE) {
SQLDropSequenceStatement stmt = parseDropSequece(false);
statementList.add(stmt);
if (lexer.token() == Token.TRIGGER) {
SQLDropTriggerStatement stmt = parseDropTrigger(false);
statementList.add(stmt);
if (lexer.token() == Token.USER) {
SQLDropUserStatement stmt = parseDropUser();
} else if (lexer.token() == Token.TRIGGER) {
accept(Token.SEQUENCE);
boolean visit(OracleDropDbLinkStatement x);
void endVisit(OracleDropDbLinkStatement x);
public boolean visit(OracleDropDbLinkStatement x) {
public void endVisit(OracleDropDbLinkStatement x) {
if (x.getEnable().booleanValue()) {
if (x.getDeferrable().booleanValue()) {
public boolean visit(SQLTruncateStatement x) {
public boolean visit(OracleDropDbLinkStatement x) {
public void endVisit(OracleDropDbLinkStatement x) {
protected void printCascade() {
print(" CASCADE CONSTRAINTS");
public boolean visit(OracleDropDbLinkStatement x) {
public void endVisit(OracleDropDbLinkStatement x) {
public PGSQLStatementParser(String sql){
super(new PGExprParser(sql));
public boolean visit(SQLTruncateStatement x) {
map.put("SEQUENCE", Token.SEQUENCE);
map.put("TRIGGER", Token.TRIGGER);
map.put("USER", Token.USER);
case SEQUENCE:
case USER:
case SEQUENC
} else if (lexer.token() == Token.USER) {
} else if (lexer.token() == Token.TRIGGER) {
SQLStatement stmt = parseDropTrigger(false);
statementList.add(stmt);
continue;
if (identifierEquals("TEMPORARY")) {
lexer.nextToken();
stmt.setTemporary(true);
accept(Token.TABLE);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
for (;;) {
if (identifierEquals("RESTRICT")) {
lexer.nextToken();
stmt.setRestrict(true);
continue;
if (identifierEquals("CASCADE")) {
lexer.nextToken();
stmt.setCascade(true);
if (identifierEquals("CONSTRAINTS")) { 
lexer.nextToken();
continue;
if (lexer.token() == Token.PURGE) {
lexer.nextToken();
stmt.setPurge(true);
continue;
return stmt;
protected SQLDropSequenceStatement parseDropSequece(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
lexer.nextToken();
SQLName name = this.exprParser.name();
SQLDropSequenceStatement stmt = new SQLDropSequenceStatement();
stmt.setName(name);
return stmt;
protected SQLDropTriggerStatement parseDropTrigger(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
lexer.nextToken();
SQLName name = this.exprParser.name();
SQLDropTriggerStatement stmt = new SQLDropTriggerStatement();
stmt.setName(name);
accept(Token.VIEW);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
if (identifierEquals("RESTRICT")) {
lexer.nextToken();
stmt.setRestrict(true);
} else if (identifierEquals("CASCADE")) {
lexer.nextToken();
if (identifierEquals("CONSTRAINTS")) { 
lexer.nextToken();
stmt.setCascade(true);
if (lexer.token() == Token.ONLY) {
lexer.nextToken();
stmt.setOnly(true);
for (;;) {
if (lexer.token() == Token.PURGE) {
lexer.nextToken();
if (identifierEquals("SNAPSHOT")) {
lexer.nextToken();
acceptIdentifier("LOG");
stmt.setPurgeSnapshotLog(true);
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
continue;
if (lexer.token() == Token.RESTART) {
lexer.nextToken();
accept(Token.IDENTITY);
stmt.setRestartIdentity(Boolean.TRUE);
continue;
} else if (lexer.token() == Token.SHARE) {
lexer.nextToken();
accept(Token.IDENTITY);
stmt.setRestartIdentity(Boolean.FALSE);
continue;
if (lexer.token() == Token.CASCADE) {
lexer.nextToken();
stmt.setCascade(Boolean.TRUE);
continue;
} else if (lexer.token() == Token.RESTRICT) {
lexer.nextToken();
stmt.setCascade(Boolean.FALSE);
continue;
public SQLDropUserStatement parseDropUser() {
accept(Token.USER);
SQLDropUserStatement stmt = new SQLDropUserStatement();
for (;;) {
SQLExpr expr = this.exprParser.expr();
stmt.getUsers().add(expr);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
return stmt;
} else if (lexer.token() == Token.SEQUENCE) {
SEQUENCE("SEQUENCE"),
TRIGGER("TRIGGER"),
USER("USER"),
PURGE("PURGE"),
if (x.isTemporary()) {
print("DROP TEMPORARY TABLE ");
print("DROP TABLE ");
if (x.isIfExists()) {
print("IF EXISTS ");
if (x.isCascade()) {
printCascade();
if (x.isRestrict()) {
print(" RESTRICT");
if (x.isPurge()) {
print(" PURGE");
protected void printCascade() {
print(" CASCADE");
if (x.isIfExists()) {
print("IF EXISTS ");
if (x.isCascade()) {
printCascade();
public boolean visit(SQLDropSequenceStatement x) {
print("DROP SEQUENCE ");
x.getName().accept(this);
return false;
public void endVisit(SQLDropSequenceStatement x) {
public boolean visit(SQLDropTriggerStatement x) {
print("DROP TRIGGER ");
x.getName().accept(this);
return false;
public void endVisit(SQLDropUserStatement x) {
public boolean visit(SQLDropUserStatement x) {
print("DROP USER ");
printAndAccept(x.getUsers(), ", ");
return false;
boolean visit(SQLDropSequenceStatement x);
void endVisit(SQLDropSequenceStatement x);
boolean visit(SQLDropTriggerStatement x);
void endVisit(SQLDropTriggerStatement x);
void endVisit(SQLDropUserStatement x);
boolean visit(SQLDropUserStatement x);
public boolean visit(SQLDropSequenceStatement x) {
return true;
public void endVisit(SQLDropSequenceStatement x) {
public boolean visit(SQLDropTriggerStatement x) {
return true;
public void endVisit(SQLDropTriggerStatement x) {
public void endVisit(SQLDropUserStatement x) {
public boolean visit(SQLDropUserStatement x) {
return true;
@Override
public boolean visit(SQLDropViewStatement x) {
setMode(x, Mode.Drop);
return true;
return false;
@Override
public boolean visit(SQLDropSequenceStatement x) {
@Override
public boolean visit(SQLDropTriggerStatement x) {
return false;
@Override
public void endVisit(SQLDropUserStatement x) {
@Override
public boolean visit(SQLDropUserStatement x) {
return true;
public class MySqlDropTriggerTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP TRIGGER hr.salary_check; ";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
SQLDropViewStatement stmt = (SQLDropViewStatement) statementList.get(0);
public class OracleDropTableTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP TABLE list_customers PURGE";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("DROP TABLE list_customers PURGE",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
public class OracleDropTableTest2 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP TABLE list_customers CASCADE CONSTRAINTS";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("DROP TABLE list_customers CASCADE CONSTRAINTS",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
public class OracleDropTriggerTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP TRIGGER hr.salary_check; ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("DROP TRIGGER hr.salary_check",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
public class OracleDropUserTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP USER sidney; ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("DROP USER sidney",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
public class OracleDropViewTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"DROP view list_customers CASCADE CONSTRAINTS";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals("DROP VIEW list_customers CASCADE CONSTRAINTS",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
new SQLDropSequenceStatement().accept(adapter);
new OracleDropDbLinkStatement().accept(adapter);
new FetchClause().accept(adapter);
new ForClause().accept(adapter);
new PGWithQuery().accept(adapter);
new PGWithClause().accept(adapter);
new PGDeleteStatement().accept(adapter);
new PGParameter().accept(adapter);
new PGFunctionTableSource().accept(adapter);
public class SQLExplainStatement extends SQLStatementImpl {
protected SQLStatement statement;
public SQLStatement getStatement() {
return statement;
public void setStatement(SQLStatement statement) {
if (statement != null) {
statement.setParent(this);
this.statement = statement;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, statement);
visitor.endVisit(this);
public class OracleExplainStatement extends SQLExplainStatement implements OracleStatement {
private SQLCharExpr statementId;
private SQLExpr     into;
acceptChild(visitor, statement);
protected void accept0(SQLASTVisitor visitor) {
accept0((OracleASTVisitor) visitor);
public String toString() {
return SQLUtils.toOracleString(this);
if (lexer.token() == Token.EXPLAIN) {
statementList.add(this.parseExplain());
if (lexer.token() == Token.IDENTIFIER) {
accept(Token.EXPLAIN);
stmt.setStatement(parseStatement());
x.getStatement().accept(this);
map.put("EXPLAIN", Token.EXPLAIN);
case EXPLAIN:
parseStatementList(statementList, -1);
public void parseStatementList(List<SQLStatement> statementList, int max) {
if (max != -1) {
if (statementList.size() >= max) {
if (lexer.token() == (Token.EXPLAIN)) {
statementList.add(parseExplain());
continue;
public SQLStatement parseStatement() {
List<SQLStatement> list = new ArrayList<SQLStatement>();
this.parseStatementList(list, 1);
return list.get(0);
public SQLExplainStatement parseExplain() {
accept(Token.EXPLAIN);
if (identifierEquals("PLAN")) {
lexer.nextToken();
if (lexer.token() == Token.FOR) {
lexer.nextToken();
SQLExplainStatement explain = new SQLExplainStatement();
explain.setStatement(parseStatement());
return explain;
EXPLAIN("EXPLAIN"),
public boolean visit(SQLExplainStatement x) {
print("EXPLAIN");
println();
x.getStatement().accept(this);
return false;
void endVisit(SQLExplainStatement x);
boolean visit(SQLExplainStatement x);
public void endVisit(SQLExplainStatement x) {
public boolean visit(SQLExplainStatement x) {
return true;
public class MySqlDescTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = " Desc City";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("City")));
SQLStatement stmt = statementList.get(0);
stmt.accept(visitor);
public class MySqlExplainTest_0 extends MysqlTest {
public void test_0() throws Exception {
String sql = "explain SELECT * FROM sonar.groups where id = 1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("sonar.groups")));
List<SQLStatement> stmtList = parser.parseStatementList();
SQLStatement stmt = stmtList.get(0);
print(stmtList);
Assert.assertEquals(1, stmtList.size());
stmt.accept(visitor);
String text = output(stmtList);
public class SQLGrantStatement extends SQLStatementImpl {
private final List<SQLExpr> privileges = new ArrayList<SQLExpr>();
private SQLExpr             on;
private SQLExpr             to;
private SQLExpr             maxQueriesPerHour;
private SQLExpr             maxUpdatesPerHour;
private SQLExpr             maxConnectionsPerHour;
private SQLExpr             maxUserConnections;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, on);
acceptChild(visitor, to);
visitor.endVisit(this);
public SQLExpr getOn() {
return on;
public void setOn(SQLExpr on) {
this.on = on;
public SQLExpr getTo() {
return to;
public void setTo(SQLExpr to) {
this.to = to;
public List<SQLExpr> getPrivileges() {
return privileges;
public void addPrivileges(String privilege) {
SQLIdentifierExpr expr = new SQLIdentifierExpr(privilege);
expr.setParent(this);
this.privileges.add(expr);
public SQLExpr getMaxQueriesPerHour() {
return maxQueriesPerHour;
public void setMaxQueriesPerHour(SQLExpr maxQueriesPerHour) {
this.maxQueriesPerHour = maxQueriesPerHour;
public SQLExpr getMaxUpdatesPerHour() {
return maxUpdatesPerHour;
public void setMaxUpdatesPerHour(SQLExpr maxUpdatesPerHour) {
this.maxUpdatesPerHour = maxUpdatesPerHour;
public SQLExpr getMaxConnectionsPerHour() {
return maxConnectionsPerHour;
public void setMaxConnectionsPerHour(SQLExpr maxConnectionsPerHour) {
this.maxConnectionsPerHour = maxConnectionsPerHour;
public SQLExpr getMaxUserConnections() {
return maxUserConnections;
public void setMaxUserConnections(SQLExpr maxUserConnections) {
this.maxUserConnections = maxUserConnections;
public class MySqlAlterUserStatement extends MySqlStatementImpl {
private final List<SQLExpr> users = new ArrayList<SQLExpr>();
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, users);
visitor.endVisit(this);
public List<SQLExpr> getUsers() {
return users;
private boolean passwordHash = false;
public boolean isPasswordHash() {
return passwordHash;
public void setPasswordHash(boolean passwordHash) {
this.passwordHash = passwordHash;
if (lexer.token() == Token.WITH) {
} else if (lexer.token() == Token.WITH) {
if (lexer.token() == Token.WITH) {
userSpec.setPasswordHash(true);
userSpec.setAuthPlugin(this.exprParser.expr());
if (lexer.token() == Token.WITH) {
if (lexer.token() == Token.USER) {
return parseAlterUser();
public MySqlAlterUserStatement parseAlterUser() {
accept(Token.USER);
MySqlAlterUserStatement stmt = new MySqlAlterUserStatement();
for (;;) {
SQLExpr user = this.exprParser.expr();
acceptIdentifier("PASSWORD");
acceptIdentifier("EXPIRE");
stmt.getUsers().add(user);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
return stmt;
boolean visit(MySqlAlterUserStatement x);
void endVisit(MySqlAlterUserStatement x);
@Override
public boolean visit(MySqlAlterUserStatement x) {
return true;
@Override
public void endVisit(MySqlAlterUserStatement x) {
if (x.isPasswordHash()) {
print("PASSWORD ");
public boolean visit(MySqlAlterUserStatement x) {
print("ALTER USER");
for (SQLExpr user : x.getUsers()) {
print(' ');
user.accept(this);
print(" PASSWORD EXPIRE");
return false;
public void endVisit(MySqlAlterUserStatement x) {
return false;
@Override
public boolean visit(MySqlAlterUserStatement x) {
return true;
@Override
public void endVisit(MySqlAlterUserStatement x) {
map.put("WITH", Token.WITH);
map.put("GRANT", Token.GRANT);
SQLExpr expr = new SQLAllColumnExpr();
if (lexer.token() == Token.DOT) {
lexer.nextToken();
accept(Token.STAR);
return new SQLPropertyExpr(expr, "*");
return expr;
case WITH:
case GRANT:
if (lexer.token() == Token.GRANT) {
SQLStatement stmt = parseGrant();
statementList.add(stmt);
continue;
public SQLGrantStatement parseGrant() {
accept(Token.GRANT);
SQLGrantStatement stmt = new SQLGrantStatement();
for (;;) {
if (lexer.token() == Token.ALL) {
lexer.nextToken();
if (identifierEquals("PRIVILEGES")) {
lexer.nextToken();
stmt.addPrivileges("ALL PRIVILEGES");
stmt.addPrivileges("ALL");
} else if (lexer.token() == Token.SELECT) {
stmt.addPrivileges("SELECT");
lexer.nextToken();
} else if (lexer.token() == Token.UPDATE) {
stmt.addPrivileges("UPDATE");
lexer.nextToken();
} else if (lexer.token() == Token.DELETE) {
stmt.addPrivileges("DELETE");
lexer.nextToken();
} else if (lexer.token() == Token.INSERT) {
stmt.addPrivileges("INSERT");
lexer.nextToken();
} else if (lexer.token() == Token.CREATE) {
lexer.nextToken();
if (lexer.token() == Token.TABLE) {
stmt.addPrivileges("CREATE TABLE");
lexer.nextToken();
} else if (identifierEquals("SYNONYM")) {
stmt.addPrivileges("CREATE SYNONYM");
lexer.nextToken();
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
} else if (identifierEquals("USAGE")) {
stmt.addPrivileges("USAGE");
lexer.nextToken();
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
if (lexer.token() == Token.ON) {
lexer.nextToken();
stmt.setOn(this.exprParser.expr());
if (lexer.token() == Token.TO) {
lexer.nextToken();
stmt.setTo(this.exprParser.expr());
if (lexer.token() == Token.WITH) {
lexer.nextToken();
for (;;) {
if (identifierEquals("MAX_QUERIES_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxQueriesPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_UPDATES_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxUpdatesPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_CONNECTIONS_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxConnectionsPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_USER_CONNECTIONS")) {
lexer.nextToken();
stmt.setMaxUserConnections(this.exprParser.primary());
continue;
return stmt;
public boolean visit(SQLGrantStatement x) {
print("GRANT ");
printAndAccept(x.getPrivileges(), ", ");
if (x.getOn() != null) {
print(" ON ");
x.getOn().accept(this);
if (x.getTo() != null) {
print(" TO ");
x.getTo().accept(this);
boolean with = false;
if (x.getMaxQueriesPerHour() != null) {
if (!with) {
print(" WITH");
with = true;
print(" MAX_QUERIES_PER_HOUR ");
x.getMaxQueriesPerHour().accept(this);
if (x.getMaxUpdatesPerHour() != null) {
if (!with) {
print(" WITH");
with = true;
print(" MAX_UPDATES_PER_HOUR ");
x.getMaxUpdatesPerHour().accept(this);
if (x.getMaxConnectionsPerHour() != null) {
if (!with) {
print(" WITH");
with = true;
print(" MAX_CONNECTIONS_PER_HOUR ");
x.getMaxConnectionsPerHour().accept(this);
if (x.getMaxUserConnections() != null) {
if (!with) {
print(" WITH");
with = true;
print(" MAX_USER_CONNECTIONS ");
x.getMaxUserConnections().accept(this);
return false;
void endVisit(SQLGrantStatement x);
boolean visit(SQLGrantStatement x);
public void endVisit(SQLGrantStatement x) {
public boolean visit(SQLGrantStatement x) {
return true;
public boolean visit(SQLDropUserStatement x) {
return false;
public boolean visit(SQLGrantStatement x) {
return false;
public class MySqlAlterUserTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlCreateUserTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE USER 'jeffrey'@'localhost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE USER 'jeffrey'@'localhost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlCreateUserTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlCreateUserTest_3 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE USER 'jeffrey'@'localhost'"
+ " IDENTIFIED BY PASSWORD '*90E462C37378CED12064BB3388827D2BA3A9B689';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY PASSWORD '*90E462C37378CED12064BB3388827D2BA3A9B689'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlCreateUserTest_4 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE USER 'jeffrey'@'localhost'"
+ " IDENTIFIED WITH my_auth_plugin;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE USER 'jeffrey'@'localhost' IDENTIFIED WITH my_auth_plugin", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlDropUserTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP USER 'jeffrey'@'localhost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DROP USER 'jeffrey'@'localhost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT ALL ON db1.* TO 'jeffrey'@'localhost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT ALL ON db1.* TO 'jeffrey'@'localhost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_1 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_2 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
private static Log         LOG                     = LogFactory.getLog(ConfigFilter.class);
public static final String CONFIG_FILE             = "config.file";
public static final String CONFIG_DECRYPT          = "config.decrypt";
public static final String CONFIG_KEY              = "config.decrypt.key";
public static final String SYS_PROP_CONFIG_FILE    = "druid.config.file";
public static final String SYS_PROP_CONFIG_DECRYPT = "druid.config.decrypt";
public static final String SYS_PROP_CONFIG_KEY     = "druid.config.decrypt.key";
String key = null;
if (configFileProperties != null) {
configFileProperties.getProperty(CONFIG_KEY);
if (filePath.startsWith("file:
public class SQLDropDatabaseStatement extends SQLStatementImpl implements SQLDDLStatement {
private SQLExpr database;
private boolean ifExists;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, database);
visitor.endVisit(this);
public SQLExpr getDatabase() {
return database;
public void setDatabase(SQLExpr database) {
if (database != null) {
database.setParent(this);
this.database = database;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
} else if (lexer.token() == Token.DATABASE) {
SQLStatement stmt = parseDropDatabase(false);
statementList.add(stmt);
continue;
protected SQLDropDatabaseStatement parseDropDatabase(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
SQLDropDatabaseStatement stmt = new SQLDropDatabaseStatement();
accept(Token.DATABASE);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
SQLName name = this.exprParser.name();
stmt.setDatabase(name);
return stmt;
public boolean visit(SQLDropDatabaseStatement x) {
print("DROP DATABASE ");
if (x.isIfExists()) {
print("IF EXISTS ");
x.getDatabase().accept(this);
return false;
void endVisit(SQLDropDatabaseStatement x);
boolean visit(SQLDropDatabaseStatement x);
public void endVisit(SQLDropDatabaseStatement x) {
public boolean visit(SQLDropDatabaseStatement x) {
return true;
@Override
public boolean visit(SQLDropDatabaseStatement x) {
return false;
public class MySqlDropDatabaseTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP DATABASE sonar";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("DROP DATABASE sonar", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class SQLServerDropIndex_Test_2 extends TestCase {
public void test_alter_first() throws Exception {
String sql = "DROP INDEX IX_ProductVendor_VendorID     ON Purchasing.ProductVendor;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("DROP INDEX IX_ProductVendor_VendorID ON Purchasing.ProductVendor", output);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
String typeName;
if (identifierEquals("LONG")) {
lexer.nextToken();
acceptIdentifier("RAW");
typeName = "LONG RAW";
SQLName typeExpr = name();
typeName = typeExpr.toString();
} else if (lexer.token() == Token.VARIANT) {
identName = lexer.stringVal();
lexer.nextToken();
} else if (token == Token.INDEX 
|| token == Token.UNIQUE 
|| identifierEquals("NONCLUSTERED") 
lexer.nextToken();
if (identifierEquals("CLUSTERED")) {
lexer.nextToken();
stmt.setType("UNIQUE CLUSTERED");
stmt.setType("UNIQUE");
} else if (identifierEquals("FULLTEXT")) {
stmt.setType("FULLTEXT");
lexer.nextToken();
} else if (identifierEquals("NONCLUSTERED")) {
stmt.setType("NONCLUSTERED");
public class OracleAlterTableTest21 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE long_tab DROP COLUMN long_pics;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals("ALTER TABLE long_tab"
+ "ntDROP COLUMN long_pics", 
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("long_tab")));
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("long_tab", "long_pics")));
public class OracleCreateTableTest34 extends OracleTest {
public void test_types() throws Exception {
String sql = 
"CREATE TABLE long_tab (pic_id NUMBER, long_pics LONG RAW);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TABLE long_tab ("
+ "ntpic_id NUMBER,"
+ "ntlong_pics LONG RAW"
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("long_tab", "pic_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("long_tab", "long_pics")));
public class OracleInsertTest10 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO departments" 
+ "   VALUES (280, 'Recreation', 121, 1700);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO departments"
+ "nVALUES"
+ "n(280, 'Recreation', 121, 1700)",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("departments")));
public class OracleInsertTest11 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO departments"
+ "   VALUES (280, 'Recreation', DEFAULT, 1700);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO departments"
+ "nVALUES"
+ "n(280, 'Recreation', DEFAULT, 1700)",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("departments")));
public class OracleInsertTest12 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO employees (employee_id, last_name, email, " 
+ "      hire_date, job_id, salary, commission_pct) "
+ "   VALUES (207, 'Gregory', 'pgregory@example.com', "
+ "      sysdate, 'PU_CLERK', 1.2E3, NULL);";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO employees" 
+ "nt(employee_id, last_name, email, hire_date, job_id" 
+ "nt, salary, commission_pct)" 
+ "nVALUES" 
+ "n(207, 'Gregory', 'pgregory@example.com', SYSDATE, 'PU_CLERK'" 
+ "nt, 1.2E+3, NULL)",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "employee_id")));
public class OracleInsertTest13 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO bonuses" 
+ "   SELECT employee_id, salary*1.1 "
+ "   FROM employees"
+ "   WHERE commission_pct > 0.25; ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO bonuses" 
+ "nSELECT employee_id, salary * 1.1"
+ "nFROM employees"
+ "nWHERE commission_pct > 0.25",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("bonuses")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "employee_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "salary")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "commission_pct")));
public class OracleInsertTest14 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO raises" 
+ "   SELECT employee_id, salary*1.1 FROM employees"
+ "   WHERE commission_pct > .2"
+ "   LOG ERRORS INTO errlog ('my_bad') REJECT LIMIT 10;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO raises" 
+ "nSELECT employee_id, salary * 1.1"
+ "nFROM employees"
+ "nWHERE commission_pct > 0.2"
+ "nLOG ERRORS INTO errlog ('my_bad') REJECT LIMIT 10",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("raises")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "employee_id")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "salary")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "commission_pct")));
public class OracleInsertTest15 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO employees@remote" 
+ "   VALUES (8002, 'Juan', 'Fernandez', 'juanf@example.com', NULL, "
+ "   TO_DATE('04-OCT-1992', 'DD-MON-YYYY'), 'SH_CLERK', 3000, "
+ "   NULL, 121, 20); ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO employees@remote" 
+ "nVALUES"
+ "n(8002, 'Juan', 'Fernandez', 'juanf@example.com', NULL"
+ "nt, TO_DATE('04-OCT-1992', 'DD-MON-YYYY'), 'SH_CLERK', 3000, NULL, 121"
+ "nt, 20)",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees@remote")));
public class OracleInsertTest16 extends OracleTest {
public void test_0() throws Exception {
String sql = "INSERT INTO departments " 
+ "   VALUES  (departments_seq.nextval, 'Entertainment', 162, 1400); ";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("INSERT INTO departments" 
+ "nVALUES"
+ "n(departments_seq.nextval, 'Entertainment', 162, 1400)",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("departments")));
Assert.assertEquals("CREATE UNIQUE INDEX [unique_schema_migrations] ON [schema_migrations] ([version])", 
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
public class SQLServerCreateIndexTest_2 extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE UNIQUE CLUSTERED INDEX Idx1 ON t1(c);";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLCreateIndexStatement stmt = (SQLCreateIndexStatement) statementList.get(0);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE UNIQUE CLUSTERED INDEX Idx1 ON t1 (c)", 
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "c")));
public class SQLServerCreateIndexTest_3 extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE NONCLUSTERED INDEX IX_SalesPerson_SalesQuota_SalesYTD" 
+ "    ON Sales.SalesPerson (SalesQuota, SalesYTD);";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLCreateIndexStatement stmt = (SQLCreateIndexStatement) statementList.get(0);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE NONCLUSTERED INDEX IX_SalesPerson_SalesQuota_SalesYTD" 
+ " ON Sales.SalesPerson (SalesQuota, SalesYTD)", 
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("Sales.SalesPerson")));
Assert.assertTrue(visitor.getColumns().contains(new Column("Sales.SalesPerson", "SalesQuota")));
Assert.assertTrue(visitor.getColumns().contains(new Column("Sales.SalesPerson", "SalesYTD")));
public class SQLServerCreateTableTest_2 extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE TABLE #Test (C1 nvarchar(10), C2 nvarchar(50), C3 datetime);";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLCreateTableStatement stmt = (SQLCreateTableStatement) statementList.get(0);
Assert.assertEquals(1, statementList.size());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("CREATE TABLE #Test (" 
+ "ntC1 nvarchar(10),"
+ "ntC2 nvarchar(50),"
+ "ntC3 datetime"
+ "n)", output);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("#Test")));
Assert.assertTrue(visitor.getColumns().contains(new Column("#Test", "C1")));
Assert.assertTrue(visitor.getColumns().contains(new Column("#Test", "C2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("#Test", "C3")));
private boolean                          unique;
private SQLName                          name;
private final List<SQLSelectOrderByItem> items = new ArrayList<SQLSelectOrderByItem>();
private String                           type;
private String                           using;
if (visitor.visit(this)) {
acceptChild(visitor, getName());
acceptChild(visitor, getItems());
visitor.endVisit(this);
public boolean isUnique() {
return unique;
public void setUnique(boolean unique) {
this.unique = unique;
public List<SQLSelectOrderByItem> getItems() {
return items;
public String getUsing() {
return using;
public void setUsing(String using) {
this.using = using;
public class MySqlAlterTableDiscardTablespace extends MySqlObjectImpl implements SQLAlterTableItem, MySqlObject {
public class MySqlAlterTableImportTablespace extends MySqlObjectImpl implements SQLAlterTableItem, MySqlObject {
SQLAlterTableAddIndex item = parseAlterTableAddIndex();
item.setParent(stmt);
SQLAlterTableAddIndex item = parseAlterTableAddIndex();
item.setParent(stmt);
|| token == Token.UNIQUE 
|| identifierEquals("NONCLUSTERED") 
protected SQLAlterTableAddIndex parseAlterTableAddIndex() {
SQLAlterTableAddIndex item = new SQLAlterTableAddIndex();
if (lexer.token() == Token.UNIQUE) {
item.setUnique(true);
lexer.nextToken();
if (lexer.token() == Token.INDEX) {
lexer.nextToken();
accept(Token.INDEX);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
item.setName(this.exprParser.name());
accept(Token.LPAREN);
for (;;) {
SQLSelectOrderByItem column = this.exprParser.parseSelectOrderByItem();
item.getItems().add(column);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
accept(Token.RPAREN);
return item;
public boolean visit(SQLAlterTableAddIndex x) {
print("ADD ");
if (x.getType() != null) {
print(x.getType());
print(" ");
if (x.isUnique()) {
print("UNIQUE ");
print("INDEX ");
if (x.getName() != null) {
x.getName().accept(this);
print(' ');
print("(");
printAndAccept(x.getItems(), ", ");
print(")");
if (x.getUsing() != null) {
print(" USING ");
print(x.getUsing());
return false;
void endVisit(SQLAlterTableAddIndex x);
boolean visit(SQLAlterTableAddIndex x);
public void endVisit(SQLAlterTableAddIndex x) {
public boolean visit(SQLAlterTableAddIndex x) {
return true;
@Override
public boolean visit(SQLAlterTableAddIndex x) {
for (SQLSelectOrderByItem item : x.getItems()) {
item.accept(this);
return false;
"ntADD UNIQUE INDEX `ix2` (`fid` ASC)", output);
Assert.assertEquals("ALTER TABLE t2ntADD INDEX (d),ntADD UNIQUE INDEX (a)", output);
Assert.assertEquals(3, visitor.getColumns().size());
private final List<SQLColumnDefinition> columns = new ArrayList<SQLColumnDefinition>();
public boolean visit(SQLCheck x) {
x.getExpr().accept(this);
return false;
public class OracleAlterTableTest22 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"ALTER TABLE employees ADD CONSTRAINT check_comp " 
+ "   CHECK (salary + (commission_pct*salary) <= 5000)" 
+ "   DISABLE;";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals("ALTER TABLE employees" 
+ "ntADD CONSTRAINT check_comp CHECK (salary + commission_pct * salary <= 5000) DIABLE", 
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employees")));
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "salary")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("employees", "commission_pct")));
Assert.assertEquals(7, visitor.getColumns().size());
public class MySqlLexer extends Lexer {
public final static Keywords DEFAULT_MYSQL_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.putAll(Keywords.DEFAULT_KEYWORDS.getKeywords());
map.put("DUAL", Token.DUAL);
map.put("FALSE", Token.FALSE);
map.put("IDENTIFIED", Token.IDENTIFIED);
map.put("IF", Token.IF);
map.put("KILL", Token.KILL);
map.put("LIMIT", Token.LIMIT);
map.put("TRUE", Token.TRUE);
map.put("BINARY", Token.BINARY);
map.put("SHOW", Token.SHOW);
map.put("CACHE", Token.CACHE);
map.put("ANALYZE", Token.ANALYZE);
map.put("OPTIMIZE", Token.OPTIMIZE);
DEFAULT_MYSQL_KEYWORDS = new Keywords(map);
public MySqlLexer(char[] input, int inputLength, boolean skipComment){
super(input, inputLength, skipComment);
super.keywods = DEFAULT_MYSQL_KEYWORDS;
public MySqlLexer(String input){
super(input);
super.keywods = DEFAULT_MYSQL_KEYWORDS;
public void scanSharp() {
if (ch != '#') {
throw new ParserException("illegal stat");
if (charAt(pos + 1) == '{') {
scanVariable();
Token lastToken = this.token;
scanChar();
mark = pos;
bufPos = 0;
for (;;) {
if (ch == 'r') {
if (charAt(pos + 1) == 'n') {
bufPos += 2;
scanChar();
} else if (ch == EOI) {
if (ch == 'n') {
scanChar();
scanChar();
stringVal = subString(mark, bufPos);
token = Token.LINE_COMMENT;
if (commentHandler != null && commentHandler.handle(lastToken, stringVal)) {
if (!isAllowComment()) {
throw new NotAllowCommentException();
public void scanVariable() {
if (ch != '@' && ch != ':' && ch != '#' && ch != '$') {
throw new ParserException("illegal variable");
mark = pos;
bufPos = 1;
if (charAt(pos + 1) == '@') {
ch = charAt(++pos);
if (charAt(pos + 1) == '`') {
for (;;) {
ch = charAt(++pos);
if (ch == '`') {
ch = charAt(++pos);
} else if (ch == EOI) {
throw new ParserException("illegal identifier");
this.ch = charAt(pos);
stringVal = subString(mark, bufPos);
token = Token.VARIANT;
} else if (charAt(pos + 1) == '{') {
for (;;) {
ch = charAt(++pos);
if (ch == '}') {
ch = charAt(++pos);
} else if (ch == EOI) {
throw new ParserException("illegal identifier");
this.ch = charAt(pos);
stringVal = subString(mark, bufPos);
token = Token.VARIANT;
for (;;) {
ch = charAt(++pos);
if (!isIdentifierChar(ch)) {
this.ch = charAt(pos);
stringVal = subString(mark, bufPos);
token = Token.VARIANT;
public void scanIdentifier() {
final char first = ch;
if (ch == '`') {
mark = pos;
bufPos = 1;
for (;;) {
ch = charAt(++pos);
if (ch == '`') {
ch = charAt(++pos);
} else if (ch == EOI) {
throw new ParserException("illegal identifier");
this.ch = charAt(pos);
stringVal = subString(mark, bufPos);
Token tok = keywods.getKeyword(stringVal);
if (tok != null) {
token = tok;
token = Token.IDENTIFIER;
final boolean firstFlag = isFirstIdentifierChar(first);
if (!firstFlag) {
throw new ParserException("illegal identifier");
mark = pos;
bufPos = 1;
for (;;) {
ch = charAt(++pos);
if (!isIdentifierChar(ch)) {
this.ch = charAt(pos);
stringVal = addSymbol();
Token tok = keywods.getKeyword(stringVal);
if (tok != null) {
token = tok;
token = Token.IDENTIFIER;
protected final void scanString() {
boolean hasSpecial = false;
int startIndex = pos + 1;
int endIndex = -1; 
for (int i = startIndex; i < text.length(); ++i) {
final char ch = text.charAt(i);
if (ch == '\') {
hasSpecial = true;
if (ch == ''') {
endIndex = i;
if (endIndex == -1) {
throw new ParserException("unclosed str");
String stringVal = subString(startIndex, endIndex - startIndex);
if (!hasSpecial) {
this.stringVal = stringVal;
int pos = endIndex + 1;
char ch = charAt(pos);
if (ch != ''') {
this.pos = pos;
this.ch = ch;
token = LITERAL_CHARS;
mark = pos;
boolean hasSpecial = false;
for (;;) {
if (isEOF()) {
lexError("unclosed.str.lit");
ch = charAt(++pos);
if (ch == '\') {
scanChar();
if (!hasSpecial) {
initBuff(bufPos);
arraycopy(mark + 1, buf, 0, bufPos);
hasSpecial = true;
switch (ch) {
putChar('0');
putChar(''');
putChar('"');
putChar('b');
putChar('n');
putChar('r');
putChar('t');
putChar('\');
putChar((char) 0x1A); 
putChar(ch);
scanChar();
if (ch == ''') {
scanChar();
if (ch != ''') {
token = LITERAL_CHARS;
initBuff(bufPos);
arraycopy(mark + 1, buf, 0, bufPos);
hasSpecial = true;
putChar(''');
if (!hasSpecial) {
if (bufPos == buf.length) {
putChar(ch);
buf[bufPos++] = ch;
if (!hasSpecial) {
stringVal = "";
stringVal = subString(mark + 1, bufPos);
stringVal = new String(buf, 0, bufPos);
public void scanComment() {
Token lastToken = this.token;
if (ch != '/' && ch != '-') {
throw new IllegalStateException();
mark = pos;
bufPos = 0;
scanChar();
if (ch == '*') {
scanChar();
while (ch == ' ') {
scanChar();
boolean isHint = false;
int startHintSp = bufPos + 1;
if (ch == '!') {
isHint = true;
scanChar();
for (;;) {
if (ch == EOI) {
this.token = Token.ERROR;
if (ch == '*' && charAt(pos + 1) == '/') {
bufPos += 3;
scanChar();
scanChar();
scanChar();
if (isHint) {
stringVal = subString(mark + startHintSp, (bufPos - startHintSp) - 2);
token = Token.HINT;
stringVal = subString(mark, bufPos);
token = Token.MULTI_LINE_COMMENT;
if (commentHandler != null && commentHandler.handle(lastToken, stringVal)) {
if (!isAllowComment()) {
throw new NotAllowCommentException();
if (ch == '/' || ch == '-') {
scanChar();
for (;;) {
if (ch == 'r') {
if (charAt(pos + 1) == 'n') {
bufPos += 2;
scanChar();
} else if (ch == EOI) {
if (ch == 'n') {
scanChar();
scanChar();
stringVal = subString(mark, bufPos + 1);
token = Token.LINE_COMMENT;
if (commentHandler != null && commentHandler.handle(lastToken, stringVal)) {
if (!isAllowComment()) {
throw new NotAllowCommentException();
public class MySqlWallTest95 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
Assert.assertFalse(provider.checkValid(
"select * from test !40101fff"));
public class MySqlSelectTest_13 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select * from test !40101fff";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT *" 
+ "nFROM test", 
if (defaultExpr != null) {
defaultExpr.setParent(this);
if (parent instanceof SQLDataType 
|| parent instanceof SQLColumnDefinition 
|| parent instanceof SQLServerTop 
public class SQLServerParameterizedOutputVisitorTest_1 extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT TOP 10 ID FROM dbo.jiraissue WHERE PROJECT IN (?) ORDER BY UPDATED DESC";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.SQL_SERVER), sql);
public class SQLServerParameterizedOutputVisitorTest_2 extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE TABLE dbo.AO_B9A0F0_APPLIED_TEMPLATE ( ID INTEGER IDENTITY(1,1) NOT NULL, PROJECT_ID BIGINT CONSTRAINT df_AO_B9A0F0_APPLIED_TEMPLATE_PROJECT_ID DEFAULT 0, PROJECT_TEMPLATE_MODULE_KEY VARCHAR(255), PROJECT_TEMPLATE_WEB_ITEM_KEY VARCHAR(255), CONSTRAINT pk_AO_B9A0F0_APPLIED_TEMPLATE_ID PRIMARY KEY(ID) )";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.SQL_SERVER), sql);
public class OracleCreateSequenceTest_2 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"CREATE SEQUENCE "AO_4AEACD_WEBHOOK_DAO_ID_SEQ" INCREMENT BY 1 START WITH 1 NOMAXVALUE MINVALUE 1";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
dataSource.setUsername("jira");
dataSource.setPassword("jira");
public final class VERSION {
public final static int MajorVersion    = 0;
public final static int MinorVersion    = 2;
public final static int RevisionVersion = 25;
public static String getVersionNumber() {
return VERSION.MajorVersion + "." + VERSION.MinorVersion + "." + VERSION.RevisionVersion;
private SQLExpr   first;
private Isolation isolation;
public Isolation getIsolation() {
return isolation;
public void setIsolation(Isolation isolation) {
this.isolation = isolation;
public static enum Isolation {
RR, RS, CS, U
if (lexer.token() == Token.WITH) {
lexer.nextToken();
if (identifierEquals("RR")) {
queryBlock.setIsolation(Isolation.RR);
} else if (identifierEquals("RS")) {
queryBlock.setIsolation(Isolation.RS);
} else if (identifierEquals("CS")) {
queryBlock.setIsolation(Isolation.CS);
} else if (identifierEquals("UR")) {
queryBlock.setIsolation(Isolation.UR);
throw new ParserException("TODO");
lexer.nextToken();
if (x.getIsolation() != null) {
println();
print("WITH ");
print(x.getIsolation().name());
public class DB2SelectTest_2 extends DB2Test {
public void test_0() throws Exception {
String sql = "SELECT CTRYNUM, FMS_INSTANCE_CD FROM DBEFMSDR.FMSA_O_WW_CTRY_AG WHERE ACCT_YR=? WITH UR";
DB2StatementParser parser = new DB2StatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
DB2SchemaStatVisitor visitor = new DB2SchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("DBEFMSDR.FMSA_O_WW_CTRY_AG")));
Assert.assertTrue(visitor.getColumns().contains(new Column("DBEFMSDR.FMSA_O_WW_CTRY_AG", "CTRYNUM")));
String output = SQLUtils.toSQLString(stmt, JdbcConstants.DB2);
Assert.assertEquals("SELECT CTRYNUM, FMS_INSTANCE_CD" 
+ "nFROM DBEFMSDR.FMSA_O_WW_CTRY_AG"
+ "nWHERE ACCT_YR = ?"
+ "nWITH UR", 
private boolean   forReadOnly;
private SQLExpr   optimizeFor;
public boolean isForReadOnly() {
return forReadOnly;
public void setForReadOnly(boolean forReadOnly) {
this.forReadOnly = forReadOnly;
public SQLExpr getOptimizeFor() {
return optimizeFor;
public void setOptimizeFor(SQLExpr optimizeFor) {
this.optimizeFor = optimizeFor;
map.put("OPTIMIZE", Token.OPTIMIZE);
for (;;) {
if (lexer.token() == Token.FETCH) {
accept(Token.FIRST);
SQLExpr first = this.exprParser.primary();
queryBlock.setFirst(first);
if (identifierEquals("ROW") || identifierEquals("ROWS")) {
lexer.nextToken();
accept(Token.ONLY);
if (lexer.token() == Token.WITH) {
lexer.nextToken();
if (identifierEquals("RR")) {
queryBlock.setIsolation(Isolation.RR);
} else if (identifierEquals("RS")) {
queryBlock.setIsolation(Isolation.RS);
} else if (identifierEquals("CS")) {
queryBlock.setIsolation(Isolation.CS);
} else if (identifierEquals("UR")) {
queryBlock.setIsolation(Isolation.UR);
throw new ParserException("TODO");
lexer.nextToken();
if (lexer.token() == Token.FOR) {
lexer.nextToken();
acceptIdentifier("READ");
accept(Token.ONLY);
queryBlock.setForReadOnly(true);
if (lexer.token() == Token.OPTIMIZE) {
lexer.nextToken();
accept(Token.FOR);
queryBlock.setOptimizeFor(this.expr());
if (identifierEquals("ROW")) {
lexer.nextToken();
acceptIdentifier("ROWS");
if (x.isForReadOnly()) {
println();
print("FOR READ ONLY");
if (x.getOptimizeFor() != null) {
println();
print("OPTIMIZE FOR ");
x.getOptimizeFor().accept(this);
public class DB2SelectTest_3 extends DB2Test {
public void test_0() throws Exception {
String sql = "select * from t for read only";
DB2StatementParser parser = new DB2StatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
DB2SchemaStatVisitor visitor = new DB2SchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t", "*")));
String output = SQLUtils.toSQLString(stmt, JdbcConstants.DB2);
Assert.assertEquals("SELECT *" 
+ "nFROM t"
+ "nFOR READ ONLY", 
public class DB2SelectTest_4 extends DB2Test {
public void test_0() throws Exception {
String sql = "select * from t OPTIMIZE FOR 10 ROWS";
DB2StatementParser parser = new DB2StatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
DB2SchemaStatVisitor visitor = new DB2SchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t", "*")));
String output = SQLUtils.toSQLString(stmt, JdbcConstants.DB2);
Assert.assertEquals("SELECT *" 
+ "nFROM t"
+ "nOPTIMIZE FOR 10", 
public class WallConfig implements WallConfigMBean {
private boolean             noneBaseStatementAllow     = false;
private boolean             callAllow                  = true;
private boolean             selelctAllow               = true;
private boolean             selectIntoAllow            = true;
private boolean             selectIntoOutfileAllow     = false;
private boolean             selectWhereAlwayTrueCheck  = true;
private boolean             selectHavingAlwayTrueCheck = false;
private boolean             selectUnionCheck           = true;
private boolean             createTableAllow           = true;
private boolean             dropTableAllow             = true;
private boolean             alterTableAllow            = true;
private boolean             conditionAndAlwayTrueAllow = false;
private boolean             selectAllColumnAllow       = true;
private boolean             deleteAllow                = true;
private boolean             deleteWhereAlwayTrueCheck  = true;
private boolean             deleteWhereNoneCheck       = false;
private boolean             updateAllow                = true;
private boolean             updateWhereAlayTrueCheck   = true;
private boolean             updateWhereNoneCheck       = false;
private boolean             insertAllow                = true;
private boolean             mergeAllow                 = true;
private boolean             minusAllow                 = false;
private boolean             intersectAllow             = false;
private boolean             replaceAllow               = true;
private boolean             setAllow                   = true;
private boolean             commitAllow                = true;
private boolean             rollbackAllow              = true;
private boolean             useAllow                   = false;
private boolean             multiStatementAllow        = false;
private boolean             truncateAllow              = true;
private boolean             commentAllow               = false;
private boolean             strictSyntaxCheck          = true;
private boolean             constArithmeticAllow       = true;
private boolean             limitZeroAllow                  = false;
private boolean             describeAllow              = true;
private boolean             showAllow                  = true;
private boolean             schemaCheck                = true;
private boolean             tableCheck                 = true;
private boolean             functionCheck              = true;
private boolean             objectCheck                = true;
private boolean             variantCheck               = true;
private boolean             mustParameterized          = false;
private boolean             doPrivilegedAllow          = false;
protected final Set<String> denyFunctions              = new ConcurrentSkipListSet<String>();
protected final Set<String> denyTables                 = new ConcurrentSkipListSet<String>();
protected final Set<String> denySchemas                = new ConcurrentSkipListSet<String>();
protected final Set<String> denyVariants               = new ConcurrentSkipListSet<String>();
protected final Set<String> denyObjects                = new ConcurrentSkipListSet<String>();
protected final Set<String> permitFunctions            = new ConcurrentSkipListSet<String>();
protected final Set<String> permitTables               = new ConcurrentSkipListSet<String>();
protected final Set<String> permitSchemas              = new ConcurrentSkipListSet<String>();
protected final Set<String> permitVariants             = new ConcurrentSkipListSet<String>();
protected final Set<String> readOnlyTables             = new ConcurrentSkipListSet<String>();
private String              dir;
private boolean             inited;
private String              tenantTablePattern;
private String              tenantColumn;
private boolean             wrapAllow                  = true;
private boolean             metadataAllow              = true;
private boolean             conditionOpXorAllow        = false;
private boolean             conditionOpBitwseAllow     = true;
public WallConfig(){
public boolean isLimitZeroAllow() {
return limitZeroAllow;
public void setLimitZeroAllow(boolean limitZero) {
this.limitZeroAllow = limitZero;
public boolean isConditionAndAlwayTrueAllow() {
return conditionAndAlwayTrueAllow;
public void setConditionAndAlwayTrueAllow(boolean conditionAndAlwayTrueAllow) {
this.conditionAndAlwayTrueAllow = conditionAndAlwayTrueAllow;
public boolean isUseAllow() {
return useAllow;
public void setUseAllow(boolean useAllow) {
this.useAllow = useAllow;
public boolean isCommitAllow() {
return commitAllow;
public void setCommitAllow(boolean commitAllow) {
this.commitAllow = commitAllow;
public boolean isRollbackAllow() {
return rollbackAllow;
public void setRollbackAllow(boolean rollbackAllow) {
this.rollbackAllow = rollbackAllow;
public boolean isIntersectAllow() {
return intersectAllow;
public void setIntersectAllow(boolean intersectAllow) {
this.intersectAllow = intersectAllow;
public boolean isMinusAllow() {
return minusAllow;
public void setMinusAllow(boolean minusAllow) {
this.minusAllow = minusAllow;
public boolean isConditionOpXorAllow() {
return conditionOpXorAllow;
public void setConditionOpXorAllow(boolean conditionOpXorAllow) {
this.conditionOpXorAllow = conditionOpXorAllow;
public boolean isConditionOpBitwseAllow() {
return conditionOpBitwseAllow;
public void setConditionOpBitwseAllow(boolean conditionOpBitwseAllow) {
this.conditionOpBitwseAllow = conditionOpBitwseAllow;
public String getTenantTablePattern() {
return tenantTablePattern;
public void setTenantTablePattern(String tenantTablePattern) {
this.tenantTablePattern = tenantTablePattern;
public String getTenantColumn() {
return tenantColumn;
public void setTenantColumn(String tenantColumn) {
this.tenantColumn = tenantColumn;
public boolean isMetadataAllow() {
return metadataAllow;
public void setMetadataAllow(boolean metadataAllow) {
this.metadataAllow = metadataAllow;
public boolean isWrapAllow() {
return wrapAllow;
public void setWrapAllow(boolean wrapAllow) {
this.wrapAllow = wrapAllow;
public boolean isDoPrivilegedAllow() {
return doPrivilegedAllow;
public void setDoPrivilegedAllow(boolean doPrivilegedAllow) {
this.doPrivilegedAllow = doPrivilegedAllow;
public boolean isSelectAllColumnAllow() {
return selectAllColumnAllow;
public void setSelectAllColumnAllow(boolean selectAllColumnAllow) {
this.selectAllColumnAllow = selectAllColumnAllow;
public boolean isInited() {
return inited;
public WallConfig(String dir){
this.dir = dir;
this.init();
public String getDir() {
return dir;
public void setDir(String dir) {
this.dir = dir;
public final void init() {
loadConfig(dir);
public void loadConfig(String dir) {
if (dir.endsWith("/")) {
dir = dir.substring(0, dir.length() - 1);
loadResource(this.denyVariants, dir + "/deny-variant.txt");
loadResource(this.denySchemas, dir + "/deny-schema.txt");
loadResource(this.denyFunctions, dir + "/deny-function.txt");
loadResource(this.denyTables, dir + "/deny-table.txt");
loadResource(this.denyObjects, dir + "/deny-object.txt");
loadResource(this.readOnlyTables, dir + "/readonly-table.txt");
loadResource(this.permitFunctions, dir + "/permit-function.txt");
loadResource(this.permitTables, dir + "/permit-table.txt");
loadResource(this.permitSchemas, dir + "/permit-schema.txt");
loadResource(this.permitVariants, dir + "/permit-variant.txt");
public boolean isNoneBaseStatementAllow() {
return noneBaseStatementAllow;
public void setNoneBaseStatementAllow(boolean noneBaseStatementAllow) {
this.noneBaseStatementAllow = noneBaseStatementAllow;
public boolean isDescribeAllow() {
return describeAllow;
public void setDescribeAllow(boolean describeAllow) {
this.describeAllow = describeAllow;
public boolean isShowAllow() {
return showAllow;
public void setShowAllow(boolean showAllow) {
this.showAllow = showAllow;
public boolean isTruncateAllow() {
return truncateAllow;
public void setTruncateAllow(boolean truncateAllow) {
this.truncateAllow = truncateAllow;
public boolean isSelelctAllow() {
return selelctAllow;
public void setSelelctAllow(boolean selelctAllow) {
this.selelctAllow = selelctAllow;
public boolean isSelectIntoAllow() {
return selectIntoAllow;
public void setSelectIntoAllow(boolean selectIntoAllow) {
this.selectIntoAllow = selectIntoAllow;
public boolean isSelectIntoOutfileAllow() {
return selectIntoOutfileAllow;
public void setSelectIntoOutfileAllow(boolean selectIntoOutfileAllow) {
this.selectIntoOutfileAllow = selectIntoOutfileAllow;
public boolean isCreateTableAllow() {
return createTableAllow;
public void setCreateTableAllow(boolean createTableAllow) {
this.createTableAllow = createTableAllow;
public boolean isDropTableAllow() {
return dropTableAllow;
public void setDropTableAllow(boolean dropTableAllow) {
this.dropTableAllow = dropTableAllow;
public boolean isAlterTableAllow() {
return alterTableAllow;
public void setAlterTableAllow(boolean alterTableAllow) {
this.alterTableAllow = alterTableAllow;
public boolean isSelectUnionCheck() {
return selectUnionCheck;
public void setSelectUnionCheck(boolean selectUnionCheck) {
this.selectUnionCheck = selectUnionCheck;
public boolean isSelectWhereAlwayTrueCheck() {
return selectWhereAlwayTrueCheck;
public void setSelectWhereAlwayTrueCheck(boolean selectWhereAlwayTrueCheck) {
this.selectWhereAlwayTrueCheck = selectWhereAlwayTrueCheck;
public boolean isSelectHavingAlwayTrueCheck() {
return selectHavingAlwayTrueCheck;
public void setSelectHavingAlwayTrueCheck(boolean selectHavingAlwayTrueCheck) {
this.selectHavingAlwayTrueCheck = selectHavingAlwayTrueCheck;
public boolean isDeleteAllow() {
return deleteAllow;
public void setDeleteAllow(boolean deleteAllow) {
this.deleteAllow = deleteAllow;
public boolean isDeleteWhereAlwayTrueCheck() {
return deleteWhereAlwayTrueCheck;
public void setDeleteWhereAlwayTrueCheck(boolean deleteWhereAlwayTrueCheck) {
this.deleteWhereAlwayTrueCheck = deleteWhereAlwayTrueCheck;
public boolean isDeleteWhereNoneCheck() {
return deleteWhereNoneCheck;
public void setDeleteWhereNoneCheck(boolean deleteWhereNoneCheck) {
this.deleteWhereNoneCheck = deleteWhereNoneCheck;
public boolean isUpdateAllow() {
return updateAllow;
public void setUpdateAllow(boolean updateAllow) {
this.updateAllow = updateAllow;
public boolean isUpdateWhereAlayTrueCheck() {
return updateWhereAlayTrueCheck;
public void setUpdateWhereAlayTrueCheck(boolean updateWhereAlayTrueCheck) {
this.updateWhereAlayTrueCheck = updateWhereAlayTrueCheck;
public boolean isUpdateWhereNoneCheck() {
return updateWhereNoneCheck;
public void setUpdateWhereNoneCheck(boolean updateWhereNoneCheck) {
this.updateWhereNoneCheck = updateWhereNoneCheck;
public boolean isInsertAllow() {
return insertAllow;
public void setInsertAllow(boolean insertAllow) {
this.insertAllow = insertAllow;
public boolean isReplaceAllow() {
return replaceAllow;
public void setReplaceAllow(boolean replaceAllow) {
this.replaceAllow = replaceAllow;
public boolean isSetAllow() {
return setAllow;
public void setSetAllow(boolean value) {
this.setAllow = value;
public boolean isMergeAllow() {
return mergeAllow;
public void setMergeAllow(boolean mergeAllow) {
this.mergeAllow = mergeAllow;
public boolean isMultiStatementAllow() {
return multiStatementAllow;
public void setMultiStatementAllow(boolean multiStatementAllow) {
this.multiStatementAllow = multiStatementAllow;
public boolean isSchemaCheck() {
return schemaCheck;
public void setSchemaCheck(boolean schemaCheck) {
this.schemaCheck = schemaCheck;
public boolean isTableCheck() {
return tableCheck;
public void setTableCheck(boolean tableCheck) {
this.tableCheck = tableCheck;
public boolean isFunctionCheck() {
return functionCheck;
public void setFunctionCheck(boolean functionCheck) {
this.functionCheck = functionCheck;
public boolean isVariantCheck() {
return variantCheck;
public void setVariantCheck(boolean variantCheck) {
this.variantCheck = variantCheck;
public boolean isObjectCheck() {
return objectCheck;
public void setObjectCheck(boolean objectCheck) {
this.objectCheck = objectCheck;
public boolean isCommentAllow() {
return commentAllow;
public void setCommentAllow(boolean commentAllow) {
this.commentAllow = commentAllow;
public boolean isStrictSyntaxCheck() {
return strictSyntaxCheck;
public void setStrictSyntaxCheck(boolean strictSyntaxCheck) {
this.strictSyntaxCheck = strictSyntaxCheck;
public boolean isConstArithmeticAllow() {
return constArithmeticAllow;
public void setConstArithmeticAllow(boolean constArithmeticAllow) {
this.constArithmeticAllow = constArithmeticAllow;
public Set<String> getDenyFunctions() {
return denyFunctions;
public Set<String> getDenyTables() {
return denyTables;
public Set<String> getDenySchemas() {
return denySchemas;
public Set<String> getDenyVariants() {
return denyVariants;
public Set<String> getDenyObjects() {
return denyObjects;
public Set<String> getReadOnlyTables() {
return readOnlyTables;
public void addReadOnlyTable(String tableName) {
this.readOnlyTables.add(tableName);
public boolean isReadOnly(String tableName) {
return this.readOnlyTables.contains(tableName);
public Set<String> getPermitFunctions() {
return permitFunctions;
public Set<String> getPermitTables() {
return permitTables;
public Set<String> getPermitSchemas() {
return permitSchemas;
public Set<String> getPermitVariants() {
return permitVariants;
public boolean isMustParameterized() {
return mustParameterized;
public void setMustParameterized(boolean mustParameterized) {
this.mustParameterized = mustParameterized;
public boolean isDenyObjects(String name) {
if (!objectCheck) {
return false;
name = WallVisitorUtils.form(name);
return denyObjects.contains(name);
public boolean isDenySchema(String name) {
if (!schemaCheck) {
return false;
name = WallVisitorUtils.form(name);
return this.denySchemas.contains(name);
public boolean isDenyFunction(String name) {
if (!functionCheck) {
return false;
name = WallVisitorUtils.form(name);
return this.denyFunctions.contains(name);
public boolean isCallAllow() {
return callAllow;
public void setCallAllow(boolean callAllow) {
this.callAllow = callAllow;
public class SQLCreateTriggerStatement extends SQLStatementImpl {
private SQLName                  name;
private boolean                  orReplace     = false;
private TriggerType              triggerType;
private final List<TriggerEvent> triggerEvents = new ArrayList<TriggerEvent>();
private SQLName                  on;
private boolean                  forEachRow    = false;
private SQLStatement             body;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
acceptChild(visitor, on);
acceptChild(visitor, body);
visitor.endVisit(this);
public SQLName getOn() {
return on;
public void setOn(SQLName on) {
this.on = on;
public SQLName getName() {
return name;
public void setName(SQLName name) {
if (name != null) {
name.setParent(this);
this.name = name;
public SQLStatement getBody() {
return body;
public void setBody(SQLStatement body) {
if (body != null) {
body.setParent(this);
this.body = body;
public boolean isOrReplace() {
return orReplace;
public void setOrReplace(boolean orReplace) {
this.orReplace = orReplace;
public TriggerType getTriggerType() {
return triggerType;
public void setTriggerType(TriggerType triggerType) {
this.triggerType = triggerType;
public List<TriggerEvent> getTriggerEvents() {
return triggerEvents;
public boolean isForEachRow() {
return forEachRow;
public void setForEachRow(boolean forEachRow) {
this.forEachRow = forEachRow;
public static enum TriggerType {
BEFORE, AFTER, INSTEAD_OF
public static enum TriggerEvent {
INSERT, UPDATE, D
private SQLExpr minValue;
private boolean noMaxValue;
private boolean noMinValue;
acceptChild(visitor, minValue);
public SQLExpr getMinValue() {
return minValue;
public void setMinValue(SQLExpr minValue) {
this.minValue = minValue;
public boolean isNoMaxValue() {
return noMaxValue;
public void setNoMaxValue(boolean noMaxValue) {
this.noMaxValue = noMaxValue;
public boolean isNoMinValue() {
return noMinValue;
public void setNoMinValue(boolean noMinValue) {
this.noMinValue = noMinValue;
} else if (identifierEquals("MINVALUE")) {
lexer.nextToken();
stmt.setMinValue(this.exprParser.expr());
} else if (identifierEquals("MAXVALUE")) {
lexer.nextToken();
stmt.setMaxValue(this.exprParser.expr());
} else if (identifierEquals("NOMAXVALUE")) {
lexer.nextToken();
stmt.setNoMaxValue(true);
} else if (identifierEquals("NOMINVALUE")) {
lexer.nextToken();
stmt.setNoMinValue(true);
if (!(x instanceof SQLStatement)) {
if ((!isPrintPostSemi()) 
&& (!(x.getParent() instanceof OracleBlockStatement))) {
if (x instanceof OraclePLSQLCommitStatement) {
if (x.getParent() instanceof OracleCreateProcedureStatement) {
if (isPrettyFormat()) {
if (x.getParent() != null) {
print(";");
println(";");
if (x.isNoMaxValue()) {
print(" NOMAXVALUE");
if (x.getMinValue() != null) {
print(" MINVALUE ");
x.getMinValue().accept(this);
if (x.isNoMinValue()) {
print(" NOMINVALUE");
} else if (token == Token.TRIGGER) {
return parseCreateTrigger();
public SQLStatement parseCreateTrigger() {
accept(Token.TRIGGER);
SQLCreateTriggerStatement stmt = new SQLCreateTriggerStatement();
stmt.setName(this.exprParser.name());
if (identifierEquals("BEFORE")) {
stmt.setTriggerType(TriggerType.BEFORE);
lexer.nextToken();
} else if (identifierEquals("AFTER")) {
stmt.setTriggerType(TriggerType.AFTER);
lexer.nextToken();
} else if (identifierEquals("INSTEAD")) {
lexer.nextToken();
accept(Token.OF);
stmt.setTriggerType(TriggerType.INSTEAD_OF);
for (;;) {
if (lexer.token() == Token.INSERT) {
lexer.nextToken();
stmt.getTriggerEvents().add(TriggerEvent.INSERT);
continue;
if (lexer.token() == Token.UPDATE) {
lexer.nextToken();
stmt.getTriggerEvents().add(TriggerEvent.UPDATE);
continue;
if (lexer.token() == Token.DELETE) {
lexer.nextToken();
stmt.getTriggerEvents().add(TriggerEvent.DELETE);
continue;
accept(Token.ON);
stmt.setOn(this.exprParser.name());
if (lexer.token() == Token.FOR) {
lexer.nextToken();
acceptIdentifier("EACH");
accept(Token.ROW);
stmt.setForEachRow(true);
SQLStatement body = this.parseBlock();
stmt.setBody(body);
return stmt;
public SQLStatement parseBlock() {
throw new ParserException("TODO " + lexer.token());
public boolean visit(SQLCreateTriggerStatement x) {
print("CREATE ");
if (x.isOrReplace()) {
print("OR REPLEACE ");
print("TRIGGER ");
x.getName().accept(this);
incrementIndent();
println();
if (TriggerType.INSTEAD_OF.equals(x.getTriggerType())) {
print("INSTEAD OF");
print(x.getTriggerType().name());
for (TriggerEvent event : x.getTriggerEvents()) {
print(' ');
print(event.name());
println();
print("ON ");
x.getOn().accept(this);
if (x.isForEachRow()) {
println();
print("FOR EACH ROW");
decrementIndent();
println();
x.getBody().accept(this);
return false;
void endVisit(SQLCreateTriggerStatement x);
boolean visit(SQLCreateTriggerStatement x);
public void endVisit(SQLCreateTriggerStatement x) {
public boolean visit(SQLCreateTriggerStatement x) {
return true;
public boolean visit(SQLCreateTriggerStatement x) {
return false;
public boolean visit(SQLCreateTriggerStatement x) {
return false;
@Override
public boolean visit(SQLCreateTriggerStatement x) {
return false;
@Override
public boolean visit(SQLCreateTriggerStatement x) {
return false;
public boolean visit(SQLCreateTriggerStatement x) {
return false;
@Override
public boolean visit(SQLCreateTriggerStatement x) {
return false;
|| x instanceof SQLCreateTriggerStatement 
|| x instanceof SQLDropViewStatement 
|| x instanceof SQLDropTriggerStatement 
|| x instanceof SQLDropSequenceStatement 
"CREATE TRIGGER "AO_4AEACD_WEBHOOK_D367380484" " 
+ "BEFORE INSERT"
+ "    ON "AO_4AEACD_WEBHOOK_DAO"   FOR EACH ROW "
+ "BEGIN"
+ "    SELECT "AO_4AEACD_WEBHOOK_DAO_ID_SEQ".NEXTVAL INTO :NEW."ID" FROM DUAL;"
public class OracleWallTest4 extends TestCase {
public void test_true() throws Exception {
String sql = 
"select sequence_name from all_sequences  " 
+ "union select synonym_name" 
+ "   from all_synonyms us, all_sequences asq" 
+ "  where asq.sequence_name = us.table_name" 
+ "    and asq.sequence_owner = us.table_owner"; 
Assert.assertTrue(WallUtils.isValidateOracle(sql));
public class OracleWallTest5 extends TestCase {
public void test_true() throws Exception {
String sql = 
"DROP TRIGGER "AO_4AEACD_WEBHOOK_D367380484"";
Assert.assertTrue(WallUtils.isValidateOracle(sql));
SQLStatement stmt = statementList.get(0);
Assert.assertEquals("CREATE SEQUENCE "AO_4AEACD_WEBHOOK_DAO_ID_SEQ" START WITH 1 INCREMENT BY 1 NOMAXVALUE MINVALUE 1",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
stmt.accept(visitor);
public class OracleCreateTriggerTest extends OracleTest {
public void test_0() throws Exception {
String sql = 
"CREATE TRIGGER "AO_4AEACD_WEBHOOK_D367380484" " 
+ "BEFORE INSERT"
+ "    ON "AO_4AEACD_WEBHOOK_DAO"   FOR EACH ROW "
+ "BEGIN"
+ "    SELECT "AO_4AEACD_WEBHOOK_DAO_ID_SEQ".NEXTVAL INTO :NEW."ID" FROM DUAL;"
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TRIGGER "AO_4AEACD_WEBHOOK_D367380484"" 
+ "ntBEFORE INSERT"
+ "ntON "AO_4AEACD_WEBHOOK_DAO""
+ "ntFOR EACH ROW"
+ "nBEGIN"
+ "ntSELECT "AO_4AEACD_WEBHOOK_DAO_ID_SEQ".NEXTVAL"
+ "ntINTO :NEW."ID"" 
+ "ntFROM DUAL;" + "nEND",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class MySqlWallTest96 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "insert into darenai_stat_url SET user='nologin',ip='58.101.223.183',reffer='http:
Assert.assertTrue(provider.checkValid(
public class MySqlUpdateTest_4 extends MysqlTest {
public void test_0() throws Exception {
String sql = "insert into darenai_stat_url SET user='nologin',ip='58.101.223.183',reffer='http:
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("darenai_stat_url")));
Assert.assertTrue(visitor.getColumns().contains(new Column("darenai_stat_url", "user")));
Assert.assertTrue(visitor.getColumns().contains(new Column("darenai_stat_url", "ip")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT INTO darenai_stat_url (user, ip, reffer, url, shopnick"
+ "nt, time)"
+ "nVALUES ('nologin', '58.101.223.183', 'http:
+ "nt, NOW())", 
public class WallBenchmarkTest_mysql extends TestCase {
WallProvider            provider = new MySqlWallProvider();
public final static int COUNT    = 1000 * 1000;
public void test_0() throws Exception {
String sql = "SELECT t1.department_id, t2.*n" + 
"FROM hr_info t1, x2 t2n" + 
"WHERE t2.department_id = t1.department_id";
for (int i = 0; i < 10; ++i) {
provider.clearCache();
long startMillis = System.currentTimeMillis();
perf(sql);
long millis = System.currentTimeMillis() - startMillis;
System.out.println("millis : " + millis);
public void perf(String sql) {
for (int i = 0; i < COUNT; ++i) {
String text = sql + " AND FID = " + i;
provider.check(text);
case INDEX:
case MODEL:
case PCTFREE:
case INITRANS:
case MAXTRANS:
case SEGMENT:
case CREATION:
case IMMEDIATE:
case DEFERRED:
case STORAGE:
case NEXT:
case MINEXTENTS:
case MAXEXTENTS:
case MAXSIZE:
case PCTINCREASE:
case FLASH_CACHE:
case CELL_FLASH_CACHE:
case KEEP:
case NONE:
case LOB:
case STORE:
case ROW:
case CHUNK:
case CACHE:
case NOCACHE:
case LOGGING:
case NOCOMPRESS:
case KEEP_DUPLICATES:
case EXCEPTIONS:
case PURGE:
case FULL:
case IDENTIFIED:
case PASSWORD:
case BINARY:
case WINDOW:
case OFFSET:
case SHARE:
case START:
case CONNECT:
case MATCHED:
case ERRORS:
case REJECT:
case UNLIMITED:
case BEGIN:
case EXCLUSIVE:
case MODE:
case ADVISE:
case INTERV
case IDENTIFIED
case PASSWORD
case BINARY
case WINDOW
case CONNEC
case MATCHED
case REJEC
case UNLIMITED
case EXCLUSIV
} else if (lexer.token() == Token.INDEX) {
lexer.nextToken();
privilege = "INDEX";
} else if (lexer.token() == Token.TRIGGER) {
lexer.nextToken();
privilege = "TRIGGER";
} else if (lexer.token() == Token.TABLESPACE) {
privilege = "CREATE TABLESPACE";
lexer.nextToken();
} else if (lexer.token() == Token.USER) {
privilege = "CREATE USER";
lexer.nextToken();
} else if (lexer.token() == Token.VIEW) {
privilege = "CREATE VIEW";
lexer.nextToken();
} else if (identifierEquals("TEMPORARY")) {
lexer.nextToken();
accept(Token.TABLE);
privilege = "CREATE TEMPORARY TABLE";
privilege = "DROP";
} else if (identifierEquals("EVENT")) {
lexer.nextToken();
privilege = "EVENT";
} else if (identifierEquals("FILE")) {
lexer.nextToken();
privilege = "FILE";
} else if (lexer.token() == Token.GRANT) {
lexer.nextToken();
acceptIdentifier("OPTION");
privilege = "GRANT OPTION";
} else if (lexer.token() == Token.LOCK) {
lexer.nextToken();
acceptIdentifier("TABLES");
privilege = "LOCK TABLES";
} else if (identifierEquals("PROCESS")) {
lexer.nextToken();
privilege = "PROCESS";
} else if (identifierEquals("RELOAD")) {
lexer.nextToken();
privilege = "RELOAD";
} else if (identifierEquals("REPLICATION")) {
lexer.nextToken();
if (identifierEquals("SLAVE")) {
lexer.nextToken();
privilege = "REPLICATION SLAVE";
acceptIdentifier("CLIENT");
privilege = "REPLICATION CLIENT";
} else if (lexer.token() == Token.SHOW) {
lexer.nextToken();
if (lexer.token() == Token.VIEW) {
lexer.nextToken();
privilege = "SHOW VIEW";
acceptIdentifier("DATABASES");
privilege = "SHOW DATABASES";
} else if (identifierEquals("SHUTDOWN")) {
lexer.nextToken();
privilege = "SHUTDOWN";
} else if (identifierEquals("SUPER")) {
lexer.nextToken();
privilege = "SUPER";
DELETE("DELETE"),
INSERT("INSERT"),
UPDATE("UPDATE"),
HAVING("HAVING"),
CREATE("CREATE"),
ALTER("ALTER"),
DROP("DROP"),
SET("SET"),
TABLE("TABLE"),
TABLESPACE("TABLESPACE"),
VIEW("VIEW"),
SEQUENCE("SEQUENCE"),
TRIGGER("TRIGGER"),
USER("USER"),
INDEX("INDEX"),
SESSION("SESSION"),
PROCEDURE("PROCEDURE"),
FUNCTION("FUNCTION"),
PRIMARY("PRIMARY"),
KEY("KEY"),
DEFAULT("DEFAULT"),
CONSTRAINT("CONSTRAINT"),
CHECK("CHECK"),
EXPLAIN("EXPLAIN"),
FOR("FOR"),
WallProvider            provider = new MySqlWallProvider();
"FROM hr_info t1, x2 t2n" + 
public class MySqlGrantTest_11 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT CREATE TABLESPACE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT CREATE TABLESPACE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_12 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT CREATE TEMPORARY TABLE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT CREATE TEMPORARY TABLE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_13 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT CREATE USER ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT CREATE USER ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_14 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT CREATE VIEW ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT CREATE VIEW ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_15 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT DELETE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT DELETE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_16 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT DROP ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT DROP ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_17 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT EVENT ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT EVENT ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_18 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT EXECUTE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT EXECUTE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_19 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT FILE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT FILE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_20 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT GRANT OPTION ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT GRANT OPTION ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_21 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT INDEX ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT INDEX ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_22 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT LOCK TABLES ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT LOCK TABLES ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_23 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT PROXY ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT PROXY ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_24 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT PROCESS ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT PROCESS ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_25 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT REFERENCES ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT REFERENCES ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_26 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT RELOAD ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT RELOAD ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_27 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT REPLICATION CLIENT ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT REPLICATION CLIENT ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_28 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT REPLICATION SLAVE ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT REPLICATION SLAVE ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_29 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT SHOW DATABASES ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT SHOW DATABASES ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_30 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT SHOW VIEW ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT SHOW VIEW ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_31 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT SHUTDOWN ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT SHUTDOWN ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_32 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT SUPER ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT SUPER ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlGrantTest_33 extends MysqlTest {
public void test_0() throws Exception {
String sql = "GRANT TRIGGER ON mydb.* TO 'someuser'@'somehost';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("GRANT TRIGGER ON mydb.* TO 'someuser'@'somehost'", 
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
static Random r = new Random();
String text = genRandomSql();
private String genRandomSql(){
int result1=r.nextInt(65535);
int result2=r.nextInt(65535);
String result = Integer.toBinaryString(result1)+""+Integer.toBinaryString(result2);
StringBuilder sb = new StringBuilder("select ");
for(int i=0;i<result.length();i++){
if(result.charAt(i) == '1'){
String tempString = "col"+(i+1)+",";
sb.append(tempString);
sb.delete(sb.length()-1, sb.length());
sb.append(" from sqlinject");
return sb.toString();
public class OracleSelectTest50 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"SELECT * from ( SELECT ID,MATTER,CODE,NAME,ADDRESS,AREA,PROPOSER,PROPOSER_CONTACTOR,PROPOSER_PHONE,REG_TIME,ASSIGN_TIME,DEPART,HANDLER,HANDLER_PHONE,STATUS,FINISH_DATE,FINISH_TYPE,DEPART_CODE,SYSTEM_CODE,rownum num FROM gxpt_items WHERE rownum<=20  order by REG_TIME desc )  WHERE num>0"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(20, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT *"
+ "nFROM (" 
+ "ntSELECT ID, MATTER, CODE, NAME, ADDRESS"
+ "ntt, AREA, PROPOSER, PROPOSER_CONTACTOR, PROPOSER_PHONE, REG_TIME"
+ "ntt, ASSIGN_TIME, DEPART, HANDLER, HANDLER_PHONE, STATUS"
+ "ntt, FINISH_DATE, FINISH_TYPE, DEPART_CODE, SYSTEM_CODE, rownum AS num"
+ "ntFROM gxpt_items"
+ "ntWHERE rownum <= 20"
+ "ntORDER BY REG_TIME DESC"
+ "nWHERE num > 0;"
+ "n", text);
public class SQLDropFunctionStatement extends SQLStatementImpl implements SQLDDLStatement {
private SQLName name;
private boolean ifExists;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
if (name != null) {
name.setParent(this);
this.name = name;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
public class SQLDropProcedureStatement extends SQLStatementImpl implements SQLDDLStatement {
private SQLName name;
private boolean ifExists;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
if (name != null) {
name.setParent(this);
this.name = name;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
public class SQLDropTableSpaceStatement extends SQLStatementImpl implements SQLDDLStatement {
private SQLName name;
private boolean ifExists;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, name);
visitor.endVisit(this);
public SQLName getName() {
return name;
public void setName(SQLName name) {
if (name != null) {
name.setParent(this);
this.name = name;
public boolean isIfExists() {
return ifExists;
public void setIfExists(boolean ifExists) {
this.ifExists = ifExists;
} else if (lexer.token() == Token.FUNCTION) {
SQLStatement stmt = parseDropFunction(false);
statementList.add(stmt);
continue;
} else if (lexer.token() == Token.TABLESPACE) {
SQLStatement stmt = parseDropTablespace(false);
statementList.add(stmt);
continue;
} else if (lexer.token() == Token.PROCEDURE) {
SQLStatement stmt = parseDropProcedure(false);
statementList.add(stmt);
continue;
protected SQLDropFunctionStatement parseDropFunction(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
SQLDropFunctionStatement stmt = new SQLDropFunctionStatement();
accept(Token.FUNCTION);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
SQLName name = this.exprParser.name();
stmt.setName(name);
return stmt;
protected SQLDropTableSpaceStatement parseDropTablespace(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
SQLDropTableSpaceStatement stmt = new SQLDropTableSpaceStatement();
accept(Token.TABLESPACE);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
SQLName name = this.exprParser.name();
stmt.setName(name);
return stmt;
protected SQLDropProcedureStatement parseDropProcedure(boolean acceptDrop) {
if (acceptDrop) {
accept(Token.DROP);
SQLDropProcedureStatement stmt = new SQLDropProcedureStatement();
accept(Token.PROCEDURE);
if (lexer.token() == Token.IF) {
lexer.nextToken();
accept(Token.EXISTS);
stmt.setIfExists(true);
SQLName name = this.exprParser.name();
stmt.setName(name);
return stmt;
public boolean visit(SQLDropFunctionStatement x) {
print("DROP FUNCTION ");
if (x.isIfExists()) {
print("IF EXISTS ");
x.getName().accept(this);
return false;
public boolean visit(SQLDropTableSpaceStatement x) {
print("DROP TABLESPACE ");
if (x.isIfExists()) {
print("IF EXISTS ");
x.getName().accept(this);
return false;
public boolean visit(SQLDropProcedureStatement x) {
print("DROP PROCEDURE ");
if (x.isIfExists()) {
print("IF EXISTS ");
x.getName().accept(this);
return false;
void endVisit(SQLDropFunctionStatement x);
boolean visit(SQLDropFunctionStatement x);
void endVisit(SQLDropTableSpaceStatement x);
boolean visit(SQLDropTableSpaceStatement x);
void endVisit(SQLDropProcedureStatement x);
boolean visit(SQLDropProcedureStatement x);
public void endVisit(SQLDropFunctionStatement x) {
public boolean visit(SQLDropFunctionStatement x) {
return true;
public void endVisit(SQLDropTableSpaceStatement x) {
public boolean visit(SQLDropTableSpaceStatement x) {
return true;
public void endVisit(SQLDropProcedureStatement x) {
public boolean visit(SQLDropProcedureStatement x) {
return true;
public boolean visit(SQLDropFunctionStatement x) {
return false;
public boolean visit(SQLDropTableSpaceStatement x) {
return false;
public boolean visit(SQLDropProcedureStatement x) {
return false;
public class MySqlDropFunctionTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP FUNCTION function_name";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlDropProcedureTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP PROCEDURE IF EXISTS sp_name";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public class MySqlDropTablespaceTest extends MysqlTest {
public void test_0() throws Exception {
String sql = "DROP TABLESPACE tablespace_name";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
setTarget(target);
setValue(value);
if (target != null) {
target.setParent(this);
if (value != null) {
value.setParent(this);
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
parseAssignItems(stmt.getItems(), stmt);
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
parseAssignItems(stmt.getItems(), stmt);
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
parseAssignItems(stmt.getItems(), stmt);
public void parseAssignItems(List<SQLAssignItem> items, SQLObject parent) {
item.setParent(parent);
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
if (!checkParameterize(x)) {
if (!checkParameterize(x)) {
public static boolean checkParameterize(SQLObject x) {
if (Boolean.TRUE.equals(x.getAttribute(ParameterizedOutputVisitorUtils.ATTR_PARAMS_SKIP))) {
return false;
SQLObject parent = x.getParent();
if (parent instanceof SQLDataType 
|| parent instanceof SQLColumnDefinition 
|| parent instanceof SQLServerTop 
|| parent instanceof SQLAssignItem 
return false;
return true;
public static boolean visit(PrintableVisitor visitor, SQLCharExpr x) {
visitor.print(''');
String text = x.getText();
text = text.replaceAll("'", "''");
text = text.replaceAll("\\", "\\");
visitor.print(text);
visitor.print(''');
return false;
public class MySqlParameterizedOutputVisitorTest_6 extends TestCase {
public void test_0() throws Exception {
String sql = "SET autocommit=1";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public void test_1() throws Exception {
String sql = "SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;";
Assert.assertSame(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), sql);
public class MySqlDeleteTest_3 extends MysqlTest {
public void test_0() throws Exception {
String sql = "DELETE FROM t1 " 
+ "WHERE s11 > ANY"
+ "(SELECT COUNT(*) /* no hint */ FROM t2"
+ "  WHERE NOT EXISTS"
+ "   (SELECT * FROM t3"
+ "    WHERE ROW(5*t2.s1,77)="
+ "     (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM"
+ "      (SELECT * FROM t5) AS t5)));";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(5, visitor.getTables().size());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t1", "s11")));
Assert.assertTrue(visitor.getColumns().contains(new Column("t2", "*")));
public class MySqlSelectTest_14 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t1")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t2")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT *" 
+ "nFROM t1"
+ "nWHERE column1 = ("
+ "ntSELECT column1"
+ "ntFROM t2"
+ "nt)", 
} catch (Throwable ex) {
AccessController.doPrivileged(new PrivilegedAction<Object>() {
public Object run() {
ObjectName objectName = DruidDataSourceStatManager.addDataSource(DruidDataSource.this,
DruidDataSource.this.name);
DruidDataSource.this.setObjectName(objectName);
DruidDataSource.this.mbeanRegistered = true;
return null;
AccessController.doPrivileged(new PrivilegedAction<Object>() {
public Object run() {
DruidDataSourceStatManager.removeDataSource(DruidDataSource.this);
DruidDataSource.this.mbeanRegistered = false;
return null;
AccessController.doPrivileged(new PrivilegedAction<Object>() {
public Object run() {
registerDriver(instance);
return null;
public class OracleDeleteTest_1 extends OracleTest {
public void test_0() throws Exception {
String sql = "delete fromm xx";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("fromm")));
public final static int RevisionVersion = 26;
public class OracleCreateTableTest35 extends OracleTest {
public void test_types() throws Exception {
String sql = 
"create table sto_scandata_bak_2013_05_08_023000 AS (select * from sto_scandata t where t.delflag=1 )";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
Assert.assertEquals("CREATE TABLE sto_scandata_bak_2013_05_08_023000" 
+ "nSELECT *"
+ "nFROM sto_scandata t"
+ "nWHERE t.delflag = 1",
SQLUtils.toSQLString(stmt, JdbcConstants.ORACLE));
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("sto_scandata", "*")));
public abstract class DB2StatementImpl extends SQLStatementImpl implements DB2Object {
protected void accept0(SQLASTVisitor visitor) {
if (visitor instanceof DB2ASTVisitor) {
accept0((DB2ASTVisitor) visitor);
super.accept0(visitor);
public abstract void accept0(DB2ASTVisitor visitor);
public class DB2ValuesStatement extends DB2StatementImpl {
private SQLExpr expr;
public void accept0(DB2ASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, expr);
visitor.endVisit(this);
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
if (expr != null) {
expr.setParent(this);
this.expr = expr;
public boolean parseStatementListDialect(List<SQLStatement> statementList) {
if (lexer.token() == Token.VALUES) {
lexer.nextToken();
DB2ValuesStatement stmt = new DB2ValuesStatement();
stmt.setExpr(this.exprParser.expr());
statementList.add(stmt);
return true;
return false;
boolean visit(DB2ValuesStatement x);
void endVisit(DB2ValuesStatement x);
public boolean visit(DB2ValuesStatement x) {
return true;
public void endVisit(DB2ValuesStatement x) {
public boolean visit(DB2ValuesStatement x) {
print("VALUES ");
x.getExpr().accept(this);
return false;
public void endVisit(DB2ValuesStatement x) {
public boolean visit(DB2ValuesStatement x) {
return false;
public void endVisit(DB2ValuesStatement x) {
public class DB2Values_Test extends DB2Test {
public void test_0() throws Exception {
String sql = "values 1";
DB2StatementParser parser = new DB2StatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
DB2SchemaStatVisitor visitor = new DB2SchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.DB2);
Assert.assertEquals("VALUES 1", 
public final static int              DEFAULT_MAX_STAT_SESSION_COUNT    = 1000 * 1;
public class HADataSource extends WrapperAdapter implements DataSource {
private int             loginTimeSeconds;
protected PrintWriter   logWriter = new PrintWriter(System.out);
private DruidDataSource master;
private DruidDataSource second;
public DruidDataSource getMaster() {
return master;
public void setMaster(DruidDataSource master) {
this.master = master;
public DruidDataSource getSecond() {
return second;
public void setSecond(DruidDataSource second) {
this.second = second;
public PrintWriter getLogWriter() throws SQLException {
return logWriter;
public void setLogWriter(PrintWriter out) throws SQLException {
this.logWriter = out;
public void setLoginTimeout(int seconds) throws SQLException {
this.loginTimeSeconds = seconds;
public int getLoginTimeout() throws SQLException {
return loginTimeSeconds;
public Logger getParentLogger() throws SQLFeatureNotSupportedException {
throw new SQLFeatureNotSupportedException();
public Connection getConnection() throws SQLException {
throw new SQLFeatureNotSupportedException();
public Connection getConnection(String username, String password) throws SQLException {
throw new SQLFeatureNotSupportedException();
private final static ThreadLocal<SpringMethodStat>       currentLocal                     = new ThreadLocal<SpringMethodStat>();
private final SpringMethodInfo                           methodInfo;
private final AtomicInteger                              runningCount                     = new AtomicInteger();
private final AtomicInteger                              concurrentMax                    = new AtomicInteger();
private final AtomicLong                                 executeCount                     = new AtomicLong(0);
private final AtomicLong                                 executeErrorCount                = new AtomicLong(0);
private final AtomicLong                                 executeTimeNano                  = new AtomicLong();
private final AtomicLong                                 jdbcFetchRowCount                = new AtomicLong();
private final AtomicLong                                 jdbcUpdateCount                  = new AtomicLong();
private final AtomicLong                                 jdbcExecuteCount                 = new AtomicLong();
private final AtomicLong                                 jdbcExecuteErrorCount            = new AtomicLong();
private final AtomicLong                                 jdbcExecuteTimeNano              = new AtomicLong();
private final AtomicLong                                 jdbcCommitCount                  = new AtomicLong();
private final AtomicLong                                 jdbcRollbackCount                = new AtomicLong();
private final AtomicLong                                 jdbcPoolConnectionOpenCount      = new AtomicLong();
private final AtomicLong                                 jdbcPoolConnectionCloseCount     = new AtomicLong();
private final AtomicLong                                 jdbcResultSetOpenCount           = new AtomicLong();
private final AtomicLong                                 jdbcResultSetCloseCount          = new AtomicLong();
private volatile Throwable                               lastError;
private volatile long                                    lastErrorTimeMillis;
private volatile long                                    histogram_0_1;
private volatile long                                    histogram_1_10;
private volatile long                                    histogram_10_100;
private volatile long                                    histogram_100_1000;
private volatile int                                     histogram_1000_10000;
private volatile int                                     histogram_10000_100000;
private volatile int                                     histogram_100000_1000000;
private volatile int                                     histogram_1000000_more;
final static AtomicLongFieldUpdater<SpringMethodStat>    histogram_0_1_Updater            = AtomicLongFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_0_1");
final static AtomicLongFieldUpdater<SpringMethodStat>    histogram_1_10_Updater           = AtomicLongFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_1_10");
final static AtomicLongFieldUpdater<SpringMethodStat>    histogram_10_100_Updater         = AtomicLongFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_10_100");
final static AtomicLongFieldUpdater<SpringMethodStat>    histogram_100_1000_Updater       = AtomicLongFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_100_1000");
final static AtomicIntegerFieldUpdater<SpringMethodStat> histogram_1000_10000_Updater     = AtomicIntegerFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_1000_10000");
final static AtomicIntegerFieldUpdater<SpringMethodStat> histogram_10000_100000_Updater   = AtomicIntegerFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_10000_100000");
final static AtomicIntegerFieldUpdater<SpringMethodStat> histogram_100000_1000000_Updater = AtomicIntegerFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_100000_1000000");
final static AtomicIntegerFieldUpdater<SpringMethodStat> histogram_1000000_more_Updater   = AtomicIntegerFieldUpdater.newUpdater(SpringMethodStat.class,
"histogram_1000000_more");
public SpringMethodStat(SpringMethodInfo methodInfo){
this.methodInfo = methodInfo;
public SpringMethodStatValue getStatValue(boolean reset) {
SpringMethodStatValue val = new SpringMethodStatValue();
val.setClassName(this.getMethodInfo().getClassName());
val.setSignature(this.getMethodInfo().getSignature());
val.setRunningCount(this.getRunningCount());
val.setConcurrentMax(get(this.concurrentMax, reset));
val.setExecuteCount(get(this.executeCount, reset));
val.setExecuteErrorCount(get(this.executeErrorCount, reset));
val.setExecuteTimeNano(get(this.executeTimeNano, reset));
val.setJdbcFetchRowCount(get(this.jdbcFetchRowCount, reset));
val.setJdbcUpdateCount(get(this.jdbcUpdateCount, reset));
val.setJdbcExecuteCount(get(this.jdbcExecuteCount, reset));
val.setJdbcExecuteErrorCount(get(this.jdbcExecuteErrorCount, reset));
val.setJdbcExecuteTimeNano(get(this.jdbcExecuteTimeNano, reset));
val.setJdbcCommitCount(get(this.jdbcCommitCount, reset));
val.setJdbcRollbackCount(get(this.jdbcRollbackCount, reset));
val.setJdbcPoolConnectionOpenCount(get(this.jdbcPoolConnectionOpenCount, reset));
val.setJdbcPoolConnectionCloseCount(get(this.jdbcPoolConnectionCloseCount, reset));
val.setJdbcResultSetOpenCount(get(this.jdbcResultSetOpenCount, reset));
val.setJdbcResultSetCloseCount(get(this.jdbcResultSetCloseCount, reset));
val.setLastError(this.lastError);
val.setLastErrorTimeMillis(this.lastErrorTimeMillis);
if (reset) {
this.lastError = null;
this.lastErrorTimeMillis = 0;
val.histogram_0_1 = get(this, histogram_0_1_Updater, reset);
val.histogram_1_10 = get(this, histogram_1_10_Updater, reset);
val.histogram_10_100 = get(this, histogram_10_100_Updater, reset);
val.histogram_100_1000 = get(this, histogram_100_1000_Updater, reset);
val.histogram_1000_10000 = get(this, histogram_1000_10000_Updater, reset);
val.histogram_10000_100000 = get(this, histogram_10000_100000_Updater, reset);
val.histogram_100000_1000000 = get(this, histogram_100000_1000000_Updater, reset);
val.histogram_1000000_more = get(this, histogram_1000000_more_Updater, reset);
return val;
histogram_0_1_Updater.set(this, 0);
histogram_1_10_Updater.set(this, 0);
histogram_10_100_Updater.set(this, 0);
histogram_100_1000_Updater.set(this, 0);
histogram_1000_10000_Updater.set(this, 0);
histogram_10000_100000_Updater.set(this, 0);
histogram_100000_1000000_Updater.set(this, 0);
histogram_1000000_more_Updater.set(this, 0);
histogramRecord(nanos);
private void histogramRecord(long nanos) {
final long millis = nanos / 1000 / 1000;
if (millis < 1) {
histogram_0_1_Updater.incrementAndGet(this);
} else if (millis < 10) {
histogram_1_10_Updater.incrementAndGet(this);
} else if (millis < 100) {
histogram_10_100_Updater.incrementAndGet(this);
} else if (millis < 1000) {
histogram_100_1000_Updater.incrementAndGet(this);
} else if (millis < 10000) {
histogram_1000_10000_Updater.incrementAndGet(this);
} else if (millis < 100000) {
histogram_10000_100000_Updater.incrementAndGet(this);
} else if (millis < 1000000) {
histogram_100000_1000000_Updater.incrementAndGet(this);
histogram_1000000_more_Updater.incrementAndGet(this);
public long[] getHistogramValues() {
return new long[] {
histogram_0_1, 
histogram_1_10, 
histogram_10_100, 
histogram_100_1000, 
histogram_1000_10000, 
histogram_10000_100000, 
histogram_100000_1000000, 
histogram_1000000_more 
public int getConcurrentMax() {
return getStatValue(false).getData();
public class SpringMethodStatValue {
private String    className;
private String    signature;
private int       runningCount;
private int       concurrentMax;
private long      executeCount;
private long      executeErrorCount;
private long      executeTimeNano;
private long      jdbcFetchRowCount;
private long      jdbcUpdateCount;
private long      jdbcExecuteCount;
private long      jdbcExecuteErrorCount;
private long      jdbcExecuteTimeNano;
private long      jdbcCommitCount;
private long      jdbcRollbackCount;
private long      jdbcPoolConnectionOpenCount;
private long      jdbcPoolConnectionCloseCount;
private long      jdbcResultSetOpenCount;
private long      jdbcResultSetCloseCount;
private Throwable lastError;
private long      lastErrorTimeMillis;
long              histogram_0_1;
long              histogram_1_10;
long              histogram_10_100;
long              histogram_100_1000;
int               histogram_1000_10000;
int               histogram_10000_100000;
int               histogram_100000_1000000;
int               histogram_1000000_more;
public String getClassName() {
return className;
public void setClassName(String className) {
this.className = className;
public String getSignature() {
return signature;
public void setSignature(String signature) {
this.signature = signature;
public int getRunningCount() {
return runningCount;
public void setRunningCount(int runningCount) {
this.runningCount = runningCount;
public int getConcurrentMax() {
return concurrentMax;
public void setConcurrentMax(int concurrentMax) {
this.concurrentMax = concurrentMax;
public long getExecuteCount() {
return executeCount;
public void setExecuteCount(long executeCount) {
this.executeCount = executeCount;
public long getExecuteErrorCount() {
return executeErrorCount;
public void setExecuteErrorCount(long executeErrorCount) {
this.executeErrorCount = executeErrorCount;
public long getExecuteTimeNano() {
return executeTimeNano;
public void setExecuteTimeNano(long executeTimeNano) {
this.executeTimeNano = executeTimeNano;
public long getJdbcFetchRowCount() {
return jdbcFetchRowCount;
public void setJdbcFetchRowCount(long jdbcFetchRowCount) {
this.jdbcFetchRowCount = jdbcFetchRowCount;
public long getJdbcUpdateCount() {
return jdbcUpdateCount;
public void setJdbcUpdateCount(long jdbcUpdateCount) {
this.jdbcUpdateCount = jdbcUpdateCount;
public long getJdbcExecuteCount() {
return jdbcExecuteCount;
public void setJdbcExecuteCount(long jdbcExecuteCount) {
this.jdbcExecuteCount = jdbcExecuteCount;
public long getJdbcExecuteErrorCount() {
return jdbcExecuteErrorCount;
public void setJdbcExecuteErrorCount(long jdbcExecuteErrorCount) {
this.jdbcExecuteErrorCount = jdbcExecuteErrorCount;
public long getJdbcExecuteTimeNano() {
return jdbcExecuteTimeNano;
public void setJdbcExecuteTimeNano(long jdbcExecuteTimeNano) {
this.jdbcExecuteTimeNano = jdbcExecuteTimeNano;
public long getJdbcCommitCount() {
return jdbcCommitCount;
public void setJdbcCommitCount(long jdbcCommitCount) {
this.jdbcCommitCount = jdbcCommitCount;
public long getJdbcRollbackCount() {
return jdbcRollbackCount;
public void setJdbcRollbackCount(long jdbcRollbackCount) {
this.jdbcRollbackCount = jdbcRollbackCount;
public long getJdbcPoolConnectionOpenCount() {
return jdbcPoolConnectionOpenCount;
public void setJdbcPoolConnectionOpenCount(long jdbcPoolConnectionOpenCount) {
this.jdbcPoolConnectionOpenCount = jdbcPoolConnectionOpenCount;
public long getJdbcPoolConnectionCloseCount() {
return jdbcPoolConnectionCloseCount;
public void setJdbcPoolConnectionCloseCount(long jdbcPoolConnectionCloseCount) {
this.jdbcPoolConnectionCloseCount = jdbcPoolConnectionCloseCount;
public long getJdbcResultSetOpenCount() {
return jdbcResultSetOpenCount;
public void setJdbcResultSetOpenCount(long jdbcResultSetOpenCount) {
this.jdbcResultSetOpenCount = jdbcResultSetOpenCount;
public long getJdbcResultSetCloseCount() {
return jdbcResultSetCloseCount;
public void setJdbcResultSetCloseCount(long jdbcResultSetCloseCount) {
this.jdbcResultSetCloseCount = jdbcResultSetCloseCount;
public Throwable getLastError() {
return lastError;
public void setLastError(Throwable lastError) {
this.lastError = lastError;
public long getLastErrorTimeMillis() {
return lastErrorTimeMillis;
public void setLastErrorTimeMillis(long lastErrorTimeMillis) {
this.lastErrorTimeMillis = lastErrorTimeMillis;
public long getExecuteTimeMillis() {
return getExecuteTimeNano() / (1000 * 1000);
public long getJdbcExecuteTimeMillis() {
return getJdbcExecuteTimeNano() / (1000 * 1000);
public Date getLastErrorTime() {
if (lastErrorTimeMillis <= 0) {
return null;
return new Date(lastErrorTimeMillis);
public long[] getHistogram() {
return new long[] {
histogram_0_1, 
histogram_1_10, 
histogram_10_100, 
histogram_100_1000, 
histogram_1000_10000, 
histogram_10000_100000, 
histogram_100000_1000000, 
histogram_1000000_more 
public Map<String, Object> getData() {
Map<String, Object> data = new LinkedHashMap<String, Object>();
data.put("Class", this.getClassName());
data.put("Method", this.getSignature());
data.put("RunningCount", this.getRunningCount());
data.put("ConcurrentMax", this.getConcurrentMax());
data.put("ExecuteCount", this.getExecuteCount());
data.put("ExecuteErrorCount", this.getExecuteErrorCount());
data.put("ExecuteTimeMillis", this.getExecuteTimeMillis());
data.put("JdbcCommitCount", this.getJdbcCommitCount());
data.put("JdbcRollbackCount", this.getJdbcRollbackCount());
data.put("JdbcPoolConnectionOpenCount", this.getJdbcPoolConnectionOpenCount());
data.put("JdbcPoolConnectionCloseCount", this.getJdbcPoolConnectionCloseCount());
data.put("JdbcResultSetOpenCount", this.getJdbcResultSetOpenCount());
data.put("JdbcResultSetCloseCount", this.getJdbcResultSetCloseCount());
data.put("JdbcExecuteCount", this.getJdbcExecuteCount());
data.put("JdbcExecuteErrorCount", this.getJdbcExecuteErrorCount());
data.put("JdbcExecuteTimeMillis", this.getJdbcExecuteTimeMillis());
data.put("JdbcFetchRowCount", this.getJdbcFetchRowCount());
data.put("JdbcUpdateCount", this.getJdbcUpdateCount());
data.put("LastError", this.getLastError());
data.put("LastErrorTime", this.getLastErrorTime());
data.put("Histogram", this.getHistogram());
return data;
if (WallVisitorUtils.queryBlockFromIsNull(visitor, x.getRight())) {
Assert.assertTrue(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select * from t", config));
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select 1, 2, 3", config));
public class OracleWallTest6 extends TestCase {
public void test_true() throws Exception {
String sql = 
"select *"
+ "  from (SELECT Distinct notice.NSERIAL,"
+ "                        unit.CUNIT_name,"
+ "                        us.CUSER_name,"
+ "                        to_char(notice.DCREATE, 'yyyy-mm-dd') DCREATE,"
+ "                        notice.csubject,"
+ "                        notice.ccontent"
+ "          From mewp_notice_info notice, bas_user us, bas_unit unit"
+ "          Left Join bas_area xsArea"
+ "            On unit.ccounty_code = xsArea.Carea_Code"
+ "          Left Join bas_area pqArea"
+ "            On unit.cpiece_code = pqArea.Carea_Code"
+ "          Left Join bas_area xzArea"
+ "            On unit.cctown_code = xzArea.Carea_Code"
+ "          Left Join bas_area czArea"
+ "            On unit.cvillage_code = czArea.Carea_Code"
+ "         Where notice.cunit_code = unit.cunit_code"
+ "           And notice.cuser_id = us.cuser_code"
+ "           And notice.nstate = 4"
+ "           And (notice.nrole = '****' or notice.nrole = '202')"
+ "           and notice.cunit_code in"
+ "               (select 'CP0008'"
+ "                  from dual"
+ "                union"
+ "                select Distinct t.cunit_code"
+ "                  from bas_unit t, bas_area us"
+ "                 where t.ccounty_code = us.carea_code"
+ "                   and t.ccounty_code = 'CP'"
+ "                   and t.ctype = '201'"
+ "                union"
+ "                select Distinct auser.cunit_code"
+ "                  from bas_user auser, bas_user_role ur"
+ "                 where auser.cuser_code = ur.cuser_code"
+ "                   and (ur.nrole_id = '1' or ur.nrole_id = '20'))"
+ "         order by DCREATE desc)"
+ " where rownum <= 30";
Assert.assertTrue(WallUtils.isValidateOracle(sql));
private final AtomicLong                        osWindows8Count                = new AtomicLong();
osWindows8Count.set(0);
data.put("OSWindows8Count", this.getOSWindows8Count());
} else if (userAgent.startsWith("Windows NT 6.2", 13)) {
osWindows8Count.incrementAndGet();
} else if (userAgent.startsWith("Windows NT 6.2", 36)) {
osWindows8Count.incrementAndGet();
public long getOSWindows8Count() {
return osWindows8Count.get();
public class UserAgentWin8ChromeTest extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36");
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(1, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentWin8IETest extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(1, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentWin8IETest_2 extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(1, stat.getBrowserIECount());
Assert.assertEquals(1, stat.getBrowserIE10Count());
Assert.assertEquals(0, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIpadCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(0, stat.getOSLinuxCount());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(1, stat.getOSWindowsCount());
Assert.assertEquals(1, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
private final AtomicLong                        osAndroid41Count               = new AtomicLong(0);
osAndroid41Count.set(0);
data.put("OSAndroid41Count", this.getOSAndroid41Count());
int toffset = 31;
if (!isAndroid) {
isAndroid = userAgent.startsWith("Android", 20);
toffset = 28;
} else if (userAgent.startsWith("4.1", toffset)) {
osAndroid41Count.incrementAndGet();
public long getOSAndroid41Count() {
return osAndroid41Count.get();
public class UserAgentAndroid_4_0_3_Test extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid40Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentAndroid_4_0_3_Test_2 extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 4.0.3; de-ch; HTC Sensation Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid40Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentAndroid_4_0_4_Test extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19");
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid40Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentAndroid_4_1_Test extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; Android 4.1.1; Galaxy Nexus Build/JRO03C) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Mobile Safari/535.19");
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid41Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
private final AtomicLong                        osAndroid42Count               = new AtomicLong(0);
private final AtomicLong                        osAndroid43Count               = new AtomicLong(0);
osAndroid42Count.set(0);
osAndroid43Count.set(0);
data.put("OSAndroid42Count", this.getOSAndroid42Count());
data.put("OSAndroid43Count", this.getOSAndroid43Count());
} else if (userAgent.startsWith("4.2", toffset)) {
osAndroid42Count.incrementAndGet();
} else if (userAgent.startsWith("4.3", toffset)) {
osAndroid43Count.incrementAndGet();
public long getOSAndroid42Count() {
return osAndroid42Count.get();
public long getOSAndroid43Count() {
return osAndroid43Count.get();
public class UserAgentAndroid_4_2_Test_2 extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 4.2; en-us; Nexus 10 Build/JVP15I) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30");
Assert.assertEquals(0, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid42Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
public class UserAgentAndroid_4_3_Test_2 extends TestCase {
public void test_mac_firefox() throws Exception {
WebAppStat stat = new WebAppStat("");
stat.computeUserAgent("Mozilla/5.0 (Linux; U; Android 4.3; en-us; Nexus 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36");
Assert.assertEquals(1, stat.getBrowserChromeCount());
Assert.assertEquals(0, stat.getBrowserFirefoxCount());
Assert.assertEquals(0, stat.getBrowserOperaCount());
Assert.assertEquals(0, stat.getBrowserSafariCount());
Assert.assertEquals(0, stat.getBrowserIECount());
Assert.assertEquals(0, stat.getBrowserIE10Count());
Assert.assertEquals(1, stat.getDeviceAndroidCount());
Assert.assertEquals(0, stat.getDeviceIphoneCount());
Assert.assertEquals(0, stat.getDeviceWindowsPhoneCount());
Assert.assertEquals(1, stat.getOSLinuxCount());
Assert.assertEquals(1, stat.getOSAndroidCount());
Assert.assertEquals(1, stat.getOSAndroid43Count());
Assert.assertEquals(0, stat.getOSLinuxUbuntuCount());
Assert.assertEquals(0, stat.getOSMacOSXCount());
Assert.assertEquals(0, stat.getOSWindowsCount());
Assert.assertEquals(0, stat.getOSWindows8Count());
Assert.assertEquals(0, stat.getOSSymbianCount());
Assert.assertEquals(0, stat.getOSFreeBSDCount());
Assert.assertEquals(0, stat.getOSOpenBSDCount());
List<Map<String, Object>> sessionStatDataList = new ArrayList<Map<String, Object>>(this.sessionStatMap.size());
sessionStatDataList.add(sessionStatData);
return sessionStatDataList;
val.requestCount = get(this, requestCountUpdater, reset);
print("PRIMARY KEY");
@MField(name = "rsHoldTime")
@MField(name = "execRsHoldTime")
for (Field field : clazz.getDeclaredFields()) {
String sql = buildCreateSql(dao, new BeanInfo(DruidDataSourceStatValue.class));
System.out.println(SQLUtils.format(sql, JdbcConstants.MYSQL));
JdbcUtils.execute(dataSource, sql, Collections.emptyList());
String sql = buildCreateSql(dao, new BeanInfo(WebURIStatValue.class));
System.out.println(SQLUtils.format(sql, JdbcConstants.MYSQL));
JdbcUtils.execute(dataSource, sql, Collections.emptyList());
String sql = buildCreateSql(dao, new BeanInfo(WebAppStatValue.class));
System.out.println(SQLUtils.format(sql, JdbcConstants.MYSQL));
JdbcUtils.execute(dataSource, sql, Collections.emptyList());
String sql = buildCreateSql(dao, new BeanInfo(SpringMethodStatValue.class));
System.out.println(SQLUtils.format(sql, JdbcConstants.MYSQL));
JdbcUtils.execute(dataSource, sql, Collections.emptyList());
Assert.assertEquals(5, sqlList.size());
Assert.assertEquals(7, sqlList.size());
buf.append(", domain varchar(45)  NOT NULL");
buf.append(", app varchar(45)  NOT NULL");
buf.append(", cluster varchar(45)  NOT NULL");
buf.append(", pid int(10)  NOT NULL");
WallProviderStatValue wallStatValue = getWallStatValue(false);
if (wallStatValue != null) {
return wallStatValue.toMap();
return null;
public WallProviderStatValue getWallStatValue(boolean reset) {
return wallFilter.getProvider().getStatValue(reset);
List<WallProviderStatValue> wallStatValueList = new ArrayList<WallProviderStatValue>();
dataSource.getWallStatMap();
WallProviderStatValue wallStatValue = dataSource.getWallStatValue(true);
if (wallStatValue != null && wallStatValue.getCheckCount() > 0) {
wallStatValueList.add(wallStatValue);
void saveSqlWall(MonitorContext ctx, List<WallProviderStatValue> statList);
public void saveSqlWall(MonitorContext ctx, List<WallProviderStatValue> statList) {
provider.setName(dataSource.getName());
@MTable(name = "druid_wall_function")
@MTable(name = "druid_wall")
@MTable(name = "druid_wall_sql")
@MTable(name = "druid_wall_table")
@MTable(name = "druid_datasource")
@MField(groupBy = true)
@MField(groupBy = true)
@MField(groupBy = true)
@MField(groupBy = true)
boolean groupBy() default false;
protected void setParameterForSqlStat(BeanInfo beanInfo, 
MonitorContext ctx, 
PreparedStatement stmt, 
Object sqlStat) throws SQLException {
private final List<FieldInfo> fields        = new ArrayList<FieldInfo>();
private final List<FieldInfo> groupByFields = new ArrayList<FieldInfo>();
FieldInfo fieldInfo = new FieldInfo(field, columnName);
fields.add(fieldInfo);
if (annotation.groupBy()) {
groupByFields.add(fieldInfo);
public List<FieldInfo> getGroupByFields() {
return groupByFields;
@MField(groupBy = true)
@MField(groupBy = true)
"ADD PRIMARY KEY (`fid`)", output);
"ntADD CONSTRAINT mYconstraint PRIMARY KEY (id)", output);
+ "ntCONSTRAINT PK_issuestatus PRIMARY KEY (ID)"
+ "ntPRIMARY KEY (ID)"
if (lexer.token() == Token.KEY) {
lexer.nextToken();
public class MySqlCreateTableTest49 extends MysqlTest {
public void test_0() throws Exception {
String sql = "    create table tauth (" 
+ "        cid varchar(36) not null unique,"
+ "        cdesc varchar(200),"
+ "        cname varchar(100) not null,"
+ "        cseq decimal(22,0),"
+ "        curl varchar(200),"
+ "        cpid varchar(36),"
+ "        primary key (cid)"
+ "    )"; 
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("tauth")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE tauth (" 
+ "ntcid varchar(36) NOT NULL PRIMARY KEY, "
+ "ntcdesc varchar(200), "
+ "ntcname varchar(100) NOT NULL, "
+ "ntcseq decimal(22, 0), "
+ "ntcurl varchar(200), "
+ "ntcpid varchar(36), "
+ "ntPRIMARY KEY (cid)"
public enum AggregateType {
String value = hashField.getCacheValue(hash);
if (value == null) {
value = getConstValueFromDb(domain, app, hashField.getHashForType(), hash);
hashField.getHashFor().set(statValue, value);
protected String getConstValueFromDb(String domain, String app, String type, Long hash) {
String sql = "select value from druid_const where domain = ? AND app = ? and type = ? and hash = ?";
Connection conn = null;
PreparedStatement stmt = null;
ResultSet rs = null;
conn = dataSource.getConnection();
stmt = conn.prepareStatement(sql);
stmt.setString(1, domain);
stmt.setString(2, app);
stmt.setString(3, type);
stmt.setLong(4, hash);
rs = stmt.executeQuery();
if (rs.next()) {
return rs.getString(1);
} catch (SQLException ex) {
LOG.error("save const error error", ex);
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
JdbcUtils.close(conn);
return null;
public String getCacheValue(long hash) {
return hashCache.get(hash);
dataSource.setInitialSize(1);
dataSource.setMinIdle(1);
if (lexer.token() == Token.INDEX) {
lexer.nextToken();
private String                    domainName  = "default";
private String                    appName     = "default";
private String                    clusterName = "default";
private BeanInfo         dataSourceStatBeanInfo   = new BeanInfo(DruidDataSourceStatValue.class);
String[] resources = new String[] { "basic.sql", 
"const.sql", 
save(dataSourceStatBeanInfo, ctx, dataSourceList);
domain = "default";
app = "default";
cluster = "default";
domain = "default";
app = "default";
public class MonitorApp {
private long   id;
private String domain;
private String app;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getDomain() {
return domain;
public void setDomain(String domain) {
this.domain = domain;
public String getApp() {
return app;
public void setApp(String app) {
this.app = app;
public class MonitorCluster {
private long   id;
private String domain;
private String app;
private String cluster;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getDomain() {
return domain;
public void setDomain(String domain) {
this.domain = domain;
public String getApp() {
return app;
public void setApp(String app) {
this.app = app;
public String getCluster() {
return cluster;
public void setCluster(String cluster) {
this.cluster = cluster;
public class MonitorDomain {
private long   id;
private String domain;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getDomain() {
return domain;
public void setDomain(String domain) {
this.domain = domain;
public class MonitorInstance {
private long   id;
private String domain;
private String app;
private String cluster;
private String host;
private String ip;
private Date   lastActiveTime;
private Long   lastPID;
public long getId() {
return id;
public void setId(long id) {
this.id = id;
public String getDomain() {
return domain;
public void setDomain(String domain) {
this.domain = domain;
public String getApp() {
return app;
public void setApp(String app) {
this.app = app;
public String getCluster() {
return cluster;
public void setCluster(String cluster) {
this.cluster = cluster;
public String getHost() {
return host;
public void setHost(String host) {
this.host = host;
public String getIp() {
return ip;
public void setIp(String ip) {
this.ip = ip;
public Date getLastActiveTime() {
return lastActiveTime;
public void setLastActiveTime(Date lastActiveTime) {
this.lastActiveTime = lastActiveTime;
public Long getLastPID() {
return lastPID;
public void setLastPID(Long lastPID) {
this.lastPID = lastPID;
dataSource.setUrl("jdbc:h2:mem:test");
dao.createTables("mysql");
this.poolPreparedStatements = false;
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "ROW_NUMBER", "ROWNUMBER" };
public class DB2SelectTest_5 extends DB2Test {
public void test_0() throws Exception {
String sql = "SELECT * FROM (SELECT TEMP_TAB.*,ROWNUMBER() OVER() AS IDX FROM (SELECT" 
+ "            DISTINCT  ( OH.ORDER_ID )" 
+ "        FROM" 
+ "            ORDER_HEADER OH," 
+ "            ORDER_ITEM OI," 
+ "            ORDER_PAYMENT_PERFERENCE OPP," 
+ "            ORDER_SHIPMENT_PERFERENCE OSP" 
+ "        WHERE" 
+ "            OH.ORDER_ID = OI.ORDER_ID" 
+ "        AND OH.ORDER_ID = OPP.ORDER_ID" 
+ "        AND OH.ORDER_ID = OSP.ORDER_ID" 
+ "             " 
+ "                AND OH.ORDER_ID = ? ) AS TEMP_TAB ) AS TEMP_TAB_WITH_IDX "
+ " WHERE TEMP_TAB_WITH_IDX.IDX > 0 AND TEMP_TAB_WITH_IDX.IDX <= 20" 
DB2StatementParser parser = new DB2StatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
DB2SchemaStatVisitor visitor = new DB2SchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(4, visitor.getTables().size());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(4, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ORDER_HEADER")));
Assert.assertTrue(visitor.getColumns().contains(new Column("ORDER_HEADER", "ORDER_ID")));
String output = SQLUtils.toSQLString(stmt, JdbcConstants.DB2);
Assert.assertEquals("SELECT *"
+ "nFROM (SELECT TEMP_TAB.*, ROWNUMBER() OVER () AS IDX"
+ "ntFROM (SELECT DISTINCT OH.ORDER_ID"
+ "nttFROM ORDER_HEADER OH, ORDER_ITEM OI, ORDER_PAYMENT_PERFERENCE OPP, ORDER_SHIPMENT_PERFERENCE OSP"
+ "nttWHERE OH.ORDER_ID = OI.ORDER_ID"
+ "ntttAND OH.ORDER_ID = OPP.ORDER_ID"
+ "ntttAND OH.ORDER_ID = OSP.ORDER_ID"
+ "ntttAND OH.ORDER_ID = ?"
+ "ntt) TEMP_TAB"
+ "nt) TEMP_TAB_WITH_IDX"
+ "nWHERE TEMP_TAB_WITH_IDX.IDX > 0"
+ "ntAND TEMP_TAB_WITH_IDX.IDX <= 20", 
public void test_false2() throws Exception {
String sql = "SELECT characteristic.columnname + '|' + RTRIM(characteristic.rpid) as rpid ," 
+ " characteristic.columnname, characteristic.chnname " 
+ "FROM characteristic" 
+ "     inner join content_sort" 
+ "         on characteristic.rpid = content_sort.rpid and content_sort.opid = 2"
+ "WHERE (characteristic.columnname IN (" 
+ "         SELECT name FROM syscolumns" 
+ "         WHERE (id =(SELECT id FROM sysobjects WHERE (name = 'content')))" 
+ "                 AND (name NOT IN ('billid', 'itemno', 'tableid', 'rpid'))" 
+ "         ))" 
+ "     AND (characteristic.closed = 0)" 
+ "ORDER BY content_sort.sort, characteristic.code";
Assert.assertFalse(provider.checkValid(sql));
public void test_false3() throws Exception {
WallProvider provider = initWallProvider();
String sql = "SELECT rpid, columnname, chnname, type, textfield" 
+ "     , valuefield, ddlbtable, ddlbwhere, ddlbsort, datatype "
+ "FROM characteristic "
+ "WHERE (closed = 0)" 
+ "     AND ((SELECT COUNT(*) FROM sysobjects WHERE (id IN (SELECT id FROM syscolumns WHERE name = columnname)) AND (name = 'content')) > 0) ORDER BY code";
Assert.assertFalse(provider.checkValid(sql));
updateCount = null;
userMapper.errorSelect(1);
@Select(value = "delete from t_User where id = #{id}")
void errorSelect(@Param("id") long id);
|| parent instanceof SQLSelectOrderByItem 
} else if ("current_user".equals(methodName)) {
} else if (c < 16) {
write("\u000");
write(Integer.toHexString(c));
} else if (c < 32) {
write("\u00");
write(Integer.toHexString(c));
} else if (c >= 0x7f && c <= 0xA0) {
write("\u00");
write(Integer.toHexString(c));
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
} catch (SQLException ex) {
incrementExecuteErrorCount();
boolean firstResult = chain.preparedStatement_execute(statement);
if (!firstResult) {
WallSqlStat sqlStat = (WallSqlStat) statement.getAttribute(ATTR_SQL_STAT);
int updateCount = statement.getUpdateCount();
if (sqlStat != null) {
provider.addUpdateCount(sqlStat, updateCount);
return firstResult;
} catch (SQLException ex) {
incrementExecuteErrorCount(statement);
return chain.preparedStatement_executeQuery(statement);
} catch (SQLException ex) {
incrementExecuteErrorCount(statement);
int updateCount = chain.preparedStatement_executeUpdate(statement);
WallSqlStat sqlStat = (WallSqlStat) statement.getAttribute(ATTR_SQL_STAT);
if (sqlStat != null) {
provider.addUpdateCount(sqlStat, updateCount);
return updateCount;
} catch (SQLException ex) {
incrementExecuteErrorCount(statement);
public void incrementExecuteErrorCount(PreparedStatementProxy statement) {
WallSqlStat sqlStat = (WallSqlStat) statement.getAttribute(ATTR_SQL_STAT);
if (sqlStat != null) {
sqlStat.incrementAndGetExecuteErrorCount();
public void incrementExecuteErrorCount() {
WallContext context = WallContext.current();
if (context == null) {
WallSqlStat sqlStat = context.getSqlStat();
if (sqlStat == null) {
sqlStat.incrementAndGetExecuteErrorCount();
private int                                           blackSqlMaxSize         = 200;                                               
private volatile long                            executeErrorCount;
final static AtomicLongFieldUpdater<WallSqlStat> executeCountUpdater      = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"executeCount");
final static AtomicLongFieldUpdater<WallSqlStat> executeErrorCountUpdater = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"executeErrorCount");
final static AtomicLongFieldUpdater<WallSqlStat> fetchRowCountUpdater     = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"fetchRowCount");
final static AtomicLongFieldUpdater<WallSqlStat> updateCountUpdater       = AtomicLongFieldUpdater.newUpdater(WallSqlStat.class,
"updateCount");
public long incrementAndGetExecuteErrorCount() {
return executeErrorCountUpdater.incrementAndGet(this);
public long getExecuteErrorCount() {
return executeErrorCount;
statValue.setExecuteErrorCount(get(this, executeErrorCountUpdater, reset));
@MField(aggregate = AggregateType.Sum)
private long    executeErrorCount;
public long getExecuteErrorCount() {
return executeErrorCount;
public void setExecuteErrorCount(long executeErrorCount) {
this.executeErrorCount = executeErrorCount;
if (executeErrorCount > 0) {
sqlStatMap.put("executeErrorCount", executeErrorCount);
if (queryBlockFromIsNull(visitor, x, false)) {
addViolation(visitor, ErrorCode.EmptyQueryHasCondition, "empty select has condition", x);
if (x.getOperator() == SQLBinaryOperator.Like && leftResult instanceof String && leftResult.equals(rightResult)) {
addViolation(visitor, ErrorCode.DoubleConstCondition, "same const like", x);
if (rightResult != null && x.getLeft() instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr leftBinaryOpExpr = (SQLBinaryOpExpr) x.getLeft();
if (leftBinaryOpExpr.getOperator() == SQLBinaryOperator.BooleanAnd) {
Object leftRightVal = getValue(leftBinaryOpExpr.getRight());
if (leftRightVal != null) {
addViolation(visitor, ErrorCode.DoubleConstCondition, "double const condition", x);
if (Boolean.FALSE == leftResult || Boolean.FALSE == rightResult) {
return false;
if (x != null && x.getAttributes().containsKey(EVAL_VALUE)) {
return x.getAttribute(EVAL_VALUE);
|| x instanceof SQLBetweenExpr 
|| x instanceof SQLInListExpr 
|| x instanceof SQLUnaryExpr 
return queryBlockFromIsNull(visitor, query, true);
public static boolean queryBlockFromIsNull(WallVisitor visitor, SQLSelectQuery query, boolean checkSelectConst) {
if (checkSelectConst) {
boolean allIsConst = true;
for (SQLSelectItem item : queryBlock.getSelectList()) {
if (getValue(visitor, item.getExpr()) == null) {
allIsConst = false;
if (allIsConst) {
return true;
public final static int EmptyQueryHasCondition        = 2106;
public final static int DoubleConstCondition          = 2107;
public final static int SameConstLike                 = 2108;
public class MySqlWallTest119 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin' AND 5376=3420 AND 'XSDD'='XSDD'";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest120 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin%' AND SLEEP(5) AND '%'=''";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest121 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin%' AND (SELECT 6384 FROM(SELECT COUNT(*),CONCAT(0x3a64686c3a,(SELECT (CASE WHEN (3252 = 3252) THEN 1 ELSE 0 END)),0x3a766f723a,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND '%'=''";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest122 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin%' AND 4667=(SELECT UPPER(XMLType(CHR(60)||CHR(58)||CHR(115)||CHR(114)||CHR(110)||CHR(58)||(SELECT (CASE WHEN (4667=4667) THEN 1 ELSE 0 END) FROM DUAL)||CHR(58)||CHR(106)||CHR(112)||CHR(122)||CHR(58)||CHR(62))) FROM DUAL) AND '%'=''";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest123 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin'||(SELECT 'tLrl' FROM DUAL WHERE 3240=3240 AND 5014=3795 )||''";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest124 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin' AND 5859=5666 AND 'Cuqo' LIKE 'Cuqo'";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest125 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin' AND 5963=CONVERT(INT,(CHAR(58)+CHAR(108)+CHAR(105)+CHAR(112)+CHAR(58)+(SELECT (CASE WHEN (5963=5963) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(58)+CHAR(117)+CHAR(107)+CHAR(114)+CHAR(58))) AND 'bSho' LIKE 'bSho'";
Assert.assertFalse(provider.checkValid(sql));
public class MySqlWallTest126 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like 'admin'+(SELECT 'NtTK' WHERE 8000=8000 UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL#'";
Assert.assertFalse(provider.checkValid(sql));
String sql = "SELECT tableid, chnname "
+ "FROM r_temptable "
+ "INNER JOIN  sys_func_pwr ss ON r_temptable.tableid = ss.mainid "
+ "INNER JOIN  sys_func_pwr sys ON ss.parentid = sys.funcid  " 
+ "WHERE (ismaintable = 1)  and  1=1  and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 550) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 551) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 391) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 552) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 393) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 396) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 4628) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 4836) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 394) AND (functype = 8) AND (Closed = 0))) and ss.funcid <> 4298 and ss.funcid <> 7441 AND (ss.funcid IN  (SELECT DISTINCT funcid FROM sys_func_pwr  WHERE (functype = 8) AND (Closed = 0)  ))  ORDER BY sys.sortflag ,ss.sortflag ";
private String sql = "SELECT F1, F2  from t WHERE 1 = 1";
private String sql = "SELECT F1, F2 from t WHERE 1 = 1 OR F1 = ?";
Assert.assertTrue(WallUtils.isValidateMySql("SELECT F1, F2 from t WHERE 1 = 1 OR FID = ?"));
Assert.assertTrue(WallUtils.isValidateOracle("SELECT F1, F2 from t WHERE 1 = 1 OR FID = ?"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT F1, F2 from t WHERE FID = ? OR 1 = 1"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT F1, F2 from t WHERE FID = ? OR 1 = 1"));
private String sql = "SELECT F1, F2  from t WHERE 1 = 1 AND FID = ?";
addViolation(visitor, ErrorCode.SameConstLike, "same const like", x);
if (leftBinaryOpExpr.getOperator() != SQLBinaryOperator.BooleanAnd 
&& leftBinaryOpExpr.getOperator() != SQLBinaryOperator.BooleanOr 
&& leftResult != null 
&& visitor != null) {
addViolation(visitor, ErrorCode.DoubleConstCondition, "double const condition", x);
if (leftBinaryOpExpr.getOperator() == SQLBinaryOperator.BooleanAnd 
|| leftBinaryOpExpr.getOperator() == SQLBinaryOperator.BooleanOr) {
public class MySqlWallTest127 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
String sql = "SELECT name, '******' password, createTime from user where name like '-1079%' OR (8868=8022) AND '%'=''";
Assert.assertFalse(provider.checkValid(sql));
Assert.assertEquals(200, provider.getBlackList().size());
if (inited && value > this.maxActive) {
throw new IllegalArgumentException("minIdle greater than maxActive, " + maxActive + " < " + this.minIdle);
if (x instanceof SQLCaseExpr) {
SQLCaseExpr caseExpr = (SQLCaseExpr) x;
if (caseExpr.getItems().size() > 0) {
SQLCaseExpr.Item item = caseExpr.getItems().get(0);
Object conditionVal = getValue(visitor, item.getConditionExpr());
if (conditionVal instanceof Boolean) {
addViolation(visitor, ErrorCode.CONST_CASE_CONDITION, "const case condition", caseExpr);
public final static int CONST_CASE_CONDITION          = 2109;
long[] words = new long[text.length() / 64 + 1];
int wordIndex = i >> 6;
words[wordIndex] |= (1L << i);
if (words.length == 1) {
val = words[0];
byte[] bytes = new byte[words.length * 8];
for (int i = 0; i < words.length; ++i) {
Utils.putLong(bytes, i * 8, words[i]);
val = new BigInteger(bytes);
public static void putLong(byte[] b, int off, long val) {
b[off + 7] = (byte) (val >>> 0);
b[off + 6] = (byte) (val >>> 8);
b[off + 5] = (byte) (val >>> 16);
b[off + 4] = (byte) (val >>> 24);
b[off + 3] = (byte) (val >>> 32);
b[off + 2] = (byte) (val >>> 40);
b[off + 1] = (byte) (val >>> 48);
b[off + 0] = (byte) (val >>> 56);
public class WallStatTest_WhiteList_disable extends TestCase {
protected void setUp() throws Exception {
WallContext.clearContext();
protected void tearDown() throws Exception {
WallContext.clearContext();
public void testMySql() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.setBlackListEnable(false);
provider.setWhiteListEnable(false);
for (int i = 0; i < 301; ++i) {
String sql = "select * from t where id = " + i;
Assert.assertTrue(provider.checkValid(sql));
for (int i = 0; i < 301; ++i) {
String sql = "select * from t where id = " + i + " OR 1 = 1";
Assert.assertTrue(provider.checkValid(sql));
WallTableStat tableStat = provider.getTableStat("t");
Assert.assertEquals(602, tableStat.getSelectCount());
Assert.assertEquals(0, provider.getBlackListHitCount());
Assert.assertEquals(0, provider.getWhiteListHitCount());
Assert.assertEquals(0, provider.getWhiteList().size());
Assert.assertEquals(602, provider.getCheckCount());
if (leftValue == EVAL_VALUE_NULL) {
x.putAttribute(EVAL_VALUE, false);
} else if (leftValue != null) {
x.putAttribute(EVAL_VALUE, true);
private int                                           whiteSqlMaxSize         = 1000;                                               
public static SQLExpr unwrap(SQLExpr expr) {
if (expr == null) {
return null;
if (expr instanceof SQLQueryExpr) {
SQLSelect select = ((SQLQueryExpr) expr).getSubQuery();
if (select == null) {
return null;
if (select.getQuery() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) select.getQuery();
if (queryBlock.getFrom() == null) {
if (queryBlock.getSelectList().size() == 1) {
return queryBlock.getSelectList().get(0).getExpr();
return expr;
SQLExpr testExpr = unwrap(x.getTestExpr());
testExpr.accept(visitor);
if (rightValue instanceof Number && ((Number) rightValue).intValue() == 0) {
x.putAttribute(EVAL_VALUE, EVAL_ERROR);
value = div(leftValue, rightValue);
x.putAttribute(EVAL_VALUE, value);
if (val instanceof Number) {
return ((Number) val).intValue();
throw new DruidRuntimeException("cast error");
BigDecimal decimalA = castToDecimal(a);
BigDecimal decimalB = castToDecimal(b);
return decimalA.divide(decimalB, BigDecimal.ROUND_HALF_UP);
Integer intA = castToInteger(a);
Integer intB = castToInteger(b);
return intA / intB;
if (a == null || a == EVAL_VALUE_NULL) {
if (b == null || a == EVAL_VALUE_NULL) {
Integer intA = castToInteger(a);
Integer intB = castToInteger(b);
return intA < intB;
if (intValue > strValue.length()) {
return SQLEvalVisitor.EVAL_ERROR;
if (bytes == null) {
return SQLEvalVisitor.EVAL_VALUE_NULL;
addViolation(visitor, ErrorCode.EMPTY_QUERY_HAS_CONDITION, "empty select has condition", x);
addViolation(visitor, ErrorCode.SAME_CONST_LIKE, "same const like", x);
addViolation(visitor, ErrorCode.DOUBLE_CONST_CONDITION, "double const condition", x);
addViolation(visitor, ErrorCode.DOUBLE_CONST_CONDITION, "double const condition", x);
Object itemVal = getValue(visitor, item.getValueExpr());
if (conditionVal instanceof Boolean && itemVal != null) {
public final static int EMPTY_QUERY_HAS_CONDITION     = 2106;
public final static int DOUBLE_CONST_CONDITION        = 2107;
public final static int SAME_CONST_LIKE               = 2108;
if (!testExpr.getAttributes().containsKey(EVAL_VALUE)) {
Object value = testExpr.getAttribute(EVAL_VALUE);
SQLExpr beginExpr = unwrap(x.getBeginExpr());
beginExpr.accept(visitor);
if (!beginExpr.getAttributes().containsKey(EVAL_VALUE)) {
Object begin = beginExpr.getAttribute(EVAL_VALUE);
SQLExpr endExpr = unwrap(x.getEndExpr());
endExpr.accept(visitor);
if (!endExpr.getAttributes().containsKey(EVAL_VALUE)) {
Object end = endExpr.getAttribute(EVAL_VALUE);
SQLExpr left = unwrap(x.getLeft());
SQLExpr right = unwrap(x.getRight());
value = div(leftValue, rightValue);
x.putAttribute(EVAL_VALUE, value);
if (decimalB.scale() < decimalA.scale()) {
decimalB.setScale(decimalA.scale());
return decimalA.divide(decimalB);
if (intB == 0) {
if (intA > 0) {
return Double.POSITIVE_INFINITY;
} else if (intA < 0) {
return Double.NEGATIVE_INFINITY;
return Double.NaN;
if (CharTypes.isWhitespace(ch)) {
public class ResourceTest extends TestCase {
private String[] items;
protected void setUp() throws Exception {
File file = new File("D:\error_sql");
FileInputStream is = new FileInputStream(file);
String all = Utils.read(is);
is.close();
items = all.split("\|\n\|");
public void test_xx() throws Exception {
WallProvider provider = new MySqlWallProvider();
for (int i = 0; i < items.length; ++i) {
String sql = items[i];
WallCheckResult result = provider.check(sql);
if (result.getViolations().size() > 0) {
Violation violation = result.getViolations().get(0);
System.err.println("error (" + i + ") : " + violation.getMessage());
System.out.println(sql);
System.out.println();
System.out.println("violaionCount : " + provider.getViolationCount());
throw new IllegalArgumentException("illegal token : " + this.token + ", expect " + token);
|| text.indexOf("select") != -1 
|| text.indexOf("insert") != -1 
|| text.indexOf("alter") != -1 
|| text.indexOf("truncate") != -1 
|| text.indexOf("sleep") != -1 
|| text.indexOf("benchmark") != -1 
|| text.indexOf("load_file") != -1 
private int                                           MAX_SQL_LENGTH          = 8192;                                              
private int                                           whiteSqlMaxSize         = 1000;
private int                                           blackSqlMaxSize         = 200;
boolean illegal = false;
illegal = true;
illegal = syntaxError = true;
illegal = true;
illegal = true;
varName = varName.toLowerCase();
addViolation(new IllegalSQLObjectViolation(ErrorCode.EVIL_HINTS, "evil hints",
SQLUtils.toMySqlString(x)));
return false;
if (ch == ''') {
scanChar();
if (ch != ''') {
token = LITERAL_CHARS;
initBuff(bufPos);
arraycopy(mark + 1, buf, 0, bufPos);
hasSpecial = true;
putChar(''');
return decimalA.divide(decimalB);
} catch (ArithmeticException ex) {
return decimalA.divide(decimalB, BigDecimal.ROUND_HALF_UP);
if (queryBlockFromIsNull(visitor, x, false)) {
addViolation(visitor, ErrorCode.EMPTY_QUERY_HAS_CONDITION, "empty select has condition", x);
public class MySqlWallTest139 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
String sql = "select count(1) as total "
+ " from (" 
+ "    select '' buyer_nick from dual " 
+ "    where 1=0  "
+ "    union " 
+ "    select distinct buyer_nick "
+ "    from sys_info.orders "
+ "    where 1=1  and receiver_district in ('')" 
+ ") a " 
+ "inner join (" 
+ "    select buyer_nick from ("
+ "        select distinct buyer_nick "
+ "        from sys_info.orders " 
+ "        where 1=1  and created > '2013-07-28' "
+ "    ) recent_days " 
+ "inner join (" 
+ "    select distinct buyer_nick " 
+ "    from sys_info.orders " 
+ "    where 1=1  and seller_nick in ('') " 
+ "    ) seller_nick using(buyer_nick) "
+ ") b using(buyer_nick)";
Assert.assertTrue(provider.checkValid(sql));
public class SQLServerWallTest_10 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new SQLServerWallProvider();
String sql = "select top 50 * FROM [V_Goods_WithAvailableStockQuantity] where Status='' and (Code like '%mu%' ESCAPE '' or Model like '%mu%' ESCAPE '' or Spec like '%mu%' ESCAPE '' or BarCode like '%mu%' ESCAPE '' or ProductName like '%mu%' ESCAPE '' or dbo.F_GetPY(ProductName) like '%mu%' ESCAPE '') ";
Assert.assertTrue(provider.checkValid(sql));
public class DMLInsertParserTest_Special extends TestCase {
public void testInsert_7() throws Exception {
String sql = "insErt LOW_PRIORITY t1 (col1, t1.col2) VALUE (123,'123\'4') oN dupLicatE key UPDATE ex.col1=?";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("INSERT LOW_PRIORITY INTO t1 (col1, t1.col2)nVALUES (123, '123''4')" + 
"nON DUPLICATE KEY UPDATE ex.col1 = ?",
File file = new File("D:\scan_error.txt");
items = all.split("\|\r\n\|");
if (ch == '-') {
char next_2 = charAt(pos + 2);
if (isDigit(next_2)) {
scanChar();
token = Token.SUB;
} else if (ch != '/') {
Assert.assertTrue(provider.checkValid(
public class MySqlSelectTest_15 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT 1--1 from t where id = 1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT 1 - -1" 
+ "nFROM t" 
+ "nWHERE id = 1", 
syntaxError = true;
public class MySqlWallTest142 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
String sql = "SELECT * FROM `my_crons` WHERE 1 OR nextrun = '0' ";
Assert.assertTrue(provider.checkValid(sql));
public class MySqlWallTest143 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
String sql = "SELECT" 
+ " `Extent1`.`ID`, " 
+ " `Extent1`.`State`, " 
+ " `Extent1`.`CreateTime`, " 
+ " `Extent1`.`UpdateTime`, " 
+ " `Extent1`.`OpeningBank`, " 
+ " `Extent1`.`BankAccount`, " 
+ " `Extent1`.`BankAccountName`, " 
+ " `Extent1`.`Zone`, " 
+ " `Extent1`.`AccountantMobile`, " 
+ " `Extent1`.`IsPublic`" 
+ " FROM `paybank` AS `Extent1`" 
+ " WHERE (`Extent1`.`State` > -1)" 
+ " AND ((`Extent1`.`Zone`) = (CASE WHEN (1 IS  NULL) THEN (1)  ELSE (1) END))";
Assert.assertTrue(provider.checkValid(sql));
public class SQLServerWallTest_11 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new SQLServerWallProvider();
provider.getConfig().setCommentAllow(true);
String sql = "SELECT KL_ArticleContent,KL_ArticleTitle " 
+ "FROM dbo.KL_Article " 
+ "WHERE KL_ArticleId =-4731 "
+ "UNION ALL "
+ "SELECT (SELECT TOP 1 CHAR(58)+CHAR(108)+CHAR(107)+CHAR(103)+CHAR(58)+ISNULL(CAST(name AS NVARCHAR(4000)),CHAR(32))+CHAR(58)+CHAR(109)+CHAR(122)+CHAR(104)+CHAR(58) FROM sys.sql_logins WHERE ISNULL(name,CHAR(32)) NOT IN (SELECT TOP 0 ISNULL(name,CHAR(32)) FROM sys.sql_logins ORDER BY 1) ORDER BY 1),NULL-- ";
Assert.assertFalse(provider.checkValid(sql));
public class SQLServerWallTest_12 extends TestCase {
public void test_true() throws Exception {
WallProvider provider = new SQLServerWallProvider();
provider.getConfig().setCommentAllow(true);
String sql = "EXEC master..xp_msver";
Assert.assertTrue(provider.checkValid(sql));
public class OracleSelectTest51 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select TRIM(TRAILING 'M' FROM RTRIM('  testM')) from dual;"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT TRIM(TRAILING 'M' FROM RTRIM('  testM'))" 
+ "nFROM dual;"
+ "n", text);
SQLExpr restExpr = relational();
public class MySqlSelectTest_16 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select a from t where not a>1 and not b<1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
MySqlSelectQueryBlock queryBlock = (MySqlSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getOrderBy());
SQLExpr where = queryBlock.getWhere();
Assert.assertTrue(where instanceof SQLBinaryOpExpr);
SQLBinaryOpExpr binaryWhere = (SQLBinaryOpExpr) where;
Assert.assertEquals(binaryWhere.getOperator(), SQLBinaryOperator.BooleanAnd);
Assert.assertTrue(binaryWhere.getLeft() instanceof SQLNotExpr);
Assert.assertTrue(binaryWhere.getRight() instanceof SQLNotExpr);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("SELECT a" 
+ "nFROM t"
+ "nWHERE NOT a > 1"
+ "ntAND NOT b < 1", 
if("".equals(path)){
response.sendRedirect("druid/login.html");
response.sendRedirect("login.html");
public String toString() {
return SQLUtils.toSQLString(this);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
void unregisterFunction(String funcName);
public void unregisterFunction(String funcName) {
functions.remove(funcName);
Function function = visitor.getFunction(methodName);
if (function == null) {
function = functions.get(methodName);
public class Nil implements Function {
public final static Nil instance = new Nil();
public Object eval(SQLEvalVisitor visitor, SQLMethodInvokeExpr x) {
return null;
return eval(dbType, x, Collections.emptyList());
return eval(dbType, x, Collections.emptyList());
return eval(dbType, x, Collections.emptyList());
public static Object eval(String dbType, SQLObject sqlObject, List<Object> parameters) {
SQLEvalVisitor visitor = SQLEvalVisitorUtils.createEvalVisitor(dbType);
visitor.setParameters(parameters);
visitor.registerFunction("rand", Nil.instance);
sqlObject.accept(visitor);
Object value = SQLEvalVisitorUtils.getValue(sqlObject);
return value;
public class MySqlWallTest144 extends TestCase {
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
String sql = "select min(id) from wx_interact where activityid=1008 group by true_name,mobile having rand()<1";
Assert.assertTrue(provider.checkValid(sql));
public void output(StringBuffer buf) {
buf.append(this.name);
private boolean             brace      = false;
private SQLVariantRefExpr   outParameter;
public SQLVariantRefExpr getOutParameter() {
return outParameter;
public void setOutParameter(SQLVariantRefExpr outParameter) {
this.outParameter = outParameter;
public boolean isBrace() {
return brace;
public void setBrace(boolean brace) {
this.brace = brace;
acceptChild(visitor, this.outParameter);
SQLCallStatement stmt = new SQLCallStatement();
if (lexer.token() == Token.QUES) {
lexer.nextToken();
accept(Token.EQ);
stmt.setOutParameter(new SQLVariantRefExpr("?"));
stmt.setBrace(true);
if (x.isBrace()) {
print("{");
if (x.getOutParameter() != null) {
x.getOutParameter().accept(this);
print(" = ");
if (x.isBrace()) {
print("}");
public class OracleCallTest2 extends OracleTest {
public void test_0() throws Exception {
String sql = "{?= call FUNC_QUERY_DEPT(?,?)}";
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
if (!isTopSelectStatement(expr) && "@".equals(((SQLVariantRefExpr) expr).getName())) {
private static boolean isTopSelectStatement(SQLObject x) {
for (;;) {
if ((x.getParent() instanceof SQLExpr) || (x.getParent() instanceof Item)) {
x = x.getParent();
if (!(x.getParent() instanceof SQLSelectItem)) {
return false;
SQLSelectItem item = (SQLSelectItem) x.getParent();
if (!(item.getParent() instanceof SQLSelectQueryBlock)) {
return false;
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) item.getParent();
if (!(queryBlock.getParent() instanceof SQLSelect)) {
return false;
SQLSelect select = (SQLSelect) queryBlock.getParent();
if (!(select.getParent() instanceof SQLSelectStatement)) {
return false;
SQLSelectStatement stmt = (SQLSelectStatement) select.getParent();
return stmt.getParent() == null;
provider.getConfig().setConditionDoubleConstAllow(true);
public void test_true4() {
WallProvider provider = initWallProvider();
String sql = "SELECT 10006,@";
Assert.assertTrue(provider.checkValid(sql));
provider.getConfig().setConditionDoubleConstAllow(true);
+ "FROM r_temptable "
+ "INNER JOIN  sys_func_pwr ss ON r_temptable.tableid = ss.mainid "
+ "INNER JOIN  sys_func_pwr sys ON ss.parentid = sys.funcid  " 
+ "WHERE (ismaintable = 1)  and  1=1  and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 550) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 551) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 391) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 552) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 393) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 396) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 4628) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 4836) AND (functype = 8) AND (Closed = 0))) and (r_temptable.tableid NOT IN (SELECT DISTINCT mainid FROM sys_func_pwr WHERE (parentid = 394) AND (functype = 8) AND (Closed = 0))) and ss.funcid <> 4298 and ss.funcid <> 7441 AND (ss.funcid IN  (SELECT DISTINCT funcid FROM sys_func_pwr  WHERE (functype = 8) AND (Closed = 0)  ))  ORDER BY sys.sortflag ,ss.sortflag ";
private volatile long                                 selectCount;
private volatile long                                 selectIntoCount;
private volatile long                                 insertCount;
private volatile long                                 updateCount;
private volatile long                                 deleteCount;
private volatile long                                 truncateCount;
private volatile long                                 createCount;
private volatile long                                 alterCount;
private volatile long                                 dropCount;
private volatile long                                 replaceCount;
private volatile long                                 deleteDataCount;
private volatile long                                 updateDataCount;
private volatile long                                 insertDataCount;
private volatile long                                 fetchRowCount;
final static AtomicLongFieldUpdater<WallTableStat>    selectCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"selectCount");
final static AtomicLongFieldUpdater<WallTableStat>    selectIntoCountUpdater             = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"selectIntoCount");
final static AtomicLongFieldUpdater<WallTableStat>    insertCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"insertCount");
final static AtomicLongFieldUpdater<WallTableStat>    updateCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"updateCount");
final static AtomicLongFieldUpdater<WallTableStat>    deleteCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"deleteCount");
final static AtomicLongFieldUpdater<WallTableStat>    truncateCountUpdater               = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"truncateCount");
final static AtomicLongFieldUpdater<WallTableStat>    createCountUpdater                 = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"createCount");
final static AtomicLongFieldUpdater<WallTableStat>    alterCountUpdater                  = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"alterCount");
final static AtomicLongFieldUpdater<WallTableStat>    dropCountUpdater                   = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"dropCount");
final static AtomicLongFieldUpdater<WallTableStat>    replaceCountUpdater                = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"replaceCount");
final static AtomicLongFieldUpdater<WallTableStat>    deleteDataCountUpdater             = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount");
final static AtomicLongFieldUpdater<WallTableStat>    insertDataCountUpdater             = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"insertDataCount");
final static AtomicLongFieldUpdater<WallTableStat>    updateDataCountUpdater             = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount");
final static AtomicLongFieldUpdater<WallTableStat>    fetchRowCountUpdater               = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount");
private volatile long                                 fetchRowCount_0_1;
private volatile long                                 fetchRowCount_1_10;
private volatile long                                 fetchRowCount_10_100;
private volatile int                                  fetchRowCount_100_1000;
private volatile int                                  fetchRowCount_1000_10000;
private volatile int                                  fetchRowCount_10000_more;
final static AtomicLongFieldUpdater<WallTableStat>    fetchRowCount_0_1_Updater          = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_0_1");
final static AtomicLongFieldUpdater<WallTableStat>    fetchRowCount_1_10_Updater         = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_1_10");
final static AtomicLongFieldUpdater<WallTableStat>    fetchRowCount_10_100_Updater       = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_10_100");
final static AtomicIntegerFieldUpdater<WallTableStat> fetchRowCount_100_1000_Updater     = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_100_1000");
final static AtomicIntegerFieldUpdater<WallTableStat> fetchRowCount_1000_10000_Updater   = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_1000_10000");
final static AtomicIntegerFieldUpdater<WallTableStat> fetchRowCount_10000_more_Updater   = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"fetchRowCount_10000_more");
private volatile long                                 updateDataCount_0_1;
private volatile long                                 updateDataCount_1_10;
private volatile long                                 updateDataCount_10_100;
private volatile int                                  updateDataCount_100_1000;
private volatile int                                  updateDataCount_1000_10000;
private volatile int                                  updateDataCount_10000_more;
final static AtomicLongFieldUpdater<WallTableStat>    updateDataCount_0_1_Updater        = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_0_1");
final static AtomicLongFieldUpdater<WallTableStat>    updateDataCount_1_10_Updater       = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_1_10");
final static AtomicLongFieldUpdater<WallTableStat>    updateDataCount_10_100_Updater     = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_10_100");
final static AtomicIntegerFieldUpdater<WallTableStat> updateDataCount_100_1000_Updater   = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_100_1000");
final static AtomicIntegerFieldUpdater<WallTableStat> updateDataCount_1000_10000_Updater = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_1000_10000");
final static AtomicIntegerFieldUpdater<WallTableStat> updateDataCount_10000_more_Updater = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"updateDataCount_10000_more");
private volatile long                                 deleteDataCount_0_1;
private volatile long                                 deleteDataCount_1_10;
private volatile long                                 deleteDataCount_10_100;
private volatile int                                  deleteDataCount_100_1000;
private volatile int                                  deleteDataCount_1000_10000;
private volatile int                                  deleteDataCount_10000_more;
final static AtomicLongFieldUpdater<WallTableStat>    deleteDataCount_0_1_Updater        = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_0_1");
final static AtomicLongFieldUpdater<WallTableStat>    deleteDataCount_1_10_Updater       = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_1_10");
final static AtomicLongFieldUpdater<WallTableStat>    deleteDataCount_10_100_Updater     = AtomicLongFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_10_100");
final static AtomicIntegerFieldUpdater<WallTableStat> deleteDataCount_100_1000_Updater   = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_100_1000");
final static AtomicIntegerFieldUpdater<WallTableStat> deleteDataCount_1000_10000_Updater = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_1000_10000");
final static AtomicIntegerFieldUpdater<WallTableStat> deleteDataCount_10000_more_Updater = AtomicIntegerFieldUpdater.newUpdater(WallTableStat.class,
"deleteDataCount_10000_more");
public long[] getDeleteDataCountHistogramValues() {
return new long[] {
deleteDataCount_0_1, 
deleteDataCount_1_10, 
deleteDataCount_10_100, 
deleteDataCount_100_1000, 
deleteDataCount_1000_10000, 
deleteDataCount_10000_more 
if (delta < 1) {
deleteDataCount_0_1_Updater.incrementAndGet(this);
} else if (delta < 10) {
deleteDataCount_1_10_Updater.incrementAndGet(this);
} else if (delta < 100) {
deleteDataCount_10_100_Updater.incrementAndGet(this);
} else if (delta < 1000) {
deleteDataCount_100_1000_Updater.incrementAndGet(this);
} else if (delta < 10000) {
deleteDataCount_1000_10000_Updater.incrementAndGet(this);
deleteDataCount_10000_more_Updater.incrementAndGet(this);
public long[] getUpdateDataCountHistogramValues() {
return new long[] {
updateDataCount_0_1, 
updateDataCount_1_10, 
updateDataCount_10_100, 
updateDataCount_100_1000, 
updateDataCount_1000_10000, 
updateDataCount_10000_more 
if (delta < 1) {
updateDataCount_0_1_Updater.incrementAndGet(this);
} else if (delta < 10) {
updateDataCount_1_10_Updater.incrementAndGet(this);
} else if (delta < 100) {
updateDataCount_10_100_Updater.incrementAndGet(this);
} else if (delta < 1000) {
updateDataCount_100_1000_Updater.incrementAndGet(this);
} else if (delta < 10000) {
updateDataCount_1000_10000_Updater.incrementAndGet(this);
updateDataCount_10000_more_Updater.incrementAndGet(this);
public long[] getFetchRowCountHistogramValues() {
return new long[] {
fetchRowCount_0_1, 
fetchRowCount_1_10, 
fetchRowCount_10_100, 
fetchRowCount_100_1000, 
fetchRowCount_1000_10000, 
fetchRowCount_10000_more 
if (delta < 1) {
fetchRowCount_0_1_Updater.incrementAndGet(this);
} else if (delta < 10) {
fetchRowCount_1_10_Updater.incrementAndGet(this);
} else if (delta < 100) {
fetchRowCount_10_100_Updater.incrementAndGet(this);
} else if (delta < 1000) {
fetchRowCount_100_1000_Updater.incrementAndGet(this);
} else if (delta < 10000) {
fetchRowCount_1000_10000_Updater.incrementAndGet(this);
fetchRowCount_10000_more_Updater.incrementAndGet(this);
statValue.fetchRowCount_0_1 = get(this, fetchRowCount_0_1_Updater, reset);
statValue.fetchRowCount_1_10 = get(this, fetchRowCount_1_10_Updater, reset);
statValue.fetchRowCount_10_100 = get(this, fetchRowCount_10_100_Updater, reset);
statValue.fetchRowCount_100_1000 = get(this, fetchRowCount_100_1000_Updater, reset);
statValue.fetchRowCount_1000_10000 = get(this, fetchRowCount_1000_10000_Updater, reset);
statValue.fetchRowCount_10000_more = get(this, fetchRowCount_10000_more_Updater, reset);
statValue.updateDataCount_0_1 = get(this, updateDataCount_0_1_Updater, reset);
statValue.updateDataCount_1_10 = get(this, updateDataCount_1_10_Updater, reset);
statValue.updateDataCount_10_100 = get(this, updateDataCount_10_100_Updater, reset);
statValue.updateDataCount_100_1000 = get(this, updateDataCount_100_1000_Updater, reset);
statValue.updateDataCount_1000_10000 = get(this, updateDataCount_1000_10000_Updater, reset);
statValue.updateDataCount_10000_more = get(this, updateDataCount_10000_more_Updater, reset);
statValue.deleteDataCount_0_1 = get(this, deleteDataCount_0_1_Updater, reset);
statValue.deleteDataCount_1_10 = get(this, deleteDataCount_1_10_Updater, reset);
statValue.deleteDataCount_10_100 = get(this, deleteDataCount_10_100_Updater, reset);
statValue.deleteDataCount_100_1000 = get(this, deleteDataCount_100_1000_Updater, reset);
statValue.deleteDataCount_1000_10000 = get(this, deleteDataCount_1000_10000_Updater, reset);
statValue.deleteDataCount_10000_more = get(this, deleteDataCount_10000_more_Updater, reset);
@MField(name = "f1", aggregate = AggregateType.Sum)
protected long fetchRowCount_0_1;
@MField(name = "f10", aggregate = AggregateType.Sum)
protected long fetchRowCount_1_10;
@MField(name = "f100", aggregate = AggregateType.Sum)
protected long fetchRowCount_10_100;
@MField(name = "f1000", aggregate = AggregateType.Sum)
protected int  fetchRowCount_100_1000;
@MField(name = "f10000", aggregate = AggregateType.Sum)
protected int  fetchRowCount_1000_10000;
@MField(name = "fmore", aggregate = AggregateType.Sum)
protected int  fetchRowCount_10000_more;
@MField(name = "u1", aggregate = AggregateType.Sum)
protected long updateDataCount_0_1;
@MField(name = "u10", aggregate = AggregateType.Sum)
protected long updateDataCount_1_10;
@MField(name = "u100", aggregate = AggregateType.Sum)
protected long updateDataCount_10_100;
@MField(name = "u1000", aggregate = AggregateType.Sum)
protected int  updateDataCount_100_1000;
@MField(name = "u10000", aggregate = AggregateType.Sum)
protected int  updateDataCount_1000_10000;
@MField(name = "umore", aggregate = AggregateType.Sum)
protected int  updateDataCount_10000_more;
@MField(name = "del_1", aggregate = AggregateType.Sum)
protected long deleteDataCount_0_1;
@MField(name = "del_10", aggregate = AggregateType.Sum)
protected long deleteDataCount_1_10;
@MField(name = "del_100", aggregate = AggregateType.Sum)
protected long deleteDataCount_10_100;
@MField(name = "del_1000", aggregate = AggregateType.Sum)
protected int  deleteDataCount_100_1000;
@MField(name = "del_10000", aggregate = AggregateType.Sum)
protected int  deleteDataCount_1000_10000;
@MField(name = "del_more", aggregate = AggregateType.Sum)
protected int  deleteDataCount_10000_more;
public long[] getDeleteDataHistogram() {
return new long[] { deleteDataCount_0_1, 
deleteDataCount_1_10, 
deleteDataCount_10_100, 
deleteDataCount_100_1000, 
deleteDataCount_1000_10000, 
deleteDataCount_10000_more, 
public long[] getFetchRowHistogram() {
return new long[] { fetchRowCount_0_1, 
fetchRowCount_1_10, 
fetchRowCount_10_100, 
fetchRowCount_100_1000, 
fetchRowCount_1000_10000, 
fetchRowCount_10000_more, 
public long[] getUpdateDataHistogram() {
return new long[] { updateDataCount_0_1, 
updateDataCount_1_10, 
updateDataCount_10_100, 
updateDataCount_100_1000, 
updateDataCount_1000_10000, 
updateDataCount_10000_more, 
map.put("deleteDataCountHistogram", getDeleteDataHistogram());
map.put("fetchRowCountHistogram", getFetchRowHistogram());
map.put("updateDataCountHistogram", getUpdateDataHistogram());
public final static int RevisionVersion = 27;
provider.getConfig().setUseAllow(false);
"use huaianapp")); 
public class BigSqlTest extends TestCase {
public void test_true() throws Exception {
String sql = "SELECT c from sbtest where id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0 or id=0";
WallConfig config = new WallConfig();
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
Assert.assertFalse(provider.checkValid(sql));
SQLObject parent = x.getParent();
if (parent instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) parent;
if (binaryOpExpr.getOperator() == SQLBinaryOperator.IsNot
|| binaryOpExpr.getOperator() == SQLBinaryOperator.Is) {
v.print("NULL");
return false;
String sql = "SELECT c from sbtest where id=0";
for (int i = 0; i < 10000; i++) {
sql += "or id=0";
String sql = "SELECT c from sbtest where id=0";
for (int i = 0; i < 10000; i++) {
sql += "and id=0";
+ "nUSING employees e ON (c.employee_id = e.employee_id) " 
case INTERV
public class OracleSelectTest52 extends OracleTest {
public void test_0() throws Exception {
String sql = 
"select 1 interval from dual"; 
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("relationships : " + visitor.getRelationships());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
String text = TestUtils.outputOracle(stmt);
Assert.assertEquals("SELECT 1 AS INTERVAL" 
+ "nFROM dual;"
+ "n", text);
DruidPooledConnection poolableConnection = getConnectionInternal(maxWaitMillis);
boolean validate = testConnectionInternal(poolableConnection.getConnection());
Connection realConnection = poolableConnection.getConnection();
Connection realConnection = poolableConnection.getConnection();
final long lastActiveTimeMillis = poolableConnection.getConnectionHolder().getLastActiveTimeMillis();
boolean validate = testConnectionInternal(poolableConnection.getConnection());
poolableConnection.setConnectStackTrace(stackTrace);
poolableConnection.setConnectedTimeNano();
poolableConnection.setTraceEnable(true);
activeConnections.put(poolableConnection, PRESENT);
poolableConnection.setAutoCommit(false);
return poolableConnection;
final WallTopStatementContext topStatementContext = WallVisitorUtils.getWallTopStatementContext();
if (topStatementContext != null
&& (topStatementContext.fromSysSchema() || topStatementContext.fromSysTable())) {
return false;
if (!config.isSelectIntoOutfileAllow() && !WallVisitorUtils.isTopSelectOutFile(x)) {
final WallTopStatementContext topStatementContext = WallVisitorUtils.getWallTopStatementContext();
if (topStatementContext != null
&& (topStatementContext.fromSysSchema() || topStatementContext.fromSysTable())) {
return false;
if (!isTopSelectItem(expr) && "@".equals(((SQLVariantRefExpr) expr).getName())) {
boolean isSelectItem = false;
} else if (parent instanceof SQLSelectItem) {
isSelectItem = true;
} else if ((isWhereQueryExpr || isSelectItem) && parent instanceof SQLSelectQueryBlock) {
private static boolean isTopSelectItem(SQLObject x) {
return isTopSelectStatement(item.getParent());
private static boolean isTopSelectStatement(SQLObject x) {
if (!(x instanceof SQLSelectQueryBlock)) {
SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) x;
public static boolean isTopSelectOutFile(MySqlOutFileExpr x) {
if (!(x.getParent() instanceof SQLExprTableSource)) {
return false;
SQLExprTableSource tableSource = (SQLExprTableSource) x.getParent();
return isTopSelectStatement(tableSource.getParent());
if (parent instanceof SQLJoinTableSource) {
SQLJoinTableSource joinTableSource = (SQLJoinTableSource) parent;
if (joinTableSource.getCondition() == x) {
return true;
if (this.createError != null) {
groupList.add(x.getRight());
private boolean             caseConditionConstAllow     = false;
public boolean isCaseConditionConstAllow() {
return caseConditionConstAllow;
public void setCaseConditionConstAllow(boolean caseConditionConstAllow) {
this.caseConditionConstAllow = caseConditionConstAllow;
if (visitor != null && !visitor.getConfig().isCaseConditionConstAllow()) {
if (visitor != null && !visitor.getConfig().isCaseConditionConstAllow()) {
if (lexer.token() == Token.FROM) {
lexer.nextToken();
SQLExpr trim_source = this.expr();
methodExpr.addParameter(trim_source);
if (x.getParameters().size() > 0) {
print(" FROM ");
x.getParameters().get(0).accept(this);
public class OracleResourceTest extends OracleTest {
public void test_0() throws Exception {
for (int i = 0; i <= 57; ++i) {
exec_test("bvt/parser/oracle-" + i + ".txt");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
System.out.println(sql);
print(statementList);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
for (int i = 0, size = statementList.size(); i < size; ++i) {
SQLStatement statement = statementList.get(i);
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println();
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public static String formatOdps(String sql) {
return format(sql, JdbcUtils.ODPS);
private boolean              overwrite  = false;
private List<SQLAssignItem>  partitions = new ArrayList<SQLAssignItem>();
protected SQLExprTableSource tableSource;
private SQLSelect            query;
public final static int MajorVersion    = 1;
public final static int MinorVersion    = 0;
public final static int RevisionVersion = 1;
public final static int RevisionVersion = 2;
return false;
return Class.forName(className);
} catch (ClassNotFoundException e) {
return clazz;
public class OdpsUDTFSQLSelectItem extends SQLSelectItem {
private final List<String> aliasList = new ArrayList<String>();
public String getAlias() {
throw new UnsupportedOperationException();
public void setAlias(String alias) {
throw new UnsupportedOperationException();
public List<String> getAliasList() {
return aliasList;
public class OdpsSelectParser extends SQLSelectParser {
public OdpsSelectParser(SQLExprParser exprParser){
super(exprParser.getLexer());
this.exprParser = exprParser;
protected SQLSelectItem parseSelectItem() {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.exprParser.primaryRest(expr);
expr = this.exprParser.exprRest(expr);
expr = expr();
if (lexer.token() == Token.AS) {
lexer.nextToken();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
OdpsUDTFSQLSelectItem selectItem = new OdpsUDTFSQLSelectItem();
selectItem.setExpr(expr);
for (;;) {
String alias = lexer.stringVal();
lexer.nextToken();
selectItem.getAliasList().add(alias);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
accept(Token.RPAREN);
return selectItem;
final String alias = as();
return new SQLSelectItem(expr, alias);
void endVisit(OdpsUDTFSQLSelectItem x);
boolean visit(OdpsUDTFSQLSelectItem x);
public void endVisit(OdpsUDTFSQLSelectItem x) {
public boolean visit(OdpsUDTFSQLSelectItem x) {
x.getExpr().accept(this);
print(" AS (");
for (int i = 0; i < x.getAliasList().size(); ++i) {
if (i != 0) {
print(", ");
print(x.getAliasList().get(i));
print(")");
return false;
public void endVisit(OdpsUDTFSQLSelectItem x) {
public boolean visit(OdpsUDTFSQLSelectItem x) {
return true;
final SQLSelectItem selectItem = parseSelectItem();
protected SQLSelectItem parseSelectItem() {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.exprParser.primaryRest(expr);
expr = this.exprParser.exprRest(expr);
expr = expr();
final String alias = as();
return new SQLSelectItem(expr, alias);
return new OdpsSelectParser(this.exprParser);
public class OdpsUDTFTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT my_udtf(1,2,3) as (a, b, c) from employee t1 WHERE t1.name = 'aaa';";
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OdpsSchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employee")));
Assert.assertTrue(visitor.getColumns().contains(new Column("employee", "name")));
buf.append("runningSqlCount ");
|| "tinytext".equalsIgnoreCase(dataTypeName)
|| "text".equalsIgnoreCase(dataTypeName)
|| "mediumtext".equalsIgnoreCase(dataTypeName)
|| "longtext".equalsIgnoreCase(dataTypeName)
public class MySqlCreateTableTest51 extends MysqlTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE `test` (" 
+ "`Id` int(11) NOT NULL," 
+ "`text` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL"
+ ") ENGINE=InnoDB DEFAULT CHARSET=gbk";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test")));
String output = SQLUtils.toMySqlString(stmt);
System.out.println(output);
Assert.assertEquals("CREATE TABLE `test` (" 
+ "nt`Id` int(11) NOT NULL, "
+ "nt`text` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL"
+ "n) ENGINE = InnoDB CHARSET = gbk",
exprList(inListExpr.getTargetList(), inListExpr);
itemExpr.setParent(inListExpr);
exprList(inListExpr.getTargetList(), inListExpr);
public void test_false10() {
WallProvider provider = initWallProvider();
String sql = "select count(*) from messages a where a.id in (2 and 1 AND 9881=IF((ORD(MID((IFNULL(CAST(DATABASE() AS CHAR),0x20)),6,1))>117),SLEEP(5),9881)) and a.message <> 'hello' and a.message like 'Little'";
Assert.assertFalse(provider.checkValid(sql));
return false;
if (JdbcUtils.ODPS.equals(dbType)) {
return toDB2String(sqlObject);
public static String toOdpsString(SQLObject sqlObject) {
StringBuilder out = new StringBuilder();
sqlObject.accept(new OdpsOutputVisitor(out));
String sql = out.toString();
return sql;
public static String formatOdps(String sql) {
return format(sql, JdbcUtils.ODPS);
public class OdpsCreateTableStatement extends SQLCreateTableStatement {
private boolean                     ifNotExiists     = false;
private SQLExprTableSource          like;
protected SQLExpr                   comment;
protected List<SQLColumnDefinition> partitionColumns = new ArrayList<SQLColumnDefinition>(2);
public boolean isIfNotExiists() {
return ifNotExiists;
public void setIfNotExiists(boolean ifNotExiists) {
this.ifNotExiists = ifNotExiists;
public SQLExprTableSource getLike() {
return like;
public void setLike(SQLName like) {
this.setLike(new SQLExprTableSource(like));
public void setLike(SQLExprTableSource like) {
this.like = like;
public SQLExpr getComment() {
return comment;
public void setComment(SQLExpr comment) {
this.comment = comment;
public List<SQLColumnDefinition> getPartitionColumns() {
return partitionColumns;
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, tableSource);
this.acceptChild(visitor, tableElementList);
this.acceptChild(visitor, partitionColumns);
visitor.endVisit(this);
public class OdpsInsert extends SQLObjectImpl {
private boolean              overwrite  = false;
private List<SQLAssignItem>  partitions = new ArrayList<SQLAssignItem>();
protected SQLExprTableSource tableSource;
private SQLSelect            query;
public boolean isOverwrite() {
return overwrite;
public void setOverwrite(boolean overwrite) {
this.overwrite = overwrite;
public List<SQLAssignItem> getPartitions() {
return partitions;
public void setPartitions(List<SQLAssignItem> partitions) {
this.partitions = partitions;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
if (tableSource != null) {
tableSource.setParent(this);
this.tableSource = tableSource;
public void setTableSource(SQLName tableName) {
this.setTableSource(new SQLExprTableSource(tableName));
public SQLSelect getQuery() {
return query;
public void setQuery(SQLSelect query) {
if (query != null) {
query.setParent(this);
this.query = query;
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, tableSource);
acceptChild(visitor, partitions);
acceptChild(visitor, query);
visitor.endVisit(this);
public class OdpsInsertStatement extends SQLStatementImpl implements SQLStatement {
private SQLSubqueryTableSource from;
private List<OdpsInsert>       items = new ArrayList<OdpsInsert>();
public void setFrom(SQLSubqueryTableSource from) {
this.from = from;
public SQLSubqueryTableSource getFrom() {
return from;
public List<OdpsInsert> getItems() {
return items;
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, from);
acceptChild(visitor, items);
visitor.endVisit(this);
public class OdpsUDTFSQLSelectItem extends SQLSelectItem {
private final List<String> aliasList = new ArrayList<String>();
public String getAlias() {
throw new UnsupportedOperationException();
public void setAlias(String alias) {
throw new UnsupportedOperationException();
public List<String> getAliasList() {
return aliasList;
public class OdpsCreateTableParser extends SQLCreateTableParser {
public OdpsCreateTableParser(String sql){
super(new OdpsExprParser(sql));
public OdpsCreateTableParser(SQLExprParser exprParser){
super(exprParser);
public SQLCreateTableStatement parseCrateTable(boolean acceptCreate) {
OdpsCreateTableStatement stmt = new OdpsCreateTableStatement();
if (acceptCreate) {
accept(Token.CREATE);
accept(Token.TABLE);
if (lexer.token() == Token.IF || identifierEquals("IF")) {
lexer.nextToken();
accept(Token.NOT);
accept(Token.EXISTS);
stmt.setIfNotExiists(true);
stmt.setName(this.exprParser.name());
if (lexer.token() == Token.LIKE) {
lexer.nextToken();
SQLName name = this.exprParser.name();
stmt.setLike(name);
accept(Token.LPAREN);
for (;;) {
if (lexer.token() != Token.IDENTIFIER) {
throw new ParserException("expect identifier");
SQLColumnDefinition column = this.exprParser.parseColumn();
stmt.getTableElementList().add(column);
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
accept(Token.RPAREN);
if (lexer.token() == Token.COMMENT) {
lexer.nextToken();
stmt.setComment(this.exprParser.primary());
if (lexer.token() == Token.PARTITIONED) {
lexer.nextToken();
accept(Token.BY);
accept(Token.LPAREN);
for (;;) {
if (lexer.token() != Token.IDENTIFIER) {
throw new ParserException("expect identifier");
SQLColumnDefinition column = this.exprParser.parseColumn();
stmt.getPartitionColumns().add(column);
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
accept(Token.RPAREN);
return stmt;
public class OdpsExprParser extends SQLExprParser {
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", 
"COUNT", 
"STDDEV", 
"ROW_NUMBER"
public OdpsExprParser(Lexer lexer){
super(lexer);
this.aggregateFunctions = AGGREGATE_FUNCTIONS;
public OdpsExprParser(String sql){
this(new OdpsLexer(sql));
this.lexer.nextToken();
public class OdpsLexer extends Lexer {
public final static Keywords DEFAULT_ODPS_KEYWORDS;
Map<String, Token> map = new HashMap<String, Token>();
map.putAll(Keywords.DEFAULT_KEYWORDS.getKeywords());
map.put("PARTITION", Token.PARTITION);
map.put("PARTITIONED", Token.PARTITIONED);
map.put("OVERWRITE", Token.OVERWRITE);
map.put("OVER", Token.OVER);
DEFAULT_ODPS_KEYWORDS = new Keywords(map);
public OdpsLexer(String input){
super(input);
super.keywods = DEFAULT_ODPS_KEYWORDS;
public void scanComment() {
if (ch != '/' && ch != '-') {
throw new IllegalStateException();
mark = pos;
bufPos = 0;
scanChar();
if (ch == '*') {
scanChar();
while (ch == ' ') {
scanChar();
boolean isHint = false;
int startHintSp = bufPos + 1;
if (ch == '+') {
isHint = true;
scanChar();
for (;;) {
if (ch == '*' && charAt(pos + 1) == '/') {
bufPos += 2;
scanChar();
scanChar();
scanChar();
if (isHint) {
stringVal = subString(mark + startHintSp, (bufPos - startHintSp) - 1);
token = Token.HINT;
stringVal = subString(mark, bufPos);
token = Token.MULTI_LINE_COMMENT;
if (token != Token.HINT && !isAllowComment()) {
throw new NotAllowCommentException();
if (!isAllowComment()) {
throw new NotAllowCommentException();
if (ch == '/' || ch == '-') {
scanChar();
for (;;) {
if (ch == 'r') {
if (charAt(pos + 1) == 'n') {
bufPos += 2;
scanChar();
} else if (ch == EOI) {
if (ch == 'n') {
scanChar();
scanChar();
stringVal = subString(mark + 1, bufPos);
token = Token.LINE_COMMENT;
public class OdpsSelectParser extends SQLSelectParser {
public OdpsSelectParser(SQLExprParser exprParser){
super(exprParser.getLexer());
this.exprParser = exprParser;
protected SQLSelectItem parseSelectItem() {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.exprParser.primaryRest(expr);
expr = this.exprParser.exprRest(expr);
expr = expr();
if (lexer.token() == Token.AS) {
lexer.nextToken();
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
OdpsUDTFSQLSelectItem selectItem = new OdpsUDTFSQLSelectItem();
selectItem.setExpr(expr);
for (;;) {
String alias = lexer.stringVal();
lexer.nextToken();
selectItem.getAliasList().add(alias);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
accept(Token.RPAREN);
return selectItem;
final String alias = as();
return new SQLSelectItem(expr, alias);
public class OdpsStatementParser extends SQLStatementParser {
public OdpsStatementParser(String sql){
super(new OdpsExprParser(sql));
public OdpsStatementParser(SQLExprParser exprParser){
super(exprParser);
public SQLCreateTableStatement parseCreateTable() {
SQLCreateTableParser parser = new OdpsCreateTableParser(this.exprParser);
return parser.parseCrateTable();
public SQLCreateTableParser getSQLCreateTableParser() {
return new OdpsCreateTableParser(this.exprParser);
public boolean parseStatementListDialect(List<SQLStatement> statementList) {
if (lexer.token() == Token.FROM) {
SQLStatement stmt = this.parseInsert();
statementList.add(stmt);
return true;
return false;
public SQLStatement parseInsert() {
OdpsInsertStatement stmt = new OdpsInsertStatement();
if (lexer.token() == Token.FROM) {
lexer.nextToken();
accept(Token.LPAREN);
SQLSelectParser selectParser = createSQLSelectParser();
SQLSelect select = selectParser.select();
accept(Token.RPAREN);
String alias = lexer.stringVal();
accept(Token.IDENTIFIER);
SQLSubqueryTableSource from = new SQLSubqueryTableSource(select, alias);
stmt.setFrom(from);
for (;;) {
OdpsInsert insert = parseOdpsInsert();
stmt.getItems().add(insert);
if (lexer.token() != Token.INSERT) {
return stmt;
public OdpsInsert parseOdpsInsert() {
OdpsInsert insert = new OdpsInsert();
SQLSelectParser selectParser = createSQLSelectParser();
accept(Token.INSERT);
if (lexer.token() == Token.INTO) {
lexer.nextToken();
accept(Token.OVERWRITE);
insert.setOverwrite(true);
accept(Token.TABLE);
insert.setTableSource(this.exprParser.name());
if (lexer.token() == Token.PARTITION) {
lexer.nextToken();
accept(Token.LPAREN);
for (;;) {
SQLAssignItem ptExpr = new SQLAssignItem();
ptExpr.setTarget(this.exprParser.name());
if (lexer.token() == Token.EQ) {
lexer.nextToken();
SQLExpr ptValue = this.exprParser.expr();
ptExpr.setValue(ptValue);
insert.getPartitions().add(ptExpr);
if (!(lexer.token() == (Token.COMMA))) {
lexer.nextToken();
accept(Token.RPAREN);
SQLSelect query = selectParser.select();
insert.setQuery(query);
return insert;
public interface OdpsASTVisitor extends SQLASTVisitor {
void endVisit(OdpsCreateTableStatement x);
boolean visit(OdpsCreateTableStatement x);
void endVisit(OdpsInsertStatement x);
boolean visit(OdpsInsertStatement x);
void endVisit(OdpsInsert x);
boolean visit(OdpsInsert x);
void endVisit(OdpsUDTFSQLSelectItem x);
boolean visit(OdpsUDTFSQLSelectItem x);
public class OdpsOutputVisitor extends SQLASTOutputVisitor implements OdpsASTVisitor {
public OdpsOutputVisitor(Appendable appender){
super(appender);
public boolean visit(OdpsCreateTableStatement x) {
if (x.isIfNotExiists()) {
print("CREATE TABLE IF NOT EXISTS ");
print("CREATE TABLE ");
x.getName().accept(this);
x.getName().accept(this);
if (x.getLike() != null) {
print(" LIKE ");
x.getLike().accept(this);
int size = x.getTableElementList().size();
if (size > 0) {
print(" (");
incrementIndent();
println();
for (int i = 0; i < size; ++i) {
if (i != 0) {
print(", ");
println();
x.getTableElementList().get(i).accept(this);
decrementIndent();
println();
print(")");
if (x.getComment() != null) {
println();
print("COMMENT ");
x.getComment().accept(this);
int partitionSize = x.getPartitionColumns().size();
if (partitionSize > 0) {
println();
print("PARTITIONED (");
for (int i = 0; i < partitionSize; ++i) {
if (i != 0) {
print(", ");
x.getPartitionColumns().get(i).accept(this);
print(")");
return false;
public void endVisit(OdpsCreateTableStatement x) {
super.endVisit((SQLCreateTableStatement) x);
public SQLStatement parseInsert() {
OdpsInsertStatement stmt = new OdpsInsertStatement();
return stmt;
public void endVisit(OdpsInsertStatement x) {
public boolean visit(OdpsInsertStatement x) {
if (x.getFrom() != null) {
print("FROM (");
incrementIndent();
println();
x.getFrom().getSelect().accept(this);
decrementIndent();
println();
print(") ");
print(x.getFrom().getAlias());
for (OdpsInsert insert : x.getItems()) {
println();
println();
insert.accept(this);
return false;
public void endVisit(OdpsInsert x) {
public boolean visit(OdpsInsert x) {
if (x.isOverwrite()) {
print("INSERT OVERWRITE TABLE ");
print("INSERT INTO OVERWRITE ");
x.getTableSource().accept(this);
int partitions = x.getPartitions().size();
if (partitions > 0) {
print(" PARTITION (");
for (int i = 0; i < partitions; ++i) {
if (i != 0) {
print(", ");
SQLAssignItem assign = x.getPartitions().get(i);
assign.getTarget().accept(this);
if (assign.getValue() != null) {
print("=");
assign.getValue().accept(this);
print(")");
println();
x.getQuery().accept(this);
return false;
public boolean visit(SQLCaseExpr x) {
incrementIndent();
print("CASE ");
if (x.getValueExpr() != null) {
x.getValueExpr().accept(this);
println();
printAndAccept(x.getItems(), " ");
if (x.getElseExpr() != null) {
println();
print("ELSE ");
x.getElseExpr().accept(this);
println();
print("END");
decrementIndent();
return false;
public boolean visit(SQLSelectGroupByClause x) {
int itemSize = x.getItems().size();
if (itemSize > 0) {
print("GROUP BY ");
incrementIndent();
for (int i = 0; i < itemSize; ++i) {
if (i != 0) {
println(", ");
x.getItems().get(i).accept(this);
decrementIndent();
if (x.getHaving() != null) {
println();
print("HAVING ");
x.getHaving().accept(this);
return false;
protected void printSelectList(List<SQLSelectItem> selectList) {
incrementIndent();
for (int i = 0, size = selectList.size(); i < size; ++i) {
if (i != 0) {
print(", ");
println();
selectList.get(i).accept(this);
decrementIndent();
public boolean visit(SQLSubqueryTableSource x) {
print("(");
incrementIndent();
println();
x.getSelect().accept(this);
decrementIndent();
println();
print(")");
if (x.getAlias() != null) {
print(' ');
print(x.getAlias());
return false;
public boolean visit(SQLJoinTableSource x) {
x.getLeft().accept(this);
if (x.getJoinType() == JoinType.COMMA) {
print(",");
println();
print(JoinType.toString(x.getJoinType()));
print(" ");
x.getRight().accept(this);
if (x.getCondition() != null) {
incrementIndent();
print(" ON ");
x.getCondition().accept(this);
decrementIndent();
if (x.getUsing().size() > 0) {
print(" USING (");
printAndAccept(x.getUsing(), ", ");
print(")");
if (x.getAlias() != null) {
print(" AS ");
print(x.getAlias());
return false;
public void endVisit(OdpsUDTFSQLSelectItem x) {
public boolean visit(OdpsUDTFSQLSelectItem x) {
x.getExpr().accept(this);
print(" AS (");
for (int i = 0; i < x.getAliasList().size(); ++i) {
if (i != 0) {
print(", ");
print(x.getAliasList().get(i));
print(")");
return false;
public class OdpsSchemaStatVisitor extends SchemaStatVisitor implements OdpsASTVisitor {
public void endVisit(OdpsCreateTableStatement x) {
super.endVisit((SQLCreateTableStatement) x);
public boolean visit(OdpsCreateTableStatement x) {
return super.visit((SQLCreateTableStatement) x);
public void endVisit(OdpsInsertStatement x) {
public boolean visit(OdpsInsertStatement x) {
return false;
public void endVisit(OdpsInsert x) {
public boolean visit(OdpsInsert x) {
return false;
public void endVisit(OdpsUDTFSQLSelectItem x) {
public boolean visit(OdpsUDTFSQLSelectItem x) {
return true;
if (lexer.token() == Token.FROM) {
lexer.nextToken();
SQLExpr trim_source = this.expr();
methodExpr.addParameter(trim_source);
if (x.getParameters().size() > 0) {
print(" FROM ");
x.getParameters().get(0).accept(this);
for (;;) {
ch = charAt(++pos);
if (ch == '}') {
if (ch != '}') {
throw new ParserException("syntax error");
this.ch = charAt(pos);
stringVal = addSymbol();
token = Token.VARIANT;
public class SQLExprParser extends SQLParser {
public final static String[] AGGREGATE_FUNCTIONS = { "AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM" };
protected String[]           aggregateFunctions  = AGGREGATE_FUNCTIONS;
public SQLExprParser(String sql){
super(sql);
public SQLExprParser(Lexer lexer){
super(lexer);
public SQLExpr expr() {
if (lexer.token() == Token.STAR) {
lexer.nextToken();
SQLExpr expr = new SQLAllColumnExpr();
if (lexer.token() == Token.DOT) {
lexer.nextToken();
accept(Token.STAR);
return new SQLPropertyExpr(expr, "*");
return expr;
SQLExpr expr = primary();
if (lexer.token() == Token.COMMA) {
return expr;
return exprRest(expr);
public SQLExpr exprRest(SQLExpr expr) {
expr = bitXorRest(expr);
expr = multiplicativeRest(expr);
expr = additiveRest(expr);
expr = shiftRest(expr);
expr = bitAndRest(expr);
expr = bitOrRest(expr);
expr = inRest(expr);
expr = relationalRest(expr);
expr = equalityRest(expr);
expr = andRest(expr);
expr = orRest(expr);
return expr;
public final SQLExpr bitXor() {
SQLExpr expr = primary();
return bitXorRest(expr);
public SQLExpr bitXorRest(SQLExpr expr) {
if (lexer.token() == Token.CARET) {
lexer.nextToken();
SQLExpr rightExp = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseXor, rightExp);
expr = bitXorRest(expr);
return expr;
public final SQLExpr multiplicative() {
SQLExpr expr = bitXor();
return multiplicativeRest(expr);
public SQLExpr multiplicativeRest(SQLExpr expr) {
if (lexer.token() == Token.STAR) {
lexer.nextToken();
SQLExpr rightExp = bitXor();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Multiply, rightExp);
expr = multiplicativeRest(expr);
} else if (lexer.token() == Token.SLASH) {
lexer.nextToken();
SQLExpr rightExp = bitXor();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Divide, rightExp);
expr = multiplicativeRest(expr);
} else if (lexer.token() == Token.PERCENT) {
lexer.nextToken();
SQLExpr rightExp = bitXor();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Modulus, rightExp);
expr = multiplicativeRest(expr);
return expr;
public SQLExpr primary() {
SQLExpr sqlExpr = null;
final Token tok = lexer.token();
switch (tok) {
lexer.nextToken();
sqlExpr = expr();
if (lexer.token() == Token.COMMA) {
SQLListExpr listExpr = new SQLListExpr();
listExpr.getItems().add(sqlExpr);
lexer.nextToken();
listExpr.getItems().add(expr());
} while (lexer.token() == Token.COMMA);
sqlExpr = listExpr;
accept(Token.RPAREN);
lexer.nextToken();
if (lexer.token() != Token.LPAREN) {
throw new ParserException("syntax error");
sqlExpr = new SQLIdentifierExpr("INSERT");
case IDENTIF
sqlExpr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextToken();
throw new ParserException("TODO");
sqlExpr = new SQLIntegerExpr(lexer.integerValue());
lexer.nextToken();
case LITERAL_FLO
sqlExpr = new SQLNumberExpr(lexer.decimalValue());
lexer.nextToken();
case LITERAL_CH
sqlExpr = new SQLCharExpr(lexer.stringVal());
lexer.nextToken();
case LITERAL_NCH
sqlExpr = new SQLNCharExpr(lexer.stringVal());
lexer.nextToken();
SQLVariantRefExpr varRefExpr = new SQLVariantRefExpr(lexer.stringVal());
lexer.nextToken();
if (varRefExpr.getName().equals("@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@'" + lexer.stringVal() + "'");
lexer.nextToken();
} else if (varRefExpr.getName().equals("@@") && lexer.token() == Token.LITERAL_CHARS) {
varRefExpr.setName("@@'" + lexer.stringVal() + "'");
lexer.nextToken();
sqlExpr = varRefExpr;
case DEFAU
sqlExpr = new SQLDefaultExpr();
lexer.nextToken();
case DISTINC
case SCHEM
case COLUM
case COMPU
case DISAB
case INITIALLY
case SEQUENC
case REPLAC
case INDEX
case CREATIO
case IMMED
case DEFERRED
case STORAG
case MINEX
case MAXEX
case MAXSIZ
case PCTINC
case FLASH_CACH
case CELL_FLASH_CACH
case CHUNK
case NOCACH
case LOGGING
case NOCOMP
case KEEP_DUPLIC
case EXCEPTIO
case IDENTIFIED
case PASSWORD
case BINARY
case WINDOW
case CONNEC
case MATCHED
case REJEC
case UNLIMITED
case EXCLUSIV
sqlExpr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextToken();
SQLCaseExpr caseExpr = new SQLCaseExpr();
lexer.nextToken();
if (lexer.token() != Token.WHEN) {
caseExpr.setValueExpr(expr());
accept(Token.WHEN);
SQLExpr testExpr = expr();
accept(Token.THEN);
SQLExpr valueExpr = expr();
SQLCaseExpr.Item caseItem = new SQLCaseExpr.Item(testExpr, valueExpr);
caseExpr.addItem(caseItem);
while (lexer.token() == Token.WHEN) {
lexer.nextToken();
testExpr = expr();
accept(Token.THEN);
valueExpr = expr();
caseItem = new SQLCaseExpr.Item(testExpr, valueExpr);
caseExpr.getItems().add(caseItem);
if (lexer.token() == Token.ELSE) {
lexer.nextToken();
caseExpr.setElseExpr(expr());
accept(Token.END);
sqlExpr = caseExpr;
lexer.nextToken();
accept(Token.LPAREN);
sqlExpr = new SQLExistsExpr(createSelectParser().select());
accept(Token.RPAREN);
lexer.nextToken();
if (lexer.token() == Token.EXISTS) {
lexer.nextToken();
accept(Token.LPAREN);
sqlExpr = new SQLExistsExpr(createSelectParser().select(), true);
accept(Token.RPAREN);
} else if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLExpr notTarget = expr();
accept(Token.RPAREN);
notTarget = exprRest(notTarget);
sqlExpr = new SQLNotExpr(notTarget);
return primaryRest(sqlExpr);
SQLExpr restExpr = relational();
sqlExpr = new SQLNotExpr(restExpr);
case SELEC
SQLQueryExpr queryExpr = new SQLQueryExpr(createSelectParser().select());
sqlExpr = queryExpr;
lexer.nextToken();
accept(Token.LPAREN);
SQLCastExpr cast = new SQLCastExpr();
cast.setExpr(expr());
accept(Token.AS);
cast.setDataType(parseDataType());
accept(Token.RPAREN);
sqlExpr = cast;
lexer.nextToken();
switch (lexer.token()) {
Number integerValue = lexer.integerValue();
if (integerValue instanceof Integer) {
int intVal = ((Integer) integerValue).intValue();
if (intVal == Integer.MIN_VALUE) {
integerValue = Long.valueOf(((long) intVal) * -1);
integerValue = Integer.valueOf(intVal * -1);
} else if (integerValue instanceof Long) {
long longVal = ((Long) integerValue).longValue();
if (longVal == 2147483648L) {
integerValue = Integer.valueOf((int) (((long) longVal) * -1));
integerValue = Long.valueOf(longVal * -1);
integerValue = ((BigInteger) integerValue).negate();
sqlExpr = new SQLIntegerExpr(integerValue);
lexer.nextToken();
case LITERAL_FLO
sqlExpr = new SQLNumberExpr(lexer.decimalValue().negate());
lexer.nextToken();
case IDENTIFIER: 
sqlExpr = new SQLIdentifierExpr(lexer.stringVal());
sqlExpr = new SQLUnaryExpr(SQLUnaryOperator.Negative, sqlExpr);
lexer.nextToken();
sqlExpr = new SQLUnaryExpr(SQLUnaryOperator.Negative, new SQLVariantRefExpr("?"));
lexer.nextToken();
lexer.nextToken();
sqlExpr = expr();
accept(Token.RPAREN);
sqlExpr = new SQLUnaryExpr(SQLUnaryOperator.Negative, sqlExpr);
throw new ParserException("TODO : " + lexer.token());
lexer.nextToken();
switch (lexer.token()) {
sqlExpr = new SQLIntegerExpr(lexer.integerValue());
lexer.nextToken();
case LITERAL_FLO
sqlExpr = new SQLNumberExpr(lexer.decimalValue());
lexer.nextToken();
lexer.nextToken();
sqlExpr = expr();
accept(Token.RPAREN);
sqlExpr = new SQLUnaryExpr(SQLUnaryOperator.Plus, sqlExpr);
throw new ParserException("TODO");
lexer.nextToken();
SQLExpr unaryValueExpr = expr();
SQLUnaryExpr unary = new SQLUnaryExpr(SQLUnaryOperator.Compl, unaryValueExpr);
sqlExpr = unary;
lexer.nextToken();
SQLVariantRefExpr quesVarRefExpr = new SQLVariantRefExpr("?");
quesVarRefExpr.setIndex(lexer.nextVarIndex());
sqlExpr = quesVarRefExpr;
sqlExpr = new SQLIdentifierExpr("LEFT");
lexer.nextToken();
sqlExpr = new SQLIdentifierExpr("RIGHT");
lexer.nextToken();
case DATAB
sqlExpr = new SQLIdentifierExpr("DATABASE");
lexer.nextToken();
sqlExpr = new SQLIdentifierExpr("LOCK");
lexer.nextToken();
sqlExpr = new SQLNullExpr();
lexer.nextToken();
lexer.nextToken();
SQLExpr bangExpr = expr();
sqlExpr = new SQLUnaryExpr(SQLUnaryOperator.Not, bangExpr);
case LITERAL_HEX
String hex = lexer.hexString();
sqlExpr = new SQLHexExpr(hex);
lexer.nextToken();
case INTERV
sqlExpr = parseInterval();
lexer.nextToken();
if (lexer.token == Token.LITERAL_ALIAS) {
sqlExpr = new SQLVariantRefExpr(":"" + lexer.stringVal() + """);
lexer.nextToken();
lexer.nextToken();
if (lexer.token() == Token.LPAREN) {
SQLAnyExpr anyExpr = new SQLAnyExpr();
accept(Token.LPAREN);
SQLSelect anySubQuery = createSelectParser().select();
anyExpr.setSubQuery(anySubQuery);
accept(Token.RPAREN);
anySubQuery.setParent(anyExpr);
sqlExpr = anyExpr;
sqlExpr = new SQLIdentifierExpr("ANY");
lexer.nextToken();
SQLSomeExpr someExpr = new SQLSomeExpr();
accept(Token.LPAREN);
SQLSelect someSubQuery = createSelectParser().select();
someExpr.setSubQuery(someSubQuery);
accept(Token.RPAREN);
someSubQuery.setParent(someExpr);
sqlExpr = someExpr;
lexer.nextToken();
SQLAllExpr allExpr = new SQLAllExpr();
accept(Token.LPAREN);
SQLSelect allSubQuery = createSelectParser().select();
allExpr.setSubQuery(allSubQuery);
accept(Token.RPAREN);
allSubQuery.setParent(allExpr);
sqlExpr = allExpr;
sqlExpr = new SQLIdentifierExpr('"' + lexer.stringVal() + '"');
lexer.nextToken();
throw new EOFParserException();
throw new ParserException("ERROR. token : " + tok + ", pos : " + lexer.pos());
return primaryRest(sqlExpr);
protected SQLExpr parseInterval() {
throw new ParserException("TODO");
public SQLSelectParser createSelectParser() {
return new SQLSelectParser(this);
public SQLExpr primaryRest(SQLExpr expr) {
if (expr == null) {
throw new IllegalArgumentException("expr");
if (lexer.token() == Token.OF) {
if (expr instanceof SQLIdentifierExpr) {
String name = ((SQLIdentifierExpr) expr).getName();
if ("CURRENT".equalsIgnoreCase(name)) {
lexer.nextToken();
SQLName cursorName = this.name();
return new SQLCurrentOfCursorExpr(cursorName);
if (lexer.token() == Token.DOT) {
lexer.nextToken();
if (expr instanceof SQLCharExpr) {
String text = ((SQLCharExpr) expr).getText();
expr = new SQLIdentifierExpr(text);
expr = dotRest(expr);
return primaryRest(expr);
if (lexer.token() == Token.LPAREN) {
return methodRest(expr, true);
return expr;
protected SQLExpr methodRest(SQLExpr expr, boolean acceptLPAREN) {
if (acceptLPAREN) {
accept(Token.LPAREN);
if (expr instanceof SQLName || expr instanceof SQLDefaultExpr) {
String methodName;
SQLMethodInvokeExpr methodInvokeExpr;
if (expr instanceof SQLPropertyExpr) {
methodName = ((SQLPropertyExpr) expr).getName();
methodInvokeExpr = new SQLMethodInvokeExpr(methodName);
methodInvokeExpr.setOwner(((SQLPropertyExpr) expr).getOwner());
methodName = expr.toString();
methodInvokeExpr = new SQLMethodInvokeExpr(methodName);
if (isAggreateFunction(methodName)) {
SQLAggregateExpr aggregateExpr = parseAggregateExpr(methodName);
return aggregateExpr;
if (lexer.token() != Token.RPAREN) {
exprList(methodInvokeExpr.getParameters(), methodInvokeExpr);
accept(Token.RPAREN);
return primaryRest(methodInvokeExpr);
throw new ParserException("not support token:" + lexer.token());
protected SQLExpr dotRest(SQLExpr expr) {
if (lexer.token() == Token.STAR) {
lexer.nextToken();
expr = new SQLPropertyExpr(expr, "*");
String name;
if (lexer.token() == Token.IDENTIFIER || lexer.token() == Token.LITERAL_CH
|| lexer.token() == Token.LITERAL_ALIAS) {
name = lexer.stringVal();
lexer.nextToken();
} else if (lexer.getKeywods().containsValue(lexer.token())) {
name = lexer.stringVal();
lexer.nextToken();
throw new ParserException("error : " + lexer.stringVal());
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLMethodInvokeExpr methodInvokeExpr = new SQLMethodInvokeExpr(name);
methodInvokeExpr.setOwner(expr);
if (lexer.token() == Token.RPAREN) {
lexer.nextToken();
if (lexer.token() == Token.PLUS) {
methodInvokeExpr.addParameter(new SQLIdentifierExpr("+"));
lexer.nextToken();
exprList(methodInvokeExpr.getParameters(), methodInvokeExpr);
accept(Token.RPAREN);
expr = methodInvokeExpr;
expr = new SQLPropertyExpr(expr, name);
expr = primaryRest(expr);
return expr;
public final SQLExpr groupComparisionRest(SQLExpr expr) {
return expr;
public final void names(Collection<SQLName> exprCol) {
names(exprCol, null);
public final void names(Collection<SQLName> exprCol, SQLObject parent) {
if (lexer.token() == Token.RBRACE) {
if (lexer.token() == Token.EOF) {
SQLName name = name();
name.setParent(parent);
exprCol.add(name);
while (lexer.token() == Token.COMMA) {
lexer.nextToken();
name = name();
name.setParent(parent);
exprCol.add(name);
public final void exprList(Collection<SQLExpr> exprCol) {
exprList(exprCol, null);
public final void exprList(Collection<SQLExpr> exprCol, SQLObject parent) {
if (lexer.token() == Token.RPAREN || lexer.token() == Token.RBRACKET) {
if (lexer.token() == Token.EOF) {
SQLExpr expr = expr();
expr.setParent(parent);
exprCol.add(expr);
while (lexer.token() == Token.COMMA) {
lexer.nextToken();
expr = expr();
expr.setParent(parent);
exprCol.add(expr);
public SQLName name() {
String identName;
if (lexer.token() == Token.LITERAL_ALIAS) {
identName = '"' + lexer.stringVal() + '"';
lexer.nextToken();
} else if (lexer.token() == Token.IDENTIFIER) {
identName = lexer.stringVal();
lexer.nextToken();
} else if (lexer.token() == Token.LITERAL_CHARS) {
identName = ''' + lexer.stringVal() + ''';
lexer.nextToken();
} else if (lexer.token() == Token.VARIANT) {
identName = lexer.stringVal();
lexer.nextToken();
switch (lexer.token()) {
case CREATIO
case IMMED
case DEFERRED
case STORAG
case MINEX
case MAXEX
case MAXSIZ
case PCTINC
case FLASH_CACH
case CELL_FLASH_CACH
case CHUNK
case NOCACH
case LOGGING
case NOCOMP
case KEEP_DUPLIC
case EXCEPTIO
case INITIALLY
case DISAB
case SEQUENC
case ANALYZ
case OPTIMIZ
identName = lexer.stringVal();
lexer.nextToken();
throw new ParserException("error " + lexer.token());
SQLName name = new SQLIdentifierExpr(identName);
name = nameRest(name);
return name;
public SQLName nameRest(SQLName name) {
if (lexer.token() == Token.DOT) {
lexer.nextToken();
if (lexer.token() == Token.KEY) {
name = new SQLPropertyExpr(name, "KEY");
lexer.nextToken();
return name;
if (lexer.token() != Token.LITERAL_ALIAS && lexer.token() != Token.IDENTIF
&& (!lexer.getKeywods().containsValue(lexer.token()))) {
throw new ParserException("error, " + lexer.token());
if (lexer.token() == Token.LITERAL_ALIAS) {
name = new SQLPropertyExpr(name, '"' + lexer.stringVal() + '"');
name = new SQLPropertyExpr(name, lexer.stringVal());
lexer.nextToken();
name = nameRest(name);
return name;
public boolean isAggreateFunction(String word) {
for (int i = 0; i < aggregateFunctions.length; ++i) {
if (aggregateFunctions[i].compareToIgnoreCase(word) == 0) {
return true;
return false;
protected SQLAggregateExpr parseAggregateExpr(String methodName) {
methodName = methodName.toUpperCase();
SQLAggregateExpr aggregateExpr;
if (lexer.token() == Token.ALL) {
aggregateExpr = new SQLAggregateExpr(methodName, SQLAggregateExpr.Option.ALL);
lexer.nextToken();
} else if (lexer.token() == Token.DISTINCT) {
aggregateExpr = new SQLAggregateExpr(methodName, SQLAggregateExpr.Option.DISTINCT);
lexer.nextToken();
aggregateExpr = new SQLAggregateExpr(methodName);
exprList(aggregateExpr.getArguments(), aggregateExpr);
parseAggregateExprRest(aggregateExpr);
accept(Token.RPAREN);
if (lexer.token() == Token.OVER) {
lexer.nextToken();
SQLOver over = new SQLOver();
accept(Token.LPAREN);
if (lexer.token() == Token.PARTITION || identifierEquals("PARTITION")) {
lexer.nextToken();
accept(Token.BY);
if (lexer.token() == (Token.LPAREN)) {
lexer.nextToken();
exprList(over.getPartitionBy());
accept(Token.RPAREN);
exprList(over.getPartitionBy());
over.setOrderBy(parseOrderBy());
accept(Token.RPAREN);
aggregateExpr.setOver(over);
return aggregateExpr;
protected SQLAggregateExpr parseAggregateExprRest(SQLAggregateExpr aggregateExpr) {
return aggregateExpr;
public SQLOrderBy parseOrderBy() {
if (lexer.token() == Token.ORDER) {
SQLOrderBy orderBy = new SQLOrderBy();
lexer.nextToken();
accept(Token.BY);
orderBy.getItems().add(parseSelectOrderByItem());
while (lexer.token() == Token.COMMA) {
lexer.nextToken();
orderBy.getItems().add(parseSelectOrderByItem());
return orderBy;
return null;
public SQLSelectOrderByItem parseSelectOrderByItem() {
SQLSelectOrderByItem item = new SQLSelectOrderByItem();
item.setExpr(expr());
if (lexer.token() == Token.ASC) {
lexer.nextToken();
item.setType(SQLOrderingSpecification.ASC);
} else if (lexer.token() == Token.DESC) {
lexer.nextToken();
item.setType(SQLOrderingSpecification.DESC);
return item;
public final SQLExpr bitAnd() {
SQLExpr expr = shift();
return bitAndRest(expr);
public final SQLExpr bitAndRest(SQLExpr expr) {
while (lexer.token() == Token.AMP) {
lexer.nextToken();
SQLExpr rightExp = shift();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseAnd, rightExp);
return expr;
public final SQLExpr bitOr() {
SQLExpr expr = bitAnd();
return bitOrRest(expr);
public final SQLExpr bitOrRest(SQLExpr expr) {
if (lexer.token() == Token.BAR) {
lexer.nextToken();
SQLExpr rightExp = bitAnd();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseOr, rightExp);
expr = bitAndRest(expr);
return expr;
public final SQLExpr equality() {
SQLExpr expr = bitOr();
return equalityRest(expr);
public SQLExpr equalityRest(SQLExpr expr) {
SQLExpr rightExp;
if (lexer.token() == Token.EQ) {
lexer.nextToken();
rightExp = bitOr();
} catch (EOFParserException e) {
throw new ParserException("EOF, " + expr + "=", e);
rightExp = equalityRest(rightExp);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Equality, rightExp);
} else if (lexer.token() == Token.BANGEQ) {
lexer.nextToken();
rightExp = bitOr();
rightExp = equalityRest(rightExp);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotEqual, rightExp);
} else if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
rightExp = expr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Assignment, rightExp);
return expr;
public final SQLExpr inRest(SQLExpr expr) {
if (lexer.token() == Token.IN) {
lexer.nextToken();
SQLInListExpr inListExpr = new SQLInListExpr(expr);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
exprList(inListExpr.getTargetList(), inListExpr);
accept(Token.RPAREN);
expr = inListExpr;
SQLExpr itemExpr = primary();
itemExpr.setParent(inListExpr);
inListExpr.getTargetList().add(itemExpr);
expr = inListExpr;
if (inListExpr.getTargetList().size() == 1) {
SQLExpr targetExpr = inListExpr.getTargetList().get(0);
if (targetExpr instanceof SQLQueryExpr) {
SQLInSubQueryExpr inSubQueryExpr = new SQLInSubQueryExpr();
inSubQueryExpr.setExpr(inListExpr.getExpr());
inSubQueryExpr.setSubQuery(((SQLQueryExpr) targetExpr).getSubQuery());
expr = inSubQueryExpr;
return expr;
public final SQLExpr additive() {
SQLExpr expr = multiplicative();
return additiveRest(expr);
public SQLExpr additiveRest(SQLExpr expr) {
if (lexer.token() == Token.PLUS) {
lexer.nextToken();
SQLExpr rightExp = multiplicative();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Add, rightExp);
expr = additiveRest(expr);
} else if (lexer.token() == Token.BARBAR) {
lexer.nextToken();
SQLExpr rightExp = multiplicative();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Concat, rightExp);
expr = additiveRest(expr);
} else if (lexer.token() == Token.SUB) {
lexer.nextToken();
SQLExpr rightExp = multiplicative();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Subtract, rightExp);
expr = additiveRest(expr);
return expr;
public final SQLExpr shift() {
SQLExpr expr = additive();
return shiftRest(expr);
public SQLExpr shiftRest(SQLExpr expr) {
if (lexer.token() == Token.LTLT) {
lexer.nextToken();
SQLExpr rightExp = additive();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LeftShift, rightExp);
expr = shiftRest(expr);
} else if (lexer.token() == Token.GTGT) {
lexer.nextToken();
SQLExpr rightExp = additive();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.RightShift, rightExp);
expr = shiftRest(expr);
return expr;
public SQLExpr and() {
SQLExpr expr = relational();
return andRest(expr);
public SQLExpr andRest(SQLExpr expr) {
for (;;) {
if (lexer.token() == Token.AND || lexer.token() == Token.AMPAMP) {
lexer.nextToken();
SQLExpr rightExp = relational();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanAnd, rightExp);
return expr;
public SQLExpr or() {
SQLExpr expr = and();
return orRest(expr);
public SQLExpr orRest(SQLExpr expr) {
for (;;) {
if (lexer.token() == Token.OR) {
lexer.nextToken();
SQLExpr rightExp = and();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp);
} else if (lexer.token() == Token.XOR) {
lexer.nextToken();
SQLExpr rightExp = and();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp);
return expr;
public SQLExpr relational() {
SQLExpr expr = equality();
return relationalRest(expr);
public SQLExpr relationalRest(SQLExpr expr) {
SQLExpr rightExp;
if (lexer.token() == Token.LT) {
SQLBinaryOperator op = SQLBinaryOperator.LessThan;
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
op = SQLBinaryOperator.LessThanOrEqual;
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, op, rightExp);
} else if (lexer.token() == Token.LTEQ) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrEqual, rightExp);
} else if (lexer.token() == Token.LTEQGT) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrEqualOrGreaterThan, rightExp);
} else if (lexer.token() == Token.GT) {
SQLBinaryOperator op = SQLBinaryOperator.GreaterThan;
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
op = SQLBinaryOperator.GreaterThanOrEqual;
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, op, rightExp);
} else if (lexer.token() == Token.GTEQ) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.GreaterThanOrEqual, rightExp);
} else if (lexer.token() == Token.BANGLT) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotLessThan, rightExp);
} else if (lexer.token() == Token.BANGGT) {
lexer.nextToken();
rightExp = bitOr();
rightExp = relationalRest(rightExp);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotGreaterThan, rightExp);
} else if (lexer.token() == Token.LTGT) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrGreater, rightExp);
} else if (lexer.token() == Token.LIKE) {
lexer.nextToken();
rightExp = bitOr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Like, rightExp);
if (lexer.token() == Token.ESCAPE) {
lexer.nextToken();
rightExp = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Escape, rightExp);
} else if (lexer.token() == (Token.NOT)) {
lexer.nextToken();
expr = notRationalRest(expr);
} else if (lexer.token() == (Token.BETWEEN)) {
lexer.nextToken();
SQLExpr beginExpr = bitOr();
accept(Token.AND);
SQLExpr endExpr = bitOr();
expr = new SQLBetweenExpr(expr, beginExpr, endExpr);
} else if (lexer.token() == (Token.IS)) {
lexer.nextToken();
if (lexer.token() == (Token.NOT)) {
lexer.nextToken();
SQLExpr rightExpr = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.IsNot, rightExpr);
SQLExpr rightExpr = primary();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Is, rightExpr);
} else if (lexer.token() == Token.IN) {
expr = inRest(expr);
return expr;
public SQLExpr notRationalRest(SQLExpr expr) {
if (lexer.token() == (Token.LIKE)) {
lexer.nextToken();
SQLExpr rightExp = equality();
rightExp = relationalRest(rightExp);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotLike, rightExp);
if (lexer.token() == Token.ESCAPE) {
lexer.nextToken();
rightExp = expr();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Escape, rightExp);
} else if (lexer.token() == Token.IN) {
lexer.nextToken();
accept(Token.LPAREN);
SQLInListExpr inListExpr = new SQLInListExpr(expr, true);
exprList(inListExpr.getTargetList(), inListExpr);
expr = inListExpr;
accept(Token.RPAREN);
if (inListExpr.getTargetList().size() == 1) {
SQLExpr targetExpr = inListExpr.getTargetList().get(0);
if (targetExpr instanceof SQLQueryExpr) {
SQLInSubQueryExpr inSubQueryExpr = new SQLInSubQueryExpr();
inSubQueryExpr.setNot(true);
inSubQueryExpr.setExpr(inListExpr.getExpr());
inSubQueryExpr.setSubQuery(((SQLQueryExpr) targetExpr).getSubQuery());
expr = inSubQueryExpr;
expr = relationalRest(expr);
return expr;
} else if (lexer.token() == (Token.BETWEEN)) {
lexer.nextToken();
SQLExpr beginExpr = bitOr();
accept(Token.AND);
SQLExpr endExpr = bitOr();
expr = new SQLBetweenExpr(expr, true, beginExpr, endExpr);
return expr;
throw new ParserException("TODO " + lexer.token());
return expr;
public SQLDataType parseDataType() {
if (lexer.token() == Token.DEFAULT || lexer.token() == Token.NOT || lexer.token() == Token.NULL) {
return null;
SQLName typeExpr = name();
String typeName = typeExpr.toString();
if (isCharType(typeName)) {
SQLCharactorDataType charType = new SQLCharactorDataType(typeName);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLExpr arg = this.expr();
arg.setParent(charType);
charType.getArguments().add(arg);
accept(Token.RPAREN);
return parseCharTypeRest(charType);
if ("character".equalsIgnoreCase(typeName) && "varying".equalsIgnoreCase(lexer.stringVal())) {
typeName += ' ' + lexer.stringVal();
lexer.nextToken();
SQLDataType dataType = new SQLDataTypeImpl(typeName);
return parseDataTypeRest(dataType);
protected SQLDataType parseDataTypeRest(SQLDataType dataType) {
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
exprList(dataType.getArguments(), dataType);
accept(Token.RPAREN);
return dataType;
protected boolean isCharType(String dataTypeName) {
return "char".equalsIgnoreCase(dataTypeName) 
|| "varchar".equalsIgnoreCase(dataTypeName)
|| "nchar".equalsIgnoreCase(dataTypeName)
|| "nvarchar".equalsIgnoreCase(dataTypeName)
|| "tinytext".equalsIgnoreCase(dataTypeName)
|| "text".equalsIgnoreCase(dataTypeName)
|| "mediumtext".equalsIgnoreCase(dataTypeName)
|| "longtext".equalsIgnoreCase(dataTypeName)
protected SQLDataType parseCharTypeRest(SQLCharactorDataType charType) {
if (identifierEquals("CHARACTER")) {
lexer.nextToken();
accept(Token.SET);
if (lexer.token() != Token.IDENTIFIER && lexer.token() != Token.LITERAL_CHARS) {
throw new ParserException();
charType.setCharSetName(lexer.stringVal());
lexer.nextToken();
if (lexer.token() == Token.IDENTIFIER) {
if (lexer.stringVal().equalsIgnoreCase("COLLATE")) {
lexer.nextToken();
if (lexer.token() != Token.IDENTIFIER) {
throw new ParserException();
charType.setCollate(lexer.stringVal());
lexer.nextToken();
return charType;
public void accept(Token token) {
if (lexer.token() == token) {
lexer.nextToken();
throw new ParserException("syntax error, expect " + token + ", actual " + lexer.token() + " "
+ lexer.stringVal());
public SQLColumnDefinition parseColumn() {
SQLColumnDefinition column = createColumnDefinition();
column.setName(name());
column.setDataType(parseDataType());
return parseColumnRest(column);
protected SQLColumnDefinition createColumnDefinition() {
SQLColumnDefinition column = new SQLColumnDefinition();
return column;
public SQLColumnDefinition parseColumnRest(SQLColumnDefinition column) {
if (lexer.token() == Token.DEFAULT) {
lexer.nextToken();
column.setDefaultExpr(bitOr());
return parseColumnRest(column);
if (lexer.token() == Token.NOT) {
lexer.nextToken();
accept(Token.NULL);
column.getConstaints().add(new NotNullConstraint());
return parseColumnRest(column);
if (lexer.token() == Token.NULL) {
lexer.nextToken();
column.setDefaultExpr(new SQLNullExpr());
return parseColumnRest(column);
if (lexer.token == Token.PRIMARY) {
lexer.nextToken();
accept(Token.KEY);
column.getConstaints().add(new SQLColumnPrimaryKey());
return parseColumnRest(column);
if (lexer.token == Token.UNIQUE) {
lexer.nextToken();
if (lexer.token() == Token.KEY) {
lexer.nextToken();
column.getConstaints().add(new SQLColumnPrimaryKey());
return parseColumnRest(column);
if (lexer.token == Token.CONSTRAINT) {
lexer.nextToken();
SQLName name = this.name();
if (lexer.token() == Token.PRIMARY) {
lexer.nextToken();
accept(Token.KEY);
SQLColumnPrimaryKey pk = new SQLColumnPrimaryKey();
pk.setName(name);
column.getConstaints().add(pk);
return parseColumnRest(column);
if (lexer.token() == Token.UNIQUE) {
lexer.nextToken();
SQLColumnUniqueKey uk = new SQLColumnUniqueKey();
uk.setName(name);
column.getConstaints().add(uk);
return parseColumnRest(column);
if (lexer.token() == Token.REFERENCES) {
lexer.nextToken();
SQLColumnReference ref = new SQLColumnReference();
ref.setName(name);
ref.setTable(this.name());
accept(Token.LPAREN);
this.names(ref.getColumns(), ref);
accept(Token.RPAREN);
column.getConstaints().add(ref);
return parseColumnRest(column);
if (lexer.token() == Token.NOT) {
lexer.nextToken();
accept(Token.NULL);
NotNullConstraint notNull = new NotNullConstraint();
notNull.setName(name);
column.getConstaints().add(notNull);
return parseColumnRest(column);
if (lexer.token == Token.CHECK) {
SQLColumnCheck check = parseColumnCheck();
check.setName(name);
check.setParent(column);
column.getConstaints().add(check);
return parseColumnRest(column);
if (lexer.token == Token.DEFAULT) {
lexer.nextToken();
SQLExpr expr = this.expr();
column.setDefaultExpr(expr);
return parseColumnRest(column);
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
if (lexer.token == Token.CHECK) {
SQLColumnCheck check = parseColumnCheck();
column.getConstaints().add(check);
return parseColumnRest(column);
if (lexer.token() == Token.COMMENT) {
lexer.nextToken();
column.setComment(primary());
return column;
protected SQLColumnCheck parseColumnCheck() {
lexer.nextToken();
SQLExpr expr = this.expr();
SQLColumnCheck check = new SQLColumnCheck(expr);
if (lexer.token() == Token.DISABLE) {
lexer.nextToken();
check.setEnable(false);
} else if (lexer.token() == Token.ENABLE) {
lexer.nextToken();
check.setEnable(true);
return check;
public SQLPrimaryKey parsePrimaryKey() {
accept(Token.PRIMARY);
accept(Token.KEY);
SQLPrimaryKeyImpl pk = new SQLPrimaryKeyImpl();
accept(Token.LPAREN);
exprList(pk.getColumns());
accept(Token.RPAREN);
return pk;
public SQLUnique parseUnique() {
accept(Token.UNIQUE);
SQLUnique unique = new SQLUnique();
accept(Token.LPAREN);
exprList(unique.getColumns());
accept(Token.RPAREN);
return unique;
public SQLAssignItem parseAssignItem() {
SQLAssignItem item = new SQLAssignItem();
SQLExpr var = primary();
if (var instanceof SQLIdentifierExpr) {
var = new SQLVariantRefExpr(((SQLIdentifierExpr) var).getName());
item.setTarget(var);
if (lexer.token() == Token.COLONEQ) {
lexer.nextToken();
accept(Token.EQ);
item.setValue(expr());
return item;
public List<SQLCommentHint> parseHints() {
List<SQLCommentHint> hints = new ArrayList<SQLCommentHint>();
parseHints(hints);
return hints;
@SuppressWarnings({ "unchecked", "rawtypes" })
public void parseHints(List hints) {
if (lexer.token() == Token.HINT) {
hints.add(new SQLCommentHint(lexer.stringVal()));
lexer.nextToken();
public SQLConstaint parseConstaint() {
SQLName name = null;
if (lexer.token() == Token.CONSTRAINT) {
lexer.nextToken();
name = this.name();
SQLConstaint constraint;
if (lexer.token() == Token.PRIMARY) {
constraint = parsePrimaryKey();
} else if (lexer.token() == Token.UNIQUE) {
constraint = parseUnique();
} else if (lexer.token() == Token.FOREIGN) {
constraint = parseForeignKey();
} else if (lexer.token() == Token.CHECK) {
constraint = parseCheck();
throw new ParserException("TODO : " + lexer.token() + " " + lexer.stringVal());
constraint.setName(name);
return constraint;
public SQLCheck parseCheck() {
accept(Token.CHECK);
SQLCheck check = createCheck();
accept(Token.LPAREN);
check.setExpr(this.expr());
accept(Token.RPAREN);
return check;
protected SQLCheck createCheck() {
return new SQLCheck();
public SQLForeignKeyConstraint parseForeignKey() {
accept(Token.FOREIGN);
accept(Token.KEY);
SQLForeignKeyConstraint fk = createForeignKey();
accept(Token.LPAREN);
this.names(fk.getReferencingColumns());
accept(Token.RPAREN);
accept(Token.REFERENCES);
fk.setReferencedTableName(this.name());
accept(Token.LPAREN);
this.names(fk.getReferencedColumns());
accept(Token.RPAREN);
return fk;
protected SQLForeignKeyConstraint createForeignKey() {
return new SQLForeignKeyImpl();
if (JdbcUtils.ODPS.equals(dbType)) {
return new OdpsExprParser(sql);
final SQLSelectItem selectItem = parseSelectItem();
protected SQLSelectItem parseSelectItem() {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.exprParser.primaryRest(expr);
expr = this.exprParser.exprRest(expr);
expr = expr();
final String alias = as();
return new SQLSelectItem(expr, alias);
return new OdpsSelectParser(this.exprParser);
PARTITION,
PARTITIONED,
OVERWRITE,
private String             indent                 = "t";
private int                indentCount            = 0;
private boolean            prettyFormat           = true;
protected int              selectListNumberOfLine = 5;
if (i % selectListNumberOfLine == 0) {
if (x.getComment() != null) {
print(" COMMENT ");
x.getComment().accept(this);
print("PARTITION BY ");
public static final String ODPS              = "odps";
return Class.forName(className);
} catch (ClassNotFoundException e) {
return clazz;
public class OdpsInsertTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/odps-2.sql");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
SchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println("---------------------------");
System.out.println(SQLUtils.toOdpsString(stmt));
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public class OdpsMultiInsertTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/odps-1.sql");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
SchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println("---------------------------");
System.out.println(SQLUtils.toOdpsString(stmt));
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public class OdpsResourceTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/odps-0.sql");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
SchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println("---------------------------");
System.out.println(SQLUtils.toOdpsString(stmt));
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public class OdpsSelectTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/odps-3.sql");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
SchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println("---------------------------");
System.out.println(SQLUtils.toOdpsString(stmt));
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public class OdpsUDTFTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT my_udtf(1,2,3) as (a, b, c) from employee t1 WHERE t1.name = 'aaa';";
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OdpsSchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employee")));
Assert.assertTrue(visitor.getColumns().contains(new Column("employee", "name")));
public class OracleResourceTest extends OracleTest {
public void test_0() throws Exception {
for (int i = 0; i <= 57; ++i) {
exec_test("bvt/parser/oracle-" + i + ".txt");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OracleStatementParser parser = new OracleStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
System.out.println(sql);
print(statementList);
OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
for (int i = 0, size = statementList.size(); i < size; ++i) {
SQLStatement statement = statementList.get(i);
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println();
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
return wrap(resultSet.getResultSetRaw().getMetaData(), resultSet);
public ResultSetMetaDataProxy wrap(ResultSetMetaData metaData, ResultSetProxy resultSet) {
if (metaData == null) {
return null;
return new ResultSetMetaDataProxyImpl(metaData, dataSource.createMetaDataId(), resultSet);
return metaData.getResultSetMetaDataRaw().getColumnCount();
return metaData.getResultSetMetaDataRaw().isAutoIncrement(column);
return metaData.getResultSetMetaDataRaw().isCaseSensitive(column);
return metaData.getResultSetMetaDataRaw().isSearchable(column);
return metaData.getResultSetMetaDataRaw().isCurrency(column);
return metaData.getResultSetMetaDataRaw().isNullable(column);
return metaData.getResultSetMetaDataRaw().isSigned(column);
return metaData.getResultSetMetaDataRaw().getColumnDisplaySize(column);
return metaData.getResultSetMetaDataRaw().getColumnLabel(column);
return metaData.getResultSetMetaDataRaw().getColumnName(column);
return metaData.getResultSetMetaDataRaw().getSchemaName(column);
return metaData.getResultSetMetaDataRaw().getPrecision(column);
return metaData.getResultSetMetaDataRaw().getScale(column);
return metaData.getResultSetMetaDataRaw().getTableName(column);
return metaData.getResultSetMetaDataRaw().getCatalogName(column);
return metaData.getResultSetMetaDataRaw().getColumnType(column);
return metaData.getResultSetMetaDataRaw().getColumnTypeName(column);
return metaData.getResultSetMetaDataRaw().isReadOnly(column);
return metaData.getResultSetMetaDataRaw().isWritable(column);
return metaData.getResultSetMetaDataRaw().isDefinitelyWritable(column);
return metaData.getResultSetMetaDataRaw().getColumnClassName(column);
public void addItem(SQLSelectOrderByItem item) {
if (item != null) {
item.setParent(this);
this.items.add(item);
public void addItem(SQLExpr sqlExpr) {
if (sqlExpr != null) {
sqlExpr.setParent(this);
this.items.add(sqlExpr);
if (rowCount != null) {
rowCount.setParent(this);
if (offset != null) {
offset.setParent(this);
groupBy.addItem(this.exprParser.expr());
for (SQLExpr sqlExpr : groupBy.getItems()) {
mySqlGroupBy.addItem(sqlExpr);
orderBy.addItem(parseSelectOrderByItem());
orderBy.addItem(parseSelectOrderByItem());
groupBy.addItem(groupingSet);
groupBy.addItem(this.exprParser.expr());
groupBy.addItem(groupingSet);
groupBy.addItem(this.exprParser.expr());
orderBy.addItem(parseSelectOrderByItem());
orderBy.addItem(parseSelectOrderByItem());
orderBy.addItem(parseSelectOrderByItem());
orderBy.addItem(parseSelectOrderByItem());
groupBy.addItem(expr());
for (SQLStatement stmt : statementList) {
stmt.accept(visitor);
} catch (ParserException e) {
violations.add(new SyntaxErrorViolation(e, sql));
if (isDeny(varName)
&& (WallVisitorUtils.isWhereOrHaving(x) || WallVisitorUtils.checkSqlExpr(varExpr))) {
if (isDeny(varName) && (WallVisitorUtils.isWhereOrHaving(x) || WallVisitorUtils.checkSqlExpr(x))) {
if (isDeny(varName) && (WallVisitorUtils.isWhereOrHaving(x) || WallVisitorUtils.checkSqlExpr(x))) {
public static boolean checkSqlExpr(SQLExpr x) { 
if (x == null) {
return false;
SQLObject obj = x;
for (;;) {
SQLObject parent = obj.getParent();
if (parent == null) {
return false;
if (parent instanceof SQLSelectGroupByClause) {
return true;
} else if (parent instanceof SQLOrderBy) {
return true;
} else if (parent instanceof Limit) {
return true;
obj = parent;
if (isWhereOrHaving(x) || checkSqlExpr(x)) {
while (selectParent instanceof SQLSelectQuery 
public void test_false11() {
WallProvider provider = initWallProvider();
String sql = "select * from messages where id=1 limit (select count(*) from products group by concat(version(),0x27202020,floor(rand(0)*2-1)));";
Assert.assertFalse(provider.checkValid(sql));
public void test_false12() {
WallProvider provider = initWallProvider();
String sql = "select * from dede_admin where id=1 order by if((ascii(substr(user(),1,1))>95),1,2);";
Assert.assertFalse(provider.checkValid(sql));
public void test_false13() {
WallProvider provider = initWallProvider();
String sql = "select * from dede_admin where id=1 limit if((ascii(substr(user(),1,1))>95),1,0);";
Assert.assertFalse(provider.checkValid(sql));
public final static int RevisionVersion = 3;
if (lexer.token() == Token.TO || lexer.token() == Token.AS) {
lexer.nextToken();
public void test_alter_3() throws Exception {
String sql = "ALTER TABLE t1 RENAME TO t2;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("RENAME TABLE t1 TO t2", output);
public void test_alter_4() throws Exception {
String sql = "ALTER TABLE t1 RENAME AS t2;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("RENAME TABLE t1 TO t2", output);
private boolean             renameTableAllow            = true;
public boolean isRenameTableAllow() {
return renameTableAllow;
public void setRenameTableAllow(boolean renameTableAllow) {
this.renameTableAllow = renameTableAllow;
} else if (x instanceof MySqlRenameTableStatement) {
allow = config.isRenameTableAllow();
denyMessage = "rename table not allow";
errorCode = ErrorCode.RENAME_TABLE_NOT_ALLOW;
public final static int RENAME_TABLE_NOT_ALLOW        = 1105;
public class MysqlWallTest_rename_table extends TestCase {
public void test_true() throws Exception {
WallConfig config = new WallConfig();
config.setRenameTableAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql("RENAME TABLE t1 TO t2", config));
public void test_false() throws Exception {
WallConfig config = new WallConfig();
config.setRenameTableAllow(false);
Assert.assertFalse(WallUtils.isValidateMySql("RENAME TABLE t1 TO t2", config));
} else if (lexer.token() == Token.COMMENT) {
lexer.nextToken();
if(lexer.token() == Token.EQ) {
accept(Token.EQ);
stmt.getItems().add(new MySqlAlterTableOption("COMMENT", ''' + lexer.stringVal() + '''));
lexer.nextToken();
public void test_alter_5() throws Exception {
String sql = "ALTER TABLE t1 COMMENT '';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE t1ntCOMMENT = ''", output);
if (context.getCommentCount() > 0) {
if (!WallVisitorUtils.queryBlockFromIsNull(visitor, x.getLeft())
&& WallVisitorUtils.queryBlockFromIsNull(visitor, x.getRight())) {
return "syntax error";
return "syntax error: " + exception.getMessage();
Assert.assertTrue(provider.checkValid("SELECT 1 FROM dual WHERE 1 = '1'''''''''''''UNION SELECT '2';"));
Assert.assertFalse(provider.checkValid("SELECT 1 FROM t WHERE 1 = '1'''''''''''''UNION SELECT '2';"));
Assert.assertTrue(provider.checkValid(
Assert.assertTrue(provider.checkValid(
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setSchemaCheck(true);
String sql = "SELECT 1, 2, 3" + 
" UNION ALL SELECT  a  from tt " + 
" UNION ALL SELECT 2 FROM dual ";
Assert.assertFalse(provider.checkValid(sql));
sql = "SELECT a from t UNION ALL SELECT 2 FROM dual ";
Assert.assertFalse(provider.checkValid(sql));
public final static int RevisionVersion = 4;
for (WebSessionStat sessionStat : Collections.unmodifiableCollection(this.sessionStatMap.values())) {
return new BigDecimal(subString(mark, bufPos).toCharArray());
if (!isAllowComment() && (isEOF() || !isSafeComment(stringVal))) {
if (!isAllowComment() && (isEOF() || !isSafeComment(stringVal))) {
if (!isAllowComment() && (isEOF() || !isSafeComment(stringVal))) {
private boolean isSafeComment(String comment) {
if (comment == null) {
return true;
comment = comment.toLowerCase();
if (comment.indexOf("select") != -1 
|| comment.indexOf("delete") != -1 
|| comment.indexOf("insert") != -1 
|| comment.indexOf("update") != -1 
|| comment.indexOf("into") != -1 
|| comment.indexOf("where") != -1 
|| comment.indexOf("or") != -1 
|| comment.indexOf("and") != -1 
|| comment.indexOf("union") != -1 
|| comment.indexOf(''') != -1 
|| comment.indexOf('=') != -1 
|| comment.indexOf('>') != -1 
|| comment.indexOf('<') != -1 
|| comment.indexOf('&') != -1 
|| comment.indexOf('|') != -1 
|| comment.indexOf('^') != -1 
return false;
return true;
public void test_false() throws Exception {
WallProvider provider = new MySqlWallProvider();
provider.getConfig().setCommentAllow(false);
Assert.assertTrue(provider.checkValid(" this is comment  SELECT id FROM t "));
Assert.assertTrue(provider.checkValid("-- this is comment n SELECT * FROM t"));
Assert.assertTrue(provider.checkValid("#this is comment n SELECT * FROM t"));
Assert.assertFalse(provider.checkValid("!40101fff select * from t"));
Assert.assertTrue(provider.checkValid("SELECT * FROM t where a=1 #this is comment n and b=1"));
Assert.assertTrue(provider.checkValid("SELECT * FROM t where a=1 -- this is comment n and c=1"));
Assert.assertTrue(provider.checkValid("SELECT * FROM t where a=1  this is comment  and d=1"));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1 #and c=1 n and e=1"));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1 -- AND c=1 n and f=1"));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1  and c=1  and g=1"));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1 #and c=1 "));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1 -- and c=1"));
Assert.assertFalse(provider.checkValid("SELECT * FROM t where a=1  and c=1 "));
private String sql = "select f1 from t  xx ";
violations.add(new IllegalSQLObjectViolation(ErrorCode.COMMENT_STATEMENT_NOT_ALLOW, "comment not allow", sql));
if(isFirst(part)) {
Object evalValue = part.getAttribute(EVAL_VALUE);
if(evalValue != null && evalValue instanceof Boolean && (Boolean)evalValue) {
return true;
denyMessage = "commit not allow";
denyMessage = "rollback not allow";
Assert.assertTrue(WallUtils.isValidateMySql("select c1 from t where 1=1 or id =1"));
Assert.assertFalse(WallUtils.isValidateMySql("select c1 from t where id =1 or 1=1"));
if (itemValue == null) {
return null;
if (Boolean.TRUE == itemValue || !SQLEvalVisitorUtils.eq(itemValue, 0)) {
} else if (lexer.token() == Token.LITERAL_NCHARS) {
expr = new SQLNCharExpr(lexer.stringVal());
if (lexer.token() != Token.LEFT && lexer.token() != Token.RIGHT && lexer.token() != Token.FULL
&& !identifierEquals("STRAIGHT_JOIN") && !identifierEquals("CROSS")) {
public class MySqlSelectTest_17 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM t1 STRAIGHT_JOIN t2 ON t2.a=t1.a;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
public void test_1() throws Exception {
String sql = "SELECT * FROM t1 CROSS JOIN t2";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statement = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statement.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
DateFormat format = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss:SSS");
public final static int RevisionVersion = 5;
if (x.getCollate() != null) {
print(" COLLATE ");
print(x.getCollate());
if (lexer.token() == Token.IDENTIFIER) {
if (lexer.stringVal().equalsIgnoreCase("COLLATE")) {
lexer.nextToken();
if (lexer.token() != Token.IDENTIFIER) {
throw new ParserException();
charType.setCollate(lexer.stringVal());
lexer.nextToken();
public void test_1() throws Exception {
String sql = "CREATE TABLE `ins_ebay_auth` ("
+ " `auth_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',"
+ " `usr_id` int(10) NOT NULL COMMENT '',"
+ " `status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.',"
+ " `ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay',"
+ " `ebay_name` varchar(50) COLLATE utf8_bin NOT NULL COMMENT 'eBay',"
+ " `create_time` datetime NOT NULL COMMENT '', "
+ " `invalid_time` datetime NOT NULL COMMENT '',"
+ " PRIMARY KEY (`auth_id`)"
+ " ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='INS_EBAY_AUTH';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
public boolean visit(SQLVariantRefExpr x) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x) || x.getName().equalsIgnoreCase("?")) {
return super.visit(x);
return ParameterizedOutputVisitorUtils.visit(this, x);
public static boolean visit(ParameterizedVisitor v, SQLVariantRefExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
print("(");
print(")");
private boolean                          logDiffrentThread       = true;
if (logDiffrentThread && pooledConnection.getOwnerThread() != Thread.currentThread()) {
public boolean isLogDiffrentThread() {
return logDiffrentThread;
public void setLogDiffrentThread(boolean logDiffrentThread) {
this.logDiffrentThread = logDiffrentThread;
public boolean visit(MySqlCharExpr x) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
return super.visit(x);
return ParameterizedOutputVisitorUtils.visit(this, x);
public class MySqlParameterizedOutputVisitorTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT appsheetserialno FROM app_trans WHERE nodeid = _gbk '619' "
+ " AND alino = _gbk '2013110900031031001700thfund00163619'"
+ " AND apserialno = _gbk '201405120002300002170013205458'";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
public boolean visit(SQLHexExpr x) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
return super.visit(x);
return ParameterizedOutputVisitorUtils.visit(this, x);
for (int i = 0; i < statementList.size(); i++) {
if (i > 0) {
out.append(";n");
SQLStatement stmt = statementList.get(i);
stmt.accept(visitor);
public static boolean visit(ParameterizedVisitor v, SQLHexExpr x) {
v.print('?');
v.incrementReplaceCunt();
return false;
if((left instanceof SQLIntegerExpr) && (right instanceof SQLIntegerExpr) ) {
if (((SQLIntegerExpr) left).getNumber().intValue() < 100) {
left.putAttribute(ATTR_PARAMS_SKIP, true);
if (((SQLIntegerExpr) right).getNumber().intValue() < 100) {
right.putAttribute(ATTR_PARAMS_SKIP, true);
left.putAttribute(ATTR_PARAMS_SKIP, true);
right.putAttribute(ATTR_PARAMS_SKIP, true);
System.out.println("-----------------------");
sql = "SELECT p.AppId, p.PlayerId, p.Nickname, p.CreateTime FROM acc_playeruser AS pu INNER JOIN acc_player AS p ON (pu.AppId = p.AppId AND pu.PlayerId = p.PlayerId) WHERE pu.UserId=x'881A58F6204D4E048F66E41596A66A57';";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
System.out.println("-----------------------");
sql = "SET @now := NOW();   INSERT characters (uid, name, race, career, sex, creation)   VALUES    (4068548, '', 58, 0, 0, @now);      SET @id := LAST_INSERT_ID();     INSERT characters_data (character_id, data, creation)   VALUES (@id, '000000004068548000:0000000000000000000000000000000000000000<000d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d000__000000000000000000000000000000000000000000000000000000000', @now);      SELECT @id; ";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
System.out.println("-----------------------");
sql = "INSERT INTO qrtz_JOB_DETAILS (SCHED_NAME, JOB_NAME, JOB_GROUP, DESCRIPTION, JOB_CLASS_NAME, IS_DURABLE, IS_NONCONCURRENT, IS_UPDATE_DATA, REQUESTS_RECOVERY, JOB_DATA)  VALUES('DefaultQuartzScheduler', 'taobao.item.recommend.delete_368815794_2_35391685928', 'tasks', null, 'cn.agooo.job.TasksJob', 0, 0, 0, 0, x'ACED0005737200156F72672E71756172747A2E4A6F62446174614D61709FB083E8BFA9B0CB020000787200266F72672E71756172747A2E7574696C732E537472696E674B65794469727479466C61674D61708208E8C3FBC55D280200015A0013616C6C6F77735472616E7369656E74446174617872001D6F72672E71756172747A2E7574696C732E4469727479466C61674D617013E62EAD28760ACE0200025A000564697274794C00036D617074000F4C6A6176612F7574696C2F4D61703B787001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000C770800000010000000017400077461736B7349647372000E6A6176612E6C616E672E4C6F6E673B8BE490CC8F23DF0200014A000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000000002063227800')";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
System.out.println("-----------------------");
sql = "SELECT * FROM sync_contactsdata WHERE __id=x'2EEE5AE7CB0E4AF697D966AE8BF046B8'";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
System.out.println("-----------------------");
sql = "select TID,POSTFEE,RECEIVERADDRESS from tradegroup003 where (0 = 650954981082695 or tid=650954981082695) And SELLERNICK='______________' And BUYERNICK='yingge7' and CREATED > date_sub(now(), interval 48 hour) and STATUS = 'WAIT_BUYER_PAY' and func_isNotFollowgroup003(tradegroup003.tid,'______________') = 0";
System.out.println(ParameterizedOutputVisitorUtils.parameterize(sql, "mysql"));
} while (lexer.token() == Token.LITERAL_CHARS || lexer.token() == Token.LITERAL_ALIAS);
print(";");
print(";");
print(";");
public void test_format_1() throws Exception {
String sql = "select * from t where tname LIKE "%"''"%"";
String formattedSql = SQLUtils.formatMySql(sql);
Assert.assertEquals("SELECT *nFROM tnWHERE tname LIKE CONCAT('%', '', '%')", formattedSql);
public void test_format_2() throws Exception {
String sql = "beginn" + " if (a=10) thenn" + " null;n" + " elsen" + " null;n" + " end if;n" + "end;";
System.out.println(SQLUtils.formatOracle(sql));
if (getDefaultReadOnly() != null) {
value.setDefaultReadOnly(this.getDefaultReadOnly());
} else if ("COLLATE".equalsIgnoreCase(lexer.stringVal())) {
FilterManager.loadFilter(this.filters, item.trim());
if (val == null) {
x.putAttribute(EVAL_VALUE, EVAL_VALUE_NULL);
return false;
protected SQLOrderBy          withinGroup;
public SQLOrderBy getWithinGroup() {
return withinGroup;
public void setWithinGroup(SQLOrderBy withinGroup) {
if (withinGroup != null) {
withinGroup.setParent(this);
this.withinGroup = withinGroup;
protected NullsOrderType             nullsOrderType;
public NullsOrderType getNullsOrderType() {
return this.nullsOrderType;
public void setNullsOrderType(NullsOrderType nullsOrderType) {
this.nullsOrderType = nullsOrderType;
public static enum NullsOrderType {
NullsFirst, NullsLast;
public String toFormalString() {
if (NullsFirst.equals(this)) {
return "NULLS FIRST";
if (NullsLast.equals(this)) {
return "NULLS LAST";
throw new IllegalArgumentException();
this.exprParser.exprList(values.getItems(), values);
this.exprParser.exprList(values.getItems(), values);
exprList(matchAgainstExpr.getColumns(), matchAgainstExpr);
this.exprParser.exprList(stmt.getColumns(), stmt);
exprParser.exprList(stmt.getParameters(), stmt);
this.exprParser.exprList(insertStatement.getColumns(), insertStatement);
exprParser.exprList(insertStatement.getDuplicateKeyUpdate(), insertStatement);
this.exprParser.exprList(list.getItems(), list);
exprList(aggregateExpr.getArguments(), aggregateExpr);
exprList(over.getPartitionBy(), over);
exprList(over.getPartitionBy(), over);
exprList(primaryKey.getColumns(), primaryKey);
this.exprParser.exprList(forUpdate.getOf(), forUpdate);
exprParser.exprList(cycleClause.getAliases(), cycleClause);
this.exprParser.exprList(cellAssignment.getConditions(), cellAssignment);
exprParser.exprList(queryPartitionClause.getExprList(), queryPartitionClause);
exprParser.exprList(queryPartitionClause.getExprList(), queryPartitionClause);
exprParser.exprList(groupingSet.getParameters(), groupingSet);
exprParser.exprList(groupingSet.getParameters(), groupingSet);
this.exprParser.exprList(sample.getPercent(), sample);
this.exprParser.exprList(join.getUsing(), join);
this.exprParser.exprList(unPivot.getItems(), unPivot);
this.exprParser.exprList(item.getAt(), item);
exprParser.exprList(insertClause.getColumns(), insertClause);
exprParser.exprList(insertClause.getValues(), insertClause);
this.exprParser.exprList(stmt.getColumns(), stmt);
this.exprParser.exprList(valuesCaluse.getValues(), valuesCaluse);
this.exprParser.exprList(insertStatement.getColumns(), insertStatement);
@Deprecated
exprList(over.getPartitionBy(), over);
exprList(over.getPartitionBy(), over);
exprList(pk.getColumns(), pk);
exprList(unique.getColumns(), unique);
this.exprParser.exprList(join.getUsing(), join);
this.exprParser.exprList(insertStatement.getColumns(), insertStatement);
this.exprParser.exprList(values.getValues(), values);
exprParser.exprList(stmt.getParameters(), stmt);
this.exprParser.exprList(list.getItems(), list);
this.exprParser.exprList(createView.getColumns(), createView);
} else if (expr instanceof SQLBooleanExpr) {
row[i] = ((SQLBooleanExpr) expr).getValue();
if (defaultReadOnly != null) {
value.setDefaultReadOnly(defaultReadOnly);
SQLAggregateExpr countExpr = new SQLAggregateExpr("COUNT");
protected boolean             ignoreNulls      = false;
public boolean isIgnoreNulls() {
return this.ignoreNulls;
public void setIgnoreNulls(boolean ignoreNulls) {
this.ignoreNulls = ignoreNulls;
public class MySqlBooleanExpr extends SQLBooleanExpr implements MySqlExpr, SQLLiteralExpr {
public boolean visit(SQLBooleanExpr x) {
x.getAttributes().put(EVAL_VALUE, x.getValue());
return false;
"LISTAGG",
protected SQLAggregateExpr parseAggregateExpr(String methodName) {
SQLAggregateExpr aggregateExpr;
aggregateExpr = new SQLAggregateExpr(methodName, SQLAggregateExpr.Option.UNIQUE);
aggregateExpr = new SQLAggregateExpr(methodName, SQLAggregateExpr.Option.ALL);
aggregateExpr = new SQLAggregateExpr(methodName, SQLAggregateExpr.Option.DISTINCT);
aggregateExpr = new SQLAggregateExpr(methodName);
if (identifierEquals("WITHIN")) {
lexer.nextToken();
accept(Token.GROUP);
accept(Token.LPAREN);
SQLOrderBy withinGroup = this.parseOrderBy();
aggregateExpr.setWithinGroup(withinGroup);
accept(Token.RPAREN);
item.setExpr((SQLAggregateExpr) this.exprParser.expr());
print("OVER (");
print(")");
map.put("TRUE", Token.TRUE);
map.put("FALSE", Token.FALSE);
lexer.nextToken();
sqlExpr = new SQLBooleanExpr(true);
lexer.nextToken();
sqlExpr = new SQLBooleanExpr(false);
if (param instanceof SQLBooleanExpr) {
Object value = ((SQLBooleanExpr) param).getValue();
if (x.getWithinGroup() != null) {
print(" WITHIN GROUP (");
x.getWithinGroup().accept(this);
print(")");
public boolean visit(SQLBooleanExpr x) {
print(x.getValue() ? "true" : "false");
return false;
public void endVisit(SQLBooleanExpr x) {
void endVisit(SQLBooleanExpr x);
boolean visit(SQLBooleanExpr x);
public void endVisit(SQLBooleanExpr x) {
public boolean visit(SQLBooleanExpr x) {
return true;
public boolean visit(SQLBooleanExpr x) {
x.getAttributes().put(EVAL_VALUE, x.getValue());
return false;
if (val == EVAL_VALUE_NULL) {
return null;
accept(x.getWithinGroup());
accept(x.getOver());
if (x instanceof SQLBooleanExpr) {
return ((SQLBooleanExpr) x).getValue();
SQLBooleanExpr exprA, exprB, exprC;
exprA = (SQLBooleanExpr) parser.expr();
exprB = (SQLBooleanExpr) parser.expr();
exprC = (SQLBooleanExpr) parser.expr();
Assert.assertEquals(new SQLBooleanExpr(), new SQLBooleanExpr());
Assert.assertEquals(new SQLBooleanExpr().hashCode(), new SQLBooleanExpr().hashCode());
new SQLBooleanExpr().accept(adapter);
public final static int RevisionVersion = 6;
private String sql        = "SELECT ID, NAME " + 
"FROM orders o inner join users u ON o.userid = u.id " + 
"WHERE FID = ? OR FID = ?";
private String expect_sql = "SELECT ID, NAME, u.tenant, o.tenant" + 
"nFROM orders o" + 
"ntINNER JOIN users u ON o.userid = u.id" + 
"nWHERE FID = ?" + 
"ntOR FID = ?";
WallConfig config = new WallConfig();
WallConfig config_callback = new WallConfig();
config.setTenantTablePattern("*");
config.setTenantColumn("tenant");
config_callback.setTenantCallBack(new TenantTestCallBack());
WallConfig config = new WallConfig();
WallConfig config_callback = new WallConfig();
config.setTenantTablePattern("*");
config.setTenantColumn("tenant");
config_callback.setTenantCallBack(new TenantTestCallBack());
@Override
public boolean matches(String pattern, String source) {
if (pattern == null || source == null) {
return false;
pattern = pattern.trim();
source = source.trim();
if (pattern.endsWith("*")) {
int length = pattern.length() - 1;
if (source.length() >= length) {
if (pattern.substring(0, length).equals(
source.substring(0, length))) {
return true;
} else if (pattern.startsWith("*")) {
int length = pattern.length() - 1;
if (source.length() >= length
&& source.endsWith(pattern.substring(1))) {
return true;
} else if (pattern.contains("*")) {
int start = pattern.indexOf("*");
int end = pattern.lastIndexOf("*");
if (source.startsWith(pattern.substring(0, start))
&& source.endsWith(pattern.substring(end + 1))) {
return true;
if (pattern.equals(source)) {
return true;
return false;
return new BigDecimal(val);
} catch (NumberFormatException e) {
if(a == EVAL_VALUE_NULL || b == EVAL_VALUE_NULL) {
return null;
if (a instanceof String) {
a = castToNumber((String) a);
if (b instanceof String) {
b = castToNumber((String) b);
if (a == EVAL_VALUE_NULL || b == EVAL_VALUE_NULL) {
return false;
public static final String LOG4JDBC          = "log4jdbc";
public static final String LOG4JDBC_DRIVER   = "net.sf.log4jdbc.DriverSpy";
} else if (rawUrl.startsWith("jdbc:log4jdbc:")) {
return LOG4JDBC_DRIVER;
} else if (rawUrl.startsWith("jdbc:log4jdbc:")) {
return LOG4JDBC;
if(a == EVAL_VALUE_NULL || b == EVAL_VALUE_NULL) {
return null;
if (a instanceof String) {
a = castToNumber((String) a);
if (b instanceof String) {
b = castToNumber((String) b);
Long longA = castToLong(a);
Long longB = castToLong(b);
if (longB == 0) {
if (longA > 0) {
return Double.POSITIVE_INFINITY;
} else if (longA < 0) {
return Double.NEGATIVE_INFINITY;
return Double.NaN;
return longA / longB;
if (index <= 0) {
if (index <= 0) {
public class SQLUnionQueryTableSource extends SQLTableSourceImpl {
private SQLUnionQuery union;
public SQLUnionQueryTableSource(){
public SQLUnionQueryTableSource(String alias){
super(alias);
public SQLUnionQueryTableSource(SQLUnionQuery union, String alias){
super(alias);
this.setUnion(union);
public SQLUnionQueryTableSource(SQLUnionQuery union){
this.setUnion(union);
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, union);
visitor.endVisit(this);
public void output(StringBuffer buf) {
buf.append("(");
this.union.output(buf);
buf.append(")");
public SQLUnionQuery getUnion() {
return union;
public void setUnion(SQLUnionQuery union) {
if (union != null) {
union.setParent(this);
this.union = union;
SQLSelectQuery query = queryRest(select.getQuery());
if (query instanceof SQLUnionQuery) {
tableSource = new SQLUnionQueryTableSource((SQLUnionQuery) query);
tableSource = new SQLSubqueryTableSource(select);
public boolean visit(SQLUnionQueryTableSource x) {
print("(");
incrementIndent();
x.getUnion().accept(this);
println();
decrementIndent();
print(")");
if (x.getAlias() != null) {
print(' ');
print(x.getAlias());
return false;
void endVisit(SQLUnionQueryTableSource x);
boolean visit(SQLUnionQueryTableSource x);
public void endVisit(SQLUnionQueryTableSource x) {
public boolean visit(SQLUnionQueryTableSource x) {
return true;
public void test_select_7() throws Exception {
String sql = "select * from ((select * from test1) UNION (select * from test2) UNION (select * from test3)) where t1='';";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
output(stmtList);
if (lexer.token() == (Token.AS)) {
lexer.nextToken();
public void test_2() throws Exception {
String sql = "create table t2 as select * from t1";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
public final static int RevisionVersion = 7;
Integer inta = castToInteger(a);
Integer intb = castToInteger(b);
if (inta == null || intb == null) {
return false;
return inta.equals(intb);
if(lexer.token() != Token.COMMA && lexer.token() != Token.RPAREN) {
expr = this.exprParser.exprRest(expr);
public class MySqlInsertTest_9 extends MysqlTest {
public void test_0() throws Exception {
String sql = "insert into sequence values('seq_wlb_order_log',268234128+10000000,now());";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLInsertStatement insertStmt = (SQLInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getValues().getValues().size());
Assert.assertEquals(0, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals("INSERT INTO sequence"
+ "nVALUES ('seq_wlb_order_log', 268234128 + 10000000, now())", SQLUtils.toMySqlString(insertStmt));
public DruidPooledConnection tryGetConnection() throws SQLException {
if (poolingCount == 0) {
return null;
return getConnection();
public void fillConnection() throws SQLException {
if (closed) {
throw new DataSourceClosedException("dataSource already closed at " + new Date(closeTimeMillis));
if (!enable) {
throw new DataSourceDisableException();
if (this.poolingCount + this.activeCount >= this.maxActive) {
int fillConnetionCount = 0;
for (; this.poolingCount + this.activeCount < this.maxActive; fillConnetionCount++) {
Connection conn = createPhysicalConnection();
DruidConnectionHolder holder = new DruidConnectionHolder(this, conn);
connections[poolingCount++] = holder;
if (poolingCount > poolingPeak) {
poolingPeak = poolingCount;
poolingPeakTime = System.currentTimeMillis();
} catch (SQLException ex) {
LOG.error("fill connection error", ex);
if (LOG.isInfoEnabled()) {
LOG.info("fill " + fillConnetionCount + " connections");
public DruidPooledConnection tryGetConnection() throws SQLException {
if (poolingCount == 0) {
return null;
return getConnection();
@Override
public int fill() throws SQLException {
return this.fill(this.maxActive);
@Override
public int fill(int toCount) throws SQLException {
if (closed) {
throw new DataSourceClosedException("dataSource already closed at " + new Date(closeTimeMillis));
if (toCount < 0) {
throw new IllegalArgumentException("toCount can't not be less than zero");
if (toCount > this.maxActive) {
toCount = this.maxActive;
int fillCount = 0;
for (;;) {
lock.lockInterruptibly();
} catch (InterruptedException e) {
connectErrorCount.incrementAndGet();
throw new SQLException("interrupt", e);
boolean fillable = this.isFillable(toCount);
lock.unlock();
if (!fillable) {
DruidConnectionHolder holder;
Connection conn = createPhysicalConnection();
holder = new DruidConnectionHolder(this, conn);
} catch (SQLException e) {
LOG.error("fill connection error", e);
connectErrorCount.incrementAndGet();
lock.lockInterruptibly();
} catch (InterruptedException e) {
connectErrorCount.incrementAndGet();
throw new SQLException("interrupt", e);
if (!this.isFillable(toCount)) {
JdbcUtils.close(holder.getConnection());
this.putLast(holder, System.currentTimeMillis());
fillCount++;
} finally {
lock.unlock();
if (LOG.isInfoEnabled()) {
LOG.info("fill " + fillCount + " connections");
return fillCount;
private boolean isFillable(int toCount) {
int currentCount = this.poolingCount + this.activeCount;
if (currentCount >= toCount || currentCount >= this.maxActive) {
return false;
return true;
int fill() throws SQLException;
int fill(int toCount) throws SQLException;
public class DruidDataSourceTest_fill extends TestCase {
private DruidDataSource dataSource;
private int             maxActive = 10;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxActive(maxActive);
dataSource.setTestOnBorrow(false);
protected void tearDown() throws Exception {
dataSource.close();
public void test_fill_0() throws Exception {
int fillCount = dataSource.fill(3);
Assert.assertEquals(3, fillCount);
public void test_fill_1() throws Exception {
int fillCount = dataSource.fill(1000);
Assert.assertEquals(maxActive, fillCount);
public void test_fill_2() throws Exception {
int fillCount = dataSource.fill(maxActive);
Assert.assertEquals(maxActive, fillCount);
public void test_fill_3() throws Exception {
int fillCount = dataSource.fill();
Assert.assertEquals(maxActive, fillCount);
public void test_fill_5() throws Exception {
Exception error = null;
dataSource.fill(-1);
} catch (IllegalArgumentException e) {
error = e;
Assert.assertNotNull(error);
public class DruidDataSourceTest_fill2 extends TestCase {
private DruidDataSource dataSource;
private int             maxActive = 100;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxActive(maxActive);
dataSource.setTestOnBorrow(false);
protected void tearDown() throws Exception {
dataSource.close();
public void test_fill() throws Exception {
final AtomicLong errorCount = new AtomicLong();
final int THREAD_COUNT = 100;
final CountDownLatch startLatch = new CountDownLatch(THREAD_COUNT);
final CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);
Thread[] threads = new Thread[THREAD_COUNT];
for (int i = 0; i < THREAD_COUNT; ++i) {
threads[i] = new Thread("thread-" + i) {
public void run() {
startLatch.countDown();
Connection conn = dataSource.getConnection();
Thread.sleep(2);
conn.close();
} catch (Exception e) {
errorCount.incrementAndGet();
} finally {
endLatch.countDown();
threads[i].start();
startLatch.await(1000, TimeUnit.MILLISECONDS);
final CountDownLatch fillLatch = new CountDownLatch(THREAD_COUNT);
final AtomicLong fillErrorCount = new AtomicLong();
final AtomicLong fillCount = new AtomicLong();
Thread fillThread = new Thread() {
public void run() {
int count = dataSource.fill();
fillCount.getAndSet(count);
} catch (Exception e) {
fillErrorCount.incrementAndGet();
} finally {
fillLatch.countDown();
fillThread.start();
fillLatch.await(1000, TimeUnit.MILLISECONDS);
Assert.assertEquals(0, fillErrorCount.get());
endLatch.await(1000, TimeUnit.MILLISECONDS);
Assert.assertEquals(true, fillCount.get() > 0);
public class DruidDataSourceTest_tryGet extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setMaxActive(1);
dataSource.setInitialSize(1);
dataSource.setTestOnBorrow(false);
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_0() throws Exception {
DruidPooledConnection conn1 = this.dataSource.tryGetConnection();
Assert.assertNotNull(conn1);
DruidPooledConnection conn2 = this.dataSource.tryGetConnection();
Assert.assertNull(conn2);
conn1.close();
void destroy();
public void destroy() {
private DestroyConnectionThread          destroyConnectionThread;
private boolean                          useGlobalDataSourceStat = false;
private boolean                          logDifferentThread      = true;
Boolean value = getBoolean(properties, "druid.useGlobalDataSourceStat");
this.setUseGlobalDataSourceStat(value);
public boolean isUseGlobalDataSourceStat() {
return useGlobalDataSourceStat;
public void setUseGlobalDataSourceStat(boolean useGlobalDataSourceStat) {
this.useGlobalDataSourceStat = useGlobalDataSourceStat;
if (timeBetweenLogStatsMillis > 0 && useGlobalDataSourceStat) {
throw new IllegalArgumentException("timeBetweenLogStatsMillis not support useGlobalDataSourceStat=true");
if (isUseGlobalDataSourceStat()) {
String threadName = "Druid-ConnectionPool-Destroy-" + System.identityHashCode(this);
destroyConnectionThread = new DestroyConnectionThread(threadName);
destroyConnectionThread.start();
if (logDifferentThread && pooledConnection.getOwnerThread() != Thread.currentThread()) {
if (destroyConnectionThread != null) {
destroyConnectionThread.interrupt();
filter.destroy();
public boolean isLogDifferentThread() {
return logDifferentThread;
public void setLogDifferentThread(boolean logDifferentThread) {
this.logDifferentThread = logDifferentThread;
functions.put("lcase", Lcase.instance);
public static void destroy() {
public class PropertyTest_useGlobalDataSourceStat extends TestCase {
System.setProperty("druid.useGlobalDataSourceStat", "true");
Assert.assertTrue(dataSource.isUseGlobalDataSourceStat());
System.setProperty("druid.useGlobalDataSourceStat", "false");
Assert.assertFalse(dataSource.isUseGlobalDataSourceStat());
System.clearProperty("druid.useGlobalDataSourceStat");
dataSourceA.setUseGlobalDataSourceStat(true);
dataSourceB.setUseGlobalDataSourceStat(true);
dataSourceA.setUseGlobalDataSourceStat(true);
dataSourceB.setUseGlobalDataSourceStat(true);
Boolean value = getBoolean(properties, "druid.useGloalDataSourceStat"); 
if (value != null) {
this.setUseGlobalDataSourceStat(value);
} else if (rawUrl.startsWith("jdbc:sqlserver:")) {
return SQL_SERVER;
protected int                                      notFullTimeoutRetryCount                  = 0;
public int getNotFullTimeoutRetryCount() {
return notFullTimeoutRetryCount;
public void setNotFullTimeoutRetryCount(int notFullTimeoutRetryCount) {
this.notFullTimeoutRetryCount = notFullTimeoutRetryCount;
String property = properties.getProperty("druid.notFullTimeoutRetryCount");
if (property != null && property.length() > 0) {
int value = Integer.parseInt(property);
this.setNotFullTimeoutRetryCount(value);
} catch (NumberFormatException e) {
LOG.error("illegal property 'druid.notFullTimeoutRetryCount'", e);
int notFullTimeoutRetryCnt = 0;
DruidPooledConnection poolableConnection;
poolableConnection = getConnectionInternal(maxWaitMillis);
} catch (GetConnectionTimeoutException ex) {
if (notFullTimeoutRetryCnt <= this.notFullTimeoutRetryCount && !isFull()) {
notFullTimeoutRetryCnt++;
if (LOG.isWarnEnabled()) {
LOG.warn("not full timeout retry : " + notFullTimeoutRetryCnt);
continue;
throw ex;
public boolean isFull() {
lock.lock();
return this.poolingCount + this.activeCount >= this.maxActive;
} finally {
lock.unlock();
public class FullTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setTestOnBorrow(false);
dataSource.init();
protected void tearDown() throws Exception {
dataSource.close();
public void test_restart() throws Exception {
Assert.assertEquals(false, dataSource.isFull());
dataSource.fill();
Assert.assertEquals(true, dataSource.isFull());
Connection conn = dataSource.getConnection();
Assert.assertEquals(true, dataSource.isFull());
conn.close();
Assert.assertEquals(true, dataSource.isFull());
if (config.isStrictSyntaxCheck()) {
violations.add(new SyntaxErrorViolation(e, sql));
if (identifierEquals("USING")) {
lexer.nextToken();
key.setIndexType(lexer.stringVal());
lexer.nextToken();
}else if (x.getCollate() != null) {
protected void printError(Token token){
String arround;
if (lexer.mark >= 0 && (lexer.text.length() > lexer.mark + 30)) {
if (lexer.mark - 5 > 0) {
arround = lexer.text.substring(lexer.mark - 5, lexer.mark + 30);
arround = lexer.text.substring(lexer.mark, lexer.mark + 30);
} else if (lexer.mark >= 0) {
if (lexer.mark - 5 > 0) {
arround = lexer.text.substring(lexer.mark - 5);
arround = lexer.text.substring(lexer.mark);
arround = lexer.text;
throw new ParserException("syntax error, error in :'" + arround + "',expect " + token + ", actual "
+ lexer.token() + " " + lexer.stringVal());
printError(token);
printError(lexer.token());
public class MySqlAlterTableTest18 extends TestCase {
public void test_alter_charset() throws Exception {
String sql = "ALTER TABLE `test`.`tb1` ADD COLUMN `f2` VARCHAR(45) CHARACTER SET gbk NULL  FIRST ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE `test`.`tb1`ntADD COLUMN `f2` VARCHAR(45) CHARACTER SET gbk NULL FIRST", output);
public void test_alter_collate() throws Exception {
String sql = "ALTER TABLE `test`.`tb1` ADD COLUMN `f2` VARCHAR(45) COLLATE utf8_bin NULL  FIRST ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE `test`.`tb1`ntADD COLUMN `f2` VARCHAR(45) COLLATE utf8_bin NULL FIRST", output);
public void test_alter_charset_collate() throws Exception {
String sql = "ALTER TABLE `test`.`tb1` ADD COLUMN `f2` VARCHAR(45) CHARACTER SET utf8 COLLATE utf8_bin  NULL  FIRST ;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE `test`.`tb1`ntADD COLUMN `f2` VARCHAR(45) CHARACTER SET utf8 COLLATE utf8_bin NULL FIRST", output);
public class MySqlCreateTableTest53 extends MysqlTest {
public void test_primary_key_using_btree() throws Exception {
String sql = "CREATE TABLE `ins_ebay_auth` ("
+ "`auth_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',"
+ "`usr_id` int(10) NOT NULL COMMENT '',"
+ "`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.',"
+ "`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay',"
+ "`ebay_name` varchar(50)  NOT NULL COMMENT 'eBay',"
+ "`create_time` datetime NOT NULL COMMENT '',"
+ "`invalid_time` datetime NOT NULL COMMENT ''," + "PRIMARY KEY USING BTREE (`auth_id`)"
+ ") ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='INS_EBAY_AUTH';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ins_ebay_auth")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE `ins_ebay_auth` ("
+"nt`auth_id` int(10) AUTO_INCREMENT NOT NULL COMMENT 'id', " 
+"nt`usr_id` int(10) NOT NULL COMMENT '', "
+"nt`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.', "
+"nt`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay', "
+"nt`ebay_name` varchar(50) NOT NULL COMMENT 'eBay', "
+"nt`create_time` datetime NOT NULL COMMENT '', "
+"nt`invalid_time` datetime NOT NULL COMMENT '', "
+"ntPRIMARY KEY USING BTREE (`auth_id`)"
+"n) ENGINE = InnoDB CHARSET = utf8 COLLATE utf8_bin COMMENT = 'INS_EBAY_AUTH'", output);
public void test_index_using_btree() throws Exception {
String sql = "CREATE TABLE `ins_ebay_auth` ("
+ "`auth_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',"
+ "`usr_id` int(10) NOT NULL COMMENT '',"
+ "`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.',"
+ "`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay',"
+ "`ebay_name` varchar(50)  NOT NULL COMMENT 'eBay',"
+ "`create_time` datetime NOT NULL COMMENT '',"
+ "`invalid_time` datetime NOT NULL COMMENT ''," + "PRIMARY KEY USING BTREE (`auth_id`), INDEX `ind_usr_id` USING BTREE (`usr_id`)"
+ ") ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='INS_EBAY_AUTH';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ins_ebay_auth")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE `ins_ebay_auth` ("
+"nt`auth_id` int(10) AUTO_INCREMENT NOT NULL COMMENT 'id', " 
+"nt`usr_id` int(10) NOT NULL COMMENT '', "
+"nt`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.', "
+"nt`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay', "
+"nt`ebay_name` varchar(50) NOT NULL COMMENT 'eBay', "
+"nt`create_time` datetime NOT NULL COMMENT '', "
+"nt`invalid_time` datetime NOT NULL COMMENT '', "
+"ntPRIMARY KEY USING BTREE (`auth_id`), "
+"ntINDEX `ind_usr_id` USING BTREE (`usr_id`)"
+"n) ENGINE = InnoDB CHARSET = utf8 COLLATE utf8_bin COMMENT = 'INS_EBAY_AUTH'", output);
public void test_key_using_btree() throws Exception {
String sql = "CREATE TABLE `ins_ebay_auth` ("
+ "`auth_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',"
+ "`usr_id` int(10) NOT NULL COMMENT '',"
+ "`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.',"
+ "`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay',"
+ "`ebay_name` varchar(50)  NOT NULL COMMENT 'eBay',"
+ "`create_time` datetime NOT NULL COMMENT '',"
+ "`invalid_time` datetime NOT NULL COMMENT ''," + "PRIMARY KEY USING BTREE (`auth_id`), KEY `ind_usr_id` USING BTREE (`usr_id`)"
+ ") ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='INS_EBAY_AUTH';";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("ins_ebay_auth")));
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE `ins_ebay_auth` ("
+"nt`auth_id` int(10) AUTO_INCREMENT NOT NULL COMMENT 'id', " 
+"nt`usr_id` int(10) NOT NULL COMMENT '', "
+"nt`status` char(1) COLLATE utf8_bin NOT NULL COMMENT ' 0.?1.', "
+"nt`ebay_token` varchar(255) COLLATE utf8_bin NOT NULL COMMENT 'eBay', "
+"nt`ebay_name` varchar(50) NOT NULL COMMENT 'eBay', "
+"nt`create_time` datetime NOT NULL COMMENT '', "
+"nt`invalid_time` datetime NOT NULL COMMENT '', "
+"ntPRIMARY KEY USING BTREE (`auth_id`), "
+"ntKEY `ind_usr_id` USING BTREE (`usr_id`)"
+"n) ENGINE = InnoDB CHARSET = utf8 COLLATE utf8_bin COMMENT = 'INS_EBAY_AUTH'", output);
} else if (lexer.token() == Token.USER) {
alias = lexer.stringVal();
lexer.nextToken();
Assert.assertTrue(provider.checkValid(
public class MySqlSelectTest_18 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT host.id as id, host.item_id as itemId, host.node_id as nodeId,   host.node_type as nodeType,   host.begin_time as beginTime,   host.end_time as endTime,   host.gmt_create as gmtCreate,   host.gmt_modify as gmtModify,   host.reason as reason,   host.creator_id as creatorId,   host.modifier_id as modifierId,   user.name as creator,   user.name as modifier,   user.nick_name as nickName    FROM notice_close_node host left join sys_user user on user.id = host.modifier_id";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(14, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
public class MySqlSelectTest_19 extends MysqlTest {
public void test_0() throws Exception {
String sql = "SELECT * FROM mj_list WHERE ( uid = 1 ) AND ( status = 1 ) ORDER BY view DESC LIMIT 10";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getConditions().size());
Assert.assertEquals(1, visitor.getOrderByColumns().size());
print("(");
+ "`invalid_time` datetime NOT NULL COMMENT ''," + "PRIMARY KEY USING BTREE (`auth_id`), INDEX `ind_usr_id` USING BTREE(`usr_id`)"
+"ntINDEX `ind_usr_id` USING BTREE(`usr_id`)"
Assert.assertEquals("syntax error, error in :'oods free_postage',expect IDENTIFIER, actual IDENTIFIER free_postage", error.getMessage());
Assert.assertEquals("syntax error, error in :'us = LIMIT ?, ?',expect QUES, actual QUES LIMIT", error.getMessage());
this.exprParser.parseHints(update.getHints());
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
print(' ');
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
print(' ');
print("INSERT ");
if (x.getHints().size() > 0) {
printAndAccept(x.getHints(), ", ");
print(' ');
print("INTO ");
x.getTableSource().accept(this);
if (x.getColumns().size() > 0) {
incrementIndent();
println();
print("(");
for (int i = 0, size = x.getColumns().size(); i < size; ++i) {
if (i != 0) {
if (i % 5 == 0) {
println();
print(", ");
x.getColumns().get(i).accept(this);
print(")");
decrementIndent();
if (x.getValues() != null) {
println();
print("VALUES");
println();
x.getValues().accept(this);
if (x.getQuery() != null) {
println();
x.getQuery().setParent(x);
x.getQuery().accept(this);
public void test_hint3() throws Exception {
String sql = "SELECT+index(aMTN_SMS_LOG_PK)* from MTN_SMS_LOG a";
String formattedSql = SQLUtils.formatOracle(sql);
Assert.assertEquals("SELECT +index(aMTN_SMS_LOG_PK) *" + "nFROM MTN_SMS_LOG a", formattedSql);
public void test_hint4() throws Exception {
String sql = "UPDATE+index(aMTN_SMS_LOG_PK)MTN_SMS_LOGaSETGMT_MODIFIED=sysdate WHEREid=1";
String formattedSql = SQLUtils.formatOracle(sql);
Assert.assertEquals("UPDATE +index(aMTN_SMS_LOG_PK) MTN_SMS_LOG a"
+ "nSET GMT_MODIFIED = SYSDATE"
+ "nWHERE id = 1", formattedSql);
public void test_hint5() throws Exception {
String sql = "SELECT +index(clk) use_nl(clk)  distinct log.id log_id from t";
String formattedSql = SQLUtils.formatOracle(sql);
Assert.assertEquals("SELECT +index(clk) use_nl(clk)  DISTINCT log.id AS log_id" + "nFROM t", formattedSql);
public void test_hint6() throws Exception {
String sql = "insert +APPEND into emp_new select a.no, sysdate, a.name, b.service_duration from emp a, work b where a.no=b.no";
String formattedSql = SQLUtils.formatOracle(sql);
Assert.assertEquals("INSERT +APPEND INTO emp_new" + "nSELECT a.no, SYSDATE, a.name, b.service_duration"
+ "nFROM emp a, work b" + "nWHERE a.no = b.no", formattedSql);
public void test_hint7() throws Exception {
String sql = "delete +PARALLEL(semp, 5)  from semp";
String formattedSql = SQLUtils.formatOracle(sql);
Assert.assertEquals("DELETE +PARALLEL(semp, 5)  FROM semp", formattedSql);
dataType.getAttributes().put("UNSIGNED", true);
if (identifierEquals("ZEROFILL")) {
lexer.nextToken();
dataType.getAttributes().put("ZEROFILL", true);
if (Boolean.TRUE == x.getAttribute("UNSIGNED")) {
print(" UNSIGNED");
if (Boolean.TRUE == x.getAttribute("ZEROFILL")) {
print(" ZEROFILL");
protected final Histogram                          transactionHistogram                      = new Histogram(1,
txn_1_10 = values[1];
private Match   referenceMatch;
private On      referenceOn;
private Option  referenceOption;
public Match getReferenceMatch() {
return referenceMatch;
public void setReferenceMatch(Match referenceMatch) {
this.referenceMatch = referenceMatch;
public On getReferenceOn() {
return referenceOn;
public void setReferenceOn(On referenceOn) {
this.referenceOn = referenceOn;
public Option getReferenceOption() {
return referenceOption;
public void setReferenceOption(Option referenceOption) {
this.referenceOption = referenceOption;
public static enum Option {
RESTRICT("RESTRICT"), CASCADE("CASCADE"), SET_NULL("SET NULL"), NO_ACTION("NO ACTION");
private String text;
Option(String text){
this.text = text;
public String getText() {
return text;
public static enum Match {
FULL, PARTIAL, SIMPLE;
public static enum On {
DELETE, UPDATE;
if (lexer.token() == Token.ERROR) {
if (identifierEquals("MATCH")) {
if (identifierEquals("FULL")) {
fk.setReferenceMatch(Match.FULL);
} else if (identifierEquals("PARTIAL")) {
fk.setReferenceMatch(Match.PARTIAL);
} else if (identifierEquals("SIMPLE")) {
fk.setReferenceMatch(Match.SIMPLE);
if (lexer.token() == Token.ON) {
lexer.nextToken();
if (lexer.token() == Token.DELETE) {
fk.setReferenceOn(On.DELETE);
} else if (lexer.token() == Token.UPDATE) {
fk.setReferenceOn(On.UPDATE);
throw new ParserException("syntax error, expect DELETE or UPDATE, actual " + lexer.token() + " "
+ lexer.stringVal());
lexer.nextToken();
if (lexer.token() == Token.RESTRICT) {
fk.setReferenceOption(Option.RESTRICT);
} else if (identifierEquals("CASCADE")) {
fk.setReferenceOption(Option.CASCADE);
} else if (lexer.token() == Token.SET) {
accept(Token.NULL);
fk.setReferenceOption(Option.SET_NULL);
} else if (identifierEquals("ON")) {
lexer.nextToken();
if (identifierEquals("ACTION")) {
fk.setReferenceOption(Option.NO_ACTION);
throw new ParserException("syntax error, expect ACTION, actual " + lexer.token() + " "
+ lexer.stringVal());
lexer.nextToken();
if(x.getReferenceMatch() != null) {
print(" MATCH ");
print(x.getReferenceMatch().name());
if(x.getReferenceOn()!= null) {
print(" ON ");
print(x.getReferenceOn().name());
print(" ");
if(x.getReferenceOption() != null) {
print(x.getReferenceOption().getText());
String sql = "CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL, day INT(2) UNSIGNED ZEROFILL);";
public void test_FOREIGN_KEY() throws Exception {
String sql = "CREATE TABLE `t_activity_node` ("
+ "n`id` bigint(20) NOT NULL,"
+ "n`sellerId` bigint(20) DEFAULT NULL,"
+ "n`canvas_id` bigint(20) NOT NULL COMMENT 'ID',"
+ "n`view_node_id` bigint(20) NOT NULL COMMENT 'id',"
+ "n`activity_type` int(11) NOT NULL COMMENT '',"
+ "n`node_type` int(11) NOT NULL COMMENT '',"
+ "n`node_title` varchar(200) NOT NULL COMMENT '',"
+ "n`status` int(11) NOT NULL DEFAULT '0' COMMENT '',"
+ "n`update_status` int(11) DEFAULT NULL COMMENT '',"
+ "n`execute_status` int(11) DEFAULT NULL COMMENT '',"
+ "n`start_time` datetime DEFAULT NULL COMMENT '',"
+ "n`end_time` datetime DEFAULT NULL COMMENT '',"
+ "n`activity_start_time` datetime DEFAULT NULL COMMENT '',"
+ "n`activity_end_time` datetime DEFAULT NULL COMMENT '',"
+ "n`report_start_time` datetime DEFAULT NULL COMMENT '',"
+ "n`report_end_time` datetime DEFAULT NULL COMMENT '',"
+ "n`cron_rule` varchar(100) DEFAULT NULL COMMENT '',"
+ "n`split_rule` varchar(1000) DEFAULT NULL COMMENT '',"
+ "n`search_json` varchar(5000) DEFAULT NULL COMMENT '',"
+ "n`filter_json` varchar(1000) DEFAULT NULL COMMENT '',"
+ "n`buyer_count` int(11) DEFAULT NULL COMMENT '',"
+ "n`gmt_modified` datetime NOT NULL COMMENT '',"
+ "n`gmt_create` datetime NOT NULL COMMENT '',"
+ "nPRIMARY KEY (`id`),"
+ "nKEY `canvas_id` (`canvas_id`),"
+ "nKEY `sid_ty_time` (`sellerId`,`node_type`,`start_time`),"
+ "nCONSTRAINT `t_activity_node_ibfk_1` FOREIGN KEY (`canvas_id`) REFERENCES `t_activity_canvas` (`id`) ON DELETE CASCADE"
+ "n) ENGINE=InnoDB DEFAULT CHARSET=utf8;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(24, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE `t_activity_node` ("
+ "nt`id` bigint(20) NOT NULL, "
+ "nt`sellerId` bigint(20) NULL, "
+ "nt`canvas_id` bigint(20) NOT NULL COMMENT 'ID', "
+ "nt`view_node_id` bigint(20) NOT NULL COMMENT 'id', "
+ "nt`activity_type` int(11) NOT NULL COMMENT '', "
+ "nt`node_type` int(11) NOT NULL COMMENT '', "
+ "nt`node_title` varchar(200) NOT NULL COMMENT '', "
+ "nt`status` int(11) DEFAULT '0' NOT NULL COMMENT '', "
+ "nt`update_status` int(11) NULL COMMENT '', "
+ "nt`execute_status` int(11) NULL COMMENT '', "
+ "nt`start_time` datetime NULL COMMENT '', "
+ "nt`end_time` datetime NULL COMMENT '', "
+ "nt`activity_start_time` datetime NULL COMMENT '', "
+ "nt`activity_end_time` datetime NULL COMMENT '', "
+ "nt`report_start_time` datetime NULL COMMENT '', "
+ "nt`report_end_time` datetime NULL COMMENT '', "
+ "nt`cron_rule` varchar(100) NULL COMMENT '', "
+ "nt`split_rule` varchar(1000) NULL COMMENT '', "
+ "nt`search_json` varchar(5000) NULL COMMENT '', "
+ "nt`filter_json` varchar(1000) NULL COMMENT '', "
+ "nt`buyer_count` int(11) NULL COMMENT '', "
+ "nt`gmt_modified` datetime NOT NULL COMMENT '', "
+ "nt`gmt_create` datetime NOT NULL COMMENT '', "
+ "ntPRIMARY KEY (`id`), "
+ "ntKEY `canvas_id` (`canvas_id`), "
+ "ntKEY `sid_ty_time` (`sellerId`, `node_type`, `start_time`), "
+ "ntCONSTRAINT `t_activity_node_ibfk_1` FOREIGN KEY (`canvas_id`) REFERENCES `t_activity_canvas` (`id`) ON DELETE CASCADE"
+ "n) ENGINE = InnoDB CHARSET = utf8", output);
Assert.assertEquals(6, dataSource.getTransactionHistogramRanges().length);
for(int i =0; i<statementList.size(); i++) {
out.append(";n");
statementList.get(i).accept(visitor);
public class MySqlHintStatement extends MySqlStatementImpl {
private List<SQLCommentHint> hints;
public void accept0(MySqlASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.hints);
visitor.endVisit(this);
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
if(lexer.token() == Token.HINT) {
statementList.add(this.parseHint());
return true;
public MySqlHintStatement parseHint() {
MySqlHintStatement stmt = new MySqlHintStatement();
stmt.setHints(this.exprParser.parseHints());
return stmt;
boolean visit(MySqlHintStatement x);
void endVisit(MySqlHintStatement x);
@Override
public boolean visit(MySqlHintStatement x) {
return true;
@Override
public void endVisit(MySqlHintStatement x) {
public boolean visit(MySqlHintStatement x) {
List<SQLCommentHint> hints = x.getHints();
for (SQLCommentHint hint : hints) {
hint.accept(this);
return false;
public void endVisit(MySqlHintStatement x) {
@Override
public boolean visit(MySqlHintStatement x) {
return true;
@Override
public void endVisit(MySqlHintStatement x) {
private boolean             hintAllow                   = true;
public boolean isHintAllow() {
return hintAllow;
public void setHintAllow(boolean hintAllow) {
this.hintAllow = hintAllow;
denyMessage = "use not allow";
} else if (x instanceof MySqlHintStatement) {
allow = config.isHintAllow();
denyMessage = "hint not allow";
errorCode = ErrorCode.HINT_NOT_ALLOW;
public final static int HINT_NOT_ALLOW                = 1400;
public class MySqlHintStatementTest extends TestCase {
public void test() {
String sql = "DROP TABLE IF EXISTS `item_similarity`;"
+ "n/*!40101 SET @saved_cs_client     = @@character_set_client */;"
+ "n/*!40101 SET character_set_client = utf8 */;" 
+ "nCREATE TABLE `item_similarity` ("
+ " `id` bigint(20) unsigned NOT NULL, "
+ " `sellerId` bigint(20) DEFAULT NULL,"
+ " PRIMARY KEY (`id`)" 
+ " ) ENGINE=InnoDB DEFAULT CHARSET=utf8;"
+ " n!40101 SET character_set_client = @saved_cs_client ;";
String rs = SQLUtils.formatMySql(sql);
System.out.println(rs);
public final static int RevisionVersion = 8;
map.put("ResultSetOpenningCount", stat.getResultSetStat().getOpeningCount());
map.put("ResultSetOpenningMax", stat.getResultSetStat().getOpeningMax());
private final long                          connectTimeMillis;
this.connectTimeMillis = System.currentTimeMillis();
this.lastActiveTimeMillis = connectTimeMillis;
return connectTimeMillis;
buf.append(Utils.toString(new Date(this.connectTimeMillis)));
stmtInfo.put("defaultRowPretch", stmtHolder.getDefaultRowPrefetch());
if (holder.getDefaultRowPrefetch() == -1) {
if (defaultRowPretch != holder.getDefaultRowPrefetch()) {
holder.setDefaultRowPrefetch(defaultRowPretch);
} else if (fetchRowPeak > holder.getDefaultRowPrefetch()) {
rowPrefetch = holder.getDefaultRowPrefetch();
public GetConnectionTimeoutException(String message, Throwable cause){
super(message, cause);
if (null == wrapper) {
return false;
if (iface == wrapper.getClass()) {
if (null == wrapper) {
return null;
if (iface == wrapper.getClass()) {
private int                        defaultRowPrefetch       = -1;
public int getDefaultRowPrefetch() {
return defaultRowPrefetch;
public void setDefaultRowPrefetch(int defaultRowPrefetch) {
this.defaultRowPrefetch = defaultRowPrefetch;
return iface != null && iface.isInstance(this);
public boolean isValidConnection(final Connection c, String validateQuery, int validationQueryTimeout) {
stmt.execute(validateQuery);
return e instanceof MockConnectionClosedException;
if ((errorCode == 0 && (errorText.contains("COMMUNICATIONS LINK FAILURE")) 
|| errorText.contains("COULD NOT CREATE CONNECTION")) 
|| errorText.contains("NO DATASOURCE") 
|| errorText.contains("NO ALIVE DATASOURCE")) {
public boolean isValidConnection(Connection conn, String validateQuery, int validationQueryTimeout) {
rs = stmt.executeQuery(validateQuery);
if ((error_text.contains("SOCKET")) 
|| (error_text.contains("")) 
|| (error_text.contains("CONNECTION HAS ALREADY BEEN CLOSED")) 
|| (error_text.contains("BROKEN PIPE")) 
|| (error_text.contains("")) 
public boolean isValidConnection(Connection conn, String validateQuery, int validationQueryTimeout) {
return status >= 0;
rs = stmt.executeQuery(validateQuery);
if ((errorText.contains("JZ0C0")) || 
(errorText.contains("JZ0C1")) 
XAConnection rawXAConnection = createPhysicalXAConnection(physicalConn);
private XAConnection createPhysicalXAConnection(Connection physicalConn) throws SQLException {
private TransactionInfo       transactionInfo;
if (transactionInfo != null) {
transactionInfo.setEndTimeMillis();
if (transactionInfo != null) {
transactionInfo.setEndTimeMillis();
if (transactionInfo != null) {
transactionInfo.setEndTimeMillis();
if (transactionInfo == null) {
transactionInfo = new TransactionInfo(transactionId);
this.putAttribute(StatFilter.ATTR_TRANSACTION, transactionInfo); 
transactionInfo = null;
return transactionInfo;
map.put("ResultSetOpenningCount", stat.getResultSetStat().getOpeningCount());
map.put("ResultSetOpenningMax", stat.getResultSetStat().getOpeningMax());
if (0 == (x.compareTo(BigDecimal.ZERO))) {
if (0 == (x.compareTo(BigDecimal.TEN))) {
result = prime * result + arguments.hashCode();
if (!arguments.equals(other.arguments)) return false;
String getSimpleName();
result = prime * result + items.hashCode();
return items.equals(other.items);
ASC, DESC
result = prime * result + partitionBy.hashCode();
return partitionBy.equals(other.partitionBy);
public String getSimpleName() {
public String getSimpleName() {
public class NotNullConstraint extends SQLConstraintImpl implements SQLColumnConstraint {
private SQLConstraint constraint;
public SQLAlterTableAddConstraint(SQLConstraint constraint){
public SQLConstraint getConstraint() {
public void setConstraint(SQLConstraint constraint) {
public class SQLAlterTableDropForeignKey extends SQLObjectImpl implements SQLAlterTableItem {
public class SQLCharacterDataType extends SQLDataTypeImpl {
public SQLCharacterDataType(String name){
public class SQLCheck extends SQLConstraintImpl implements SQLTableElement {
public class SQLColumnCheck extends SQLConstraintImpl implements SQLColumnConstraint {
public interface SQLColumnConstraint extends SQLConstraint {
protected final List<SQLColumnConstraint> constraints = new ArrayList<SQLColumnConstraint>(0);
public List<SQLColumnConstraint> getConstraints() {
return constraints;
this.acceptChild(visitor, constraints);
public class SQLColumnPrimaryKey extends SQLConstraintImpl implements SQLColumnConstraint {
public class SQLColumnReference extends SQLConstraintImpl implements SQLColumnConstraint {
public class SQLColumnUniqueKey extends SQLConstraintImpl implements SQLColumnConstraint {
public interface SQLConstraint extends SQLObject {
public abstract class SQLConstraintImpl extends SQLObjectImpl implements SQLConstraint {
public SQLConstraintImpl(){
public interface SQLForeignKeyConstraint extends SQLConstraint, SQLTableElement, SQLTableConstraint {
public class SQLForeignKeyImpl extends SQLConstraintImpl implements SQLForeignKeyConstraint {
public interface SQLTableConstraint extends SQLConstraint, SQLTableElement {
public class SQLUnique extends SQLConstraintImpl implements SQLUniqueConstraint, SQLTableElement {
public interface SQLUniqueConstraint extends SQLConstraint {
public class MySqlKey extends SQLUnique implements SQLUniqueConstraint, SQLTableConstraint {
private boolean hasConstraint;
public boolean isHasConstraint() {
return hasConstraint;
public void setHasConstraint(boolean hasConstraint) {
this.hasConstraint = hasConstraint;
public String getSimpleName() {
return getSimpleName();
SQLTableConstraint pk = parseConstraint();
protected SQLTableConstraint parseConstraint() {
return (SQLTableConstraint) pk;
return (SQLTableConstraint) uk;
fk.setHasConstraint(hasConstaint);
return (SQLTableConstraint) fk;
fk.setHasConstraint(true);
SQLAlterTableDropForeignKey item = new SQLAlterTableDropForeignKey();
for (SQLColumnConstraint item : x.getConstraints()) {
if (x instanceof SQLCharacterDataType) {
SQLCharacterDataType charType = (SQLCharacterDataType) x;
public boolean visit(SQLCharacterDataType x) {
if (x.isHasConstraint()) {
configFromProperty(System.getProperties());
public void configFromProperty(Properties properties) {
public String getSimpleName() {
private SQLConstraint constraint;
public SQLConstraint getConstraint() {
public void setConstraint(SQLConstraint constraint) {
public interface OracleConstraint extends OracleSQLObject, SQLConstraint, SQLTableElement {
SQLCharacterDataType charType = new SQLCharacterDataType(typeName);
charType.setCharType(SQLCharacterDataType.CHAR_TYPE_CHAR);
charType.setCharType(SQLCharacterDataType.CHAR_TYPE_BYTE);
public boolean visit(SQLCharacterDataType x) {
this.acceptChild(visitor, constraints);
public String getSimpleName() {
for (SQLColumnConstraint item : x.getConstraints()) {
SQLConstraint constraint = this.exprParser.parseConstaint();
protected SQLTableConstraint parseConstraint() {
SQLCharacterDataType charType = new SQLCharacterDataType(typeName);
protected SQLDataType parseCharTypeRest(SQLCharacterDataType charType) {
column.getConstraints().add(new NotNullConstraint());
column.getConstraints().add(new SQLColumnPrimaryKey());
column.getConstraints().add(new SQLColumnPrimaryKey());
column.getConstraints().add(pk);
column.getConstraints().add(uk);
column.getConstraints().add(ref);
column.getConstraints().add(notNull);
column.getConstraints().add(check);
column.getConstraints().add(check);
public SQLConstraint parseConstaint() {
SQLConstraint constraint;
SQLConstraint check = this.exprParser.parseConstaint();
public boolean visit(SQLCharacterDataType x) {
for (SQLColumnConstraint item : x.getConstraints()) {
public boolean visit(SQLAlterTableDropForeignKey x) {
boolean visit(SQLCharacterDataType x);
void endVisit(SQLCharacterDataType x);
boolean visit(SQLAlterTableDropForeignKey x);
void endVisit(SQLAlterTableDropForeignKey x);
public boolean visit(SQLCharacterDataType x) {
public void endVisit(SQLCharacterDataType x) {
public boolean visit(SQLAlterTableDropForeignKey x) {
public void endVisit(SQLAlterTableDropForeignKey x) {
public boolean visit(SQLAlterTableDropForeignKey x) {
String table = x.getReferencedTableName().getSimpleName();
String columnName = column.getSimpleName();
private static volatile IdentityHashMap         dataSources;
public static void clear() {
public static IdentityHashMap<Object, ObjectName> getInstances() {
IdentityHashMap<Object, ObjectName> tmp = dataSources;
if (tmp == null) {
synchronized (DruidDataSourceStatManager.class) {
if (isRegisterToSystemProperty()) {
dataSources = getInstances0();
tmp = dataSources;
if (null == tmp) {
dataSources = tmp = new IdentityHashMap<Object, ObjectName>();
return "true".equals(value);
mbeanServer.unregisterMBean(objectName);
} catch (Throwable ex) {
LOG.error("unregister mbean error", ex);
private int                                                 maxSqlSize              = 1000;
for (JdbcSqlStat stat : stats) {
for (Map.Entry<String, JdbcSqlStat> entry : sqlStatMap.entrySet()) {
for (JdbcSqlStat stat : stats) {
private final AtomicInteger openingCount   = new AtomicInteger();
private final AtomicInteger openingMax     = new AtomicInteger();
openingMax.set(0);
int invoking = openingCount.incrementAndGet();
int max = openingMax.get();
if (openingMax.compareAndSet(max, invoking)) {
public int getOpeningCount() {
return openingCount.get();
public int getOpeningMax() {
return openingMax.get();
openingCount.decrementAndGet();
int getOpeningCount();
int getOpeningMax();
return new JdbcStatContext();
public static JdbcStatManager getInstance() {
public JdbcConnectionStat getConnectionStat() {
indexNames, indexTypes);
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append(this.column.toString());
stringBuilder.append(' ');
stringBuilder.append(this.operator);
stringBuilder.append(' ');
stringBuilder.append(String.valueOf(this.values.get(0)));
stringBuilder.append(" (");
stringBuilder.append(", ");
stringBuilder.append(String.valueOf(values.get(i)));
stringBuilder.append(")");
return stringBuilder.toString();
if (!(obj instanceof  Column)) {
return false;
return Integer.parseInt(v);
String[] titleRow  = rows.get(0);
int[] maxLens = new int[titleRow.length];
for (String[] row : rows) {
for (int j = 0; j < row.length; j++) {
int len = displayLen(row[j]);
if (len > maxLens[j]) {
maxLens[j] = len;
int vLen = displayLen(old);
if (vLen > length) {
StringBuilder sb = new StringBuilder(old);
for (int i=0; i< length -vLen ; i++) {
if (idStr == opt.getId()) {
if (idStr == opt.getId()) {
return TableFormatter.format(printContents);
for (String titleField : titleFields) {
row[0] = titleField;
Object value = sqlStat.get(titleField);
row[j + 1] = handleAndConvert(value, titleField);
return TableFormatter.format(printContents);
public abstract class ResourceServlet extends HttpServlet {
private final static Log   LOG                 = LogFactory.getLog(ResourceServlet.class);
public ResourceServlet(String resourcePath){
return "0:0:0:0:0:0:0:1".equals(remoteAddress) || (denyList.size() == 0 && allowList.size() == 0);
if (contextPath.equals("") || contextPath.equals("/")) {
if (contextPath.equals("") || contextPath.equals("/")) {
if (path.contains(".json")) {
return session != null && session.getAttribute(SESSION_USER_KEY) != null;
String remoteAddress = null;
remoteAddress = request.getHeader(remoteAddressHeader);
if (remoteAddress == null) {
remoteAddress = request.getRemoteAddr();
return remoteAddress;
public class StatViewServlet extends ResourceServlet {
public final static String PARAM_NAME_PROFILE_ENABLE         = "profileEnable";
String param = config.getInitParameter(PARAM_NAME_PROFILE_ENABLE);
LOG.error("WebStatFilter Parameter '" + PARAM_NAME_PROFILE_ENABLE + "' config error");
uriStatMap.putIfAbsent(uri, new WebURIStat(uri));
uriStat = uriStatMap.get(uri);
if (userAgent.contains("Windows Phone")) {
if (userAgent.contains("Windows Phone")) {
if (isIpad && userAgent.contains("iPad")) {
} else if (isIPhone || userAgent.contains("iPhone")) {
} else if (userAgent.contains("Symbian")) {
} else if (userAgent.contains("Ubuntu")) {
if (userAgent.contains("OpenBSD")) {
} else if (userAgent.contains("FreeBSD")) {
} else if ((!isLinux) && userAgent.contains("Linux")) {
if (userAgent.contains("Windows")) {
} else if (userAgent.contains("Linux")) {
} else if (userAgent.contains("Macintosh")) {
if (userAgent.contains("Chrome")) {
if ((!isAndroid) && userAgent.contains("Safari")) {
if (userAgent.contains("Firefox")) {
} else if (userAgent.contains("Spider") || userAgent.contains("spider")) {
} else if (userAgent.contains("crawl") || userAgent.contains("Crawl")) {
} else if (userAgent.contains("Bot") || userAgent.contains("bot")) {
LOG.error("session ip change too many");
val.remoteAddress = remoteAddresses;
String remoteAddress;
public String getRemoteAddress() {
return remoteAddress;
public void setRemoteAddress(String remoteAddresses) {
this.remoteAddress = remoteAddresses;
data.put("RemoteAddress", this.getRemoteAddress());
for (ProfileEntryStatValue profileEntryStatValue : profileEntryStatValueList) {
profileDataList.add(profileEntryStatValue.getData());
StringBuilder result = new StringBuilder();
return another instanceof IPAddress && ipAddress == ((IPAddress) another).ipAddress;
return ipAddress.toString() + "/" + extendedNetworkPrefix;
StringBuilder decimalIp = new StringBuilder();
decimalIp.append(octet);
decimalIp.append('.');
return decimalIp.toString();
throw new RuntimeException("init data source error", e);
private static Field sessionField;
if (method.getName().equals("setResultObjectValues")) { 
LOG.error("Error while initializing", e);
for (String mappedName : this.beanNames) {
public void setUserConnection(Connection connection) throws SQLException {
client.setUserConnection(connection);
return executor.update(id, parameterObject);
return executor.update(id);
return executor.delete(id, parameterObject);
return executor.delete(id);
return executor.queryForObject(id, parameterObject);
return executor.queryForObject(id);
return executor.queryForObject(id, parameterObject, resultObject);
return executor.queryForList(id, parameterObject);
return executor.queryForList(id);
return executor.queryForList(id, parameterObject, skip, max);
return executor.queryForList(id, skip, max);
return executor.queryForPaginatedList(id, parameterObject, pageSize);
return executor.queryForPaginatedList(id, pageSize);
return executor.queryForMap(id, parameterObject, keyProp);
return executor.queryForMap(id, parameterObject, keyProp, valueProp);
public void setUserConnection(Connection connection) throws SQLException {
session.setUserConnection(connection);
ArrayList<ArrayList<LinkedHashMap<String, Object>>> data = columnData.getTableData();
ColumnData columnData = TableDataProcessor.multiRow2Col(data, KEY_WORD_IDENTITY);
tableModel = new DruidTableModel(columnData.getData());
private static final String            HISTOGRAM                      = "Histogram";
add(HISTOGRAM);
if (HISTOGRAM.equals(keyNow)) {
groupHistogram = new ColumnGroup(HISTOGRAM);
DruidTableModel tableModel = new DruidTableModel(colData.getData());
private JTable            refTable;              
public RowHeaderRenderer(JTable refTable, JTable tableShow){
this(null, refTable, tableShow, 0);
public RowHeaderRenderer(ArrayList<String> headerList, JTable refTable, JTable tableShow, int rowSpan){
this.refTable = refTable;
ListSelectionModel listModel = refTable.getSelectionModel();
rowHeightNow = refTable.getRowCount() * refTable.getRowHeight();
rowHeightNow = rowSpan * refTable.getRowHeight();
int rowCountNow = refTable.getRowCount() / rowSpan;
JTableHeader header = refTable.getTableHeader();
int[] sel = refTable.getSelectedRows();
for (int item : sel) {
if (item == row) {
for (int item : sel) {
if (item / rowSpan == row) {
public static ColumnData row2col(ArrayList<LinkedHashMap<String, Object>> rowData, String keyword) {
ColumnData data = new ColumnData();
ArrayList<LinkedHashMap<String, Object>> colData = new ArrayList<LinkedHashMap<String, Object>>();
for (LinkedHashMap<String, Object> row : rowData) {
LinkedHashMap<String, Object> colDataItem = new LinkedHashMap<String, Object>();
colDataItem.put(COLUMN_KEY_NAME, element.getKey());
colDataItem.put(COLUMN_VALUE_NAME, element.getValue());
colData.add(colDataItem);
data.setCount(colCount);
data.setData(colData);
data.setNames(colNames);
return data;
public static ColumnData multiRow2Col(ArrayList<LinkedHashMap<String, Object>> rowData, String keyword) {
ColumnData data = new ColumnData();
ArrayList<ArrayList<LinkedHashMap<String, Object>>> tableData = new ArrayList<ArrayList<LinkedHashMap<String, Object>>>();
for (LinkedHashMap<String, Object> row : rowData) {
ArrayList<LinkedHashMap<String, Object>> colData = new ArrayList<LinkedHashMap<String, Object>>();
LinkedHashMap<String, Object> colDataItem = new LinkedHashMap<String, Object>();
colDataItem.put(COLUMN_KEY_NAME, element.getKey());
colDataItem.put(COLUMN_VALUE_NAME, element.getValue());
colData.add(colDataItem);
tableData.add(colData);
data.setCount(rowCount);
data.setTableData(tableData);
data.setNames(colNames);
return data;
public static ColumnData row2col(ArrayList<LinkedHashMap<String, Object>> rowData) {
return row2col(rowData, null);
private ArrayList<LinkedHashMap<String, Object>> data;
private ArrayList<ArrayList<LinkedHashMap<String, Object>>> tableData;
public ArrayList<LinkedHashMap<String, Object>> getData() {
return data;
public void setData(ArrayList<LinkedHashMap<String, Object>> data) {
this.data = data;
public ArrayList<ArrayList<LinkedHashMap<String, Object>>> getTableData() {
return tableData;
public void setTableData(ArrayList<ArrayList<LinkedHashMap<String, Object>>> tableData) {
this.tableData = tableData;
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
if (null != logConstructor) {
logConstructor.newInstance(LogFactory.class.getName());
return (Log) logConstructor.newInstance(loggerName);
private long                     timeBetweenSqlCollect        = DEFAULT_TIME_BETWEEN_COLLECT;
private long                     timeBetweenSpringCollect     = DEFAULT_TIME_BETWEEN_COLLECT;
private long                     timeBetweenWebUriCollect     = DEFAULT_TIME_BETWEEN_COLLECT;
private boolean                  collectSpringMethodEnable    = true;
private boolean                  collectWebAppEnable          = true;
configFromProperty(System.getProperties());
public void configFromProperty(Properties properties) {
Integer value = getInteger(properties, "druid.monitor.client.timeBetweenSqlCollect");
this.setTimeBetweenSqlCollect(value);
Integer value = getInteger(properties, "druid.monitor.client.timeBetweenSpringCollect");
this.setTimeBetweenSpringCollect(value);
Integer value = getInteger(properties, "druid.monitor.client.timeBetweenWebUriCollect");
this.setTimeBetweenWebUriCollect(value);
Boolean value = getBoolean(properties, "druid.monitor.client.collectSpringMethodEnable");
this.setCollectSpringMethodEnable(value);
Boolean value = getBoolean(properties, "druid.monitor.client.collectWebAppEnable");
this.setCollectWebAppEnable(value);
}, timeBetweenSqlCollect, timeBetweenSqlCollect, timeUnit);
}, timeBetweenSpringCollect, timeBetweenSpringCollect, timeUnit);
}, timeBetweenWebUriCollect, timeBetweenWebUriCollect, timeUnit);
if (!collectSpringMethodEnable) {
if ((!collectWebAppEnable) && !collectWebURIEnable) {
if (collectWebAppEnable) {
public long getTimeBetweenSqlCollect() {
return timeBetweenSqlCollect;
public void setTimeBetweenSqlCollect(long timeBetweenSqlCollect) {
this.timeBetweenSqlCollect = timeBetweenSqlCollect;
public long getTimeBetweenSpringCollect() {
return timeBetweenSpringCollect;
public void setTimeBetweenSpringCollect(long timeBetweenSpringCollect) {
this.timeBetweenSpringCollect = timeBetweenSpringCollect;
public long getTimeBetweenWebUriCollect() {
return timeBetweenWebUriCollect;
public void setTimeBetweenWebUriCollect(long timeBetweenWebUriCollect) {
this.timeBetweenWebUriCollect = timeBetweenWebUriCollect;
public boolean isCollectSpringMethodEnable() {
return collectSpringMethodEnable;
public void setCollectSpringMethodEnable(boolean collectSpringMethodEnable) {
this.collectSpringMethodEnable = collectSpringMethodEnable;
public boolean isCollectWebAppEnable() {
return collectWebAppEnable;
public void setCollectWebAppEnable(boolean collectWebAppEnable) {
this.collectWebAppEnable = collectWebAppEnable;
InetAddress inetAddress = null;
while (netInterfaces.hasMoreElements()) {
inetAddress = (InetAddress) e2.nextElement();
if (!inetAddress.isLoopbackAddress() && !inetAddress.getHostAddress().contains(":")) {
return inetAddress;
private final Map<String, Object> attributes = new HashMap<String, Object>();
public Map<String, Object> getAttributes() {
return attributes;
public class MonitorServlet extends ResourceServlet {
for (FieldInfo field : fields) {
for (FieldInfo field : fields) {
for (FieldInfo field : fields) {
for (ProfileEntryStatValue profileEntryStatValue : statValueList) {
list.add(profileEntryStatValue.getData());
for (String mappedName : this.beanNames) {
Collections.addAll(this.beanNames, beanNames);
public static final String          PROP_NAME_PROFILE   = "druid.profile";
private SpringMethodContextListener statContextListener = new SpringMethodContextListener();
StatFilterContext.getInstance().addContextListener(statContextListener);
StatFilterContext.getInstance().removeContextListener(statContextListener);
return invocation.proceed();
if (obj == null || !(obj instanceof SpringMethodInfo)) {
StringBuilder sb = new StringBuilder();
StringBuilder result = new StringBuilder(resultLen);
public static String getUrl(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getUrl();
Method method = druidDataSource.getClass().getMethod("getUrl");
Object obj = method.invoke(druidDataSource);
public static long getID(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getID();
Method method = druidDataSource.getClass().getMethod("getID");
Object obj = method.invoke(druidDataSource);
public static String getName(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getName();
Method method = druidDataSource.getClass().getMethod("getName");
Object obj = method.invoke(druidDataSource);
public static ObjectName getObjectName(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getObjectName();
Method method = druidDataSource.getClass().getMethod("getObjectName");
Object obj = method.invoke(druidDataSource);
public static Object getSqlStat(Object druidDataSource, int sqlId) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getSqlStat(sqlId);
Method method = druidDataSource.getClass().getMethod("getSqlStat", int.class);
return method.invoke(druidDataSource, sqlId);
public static boolean isRemoveAbandoned(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).isRemoveAbandoned();
Method method = druidDataSource.getClass().getMethod("isRemoveAbandoned");
Object obj = method.invoke(druidDataSource);
public static Map<String, Object> getStatDataForMBean(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getStatDataForMBean();
Method method = druidDataSource.getClass().getMethod("getStatDataForMBean");
Object obj = method.invoke(druidDataSource);
public static Map<String, Object> getStatData(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getStatData();
Method method = druidDataSource.getClass().getMethod("getStatData");
Object obj = method.invoke(druidDataSource);
public static Map getSqlStatMap(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getSqlStatMap();
Method method = druidDataSource.getClass().getMethod("getSqlStatMap");
Object obj = method.invoke(druidDataSource);
public static Map<String, Object> getWallStatMap(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getWallStatMap();
Method method = druidDataSource.getClass().getMethod("getWallStatMap");
Object obj = method.invoke(druidDataSource);
public static List<Map<String, Object>> getPoolingConnectionInfo(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getPoolingConnectionInfo();
Method method = druidDataSource.getClass().getMethod("getPoolingConnectionInfo");
Object obj = method.invoke(druidDataSource);
public static List<String> getActiveConnectionStackTrace(Object druidDataSource) {
if (druidDataSource.getClass() == DruidDataSource.class) {
return ((DruidDataSource) druidDataSource).getActiveConnectionStackTrace();
Method method = druidDataSource.getClass().getMethod("getActiveConnectionStackTrace");
Object obj = method.invoke(druidDataSource);
this("druidDataSource password", false);
static private final int    BASE_LENGTH        = 128;
static private final int    LOOKUP_LENGTH      = 16;
static final private byte[] HEX_NUMBER_TABLE   = new byte[BASE_LENGTH];
static final private char[] UPPER_CHARS        = new char[LOOKUP_LENGTH];
static final private char[] LOWER_CHARS        = new char[LOOKUP_LENGTH];
for (int i = 0; i < BASE_LENGTH; i++) {
HEX_NUMBER_TABLE[i] = -1;
HEX_NUMBER_TABLE[i] = (byte) (i - '0');
HEX_NUMBER_TABLE[i] = (byte) (i - 'A' + 10);
HEX_NUMBER_TABLE[i] = (byte) (i - 'a' + 10);
UPPER_CHARS[i] = (char) ('0' + i);
LOWER_CHARS[i] = (char) ('0' + i);
UPPER_CHARS[i] = (char) ('A' + i - 10);
LOWER_CHARS[i] = (char) ('a' + i - 10);
final char[] chars = upperCase ? UPPER_CHARS : LOWER_CHARS;
temp1 = (tempChar < BASE_LENGTH) ? HEX_NUMBER_TABLE[tempChar] : -1;
temp2 = (tempChar < BASE_LENGTH) ? HEX_NUMBER_TABLE[tempChar] : -1;
responseBuilder.append(line).append("n");
private final static Log        LOG                = LogFactory.getLog(JdbcUtils.class);
private static final Properties DRIVER_URL_MAPPING = new Properties();
DRIVER_URL_MAPPING.putAll(property);
public static void close(Connection x) {
public static void close(Statement x) {
public static void close(ResultSet x) {
LOG.debug("close result set error", e);
public static void close(Closeable x) {
public static void printResultSet(ResultSet rs) throws SQLException {
public static void printResultSet(ResultSet rs, PrintStream out) throws SQLException {
Object object = rs.getObject(columnIndex);
out.print(String.valueOf(object));
Object object = rs.getString(columnIndex);
out.print(String.valueOf(object));
Object object = rs.getObject(columnIndex);
if (object instanceof byte[]) {
byte[] bytes = (byte[]) object;
out.print(String.valueOf(object));
private final static ServletPathMatcher INSTANCE = new ServletPathMatcher();
return INSTANCE;
if (null != start) {
indexFrom += start.length();
private SQLWarning            warnings;
return warnings;
this.warnings = null;
public void setWarnings(SQLWarning warnings) {
this.warnings = warnings;
return row[columnIndex - 1];
return iface.isInstance(this);
String columnName = this.getMetaData().getColumnName(columnIndex);
return getObject(columnName);
return (Boolean) obj;
return iface.isAssignableFrom(this.getClass());
private boolean             selectAllow                 = true;
private boolean             selectWhereAlwaysTrueCheck  = true;
private boolean             selectHavingAlwaysTrueCheck = true;
private boolean             conditionAndAlwaysTrueAllow = false;
private boolean             conditionAndAlwaysFalseAllow = false;
private boolean             deleteWhereAlwaysTrueCheck  = true;
private boolean             updateWhereAlwaysTrueCheck  = true;
private boolean             conditionOpBitwiseAllow     = true;
public boolean isConditionAndAlwaysTrueAllow() {
return conditionAndAlwaysTrueAllow;
public void setConditionAndAlwaysTrueAllow(boolean conditionAndAlwaysTrueAllow) {
this.conditionAndAlwaysTrueAllow = conditionAndAlwaysTrueAllow;
public boolean isConditionAndAlwaysFalseAllow() {
return conditionAndAlwaysFalseAllow;
public void setConditionAndAlwaysFalseAllow(boolean conditionAndAlwaysFalseAllow) {
this.conditionAndAlwaysFalseAllow = conditionAndAlwaysFalseAllow;
public boolean isConditionOpBitwiseAllow() {
return conditionOpBitwiseAllow;
public void setConditionOpBitwiseAllow(boolean conditionOpBitwiseAllow) {
this.conditionOpBitwiseAllow = conditionOpBitwiseAllow;
public boolean isSelectAllow() {
return selectAllow;
public void setSelectAllow(boolean selelctAllow) {
this.selectAllow = selelctAllow;
public boolean isSelectWhereAlwaysTrueCheck() {
return selectWhereAlwaysTrueCheck;
public void setSelectWhereAlwaysTrueCheck(boolean selectWhereAlwayTrueCheck) {
this.selectWhereAlwaysTrueCheck = selectWhereAlwayTrueCheck;
public boolean isSelectHavingAlwaysTrueCheck() {
return selectHavingAlwaysTrueCheck;
public void setSelectHavingAlwaysTrueCheck(boolean selectHavingAlwayTrueCheck) {
this.selectHavingAlwaysTrueCheck = selectHavingAlwayTrueCheck;
public boolean isDeleteWhereAlwaysTrueCheck() {
return deleteWhereAlwaysTrueCheck;
public void setDeleteWhereAlwaysTrueCheck(boolean deleteWhereAlwayTrueCheck) {
this.deleteWhereAlwaysTrueCheck = deleteWhereAlwayTrueCheck;
public boolean isUpdateWhereAlwaysTrueCheck() {
return updateWhereAlwaysTrueCheck;
public void setUpdateWhereAlwaysTrueCheck(boolean updateWhereAlayTrueCheck) {
this.updateWhereAlwaysTrueCheck = updateWhereAlayTrueCheck;
boolean isSelectAllow();
void setSelectAllow(boolean selectAllow);
boolean isSelectWhereAlwaysTrueCheck();
void setSelectWhereAlwaysTrueCheck(boolean selectWhereAlwaysTrueCheck);
boolean isSelectHavingAlwaysTrueCheck();
void setSelectHavingAlwaysTrueCheck(boolean selectHavingAlwaysTrueCheck);
boolean isDeleteWhereAlwaysTrueCheck();
void setDeleteWhereAlwaysTrueCheck(boolean deleteWhereAlwaysTrueCheck);
boolean isUpdateWhereAlwaysTrueCheck();
void setUpdateWhereAlwaysTrueCheck(boolean updateWhereAlwaysTrueCheck);
private int                                   warnings                     = 0;
private int                                   unionWarnings                = 0;
private int                                   updateNoneConditionWarnings  = 0;
private int                                   deleteNoneConditionWarnings  = 0;
private int                                   likeNumberWarnings           = 0;
this.warnings++;
public int getWarnings() {
return warnings;
public void incrementWarnings() {
this.warnings++;
public int getLikeNumberWarnings() {
return likeNumberWarnings;
public void incrementLikeNumberWarnings() {
if (likeNumberWarnings == 0) {
this.warnings++;
likeNumberWarnings++;
public int getUnionWarnings() {
return unionWarnings;
public void incrementUnionWarnings() {
if (this.unionWarnings == 0) {
this.incrementWarnings();
this.unionWarnings++;
public int getUpdateNoneConditionWarnings() {
return updateNoneConditionWarnings;
public void incrementUpdateNoneConditionWarnings() {
this.updateNoneConditionWarnings++;
public int getDeleteNoneConditionWarnings() {
return deleteNoneConditionWarnings;
public void incrementDeleteNoneConditionWarnings() {
this.deleteNoneConditionWarnings++;
if (null == dataSource) {
LOG.error("dataSource should not be null");
if (dataSource.getDbType() != null) {
for (int count : updateCounts) {
updateCount += count;
return WallContext.create(dbType);
if (updateCount > 0) {
return checkResult.getSql();
if (config.isDoPrivilegedAllow() && WallProvider.ispPrivileged()) {
return this.provider.getConfig().isWrapAllow() && chain.isWrapperFor(wrapper, iface);
if (config.isDoPrivilegedAllow() && WallProvider.ispPrivileged()) {
if (config.isDoPrivilegedAllow() && WallProvider.ispPrivileged()) {
LOG.error("not support method : Connection.getMetaData");
throw new WallSQLException("not support method : Connection.getMetaData");
if (null != hiddenColumn && hiddenColumn.equalsIgnoreCase(columnName)) {
&& null != tenantColumn && tenantColumn.equalsIgnoreCase(metaData.getColumnName(physicalColumn))) {
protected final AtomicLong                            syntaxErrorCount        = new AtomicLong();
return new WallSqlStat(tableStats, functionStats, violations, syntaxError);
return !getConfig().getDenyFunctions().contains(functionName);
return !getConfig().getDenySchemas().contains(schemaName);
return !getConfig().getDenyTables().contains(tableName);
return !getConfig().isReadOnly(tableName);
if (config.isDoPrivilegedAllow() && ispPrivileged()) {
syntaxErrorCount.incrementAndGet();
result = new WallCheckResult(null, violations, tableStats, functionStats, statementList, syntaxError);
syntaxErrorCount.incrementAndGet();
syntaxErrorCount.incrementAndGet();
public static boolean ispPrivileged() {
return value;
return syntaxErrorCount.get();
statValue.setSyntaxErrorCount(get(syntaxErrorCount, reset));
public void setSyntaxErrorCount(long syntaxErrorCount) {
this.syntaxErrorCount = syntaxErrorCount;
info.put("syntaxErrorCount", this.getSyntaxErrorCount());
if (!sql.equals(sqlSample)) {
if (!config.isSelectAllow()) {
if (!config.isSelectAllow()) {
context.incrementWarnings();
String tableName = ((SQLName) x.getName()).getSimpleName();
if (!config.isSelectAllow()) {
return !(x.getExpr() instanceof SQLName);
if (!config.isSelectAllow()) {
return !(x.getExpr() instanceof SQLName);
if (!config.isSelectAllow()) {
String tableName = ((SQLName) x.getName()).getSimpleName();
String tableName = ((SQLName) x.getName()).getSimpleName();
String tableName = ((SQLName) expr).getSimpleName();
Object whereValue = getConditionValue(visitor, where, visitor.getConfig().isSelectWhereAlwaysTrueCheck());
addViolation(visitor, ErrorCode.ALWAYS_TRUE, "select alway true condition not allow", x);
if (Boolean.TRUE == getConditionValue(visitor, x, visitor.getConfig().isSelectHavingAlwaysTrueCheck())) {
addViolation(visitor, ErrorCode.ALWAYS_TRUE, "having alway true condition not allow", x);
context.incrementDeleteNoneConditionWarnings();
if (Boolean.TRUE == getConditionValue(visitor, where, config.isDeleteWhereAlwaysTrueCheck())) {
addViolation(visitor, ErrorCode.ALWAYS_TRUE, "delete alway true condition not allow", x);
tableName = ((SQLName) tableNameExpr).getSimpleName();
context.incrementUpdateNoneConditionWarnings();
if (Boolean.TRUE == getConditionValue(visitor, where, config.isUpdateWhereAlwaysTrueCheck())) {
addViolation(visitor, ErrorCode.ALWAYS_TRUE, "update alway true condition not allow", x);
context.incrementLikeNumberWarnings();
context.incrementWarnings();
if (current.hasPartAlwayTrue() && alwayTrueCheck && !visitor.getConfig().isConditionAndAlwaysTrueAllow()) {
addViolation(visitor, ErrorCode.ALWAYS_TRUE, "part alway true condition not allow", x);
if (current.hasPartAlwayFalse() && !visitor.getConfig().isConditionAndAlwaysFalseAllow()) {
addViolation(visitor, ErrorCode.ALWAYS_FALSE, "part alway false condition not allow", x);
if (current.hasBitwise() && !visitor.getConfig().isConditionOpBitwiseAllow()) {
String owner = ((SQLName) x).getSimpleName();
String tableName = ((SQLName) expr).getSimpleName();
context.incrementUnionWarnings();
public final static int ALWAYS_TRUE                   = 2100;
public final static int ALWAYS_FALSE                  = 2113;
config.setConditionOpBitwiseAllow(false);
config.setConditionOpBitwiseAllow(false);
config.setConditionOpBitwiseAllow(false);
config.setConditionOpBitwiseAllow(false);
provider.getConfig().setConditionAndAlwaysTrueAllow(true);
provider.getConfig().setConditionAndAlwaysFalseAllow(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setConditionAndAlwaysTrueAllow(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setConditionAndAlwaysTrueAllow(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
provider.getConfig().setSelectHavingAlwaysTrueCheck(true);
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
DruidDataSourceStatManager.clear();
Assert.assertEquals(0, JdbcStatManager.getInstance().getConnectionStat().getConnectCount());
Assert.assertEquals(0, JdbcStatManager.getInstance().getConnectionStat().getCloseCount());
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionStat().getConnectCount());
Assert.assertEquals(0, JdbcStatManager.getInstance().getConnectionStat().getCloseCount());
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionStat().getConnectCount());
Assert.assertEquals(1, JdbcStatManager.getInstance().getConnectionStat().getCloseCount());
provider.getConfig().setConditionAndAlwaysTrueAllow(true);
public SQLExpr additiveRest(SQLExpr expr) {
if (lexer.token() == Token.PLUS) {
lexer.nextToken();
SQLExpr rightExp = multiplicative();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Add, rightExp);
expr = additiveRest(expr);
} else if (lexer.token() == Token.SUB) {
lexer.nextToken();
SQLExpr rightExp = multiplicative();
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Subtract, rightExp);
expr = additiveRest(expr);
return expr;
Assert.assertFalse(WallUtils.isValidateMySql("select c1 from t where id =1 || 1=1"));
Assert.assertEquals("SELECT 0ntOR NULL;", text);
parseInto(queryBlock);
parseInto(queryBlock);
protected void parseInto(SQLSelectQueryBlock queryBlock) {
if (lexer.token() == (Token.INTO)) {
lexer.nextToken();
if (identifierEquals("OUTFILE")) {
lexer.nextToken();
MySqlOutFileExpr outFile = new MySqlOutFileExpr();
outFile.setFile(expr());
queryBlock.setInto(outFile);
if (identifierEquals("FIELDS") || identifierEquals("COLUMNS")) {
lexer.nextToken();
if (identifierEquals("TERMINATED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsTerminatedBy((SQLLiteralExpr) expr());
if (identifierEquals("OPTIONALLY")) {
lexer.nextToken();
outFile.setColumnsEnclosedOptionally(true);
if (identifierEquals("ENCLOSED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsEnclosedBy((SQLLiteralExpr) expr());
if (identifierEquals("ESCAPED")) {
lexer.nextToken();
accept(Token.BY);
outFile.setColumnsEscaped((SQLLiteralExpr) expr());
if (identifierEquals("LINES")) {
lexer.nextToken();
if (identifierEquals("STARTING")) {
lexer.nextToken();
accept(Token.BY);
outFile.setLinesStartingBy((SQLLiteralExpr) expr());
identifierEquals("TERMINATED");
lexer.nextToken();
accept(Token.BY);
outFile.setLinesTerminatedBy((SQLLiteralExpr) expr());
queryBlock.setInto(this.exprParser.name());
protected ScheduledExecutorService                 destroyScheduler;
protected ScheduledExecutorService                 createScheduler;
to.createScheduler = this.createScheduler;
to.destroyScheduler = this.destroyScheduler;
public ScheduledExecutorService getCreateScheduler() {
return createScheduler;
public void setCreateScheduler(ScheduledExecutorService createScheduler) {
if (isInited()) {
throw new DruidRuntimeException("dataSource inited.");
this.createScheduler = createScheduler;
public ScheduledExecutorService getDestroyScheduler() {
return destroyScheduler;
public void setDestroyScheduler(ScheduledExecutorService destroyScheduler) {
if (isInited()) {
throw new DruidRuntimeException("dataSource inited.");
this.destroyScheduler = destroyScheduler;
public boolean isInited() {
return this.inited;
public static boolean                       holdabilityUnsupported   = false;
boolean initUnderlyHoldability = !holdabilityUnsupported;
} catch (UnsupportedOperationException e) {
holdabilityUnsupported = true;
LOG.warn("getHoldability unsupported", e);
if (!"com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException".equals(e.getClass().getName())) {
public class HoldableUnsupportTest extends TestCase {
private DruidDataSource dataSource;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:xxx");
Filter filter = new FilterAdapter() {
public int connection_getHoldability(FilterChain chain, ConnectionProxy connection) throws SQLException {
throw new UnsupportedOperationException();
dataSource.getProxyFilters().add(filter);
protected void tearDown() throws Exception {
dataSource.close();
public void test_0 () throws Exception {
Connection[] connections = new Connection[8];
for (int i = 0; i < connections.length; ++i) {
connections[i] = dataSource.getConnection();
for (int i = 0; i < connections.length; ++i) {
connections[i].close();
|| text.indexOf("xor") != -1 
|| text.indexOf("version") != -1 
|| text.indexOf("database") != -1 
|| text.indexOf("schema") != -1 
|| text.indexOf("system_user") != -1 
|| text.indexOf("session_user") != -1 
|| text.indexOf("current_user") != -1 
|| text.indexOf("user") != -1 
|| text.indexOf("xmltype") != -1 
|| text.indexOf("receive_message") != -1 
|| text.indexOf("version_compile_os") != -1 
|| text.indexOf("basedir") != -1 
|| text.indexOf("datadir") != -1 
Assert.assertFalse(WallUtils.isValidateMySql("select * from person where id = '3'union select v,b,a from (select 1,2,4! ,database() as b,user() as a,version() as v) a where '1'<>''"));
while(lexer.token() == Token.HINT) {
public final static int RevisionVersion = 9;
if(!provider.getConfig().isHintAllow()) {
addViolation(new IllegalSQLObjectViolation(ErrorCode.EVIL_HINTS, "hint not allow", SQLUtils.toMySqlString(x)));
return true;
public class HintTest extends TestCase {
public void test_false() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(false);
String sql = "select * from person where id = '3'union select 0,1,v from (select 1,2,user!() as v) a where '1'<>''";
Assert.assertFalse(WallUtils.isValidateMySql(sql, config)); 
public void test_true() throws Exception {
String sql = "select * from person where id = '3'union select 0,1,v from (select 1,2,user!() as v) a where '1'<>''";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public class Large10KConcurrentTest extends TestCase {
public class Large10KConcurrentTest_2 extends TestCase {
private DruidDataSource[]        dataSources = new DruidDataSource[10000];
private ScheduledExecutorService scheduler;
private ExecutorService          executor;
protected void setUp() throws Exception {
executor = Executors.newFixedThreadPool(100);
scheduler = Executors.newScheduledThreadPool(10);
for (int i = 0; i < dataSources.length; ++i) {
DruidDataSource dataSource = new DruidDataSource();
dataSource.setMaxActive(8);
dataSource.setMinIdle(0);
dataSource.setUrl("jdbc:mock:xxx");
dataSource.setCreateScheduler(scheduler);
dataSource.setDestroyScheduler(scheduler);
dataSource.setTestOnBorrow(false);
dataSource.setTestWhileIdle(false);
dataSource.setAsyncCloseConnectionEnable(true);
dataSources[i] = dataSource;
protected void tearDown() throws Exception {
for (int i = 0; i < dataSources.length; ++i) {
JdbcUtils.close(dataSources[i]);
executor.shutdown();
scheduler.shutdown();
public void test_large() throws Exception {
final Connection[] connections_A = new Connection[dataSources.length * 8];
final Connection[] connections_B = new Connection[dataSources.length * 8];
final CountDownLatch connLatch_A = new CountDownLatch(connections_A.length);
final CountDownLatch connLatch_B = new CountDownLatch(connections_A.length);
final CountDownLatch closeLatch_A = new CountDownLatch(connections_A.length);
final CountDownLatch closeLatch_B = new CountDownLatch(connections_A.length);
final AtomicLong connErrorCount = new AtomicLong();
for (int i = 0; i < dataSources.length; ++i) {
for (int j = 0; j < 8; ++j) {
final DataSource dataSource = dataSources[i];
final int index = i * 8 + j;
Runnable task = new Runnable() {
public void run() {
connections_A[index] = dataSource.getConnection();
} catch (SQLException e) {
connErrorCount.incrementAndGet();
e.printStackTrace();
} finally {
connLatch_A.countDown();
executor.execute(task);
connLatch_A.await();
for (int i = 0; i < dataSources.length; ++i) {
Assert.assertEquals(8, dataSources[i].getActiveCount());
for (int i = 0; i < dataSources.length; ++i) {
Assert.assertEquals(0, dataSources[i].getPoolingCount());
for (int i = 0; i < dataSources.length; ++i) {
for (int j = 0; j < 8; ++j) {
final int index = i * 8 + j;
Runnable task = new Runnable() {
public void run() {
JdbcUtils.close(connections_A[index]);
closeLatch_A.countDown();
executor.execute(task);
for (int i = 0; i < dataSources.length; ++i) {
for (int j = 0; j < 8; ++j) {
final DataSource dataSource = dataSources[i];
final int index = i * 8 + j;
Runnable task = new Runnable() {
public void run() {
connections_B[index] = dataSource.getConnection();
} catch (SQLException e) {
connErrorCount.incrementAndGet();
e.printStackTrace();
} finally {
connLatch_B.countDown();
executor.execute(task);
closeLatch_A.await();
connLatch_B.await();
for (int i = 0; i < dataSources.length; ++i) {
for (int j = 0; j < 8; ++j) {
final int index = i * 8 + j;
Runnable task = new Runnable() {
public void run() {
JdbcUtils.close(connections_B[index]);
closeLatch_B.countDown();
executor.execute(task);
closeLatch_B.await();
boolean itemIsConst = true;
for (SQLSelectItem item : queryBlock.getSelectList()) {
if (item.getExpr() instanceof SQLIdentifierExpr || item.getExpr() instanceof SQLPropertyExpr) {
itemIsConst = false;
if (itemIsConst) {
return true;
return false;
public class MySqlWallTest_union extends TestCase {
public void testUnion() throws Exception {
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t union select 1, 2", config));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t union select null, '1', 2", config));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t union select c1, c2", config));
public class Large10ConcurrentTest extends TestCase {
private boolean             selelctAllow                = true;
private boolean             selectWhereAlwayTrueCheck   = true;
private boolean             selectHavingAlwayTrueCheck  = true;
private boolean             conditionAndAlwayTrueAllow  = false;
private boolean             conditionAndAlwayFalseAllow = false;
private boolean             deleteWhereAlwayTrueCheck   = true;
private boolean             updateWhereAlayTrueCheck    = true;
private boolean             conditionOpBitwseAllow      = true;
public boolean isSelelctAllow() {
return selelctAllow;
public void setSelelctAllow(boolean selelctAllow) {
this.selelctAllow = selelctAllow;
public boolean isSelectWhereAlwayTrueCheck() {
return selectWhereAlwayTrueCheck;
public void setSelectWhereAlwayTrueCheck(boolean selectWhereAlwayTrueCheck) {
this.selectWhereAlwayTrueCheck = selectWhereAlwayTrueCheck;
public boolean isSelectHavingAlwayTrueCheck() {
return selectHavingAlwayTrueCheck;
public void setSelectHavingAlwayTrueCheck(boolean selectHavingAlwayTrueCheck) {
this.selectHavingAlwayTrueCheck = selectHavingAlwayTrueCheck;
public boolean isConditionAndAlwayTrueAllow() {
return conditionAndAlwayTrueAllow;
public void setConditionAndAlwayTrueAllow(boolean conditionAndAlwayTrueAllow) {
this.conditionAndAlwayTrueAllow = conditionAndAlwayTrueAllow;
public boolean isConditionAndAlwayFalseAllow() {
return conditionAndAlwayFalseAllow;
public void setConditionAndAlwayFalseAllow(boolean conditionAndAlwayFalseAllow) {
this.conditionAndAlwayFalseAllow = conditionAndAlwayFalseAllow;
public boolean isDeleteWhereAlwayTrueCheck() {
return deleteWhereAlwayTrueCheck;
public void setDeleteWhereAlwayTrueCheck(boolean deleteWhereAlwayTrueCheck) {
this.deleteWhereAlwayTrueCheck = deleteWhereAlwayTrueCheck;
public boolean isUpdateWhereAlayTrueCheck() {
return updateWhereAlayTrueCheck;
public void setUpdateWhereAlayTrueCheck(boolean updateWhereAlayTrueCheck) {
this.updateWhereAlayTrueCheck = updateWhereAlayTrueCheck;
public boolean isConditionOpBitwseAllow() {
return conditionOpBitwseAllow;
public void setConditionOpBitwseAllow(boolean conditionOpBitwseAllow) {
this.conditionOpBitwseAllow = conditionOpBitwseAllow;
public void setInited(boolean inited) {
this.inited = inited;
boolean isSelelctAllow();
void setSelelctAllow(boolean selelctAllow);
boolean isSelectWhereAlwayTrueCheck();
void setSelectWhereAlwayTrueCheck(boolean selectWhereAlwayTrueCheck);
boolean isSelectHavingAlwayTrueCheck();
void setSelectHavingAlwayTrueCheck(boolean selectHavingAlwayTrueCheck);
boolean isDeleteWhereAlwayTrueCheck();
void setDeleteWhereAlwayTrueCheck(boolean deleteWhereAlwayTrueCheck);
boolean isUpdateWhereAlayTrueCheck();
void setUpdateWhereAlayTrueCheck(boolean updateWhereAlayTrueCheck);
if (!config.isSelelctAllow()) {
if (!config.isSelelctAllow()) {
if (!config.isSelelctAllow()) {
if (!config.isSelelctAllow()) {
if (!config.isSelelctAllow()) {
Object whereValue = getConditionValue(visitor, where, visitor.getConfig().isSelectWhereAlwayTrueCheck());
if (Boolean.TRUE == getConditionValue(visitor, x, visitor.getConfig().isSelectHavingAlwayTrueCheck())) {
if (Boolean.TRUE == getConditionValue(visitor, where, config.isDeleteWhereAlwayTrueCheck())) {
if (Boolean.TRUE == getConditionValue(visitor, where, config.isUpdateWhereAlayTrueCheck())) {
if (current.hasPartAlwayTrue() && alwayTrueCheck && !visitor.getConfig().isConditionAndAlwayTrueAllow()) {
if (current.hasPartAlwayFalse() && !visitor.getConfig().isConditionAndAlwayFalseAllow()) {
if (current.hasBitwise() && !visitor.getConfig().isConditionOpBitwseAllow()) {
config.setConditionOpBitwseAllow(false);
config.setConditionOpBitwseAllow(false);
config.setConditionOpBitwseAllow(false);
config.setConditionOpBitwseAllow(false);
public void test_false_1() throws Exception {
Assert.assertFalse(WallUtils.isValidateMySql(sql)); 
public void test_true() throws Exception {
String sql = "SELECT ! STRAIGHT_JOIN  col1 FROM table1,table2";
provider.getConfig().setConditionAndAlwayTrueAllow(true);
provider.getConfig().setConditionAndAlwayFalseAllow(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setConditionAndAlwayTrueAllow(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setConditionAndAlwayTrueAllow(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setSelectHavingAlwayTrueCheck(true);
provider.getConfig().setConditionAndAlwayTrueAllow(true);
private boolean isIdentifierChar(char c) {
return c != '#' && CharTypes.isIdentifierChar(c);
public void test_format_3() throws Exception {
String sql = "select lottery_notice_issue,lottery_notice_date,lottery_notice_result from tb_lottery_notice where lottery_type_id=8 and lottery_notice_issue<=2014066 UNION ALL SELECT NULL, NULL, NULL, NULL, NULL, NULL# and lottery_notice_issue>=2014062 order by lottery_notice_issue desc";
String formattedSql = SQLUtils.formatMySql(sql);
String expected = "SELECT lottery_notice_issue, lottery_notice_date, lottery_notice_result"
+ "nFROM tb_lottery_notice" + "nWHERE lottery_type_id = 8"
+ "ntAND lottery_notice_issue <= 2014066" + "nUNION ALL"
+ "nSELECT NULL, NULL, NULL, NULL, NULL" + "nt, NULL";
Assert.assertEquals(expected, formattedSql);
public class AsyncCloseTest extends TestCase {
protected DruidDataSource                     dataSource;
private ExecutorService                       closeExecutor;
private ExecutorCompletionService<Connection> completionService;
protected void setUp() throws Exception {
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setAsyncCloseConnectionEnable(true);
dataSource.setTestOnBorrow(false);
dataSource.setMaxActive(16);
closeExecutor = Executors.newFixedThreadPool(100);
completionService = new ExecutorCompletionService<Connection>(Executors.newFixedThreadPool(100));
public void test_0() throws Exception {
for (int i = 0; i < 16; ++i) {
protected void loop() throws InterruptedException {
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getPoolingCount());
final Callable<Connection> getTask = new Callable<Connection>() {
public Connection call() throws Exception {
return dataSource.getConnection();
final int COUNT = 1024 * 1024;
final CountDownLatch latch = new CountDownLatch(COUNT);
for (int i = 0; i < COUNT; ++i) {
completionService.submit(getTask);
Runnable closeTask = new Runnable() {
public void run() {
Future<Connection> task = completionService.take();
Connection conn = task.get();
conn.close();
} catch (Exception e) {
e.printStackTrace();
} finally {
latch.countDown();
for (int i = 0; i < COUNT; ++i) {
closeExecutor.submit(closeTask);
latch.await();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(16, dataSource.getPoolingCount());
protected DruidDataSource dataSource;
private ExecutorService   connExecutor;
private ExecutorService   closeExecutor;
final AtomicInteger       errorCount = new AtomicInteger();
connExecutor = Executors.newFixedThreadPool(100);
System.out.println("loop " + i + " done.");
class CloseTask implements Runnable {
private Connection     conn;
private CountDownLatch latch;
public CloseTask(Connection conn, CountDownLatch latch){
this.conn = conn;
this.latch = latch;
public void run() {
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
} finally {
latch.countDown();
protected void loop() throws InterruptedException {
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getPoolingCount());
final int COUNT = 1024 * 128;
final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
Runnable connTask = new Runnable() {
Connection conn = dataSource.getConnection();
CloseTask closeTask = new CloseTask(conn, closeLatch);
closeExecutor.submit(closeTask);
closeExecutor.submit(closeTask); 
} catch (SQLException e) {
errorCount.incrementAndGet();
connExecutor.submit(connTask);
closeLatch.await();
JdbcUtils.close(stmt);
destroySchedulerFuture = destroyScheduler.scheduleAtFixedRate(destoryTask, period, period,
TimeUnit.MILLISECONDS);
if (this.exceptionSorter != null) {
boolean requireDiscard = false;
synchronized (pooledConnection) {
if ((!pooledConnection.isClosed()) || !pooledConnection.isDisable()) {
holder.setDiscard(true);
pooledConnection.disable(t);
requireDiscard = true;
if (requireDiscard) {
this.discardConnection(holder.getConnection());
&& (!isAsyncCloseConnectionEnable()) 
&& pooledConnection.getOwnerThread() != Thread.currentThread()
public Logger getLog() {
return log;
protected void tearDown() throws Exception {
dataSource.close();
public class AsyncCloseTest2 extends TestCase {
protected DruidDataSource dataSource;
private ExecutorService   connExecutor;
private ExecutorService   closeExecutor;
final AtomicInteger       errorCount = new AtomicInteger();
private Logger            log;
private Level             oldLevel;
protected void setUp() throws Exception {
log = ((Log4jImpl) LogFactory.getLog(DruidDataSource.class)).getLog();
oldLevel = log.getLevel();
log.setLevel(Level.FATAL);
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setAsyncCloseConnectionEnable(true);
dataSource.setTestOnBorrow(false);
dataSource.setMaxActive(16);
dataSource.getProxyFilters().add(new FilterAdapter() {
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql)
throws SQLException {
throw new SQLException();
dataSource.setExceptionSorter(new MyExceptionSorter());
dataSource.init();
connExecutor = Executors.newFixedThreadPool(128);
closeExecutor = Executors.newFixedThreadPool(128);
protected void tearDown() throws Exception {
dataSource.close();
log.setLevel(oldLevel);
public void test_0() throws Exception {
for (int i = 0; i < 16; ++i) {
System.out.println("loop " + i + " done.");
public static class MyExceptionSorter extends MockExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
return true;
class CloseTask implements Runnable {
private Connection     conn;
private CountDownLatch latch;
public CloseTask(Connection conn, CountDownLatch latch){
this.conn = conn;
this.latch = latch;
public void run() {
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
} finally {
latch.countDown();
protected void loop() throws InterruptedException {
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getPoolingCount());
final int COUNT = 1024 * 128;
final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
Runnable connTask = new Runnable() {
public void run() {
Connection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
CloseTask closeTask = new CloseTask(conn, closeLatch);
closeExecutor.submit(closeTask);
closeExecutor.submit(closeTask); 
stmt.execute("select 1");
} finally {
stmt.close();
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
for (int i = 0; i < COUNT; ++i) {
connExecutor.submit(connTask);
closeLatch.await();
Assert.assertEquals(0, dataSource.getActiveCount());
holder.setDiscard(true);
boolean isSameThread = pooledConnection.getOwnerThread() == Thread.currentThread();
if (!isSameThread) {
synchronized (pooledConnection) {
holder.reset();
holder.reset();
if (holder.isDiscard()) {
DruidAbstractDataSource dataSource = holder.getDataSource();
boolean isSameThread = this.getOwnerThread() == Thread.currentThread();
if (!isSameThread) {
dataSource.setAsyncCloseConnectionEnable(true);
if (dataSource.isAsyncCloseConnectionEnable()) {
public class AsyncCloseTest1 extends TestCase {
protected DruidDataSource dataSource;
private ExecutorService   connExecutor;
private ExecutorService   closeExecutor;
final AtomicInteger       errorCount = new AtomicInteger();
private Logger            log;
private Level             oldLevel;
protected void setUp() throws Exception {
log = ((Log4jImpl) LogFactory.getLog(DruidDataSource.class)).getLog();
oldLevel = log.getLevel();
log.setLevel(Level.FATAL);
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setTestOnBorrow(false);
dataSource.setMaxActive(16);
connExecutor = Executors.newFixedThreadPool(128);
closeExecutor = Executors.newFixedThreadPool(128);
protected void tearDown() throws Exception {
dataSource.close();
log.setLevel(oldLevel);
public void test_0() throws Exception {
for (int i = 0; i < 16; ++i) {
System.out.println("loop " + i + " done.");
class CloseTask implements Runnable {
private Connection     conn;
private CountDownLatch latch;
public CloseTask(Connection conn, CountDownLatch latch){
this.conn = conn;
this.latch = latch;
public void run() {
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
} finally {
latch.countDown();
protected void loop() throws InterruptedException {
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getPoolingCount());
final int COUNT = 1024 * 128;
final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
Runnable connTask = new Runnable() {
public void run() {
Connection conn = dataSource.getConnection();
CloseTask closeTask = new CloseTask(conn, closeLatch);
closeExecutor.submit(closeTask);
closeExecutor.submit(closeTask); 
} catch (SQLException e) {
errorCount.incrementAndGet();
for (int i = 0; i < COUNT; ++i) {
connExecutor.submit(connTask);
closeLatch.await();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(16, dataSource.getPoolingCount());
public class AsyncCloseTest3 extends TestCase {
protected DruidDataSource dataSource;
private ExecutorService   connExecutor;
private ExecutorService   closeExecutor;
final AtomicInteger       errorCount = new AtomicInteger();
private Logger            log;
private Level             oldLevel;
protected void setUp() throws Exception {
log = ((Log4jImpl) LogFactory.getLog(DruidDataSource.class)).getLog();
oldLevel = log.getLevel();
log.setLevel(Level.FATAL);
dataSource = new DruidDataSource();
dataSource.setUrl("jdbc:mock:");
dataSource.setTestOnBorrow(false);
dataSource.setMaxActive(16);
dataSource.getProxyFilters().add(new FilterAdapter() {
public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql)
throws SQLException {
throw new SQLException();
dataSource.setExceptionSorter(new MyExceptionSorter());
dataSource.init();
connExecutor = Executors.newFixedThreadPool(2);
closeExecutor = Executors.newFixedThreadPool(2);
protected void tearDown() throws Exception {
dataSource.close();
log.setLevel(oldLevel);
public void test_0() throws Exception {
for (int i = 0; i < 16; ++i) {
System.out.println("loop " + i + " done.");
public static class MyExceptionSorter extends MockExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
return true;
class CloseTask implements Runnable {
private Connection     conn;
private CountDownLatch latch;
public CloseTask(Connection conn, CountDownLatch latch){
this.conn = conn;
this.latch = latch;
public void run() {
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
} finally {
latch.countDown();
protected void loop() throws InterruptedException {
dataSource.shrink();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getPoolingCount());
final int COUNT = 1024 * 128;
final CountDownLatch closeLatch = new CountDownLatch(COUNT * 2);
final CountDownLatch execLatch = new CountDownLatch(COUNT);
Runnable connTask = new Runnable() {
public void run() {
DruidPooledConnection conn = dataSource.getConnection();
Statement stmt = conn.createStatement();
CloseTask closeTask = new CloseTask(conn, closeLatch);
closeExecutor.submit(closeTask);
closeExecutor.submit(closeTask); 
stmt.execute("select 1");
} finally {
stmt.close();
conn.close();
} catch (SQLException e) {
errorCount.incrementAndGet();
} finally {
execLatch.countDown();
for (int i = 0; i < COUNT; ++i) {
connExecutor.submit(connTask);
execLatch.await();
closeLatch.await();
Assert.assertEquals(0, dataSource.getActiveCount());
Assert.assertEquals(1, dataSource.getActiveCount());
Assert.assertEquals(0, dataSource.getActiveCount());
if (!isHint && !isAllowComment() && (isEOF() || !isSafeComment(stringVal))) {
boolean lastIsHint = false;
for (int i=0; i<statementList.size(); i++) {
SQLStatement stmt = statementList.get(i);
if ((i == 0 || lastIsHint) && stmt instanceof MySqlHintStatement) {
lastIsHint = true;
public class MySqlWallTest_hint extends TestCase {
public void test_false() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(false);
String sql = "select * from person where id = '3'union select 0,1,v from (select 1,2,user!() as v) a where '1'<>''";
Assert.assertFalse(WallUtils.isValidateMySql(sql, config)); 
public void test_false_1() throws Exception {
String sql = "select * from person where id = '3'union select 0,1,v from (select 1,2,user!() as v) a where '1'<>''";
Assert.assertFalse(WallUtils.isValidateMySql(sql)); 
public void test_true() throws Exception {
String sql = "SELECT ! STRAIGHT_JOIN  col1 FROM table1,table2";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public void test_true_1() throws Exception {
String sql = "!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT ";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public void test_true_2() throws Exception {
String sql = "!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 ";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public void test_true_3() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
String sql = " !50003 CREATE !50020  !50003 PROCEDURE `top_calculate_customer_update`(in update_time DATETIME)"
+ " DETERMINISTIC"
+ " BEGIN"
+ " DECLARE done INT DEFAULT FALSE;"
+ " DECLARE c_receiver_city,c_receiver_district,c_receiver_address VARCHAR(200);"
+ " DECLARE c_last_updated DATETIME;"
+ " DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;"
+ " insert into top_calculate_customer_log (execute_time,info) values (now(),'update table top_taobao_order_customer_mid begin');"
+ " update top_tmp_order_middle_last_sync set status = 'wait', last_sync = update_time where plat_form = 'taobao' and status = 'blocking';"
+ " END */";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
if (evalValue == null) {
if (part instanceof SQLBooleanExpr) {
evalValue = ((SQLBooleanExpr) part).getValue();
} else if (part instanceof SQLNumericLiteralExpr) {
evalValue = ((SQLNumericLiteralExpr) part).getNumber();
} else if (part instanceof SQLCharExpr) {
evalValue = ((SQLCharExpr) part).getText();
} else if (part instanceof SQLNCharExpr) {
evalValue = ((SQLNCharExpr) part).getText();
Boolean result = SQLEvalVisitorUtils.castToBoolean(evalValue);
if (result != null && result) {
public void test() throws Exception {
WallProvider provider = initWallProvider();
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where 1 and 1='1'";
Assert.assertTrue(provider.checkValid(sql));
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where 1 or 1='1'";
Assert.assertTrue(provider.checkValid(sql));
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where true or 1='1'";
Assert.assertTrue(provider.checkValid(sql));
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where 'a' or 1='1'";
Assert.assertTrue(provider.checkValid(sql));
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where id=1 or 1='1'";
Assert.assertFalse(provider.checkValid(sql));
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where id=1 or true";
Assert.assertFalse(provider.checkValid(sql));
private boolean             lockTableAllow              = true;
public boolean isLockTableAllow() {
return lockTableAllow;
public void setLockTableAllow(boolean lockTableAllow) {
this.lockTableAllow = lockTableAllow;
WallVisitorUtils.check(this, x);
private final static Log     LOG           = LogFactory.getLog(WallVisitorUtils.class);
public final static String   HAS_TRUE_LIKE = "hasTrueLike";
public final static String[] whiteHints    = { "LOCAL", "TEMPORARY", "SQL_NO_CACHE", "SQL_CACHE", "HIGH_PRIORITY",
"LOW_PRIORITY", "STRAIGHT_JOIN", "SQL_BUFFER_RESULT", "SQL_BIG_RESULT", "SQL_SMALL_RESULT", "DELAYED" };
} else if (x instanceof MySqlLockTableStatement) {
allow = config.isLockTableAllow();
denyMessage = "lock table not allow";
errorCode = ErrorCode.LOCK_TABLE_NOT_ALLOW;
public static void check(WallVisitor visitor, SQLCommentHint x) {
if (!visitor.getConfig().isHintAllow()) {
addViolation(visitor, ErrorCode.EVIL_HINTS, "hint not allow", x);
String text = x.getText();
text = text.trim();
if (text.startsWith("!")) {
text = text.substring(1);
if (text.length() == 0) {
int pos = 0;
for (; pos < text.length(); pos++) {
char ch = text.charAt(pos);
if (ch >= '0' && ch <= '9') {
continue;
if (pos == 5) {
text = text.substring(5);
text = text.trim();
text = text.toUpperCase();
boolean isWhite = false;
for (String hint : whiteHints) {
if (text.equals(hint)) {
isWhite = true;
if (!isWhite) {
if (text.startsWith("FORCE INDEX") || text.startsWith("IGNORE INDEX")) {
isWhite = true;
if(!isWhite) {
if (text.startsWith("SET")) {
SQLStatementParser parser = new MySqlStatementParser(text);
List<SQLStatement> statementList = parser.parseStatementList();
if (statementList != null && statementList.size() > 0)  {
SQLStatement statement = statementList.get(0);
if (statement instanceof SQLSetStatement || statement instanceof MySqlSetCharSetStatement
|| statement instanceof MySqlSetNamesStatement) {
isWhite = true;
if (!isWhite) {
addViolation(visitor, ErrorCode.EVIL_HINTS, "hint not allow", x);
public final static int LOCK_TABLE_NOT_ALLOW          = 1105;
public void test_true_4() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
String sql = "LOCK TABLES `m_rpt_adgroupeffect` READ !32311 LOCAL ";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config)); 
public void test_true_5() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
String sql = "DROP TABLE IF EXISTS `item_similarity`;"
+ "n/*!40101 SET @saved_cs_client     = @@character_set_client */;"
+ "n/*!40101 SET character_set_client = utf8 */;" 
+ "nCREATE TABLE `item_similarity` ("
+ " `id` bigint(20) unsigned NOT NULL, "
+ " `sellerId` bigint(20) DEFAULT NULL,"
+ " PRIMARY KEY (`id`)" 
+ " ) ENGINE=InnoDB DEFAULT CHARSET=utf8;"
+ " n!40101 SET character_set_client = @saved_cs_client ;";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config)); 
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
acceptChild(visitor, this.hints);
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
private SQLName              table;
private SQLName              database;
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
private boolean              consistentSnapshot = false;
private boolean              begin              = false;
private boolean              work               = false;
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
if(lexer.token() == Token.HINT) {
stmt.setHints(this.exprParser.parseHints());
if (lexer.token() == Token.HINT) {
stmt.setHints(this.exprParser.parseHints());
if(lexer.token() == Token.HINT) {
stmt.setHints(this.exprParser.parseHints());
if(lexer.token() == Token.HINT) {
stmt.setHints(this.exprParser.parseHints());
List<SQLCommentHint> hints = x.getHints();
if (hints != null && !hints.isEmpty()) {
print(" ");
for (SQLCommentHint hint : hints) {
hint.accept(this);
List<SQLCommentHint> hints = x.getHints();
if (hints != null && !hints.isEmpty()) {
print(" ");
for (SQLCommentHint hint : hints) {
hint.accept(this);
List<SQLCommentHint> hints = x.getHints();
if (hints != null && !hints.isEmpty()) {
print(" ");
for (SQLCommentHint hint : hints) {
hint.accept(this);
List<SQLCommentHint> hints = x.getHints();
if (hints != null && !hints.isEmpty()) {
print(" ");
for (SQLCommentHint hint : hints) {
hint.accept(this);
private boolean             startTransactionAllow       = true;
public boolean isStartTransactionAllow() {
return startTransactionAllow;
public void setStartTransactionAllow(boolean startTransactionAllow) {
this.startTransactionAllow = startTransactionAllow;
} else if (x instanceof MySqlStartTransactionStatement) {
allow = config.isStartTransactionAllow();
denyMessage = "start transaction not allow";
errorCode = ErrorCode.START_TRANSACTION_NOT_ALLOW;
public final static int START_TRANSACTION_NOT_ALLOW   = 1303;
public final static int LOCK_TABLE_NOT_ALLOW          = 1106;
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config)); 
public void test_true_6() throws Exception {
String sql = "START TRANSACTION !40100 WITH CONSISTENT SNAPSHOT ";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public void test_true_7() throws Exception {
String sql = "LOCK TABLES `m_rpt_adgroupeffect` READ !32311 LOCAL ";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
public void test_true_8() throws Exception {
String sql = "SET SQL_QUOTE_SHOW_CREATE=1!40102 ,SQL_MODE=concat(@@sql_mode, _utf8 ',NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS') ";
Assert.assertTrue(WallUtils.isValidateMySql(sql)); 
if (x.getLeft() instanceof SQLSelectQueryBlock) {
SQLSelectQueryBlock left = (SQLSelectQueryBlock) x.getLeft();
SQLTableSource tableSource = left.getFrom();
if (left.getWhere() == null && tableSource != null && tableSource instanceof SQLExprTableSource) {
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where c1=1 union select 1, 2"));
" UNION ALL SELECT  a  from tt where c=1" + 
sql = "SELECT a from t where c=1 UNION ALL SELECT 2 FROM dual ";
"SELECT FID, FNAME FROM T WHERE C=1 UNION SELECT 1, 'AAA'"));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select 1, 2", config));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t union select 1, 2", config));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select null, '1', 2",
config));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select c1, c2", config));
Assert.assertTrue(WallUtils.isValidateMySql("SELECT typeid, typename FROM (SELECT typeid, typename FROM materialtype UNION ALL SELECT ? AS typeid, ? AS typename) a ORDER BY typeid",
config));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from (select 1 as f1, 2 as f2) t union select 'u1', 'u2'",
config));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where c=1 union select 1, 2"));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where f1=1 union select 1, 2"));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where f1=1 union select 1, 2"));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1"));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1"));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X)"));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X)"));
public static String formatSQLServer(String sql) {
return format(sql, JdbcUtils.SQL_SERVER);
if (!parseCompleteValues && valueClauseList.size() >= parseValuesSize) {
lexer.skipToEOF();
if (!parseCompleteValues && insertStatement.getValuesList().size() >= parseValuesSize) {
lexer.skipToEOF();
public void skipToEOF() {
pos = text.length();
this.token = Token.EOF;
protected boolean       parseCompleteValues = true;
protected int           parseValuesSize     = 3;
public boolean isParseCompleteValues() {
return parseCompleteValues;
public void setParseCompleteValues(boolean parseCompleteValues) {
this.parseCompleteValues = parseCompleteValues;
public int getParseValuesSize() {
return parseValuesSize;
public void setParseValuesSize(int parseValuesSize) {
this.parseValuesSize = parseValuesSize;
private boolean             completeInsertValuesCheck   = false;
private int                 insertValuesCheckSize       = 3;
public boolean isCompleteInsertValuesCheck() {
return completeInsertValuesCheck;
public void setCompleteInsertValuesCheck(boolean completeInsertValuesCheck) {
this.completeInsertValuesCheck = completeInsertValuesCheck;
public int getInsertValuesCheckSize() {
return insertValuesCheckSize;
public void setInsertValuesCheckSize(int insertValuesCheckSize) {
this.insertValuesCheckSize = insertValuesCheckSize;
if (!config.isCompleteInsertValuesCheck()) {
parser.setParseCompleteValues(false);
parser.setParseValuesSize(config.getInsertValuesCheckSize());
public class MySqlInsertTest_10 extends MysqlTest {
public void test_parseCompleteValues_false() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
MySqlStatementParser parser = new MySqlStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t (a, b)"
+ "nVALUES ('a1', 'b1'),"
+ "nt('a2', 'b2'),"
+ "nt('a3', 'b3')";
Assert.assertEquals(formatSql, SQLUtils.toMySqlString(insertStmt));
public void test_parseCompleteValues_true() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
MySqlStatementParser parser = new MySqlStatementParser(sql);
parser.setParseCompleteValues(true);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(4, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t (a, b)"
+ "nVALUES ('a1', 'b1'),"
+ "nt('a2', 'b2'),"
+ "nt('a3', 'b3'),"
+ "nt('a4', 'b4')";
Assert.assertEquals(formatSql, SQLUtils.toMySqlString(insertStmt));
public class SQLServerInsertTest5 extends TestCase {
public void test_parseCompleteValues_false() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t"
+ "nt(a, b)"
+ "nVALUES" + "n('a1', 'b1'),"
+ "n('a2', 'b2'),"
+ "n('a3', 'b3')";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public void test_parseCompleteValues_true() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(true);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(4, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t"
+ "nt(a, b)"
+ "nVALUES"
+ "n('a1', 'b1'),"
+ "n('a2', 'b2'),"
+ "n('a3', 'b3'),"
+ "n('a4', 'b4')";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public static String formatSQLServer(String sql) {
return format(sql, JdbcUtils.SQL_SERVER);
if (!parseCompleteValues && valueClauseList.size() >= parseValuesSize) {
lexer.skipToEOF();
if (!parseCompleteValues && insertStatement.getValuesList().size() >= parseValuesSize) {
lexer.skipToEOF();
public void skipToEOF() {
pos = text.length();
this.token = Token.EOF;
protected boolean       parseCompleteValues = true;
protected int           parseValuesSize     = 3;
public boolean isParseCompleteValues() {
return parseCompleteValues;
public void setParseCompleteValues(boolean parseCompleteValues) {
this.parseCompleteValues = parseCompleteValues;
public int getParseValuesSize() {
return parseValuesSize;
public void setParseValuesSize(int parseValuesSize) {
this.parseValuesSize = parseValuesSize;
private boolean             completeInsertValuesCheck   = false;
private int                 insertValuesCheckSize       = 3;
public boolean isCompleteInsertValuesCheck() {
return completeInsertValuesCheck;
public void setCompleteInsertValuesCheck(boolean completeInsertValuesCheck) {
this.completeInsertValuesCheck = completeInsertValuesCheck;
public int getInsertValuesCheckSize() {
return insertValuesCheckSize;
public void setInsertValuesCheckSize(int insertValuesCheckSize) {
this.insertValuesCheckSize = insertValuesCheckSize;
if (!config.isCompleteInsertValuesCheck()) {
parser.setParseCompleteValues(false);
parser.setParseValuesSize(config.getInsertValuesCheckSize());
public class MySqlInsertTest_10 extends MysqlTest {
public void test_parseCompleteValues_false() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
MySqlStatementParser parser = new MySqlStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t (a, b)"
+ "nVALUES ('a1', 'b1'),"
+ "nt('a2', 'b2'),"
+ "nt('a3', 'b3')";
Assert.assertEquals(formatSql, SQLUtils.toMySqlString(insertStmt));
public void test_parseCompleteValues_true() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
MySqlStatementParser parser = new MySqlStatementParser(sql);
parser.setParseCompleteValues(true);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt;
Assert.assertEquals(4, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t (a, b)"
+ "nVALUES ('a1', 'b1'),"
+ "nt('a2', 'b2'),"
+ "nt('a3', 'b3'),"
+ "nt('a4', 'b4')";
Assert.assertEquals(formatSql, SQLUtils.toMySqlString(insertStmt));
public class SQLServerInsertTest5 extends TestCase {
public void test_parseCompleteValues_false() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(3, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t"
+ "nt(a, b)"
+ "nVALUES" + "n('a1', 'b1'),"
+ "n('a2', 'b2'),"
+ "n('a3', 'b3')";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public void test_parseCompleteValues_true() throws Exception {
String sql = "insert into t(a,b) values ('a1','b1'),('a2','b2'),('a3','b3'),('a4','b4');";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(true);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(4, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(2, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO t"
+ "nt(a, b)"
+ "nVALUES"
+ "n('a1', 'b1'),"
+ "n('a2', 'b2'),"
+ "n('a3', 'b3'),"
+ "n('a4', 'b4')";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
private List<SQLCommentHint>   optionHints  = new ArrayList<SQLCommentHint>();
public List<SQLCommentHint> getOptionHints() {
return optionHints;
public void setOptionHints(List<SQLCommentHint> optionHints) {
this.optionHints = optionHints;
while (lexer.token() == (Token.HINT)) {
this.exprParser.parseHints(stmt.getOptionHints());
for (SQLCommentHint hint : x.getOptionHints()) {
print(' ');
hint.accept(this);
public void test_true_9() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
String sql = "CREATE TABLE `session` ("
+ " `sess_id` varchar(128) NOT NULL,"
+ " `created` datetime NOT NULL DEFAULT '1000-01-01 00:00:00',"
+ " `changed` datetime NOT NULL DEFAULT '1000-01-01 00:00:00',"
+ " `ip` varchar(40) NOT NULL,"
+ " `vars` mediumtext NOT NULL,"
+ " PRIMARY KEY(`sess_id`),"
+ " INDEX `changed_index` (`changed`)"
+ ") !40000 ENGINE=INNODB  !40101 CHARACTER SET utf8 COLLATE utf8_general_ci  ";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config)); 
private SQLName              name;
private String               characterSet;
private String               collate;
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
protected SQLStatement       statement;
private List<SQLCommentHint> hints;
public List<SQLCommentHint> getHints() {
return hints;
public void setHints(List<SQLCommentHint> hints) {
this.hints = hints;
if (lexer.token() == Token.HINT) {
stmt.setHints(this.exprParser.parseHints());
if (x.getHints() != null && x.getHints().size() > 0) {
printAndAccept(x.getHints(), " ");
if (x.getHints() != null && x.getHints().size() > 0) {
printAndAccept(x.getHints(), " ");
if (x.getHints() != null && x.getHints().size() > 0) {
printAndAccept(x.getHints(), " ");
if(lexer.token == Token.HINT) {
explain.setHints(this.exprParser.parseHints());
if (x.getHints() != null && x.getHints().size() > 0) {
printAndAccept(x.getHints(), " ");
if (x.getHints() != null && x.getHints().size() > 0) {
print(" ");
printAndAccept(x.getHints(), " ");
public void test_true_10() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
config.setNoneBaseStatementAllow(true);
String sql = "CREATE DATABASE `newsfocus` !40100 COLLATE 'big5_chinese_ci'  ";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config)); 
public void test_true_11() throws Exception {
WallConfig config = new WallConfig();
config.setHintAllow(true);
config.setMultiStatementAllow(true);
config.setNoneBaseStatementAllow(true);
String sql = "EXPLAIN !40100 EXTENDED  SELECT * FROM trade_order_header WHERE id = ?";
Assert.assertTrue(WallUtils.isValidateMySql(sql, config)); 
public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource, MBeanRegistration {
public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
return null;
public void postRegister(Boolean registrationDone) {
public void preDeregister() throws Exception {
public void postDeregister() {
jdbcUrl = "jdbc:mysql:
jdbcUrl = "jdbc:mysql:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ointest3";
static String url = "jdbc:jtds:sqlserver:
jdbcUrl = "jdbc:jtds:sqlserver:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
jdbcUrl = "jdbc:mysql:
jdbcUrl = "jdbc:mysql:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ointest3";
String jdbcUrl = "jdbc:mysql:
String jdbcUrl = "jdbc:wrap-jdbc:filters=default:name=benchmark:jdbc:mysql:
jdbcUrl = "jdbc:mysql:
dataSource.setUrl("jdbc:oracle:thin:@a.b.c.d:1521:OINTEST");
dataSource.setUrl("jdbc:mysql:
jdbcUrl = "jdbc:mysql:
DruidTest db = new DruidTest("jdbc:mysql:
jdbcUrl = "jdbc:mysql:
dataSource.setUrl("jdbc:oracle:thin:@a.b.c.d:1521:OINTEST");
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
String url = "jdbc:mysql:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ointest3";
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
dataSource.setUrl("jdbc:oracle:thin:@a.b.c.d:1521:testconn");
dataSource.setUrl("jdbc:mysql:
private String url      = "jdbc:mysql:
dataSource.setUrl("jdbc:mysql:
dataSource.setUrl("jdbc:mysql:
"jdbc:oracle:thin:@a.b.c.d:1521:ocndb");
jdbcUrl = "jdbc:wrap-jdbc:filters=default:name=oracleTest:jdbc:oracle:thin:@a.b.c.d:1521:ocnauto";
jdbcUrl = "jdbc:oracle:thin:@xx.xx.xx.xx:1521:emdb";
private String url      = "jdbc:mysql:
private String url      = "jdbc:mysql:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:emdb";
private String       url      = "jdbc:mysql:
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:emdb";
String url = "jdbc:oracle:thin:@a.b.c.d:1521:orcl";
if (JdbcConstants.POSTGRESQL.equals(dbType))
return limitPostgreSQLQueryBlock((PGSelectQueryBlock) queryBlock, dbType, offset, count);
private static String limitPostgreSQLQueryBlock(PGSelectQueryBlock queryBlock, String dbType,
int offset, int count) {
if (queryBlock.getLimit() != null)
throw new IllegalArgumentException("limit already exists.");
PGLimit limit = new PGLimit();
if (offset > 0)
limit.setOffset(new SQLNumberExpr(offset));
limit.setRowCount(new SQLNumberExpr(count));
queryBlock.setLimit(limit);
return SQLUtils.toSQLString(queryBlock, dbType);
public static class PGLimit extends SQLObjectImpl implements SQLExpr {
public PGLimit(){
private SQLExpr rowCount;
private SQLExpr offset;
public SQLExpr getRowCount() {
return rowCount;
public void setRowCount(SQLExpr rowCount) {
if (rowCount != null) {
rowCount.setParent(this);
this.rowCount = rowCount;
public SQLExpr getOffset() {
return offset;
public void setOffset(SQLExpr offset) {
if (offset != null) {
offset.setParent(this);
this.offset = offset;
@Override
protected void accept0(SQLASTVisitor visitor) {
if (visitor instanceof PGASTVisitor) {
PGASTVisitor pgVisitor = (PGASTVisitor) visitor;
if (pgVisitor.visit(this)) {
if (pgVisitor instanceof PGOutputVisitor)
PGOutputVisitor pgv = (PGOutputVisitor) pgVisitor;
pgv.print(this.rowCount.toString());
if (this.offset != null)
pgv.print(" OFFSET ");
pgv.print(this.offset.toString());
acceptChild(visitor, offset);
acceptChild(visitor, rowCount);
pgVisitor.endVisit(this);
boolean visit(PGSelectQueryBlock.PGLimit x);
void endVisit(PGSelectQueryBlock.PGLimit x);
@Override
public boolean visit(PGLimit x) {
return true;
@Override
public void endVisit(PGLimit x) {
@Override
public boolean visit(PGLimit x) {
return true;
@Override
public void endVisit(PGLimit x) {
public class PGLimitTest {
public static void main(String[] args) {
String dbType = JdbcConstants.POSTGRESQL;
String sql = " select * from brandinfo where 1=1 and brandid > 100 order by brandid asc";
String sqlLimit = com.alibaba.druid.sql.PagerUtils.limit(sql, dbType,
2499, 100);
System.out.println("sqlLimit == " + sqlLimit);
String sqlCount = com.alibaba.druid.sql.PagerUtils.count(sql, dbType);
System.out.println("sqlCount == " + sqlCount);
@Override
public boolean visit(PGLimit x) {
return false;
@Override
public void endVisit(PGLimit x) {
public final static int RevisionVersion = 10;
if (identifierEquals("STATS_SAMPLE_PAGES")) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
stmt.getTableOptions().put("STATS_SAMPLE_PAGES", this.exprParser.expr());
continue;
if (lexer.token() == Token.UNION) {
lexer.nextToken();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
accept(Token.LPAREN);
SQLTableSource tableSrc = this.createSQLSelectParser().parseTableSource();
stmt.getTableOptions().put("UNION", tableSrc);
accept(Token.RPAREN);
continue;
} else if ("UNION".equals(key)) {
print(" = (");
option.getValue().accept(this);
print(')');
boolean val = super.visit((SQLCreateTableStatement) x);
for (SQLObject option : x.getTableOptions().values()) {
if (option instanceof SQLTableSource) {
option.accept(this);
return val;
public class MySqlCreateTableTest55 extends MysqlTest {
public void test_union() throws Exception {
String sql = "CREATE TABLE tableA (datasn varchar(100) NOT NULL,PRIMARY KEY(datasn)) ENGINE=MRG_MyISAM DEFAULT CHARSET=utf8 UNION=(tableB)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE tableA (" 
+ "ntdatasn varchar(100) NOT NULL, " 
+ "ntPRIMARY KEY (datasn)" 
+ "n) ENGINE = MRG_MyISAM CHARSET = utf8 UNION = (tableB)", output);
public class MySqlCreateTableTest56 extends MysqlTest {
public void test_union() throws Exception {
String sql = "CREATE TABLE tableA (datasn varchar(100) NOT NULL,PRIMARY KEY(datasn)) ENGINE=MRG_MyISAM DEFAULT CHARSET=utf8 UNION=(tableB,tableC)";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseCreateTable();
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(3, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("CREATE TABLE tableA (" 
+ "ntdatasn varchar(100) NOT NULL, " 
+ "ntPRIMARY KEY (datasn)" 
+ "n) ENGINE = MRG_MyISAM CHARSET = utf8 UNION = (tableB, tableC)", output);
|| rawUrl.startsWith("JDBC:oracle:")) {
} else if (rawUrl.startsWith("jdbc:mysql:") || rawUrl.startsWith("jdbc:cobar:")) {
public boolean visit(SQLHexExpr x) {
if (!ParameterizedOutputVisitorUtils.checkParameterize(x)) {
return super.visit(x);
return ParameterizedOutputVisitorUtils.visit(this, x);
protected boolean               ifNotExiists     = false;
public boolean isIfNotExiists() {
return ifNotExiists;
public void setIfNotExiists(boolean ifNotExiists) {
this.ifNotExiists = ifNotExiists;
} else if (identifierEquals("ALGORITHM")) {
lexer.nextToken();
accept(Token.EQ);
stmt.getItems().add(new MySqlAlterTableOption("ALGORITHM", lexer.stringVal()));
lexer.nextToken();
protected SQLExpr                   lifecycle;
public SQLExpr getLifecycle() {
return lifecycle;
public void setLifecycle(SQLExpr lifecycle) {
this.lifecycle = lifecycle;
this.acceptChild(visitor, lifecycle);
public class OdpsShowPartitionsStmt extends SQLStatementImpl implements SQLStatement {
private SQLExprTableSource tableSource;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, tableSource);
visitor.endVisit(this);
public class OdpsShowStatisticStmt extends SQLStatementImpl implements SQLStatement {
private SQLExprTableSource tableSource;
public SQLExprTableSource getTableSource() {
return tableSource;
public void setTableSource(SQLExprTableSource tableSource) {
this.tableSource = tableSource;
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, tableSource);
visitor.endVisit(this);
if (identifierEquals("LIFECYCLE")) {
lexer.nextToken();
stmt.setLifecycle(this.exprParser.expr());
map.put("SHOW", Token.SHOW);
public SQLStatement parseShow() {
accept(Token.SHOW);
if (identifierEquals("PARTITIONS")) {
lexer.nextToken();
OdpsShowPartitionsStmt stmt = new OdpsShowPartitionsStmt();
SQLExpr expr = this.exprParser.expr();
stmt.setTableSource(new SQLExprTableSource(expr));
return stmt;
if (identifierEquals("STATISTIC")) {
lexer.nextToken();
OdpsShowStatisticStmt stmt = new OdpsShowStatisticStmt();
SQLExpr expr = this.exprParser.expr();
stmt.setTableSource(new SQLExprTableSource(expr));
return stmt;
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
void endVisit(OdpsShowPartitionsStmt x);
boolean visit(OdpsShowPartitionsStmt x);
void endVisit(OdpsShowStatisticStmt x);
boolean visit(OdpsShowStatisticStmt x);
if (x.getLifecycle() != null) {
println();
print("LIFECYCLE ");
x.getLifecycle().accept(this);
public void endVisit(OdpsShowPartitionsStmt x) {
public boolean visit(OdpsShowPartitionsStmt x) {
print("SHOW PARTITIONS ");
x.getTableSource().accept(this);
return false;
public void endVisit(OdpsShowStatisticStmt x) {
public boolean visit(OdpsShowStatisticStmt x) {
print("SHOW STATISTIC ");
x.getTableSource().accept(this);
return false;
public void endVisit(OdpsShowPartitionsStmt x) {
public boolean visit(OdpsShowPartitionsStmt x) {
return true;
public void endVisit(OdpsShowStatisticStmt x) {
public boolean visit(OdpsShowStatisticStmt x) {
return true;
public class MySql57Test extends TestCase {
public void test_0() throws Exception {
String sql = "ALTER TABLE t1 ALGORITHM=INPLACE, CHANGE COLUMN c1 c1 VARCHAR(255);";
MySqlStatementParser parser = new MySqlStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toMySqlString(stmt);
Assert.assertEquals("ALTER TABLE t1" 
+ "ntALGORITHM = INPLACE," 
+ "ntCHANGE COLUMN c1 c1 VARCHAR(255)", output);
public class OdpsCreateTableTest extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE TABLE IF NOT EXISTS sale_detail(" 
+ " shop_name     STRING," 
+ " customer_id   STRING," 
+ " total_price   DOUBLE" 
+ "comment 'xxxx'" 
+ "PARTITIONED BY (sale_date STRING,region STRING)" 
+ "LIFECYCLE 5" 
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("CREATE TABLE IF NOT EXISTS sale_detailsale_detail ("
+ "ntshop_name STRING, "
+ "ntcustomer_id STRING, "
+ "nttotal_price DOUBLE"
+ "nCOMMENT 'xxxx'"
+ "nPARTITIONED (sale_date STRING, region STRING)"
+ "nLIFECYCLE 5", output);
public class OdpsCreateTableTest_1 extends TestCase {
public void test_0() throws Exception {
String sql = "CREATE TABLE sale_detail_like LIKE sale_detail;";
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("CREATE TABLE sale_detail_likesale_detail_like LIKE sale_detail", output);
public class OdpsShowPartitionsTest extends TestCase {
public void test_0() throws Exception {
String sql = "show partitions secods.xxx";
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("SHOW PARTITIONS secods.xxx", output);
public class OdpsShowStatisticTest extends TestCase {
public void test_0() throws Exception {
String sql = "show statistic secods.xxx";
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("SHOW STATISTIC secods.xxx", output);
public class SQLServerSetStatement extends SQLServerObjectImpl implements SQLServerStatement {
private SQLAssignItem item = new SQLAssignItem();
public SQLServerSetStatement(){
public SQLServerSetStatement(SQLExpr target, SQLExpr value){
this.item = new SQLAssignItem(target, value);
public SQLAssignItem getItem() {
return item;
public void setItem(SQLAssignItem item) {
this.item = item;
public void output(StringBuffer buf) {
buf.append("SET ");
item.output(buf);
@Override
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.item);
visitor.endVisit(this);
public class SQLServerSetTransactionIsolationLevelStatement extends SQLServerObjectImpl implements SQLServerStatement {
private String level;
public void accept0(SQLServerASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public String getLevel() {
return level;
public void setLevel(String level) {
this.level = level;
public SQLStatement parseSet() {
accept(Token.SET);
if (identifierEquals("TRANSACTION")) {
lexer.nextToken();
acceptIdentifier("ISOLATION");
acceptIdentifier("LEVEL");
SQLServerSetTransactionIsolationLevelStatement stmt = new SQLServerSetTransactionIsolationLevelStatement();
if (identifierEquals("READ")) {
lexer.nextToken();
if (identifierEquals("UNCOMMITTED")) {
stmt.setLevel("READ UNCOMMITTED");
lexer.nextToken();
} else if (identifierEquals("COMMITTED")) {
stmt.setLevel("READ COMMITTED");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
} else if (identifierEquals("SERIALIZABLE")) {
stmt.setLevel("SERIALIZABLE");
lexer.nextToken();
} else if (identifierEquals("SNAPSHOT")) {
stmt.setLevel("SNAPSHOT");
lexer.nextToken();
} else if (identifierEquals("REPEATABLE")) {
lexer.nextToken();
if (identifierEquals("READ")) {
stmt.setLevel("REPEATABLE READ");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
return stmt;
if (identifierEquals("STATISTICS")) {
lexer.nextToken();
SQLServerSetStatement stmt = new SQLServerSetStatement();
if (identifierEquals("IO") || identifierEquals("XML") || identifierEquals("PROFILE")
|| identifierEquals("TIME")) {
stmt.getItem().setTarget(new SQLIdentifierExpr("STATISTICS " + lexer.stringVal().toUpperCase()));
lexer.nextToken();
if (lexer.token() == Token.ON) {
stmt.getItem().setValue(new SQLIdentifierExpr("ON"));
lexer.nextToken();
} else if (identifierEquals("OFF")) {
stmt.getItem().setValue(new SQLIdentifierExpr("OFF"));
lexer.nextToken();
return stmt;
if (lexer.token() == Token.VARIANT) {
SQLSetStatement stmt = new SQLSetStatement();
parseAssignItems(stmt.getItems(), stmt);
return stmt;
SQLServerSetStatement stmt = new SQLServerSetStatement();
stmt.getItem().setTarget(this.exprParser.expr());
if (lexer.token() == Token.ON) {
stmt.getItem().setValue(new SQLIdentifierExpr("ON"));
lexer.nextToken();
} else if (identifierEquals("OFF")) {
stmt.getItem().setValue(new SQLIdentifierExpr("OFF"));
lexer.nextToken();
stmt.getItem().setValue(this.exprParser.expr());
return stmt;
boolean visit(SQLServerSetTransactionIsolationLevelStatement x);
void endVisit(SQLServerSetTransactionIsolationLevelStatement x);
boolean visit(SQLServerSetStatement x);
void endVisit(SQLServerSetStatement x);
@Override
public boolean visit(SQLServerSetTransactionIsolationLevelStatement x) {
return true;
@Override
public void endVisit(SQLServerSetTransactionIsolationLevelStatement x) {
@Override
public boolean visit(SQLServerSetStatement x) {
return true;
@Override
public void endVisit(SQLServerSetStatement x) {
@Override
public boolean visit(SQLServerSetTransactionIsolationLevelStatement x) {
print("SET TRANSACTION ISOLATION LEVEL ");
print(x.getLevel());
return false;
@Override
public void endVisit(SQLServerSetTransactionIsolationLevelStatement x) {
@Override
public boolean visit(SQLServerSetStatement x) {
print("SET ");
SQLAssignItem item = x.getItem();
item.getTarget().accept(this);
print(" ");
item.getValue().accept(this);
return false;
@Override
public void endVisit(SQLServerSetStatement x) {
@Override
public boolean visit(SQLServerSetTransactionIsolationLevelStatement x) {
return false;
@Override
public void endVisit(SQLServerSetTransactionIsolationLevelStatement x) {
@Override
public boolean visit(SQLServerSetStatement x) {
return false;
@Override
public void endVisit(SQLServerSetStatement x) {
public class SQLServerSetTest extends TestCase {
public void test_0() {
String sql = "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
SQLStatement stmt = stmtList.get(0);
Assert.assertEquals(1, stmtList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED", text);
public void test_1() {
String sql = "SET FMTONLY ON";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
SQLStatement stmt = stmtList.get(0);
Assert.assertEquals(1, stmtList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("SET FMTONLY ON", text);
public void test_2() {
String sql = "SET STATISTICS XML OFF";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
SQLStatement stmt = stmtList.get(0);
Assert.assertEquals(1, stmtList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("SET STATISTICS XML OFF", text);
public void test_3() {
String sql = "SET @state = N'Oregon'";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
SQLStatement stmt = stmtList.get(0);
Assert.assertEquals(1, stmtList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("SET @state = N'Oregon'", text);
LEFT_OUTER_JOIN("LEFT JOIN"), 
RIGHT_OUTER_JOIN("RIGHT JOIN"), 
FULL_OUTER_JOIN("FULL JOIN"),
STRAIGHT_JOIN("STRAIGHT_JOIN"), 
OUTER_APPLY("OUTER APPLY"),
CROSS_APPLY("CROSS APPLY");
SQLName tableName = this.exprParser.name();
insertStatement.setTableName(tableName);
if (lexer.token() == Token.LITERAL_ALIAS) {
insertStatement.setAlias(as());
parseInsert0_hinits(insertStatement);
if (lexer.token() == Token.IDENTIFIER) {
insertStatement.setAlias(lexer.stringVal());
lexer.nextToken();
&& !identifierEquals("STRAIGHT_JOIN") && !identifierEquals("CROSS") && lexer.token != Token.OUTER) {
if (lexer.token() == Token.JOIN) {
lexer.nextToken();
joinType = SQLJoinTableSource.JoinType.CROSS_JOIN;
} else if (identifierEquals("APPLY")) {
lexer.nextToken();
joinType = SQLJoinTableSource.JoinType.CROSS_APPLY;
} else if (lexer.token() == Token.OUTER) {
lexer.nextToken();
if (identifierEquals("APPLY")) {
lexer.nextToken();
joinType = SQLJoinTableSource.JoinType.OUTER_APPLY;
public class SQLServerInsertTest6 extends TestCase {
public void test() throws Exception {
String sql = "INSERT [dbo].[SurveyAnswer]([CustomerId], [QuestionId], [OptionId], [CreateTime], [LastUpdateTime]) VALUES (@0, @1, @2, @3, @4)";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(1, insertStmt.getValuesList().size());
Assert.assertEquals(5, insertStmt.getValues().getValues().size());
Assert.assertEquals(5, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO [dbo].[SurveyAnswer]"
+ "nt([CustomerId], [QuestionId], [OptionId], [CreateTime], [LastUpdateTime])"
+ "nVALUES" 
+ "n(@0, @1, @2, @3, @4)";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public class SQLServerSelectTest_cross_apply extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT DeptID, DeptName, DeptMgrID, EmpID, EmpLastName, EmpSalary FROM Departments d CROSS APPLY dbo.GetReports(d.DeptMgrID)";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
SQLServerSelectQueryBlock queryBlock = (SQLServerSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getGroupBy());
String fomatSQL = SQLUtils.toSQLString(statementList, JdbcUtils.SQL_SERVER);
System.out.println(fomatSQL);
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
String expected = "SELECT DeptID, DeptName, DeptMgrID, EmpID, EmpLastName"
+ "nt, EmpSalary"
+ "nFROM Departments d" 
+ "ntCROSS APPLY dbo.GetReports(d.DeptMgrID)";
Assert.assertEquals(expected, fomatSQL);
public class SQLServerSelectTest_outer_apply extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT DeptID, DeptName, DeptMgrID, EmpID, EmpLastName, EmpSalary FROM Departments d OUTER APPLY dbo.GetReports(d.DeptMgrID)";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLSelectStatement selectStmt = (SQLSelectStatement) stmt;
SQLSelect select = selectStmt.getSelect();
Assert.assertNotNull(select.getQuery());
SQLServerSelectQueryBlock queryBlock = (SQLServerSelectQueryBlock) select.getQuery();
Assert.assertNull(queryBlock.getGroupBy());
String fomatSQL = SQLUtils.toSQLString(statementList, JdbcUtils.SQL_SERVER);
System.out.println(fomatSQL);
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(7, visitor.getColumns().size());
Assert.assertEquals(0, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
String expected = "SELECT DeptID, DeptName, DeptMgrID, EmpID, EmpLastName"
+ "nt, EmpSalary"
+ "nFROM Departments d" 
+ "ntOUTER APPLY dbo.GetReports(d.DeptMgrID)";
Assert.assertEquals(expected, fomatSQL);
public class SQLServerOutput extends SQLServerObjectImpl {
protected SQLExprTableSource        into;
protected final List<SQLExpr>       columns    = new ArrayList<SQLExpr>();
protected final List<SQLSelectItem> selectList = new ArrayList<SQLSelectItem>();
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, selectList);
this.acceptChild(visitor, into);
this.acceptChild(visitor, columns);
visitor.endVisit(this);
public SQLExprTableSource getInto() {
return into;
public void setInto(SQLExprTableSource into) {
this.into = into;
public List<SQLExpr> getColumns() {
return columns;
public List<SQLSelectItem> getSelectList() {
return selectList;
private SQLServerTop       top;
private SQLServerOutput    output;
this.acceptChild(visitor, getTop());
this.acceptChild(visitor, getOutput());
public SQLServerOutput getOutput() {
return output;
public void setOutput(SQLServerOutput output) {
this.output = output;
public SQLServerTop getTop() {
return top;
public void setTop(SQLServerTop top) {
this.top = top;
private SQLServerTop    top;
private SQLTableSource  from;
private SQLServerOutput output;
public SQLServerOutput getOutput() {
return output;
public void setOutput(SQLServerOutput output) {
this.output = output;
acceptChild(visitor, output);
protected SQLServerOutput parserOutput() {
if (identifierEquals("OUTPUT")) {
lexer.nextToken();
SQLServerOutput output = new SQLServerOutput();
final List<SQLSelectItem> selectList = output.getSelectList();
for (;;) {
final SQLSelectItem selectItem = parseSelectItem();
selectList.add(selectItem);
if (lexer.token() != Token.COMMA) {
lexer.nextToken();
if (lexer.token() == Token.INTO) {
lexer.nextToken();
output.setInto(new SQLExprTableSource(this.name()));
if (lexer.token() == (Token.LPAREN)) {
lexer.nextToken();
this.exprList(output.getColumns(), output);
accept(Token.RPAREN);
return output;
return null;
protected SQLSelectItem parseSelectItem() {
SQLExpr expr;
if (lexer.token() == Token.IDENTIFIER) {
expr = new SQLIdentifierExpr(lexer.stringVal());
lexer.nextTokenComma();
if (lexer.token() != Token.COMMA) {
expr = this.primaryRest(expr);
expr = this.exprRest(expr);
expr = this.expr();
final String alias = as();
return new SQLSelectItem(expr, alias);
SQLServerTop top = this.getExprParser().parseTop();
if (top != null) {
insertStatement.setTop(top);
if (lexer.token() == Token.IDENTIFIER && !lexer.stringVal().equalsIgnoreCase("OUTPUT")) {
SQLServerOutput output = this.getExprParser().parserOutput();
if (output != null) {
insertStatement.setOutput(output);
SQLServerOutput output = this.getExprParser().parserOutput();
if (output != null) {
udpateStatement.setOutput(output);
boolean visit(SQLServerOutput x);
void endVisit(SQLServerOutput x);
@Override
public boolean visit(SQLServerOutput x) {
return true;
@Override
public void endVisit(SQLServerOutput x) {
if (x.getParent() instanceof SQLServerUpdateStatement || x.getParent() instanceof SQLServerInsertStatement) {
print("INSERT ");
if (x.getTop() != null) {
x.getTop().setParent(x);
x.getTop().accept(this);
print(' ');
print("INTO ");
if (x.getOutput() != null) {
println();
x.getOutput().setParent(x);
x.getOutput().accept(this);
if (x.getOutput() != null) {
println();
x.getOutput().setParent(x);
x.getOutput().accept(this);
@Override
public boolean visit(SQLServerOutput x) {
print("OUTPUT ");
printSelectList(x.getSelectList());
if (x.getInto() != null) {
incrementIndent();
println();
print("INTO ");
x.getInto().accept(this);
if (x.getColumns().size() > 0) {
incrementIndent();
println();
print("(");
for (int i = 0, size = x.getColumns().size(); i < size; ++i) {
if (i != 0) {
if (i % 5 == 0) {
println();
print(", ");
x.getColumns().get(i).accept(this);
print(")");
decrementIndent();
decrementIndent();
return false;
@Override
public void endVisit(SQLServerOutput x) {
@Override
public boolean visit(SQLServerOutput x) {
return false;
@Override
public void endVisit(SQLServerOutput x) {
public class SQLServerInsertTest7 extends TestCase {
public void test_0() throws Exception {
String sql = "INSERT Production.ScrapReason OUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate INTO @MyTableVar VALUES (N'Operator error', GETDATE());";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(1, insertStmt.getValuesList().size());
Assert.assertEquals(2, insertStmt.getValues().getValues().size());
Assert.assertEquals(0, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT INTO Production.ScrapReason"
+ "nOUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate"
+ "ntINTO @MyTableVar"
+ "nVALUES"
+ "n(N'Operator error', GETDATE())";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public void test_1() throws Exception {
String sql = "INSERT TOP(5)INTO dbo.EmployeeSales  OUTPUT inserted.EmployeeID, inserted.FirstName, inserted.LastName, inserted.YearlySales SELECT sp.BusinessEntityID, c.LastName, c.FirstName, sp.SalesYTD FROM Sales.SalesPerson AS sp INNER JOIN Person.Person AS c ON sp.BusinessEntityID = c.BusinessEntityID WHERE sp.SalesYTD > 250000.00 ORDER BY sp.SalesYTD DESC;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
parser.setParseCompleteValues(false);
parser.setParseValuesSize(3);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
SQLServerInsertStatement insertStmt = (SQLServerInsertStatement) stmt;
Assert.assertEquals(0, insertStmt.getValuesList().size());
Assert.assertEquals(0, insertStmt.getColumns().size());
Assert.assertEquals(1, statementList.size());
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
String formatSql = "INSERT TOP (5) INTO dbo.EmployeeSales"
+ "nOUTPUT inserted.EmployeeID, inserted.FirstName, inserted.LastName, inserted.YearlySales"
+ "nSELECT sp.BusinessEntityID, c.LastName, c.FirstName, sp.SalesYTD"
+ "nFROM Sales.SalesPerson sp"
+ "nINNER JOIN Person.Person c ON sp.BusinessEntityID = c.BusinessEntityID"
+ "nWHERE sp.SalesYTD > 250000.00"
+ "nORDER BY sp.SalesYTD DESC";
Assert.assertEquals(formatSql, SQLUtils.toSQLServerString(insertStmt));
public class SQLServerUpdateTest5 extends TestCase {
public void test_update() throws Exception {
String sql = "UPDATE TOP (10) HumanResources.Employee SET VacationHours = VacationHours * 1.25, ModifiedDate = GETDATE()  OUTPUT inserted.BusinessEntityID, deleted.VacationHours, inserted.VacationHours, inserted.ModifiedDate INTO @MyTableVar;";
String expect = "UPDATE TOP (10) HumanResources.Employee"
+ "nSET VacationHours = VacationHours * 1.25, ModifiedDate = GETDATE()"
+ "nOUTPUT inserted.BusinessEntityID, deleted.VacationHours, inserted.VacationHours, inserted.ModifiedDate"
+ "ntINTO @MyTableVar";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerDeclareItem extends SQLServerObjectImpl {
protected Type                  type;
protected SQLExpr               name;
protected SQLDataType           dataType;
protected SQLExpr               value;
protected List<SQLTableElement> tableElementList = new ArrayList<SQLTableElement>();
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.name);
acceptChild(visitor, this.dataType);
acceptChild(visitor, this.value);
acceptChild(visitor, this.tableElementList);
visitor.endVisit(this);
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
public SQLDataType getDataType() {
return dataType;
public void setDataType(SQLDataType dataType) {
this.dataType = dataType;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public List<SQLTableElement> getTableElementList() {
return tableElementList;
public void setTableElementList(List<SQLTableElement> tableElementList) {
this.tableElementList = tableElementList;
public enum Type {
TABLE, LOCAL, CURSOR;
public Type getType() {
return type;
public void setType(Type type) {
this.type = type;
public class SQLServerDeclareStatement extends SQLServerObjectImpl implements SQLServerStatement {
protected List<SQLServerDeclareItem> items = new ArrayList<SQLServerDeclareItem>();
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
this.acceptChild(visitor, items);
visitor.endVisit(this);
public List<SQLServerDeclareItem> getItems() {
return items;
public void setItems(List<SQLServerDeclareItem> items) {
this.items = items;
map.put("DECLARE", Token.DECLARE);
if (lexer.token() == Token.DECLARE) {
statementList.add(this.parseDeclare());
return true;
public SQLStatement parseDeclare() {
this.accept(Token.DECLARE);
SQLServerDeclareStatement declareStatement = new SQLServerDeclareStatement();
for (;;) {
SQLServerDeclareItem item = new  SQLServerDeclareItem();
declareStatement.getItems().add(item);
item.setName(this.exprParser.name());
if (lexer.token() == Token.AS) {
lexer.nextToken();
if (lexer.token() == Token.TABLE) {
lexer.nextToken();
item.setType(SQLServerDeclareItem.Type.TABLE);
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
for (;;) {
if (lexer.token() == Token.IDENTIFIER 
|| lexer.token() == Token.LITERAL_ALIAS) {
SQLColumnDefinition column = this.exprParser.parseColumn();
item.getTableElementList().add(column);
} else if (lexer.token() == Token.PRIMARY 
|| lexer.token() == Token.UNIQUE 
|| lexer.token() == Token.CHECK 
|| lexer.token() == Token.CONSTRAINT) {
SQLConstraint constraint = this.exprParser.parseConstaint();
constraint.setParent(item);
item.getTableElementList().add((SQLTableElement) constraint);
} else if (lexer.token() == Token.TABLESPACE) {
throw new ParserException("TODO " + lexer.token());
SQLColumnDefinition column = this.exprParser.parseColumn();
item.getTableElementList().add(column);
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
if (lexer.token() == Token.RPAREN) {
accept(Token.RPAREN);
} else if (lexer.token() == Token.CURSOR) {
item.setType(SQLServerDeclareItem.Type.CURSOR);
lexer.nextToken();
item.setType(SQLServerDeclareItem.Type.LOCAL);
item.setDataType(this.exprParser.parseDataType());
if (lexer.token() == Token.EQ) {
lexer.nextToken();
item.setValue(this.exprParser.expr());
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
return declareStatement;
boolean visit(SQLServerDeclareItem x);
void endVisit(SQLServerDeclareItem x);
boolean visit(SQLServerDeclareStatement x);
void endVisit(SQLServerDeclareStatement x);
@Override
public boolean visit(SQLServerDeclareItem x) {
return true;
@Override
public void endVisit(SQLServerDeclareItem x) {
@Override
public boolean visit(SQLServerDeclareStatement x) {
return true;
@Override
public void endVisit(SQLServerDeclareStatement x) {
@Override
public boolean visit(SQLServerDeclareItem x) {
x.getName().accept(this);
if(x.getType() == SQLServerDeclareItem.Type.TABLE) {
print(" TABLE");
int size = x.getTableElementList().size();
if (size > 0) {
print(" (");
incrementIndent();
println();
for (int i = 0; i < size; ++i) {
if (i != 0) {
print(",");
println();
x.getTableElementList().get(i).accept(this);
decrementIndent();
println();
print(")");
} else if (x.getType() == SQLServerDeclareItem.Type.CURSOR) {
print(" CURSOR");
print(" ");
x.getDataType().accept(this);
if (x.getValue() != null) {
print(" = ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(SQLServerDeclareItem x) {
@Override
public boolean visit(SQLServerDeclareStatement x) {
print("DECLARE ");
this.printAndAccept(x.getItems(), ", ");
return false;
@Override
public void endVisit(SQLServerDeclareStatement x) {
@Override
public boolean visit(SQLServerDeclareItem x) {
return false;
@Override
public void endVisit(SQLServerDeclareItem x) {
@Override
public boolean visit(SQLServerDeclareStatement x) {
return false;
@Override
public void endVisit(SQLServerDeclareStatement x) {
public class SQLServerDeclareTest extends TestCase {
public void test_0() {
String sql = "declare @is_updated bit";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("DECLARE @is_updated bit", text);
public void test_1() {
String sql = "DECLARE @Group nvarchar(50), @Sales money=1;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("DECLARE @Group nvarchar(50), @Sales money = 1", text);
public void test_2() {
String sql = "DECLARE @cursor CURSOR";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("DECLARE @cursor CURSOR", text);
public void test_3() {
String sql = "DECLARE @MyTableVar table( EmpID int NOT NULL, OldVacationHours int, NewVacationHours int, ModifiedDate datetime);";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
String expected = "DECLARE @MyTableVar TABLE ("
+ "ntEmpID int NOT NULL,"
+ "ntOldVacationHours int,"
+ "ntNewVacationHours int,"
+ "ntModifiedDate datetime"
Assert.assertEquals(expected, text);
public void restart() throws SQLException {
if (activeCount > 0) {
throw new SQLException("can not restart, activeCount not zero. " + activeCount);
Connection conn = dataSource.getConnection();
Assert.assertEquals(1, dataSource.getActiveCount());
Exception error = null;
dataSource.restart();
} catch (SQLException ex) {
error = ex;
Assert.assertNotNull(error);
Assert.assertEquals(true, dataSource.isInited());
conn.close();
dataSource.restart();
Assert.assertEquals(0, dataSource.getActiveCount());
public class SQLServerBlockStatement  extends SQLServerObjectImpl implements SQLServerStatement  {
private List<SQLStatement>    statementList = new ArrayList<SQLStatement>();
public List<SQLStatement> getStatementList() {
return statementList;
public void setStatementList(List<SQLStatement> statementList) {
this.statementList = statementList;
@Override
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, statementList);
visitor.endVisit(this);
public class SQLServerIfStatement extends SQLServerObjectImpl implements SQLServerStatement {
private SQLExpr            condition;
private List<SQLStatement> statements = new ArrayList<SQLStatement>();
private Else               elseItem;
@Override
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, condition);
acceptChild(visitor, statements);
acceptChild(visitor, elseItem);
visitor.endVisit(this);
public SQLExpr getCondition() {
return condition;
public void setCondition(SQLExpr condition) {
this.condition = condition;
public List<SQLStatement> getStatements() {
return statements;
public void setStatements(List<SQLStatement> statements) {
this.statements = statements;
public Else getElseItem() {
return elseItem;
public void setElseItem(Else elseItem) {
this.elseItem = elseItem;
public static class Else extends SQLServerObjectImpl {
private List<SQLStatement> statements = new ArrayList<SQLStatement>();
@Override
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, statements);
visitor.endVisit(this);
public List<SQLStatement> getStatements() {
return statements;
public void setStatements(List<SQLStatement> statements) {
this.statements = statements;
map.put("IF", Token.IF);
map.put("ELSE", Token.ELSE);
map.put("BEGIN", Token.BEGIN);
map.put("END", Token.END);
if (lexer.token() == Token.IF) {
statementList.add(this.parseIf());
return true;
if (lexer.token() == Token.BEGIN) {
statementList.add(this.parseBlock());
return true;
public SQLServerIfStatement parseIf() {
accept(Token.IF);
SQLServerIfStatement stmt = new SQLServerIfStatement();
stmt.setCondition(this.exprParser.expr());
this.parseStatementList(stmt.getStatements(), 1);
if(lexer.token() == Token.SEMI) {
lexer.nextToken();
if (lexer.token() == Token.ELSE) {
lexer.nextToken();
SQLServerIfStatement.Else elseItem = new SQLServerIfStatement.Else();
this.parseStatementList(elseItem.getStatements(), 1);
stmt.setElseItem(elseItem);
return stmt;
public SQLServerBlockStatement parseBlock() {
SQLServerBlockStatement block = new SQLServerBlockStatement();
accept(Token.BEGIN);
parseStatementList(block.getStatementList());
accept(Token.END);
return block;
boolean visit(Else x);
void endVisit(Else x);
boolean visit(SQLServerIfStatement x);
void endVisit(SQLServerIfStatement x);
boolean visit(SQLServerBlockStatement x);
void endVisit(SQLServerBlockStatement x);
@Override
public boolean visit(Else x) {
return true;
@Override
public void endVisit(Else x) {
@Override
public boolean visit(SQLServerIfStatement x) {
return true;
@Override
public void endVisit(SQLServerIfStatement x) {
@Override
public boolean visit(SQLServerBlockStatement x) {
return true;
@Override
public void endVisit(SQLServerBlockStatement x) {
@Override
public boolean visit(Else x) {
print("ELSE");
incrementIndent();
println();
for (int i = 0, size = x.getStatements().size(); i < size; ++i) {
if (i != 0) {
println();
SQLStatement item = x.getStatements().get(i);
item.setParent(x);
item.accept(this);
decrementIndent();
return false;
@Override
public void endVisit(Else x) {
@Override
public boolean visit(SQLServerIfStatement x) {
print("IF ");
x.getCondition().accept(this);
incrementIndent();
println();
for (int i = 0, size = x.getStatements().size(); i < size; ++i) {
SQLStatement item = x.getStatements().get(i);
item.setParent(x);
item.accept(this);
if (i != size - 1) {
println();
decrementIndent();
if (x.getElseItem() != null) {
println();
x.getElseItem().accept(this);
return false;
@Override
public void endVisit(SQLServerIfStatement x) {
@Override
public boolean visit(SQLServerBlockStatement x) {
print("BEGIN");
incrementIndent();
println();
for (int i = 0, size = x.getStatementList().size(); i < size; ++i) {
if (i != 0) {
println();
SQLStatement stmt = x.getStatementList().get(i);
stmt.setParent(x);
stmt.accept(this);
print(";");
decrementIndent();
println();
print("END");
return false;
@Override
public void endVisit(SQLServerBlockStatement x) {
for (SQLServerDeclareItem item : x.getItems()) {
item.setParent(x);
SQLExpr name = item.getName();
this.variants.put(name.toString(), name);
return true;
@Override
public boolean visit(Else x) {
return true;
@Override
public void endVisit(Else x) {
@Override
public boolean visit(SQLServerIfStatement x) {
return true;
@Override
public void endVisit(SQLServerIfStatement x) {
@Override
public boolean visit(SQLServerBlockStatement x) {
return true;
@Override
public void endVisit(SQLServerBlockStatement x) {
if (lexer.token() == Token.END) {
public class SQLServerIfTest extends TestCase {
public void test() {
String sql = "if @is_exists is null begin  insert into Inventory_1 (co_id,sku_id,order_lock) values (@0,@1,@2) end else begin insert into Inventory_2 (co_id,sku_id,order_lock) values (@0,@1,@2) end ";
String expect = "IF @is_exists IS NULL"
+ "ntBEGIN"
+ "nttINSERT INTO Inventory_1"
+ "nttt(co_id, sku_id, order_lock)"
+ "nttVALUES"
+ "ntt(@0, @1, @2);"
+ "ntEND"
+ "nELSE"
+ "ntBEGIN"
+ "nttINSERT INTO Inventory_2"
+ "nttt(co_id, sku_id, order_lock)"
+ "nttVALUES"
+ "ntt(@0, @1, @2);"
+ "ntEND";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class MySqlSelectGroupByExpr extends SQLExprImpl implements MySqlExpr {
protected SQLExpr                  expr;
protected SQLOrderingSpecification type;
protected void accept0(SQLASTVisitor visitor) {
MySqlASTVisitor mysqlVisitor = (MySqlASTVisitor) visitor;
if (mysqlVisitor.visit(this)) {
acceptChild(visitor, this.expr);
mysqlVisitor.endVisit(this);
public SQLExpr getExpr() {
return expr;
public void setExpr(SQLExpr expr) {
expr.setParent(this);
this.expr = expr;
public SQLOrderingSpecification getType() {
return type;
public void setType(SQLOrderingSpecification type) {
this.type = type;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
MySqlSelectGroupByExpr other = (MySqlSelectGroupByExpr) obj;
if (expr != other.expr) {
return false;
if (type == null) {
if (other.type != null) {
return false;
} else if (!type.equals(other.type)) {
return false;
return true;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((expr == null) ? 0 : expr.hashCode());
result = prime * result + ((type == null) ? 0 : type.hashCode());
return result;
public MySqlSelectGroupByExpr parseSelectGroupByItem() {
MySqlSelectGroupByExpr item = new MySqlSelectGroupByExpr();
item.setExpr(expr());
if (lexer.token() == Token.ASC) {
lexer.nextToken();
item.setType(SQLOrderingSpecification.ASC);
} else if (lexer.token() == Token.DESC) {
lexer.nextToken();
item.setType(SQLOrderingSpecification.DESC);
return item;
groupBy.addItem(this.getExprParser().parseSelectGroupByItem());
public MySqlExprParser getExprParser() {
return (MySqlExprParser) exprParser;
boolean visit(MySqlSelectGroupByExpr x);
void endVisit(MySqlSelectGroupByExpr x);
@Override
public boolean visit(MySqlSelectGroupByExpr x) {
return true;
@Override
public void endVisit(MySqlSelectGroupByExpr x) {
public boolean visit(MySqlSelectGroupByExpr x) {
x.getExpr().accept(this);
if (x.getType() != null) {
print(" ");
print(x.getType().name().toUpperCase());
return false;
public void endVisit(MySqlSelectGroupByExpr x) {
@Override
public boolean visit(MySqlSelectGroupByExpr x) {
return true;
@Override
public void endVisit(MySqlSelectGroupByExpr x) {
private SQLName       returnStatus;
acceptChild(visitor, this.returnStatus);
public SQLName getReturnStatus() {
return returnStatus;
public void setReturnStatus(SQLName returnStatus) {
this.returnStatus = returnStatus;
SQLName sqlNameName = this.exprParser.name();
if (lexer.token() == Token.EQ) {
lexer.nextToken();
execStmt.setReturnStatus(sqlNameName);
execStmt.setModuleName(this.exprParser.name());
execStmt.setModuleName(sqlNameName);
SQLName returnStatus = x.getReturnStatus();
if (returnStatus != null) {
returnStatus.accept(this);
print(" = ");
} else if (parent instanceof MySqlSelectGroupByExpr) {
return true;
public class MySqlSelectTest_20 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select bsvariety,max(bsh) as bsh,min(bsl) as bsl from   exchange_market_info  where bsdate>date_sub(now(),interval 1 day) group by bsvariety desc;";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(0, visitor.getOrderByColumns().size());
public void test_0() throws Exception {
public void test_2() throws Exception {
String sql = "EXEC @returnstatus = dbo.ufnGetSalesOrderStatusText @Status = 2";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("EXEC @returnstatus = dbo.ufnGetSalesOrderStatusText @Status = 2", output);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
case ESCAP
accept(x.getWithSubQuery());
return visit((SQLSelect) x);
public class JdbcUtilsTest extends TestCase {
public void testGetDbType() {
String jdbcUrl = "jdbc:cobar:
String dbType = JdbcUtils.getDbType(jdbcUrl, null);
assertEquals("not support cobar driver, url like jdbc:cobar:...", JdbcConstants.MYSQL, dbType);
entry.setParent(withQueryClause);
@Override
public boolean visit(SQLWithSubqueryClause.Entry x) {
String alias = x.getName().toString();
Map<String, String> aliasMap = getAliasMap();
SQLWithSubqueryClause with = (SQLWithSubqueryClause) x.getParent();
if (Boolean.TRUE == with.getRecursive()) {
if (aliasMap != null && alias != null) {
aliasMap.put(alias, null);
subQueryMap.put(alias, x.getSubQuery().getQuery());
x.getSubQuery().accept(this);
x.getSubQuery().accept(this);
if (aliasMap != null && alias != null) {
aliasMap.put(alias, null);
subQueryMap.put(alias, x.getSubQuery().getQuery());
return false;
String sql = " SELECT rs.* FROM ( " 
+ "WITH RECURSIVE r AS( "
+ "SELECT * " 
+ "FROM t_e_shopcatalog " 
+ "WHERE parentcatalogid= (SELECT catalogid FROM t_e_shopcatalog where catalogname='' and parentcatalogid='0') " 
+ "UNION ALL " 
+ "SELECT t_e_shopcatalog.* " 
+ "FROM t_e_shopcatalog, r " 
+ "WHERE t_e_shopcatalog.parentcatalogid = r.catalogid )"
+ "SELECT * FROM r )rs WHERE 1=1";
Assert.assertEquals(4, visitor.getColumns().size());
while (lexer.token() == Token.BAR) {
+ millis + " millis. n" + sql);
+ "} batch executed. " + millis + " millis. n" + sql);
+ resultSet.getId() + "} query executed. " + millis + " millis. n" + sql);
+ "} update executed. effort " + updateCount + ". " + millis + " millis. n" + sql);
statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. n"
statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. n"
+ "} created. n" + statement.getSql());
+ "} created. n" + statement.getSql());
if (queryBlock.getSelectList().size() < 1) {
return false;
boolean itemHasAlias = false;
if(item.getAlias() != null ) {
itemHasAlias = true;
if (itemIsConst && !itemHasAlias) {
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Stat {
@SuppressWarnings("serial")
public class StatAnnotationBeanPostProcessor extends AbstractAdvisingBeanPostProcessor implements BeanFactoryAware {
@Resource(name="druid-stat-interceptor")
private DruidStatInterceptor druidStatInterceptor;
public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
setBeforeExistingAdvisors(true);
StatAnnotationAdvisor advisor = new StatAnnotationAdvisor(druidStatInterceptor);
advisor.setBeanFactory(beanFactory);
this.advisor = advisor;
@SuppressWarnings("serial")
public class StatAnnotationAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware {
private Advice advice;
private Pointcut pointcut;
private DruidStatInterceptor druidStatInterceptor;
public StatAnnotationAdvisor(DruidStatInterceptor druidStatInterceptor) {
this.druidStatInterceptor = druidStatInterceptor;
this.advice = buildAdvice();
this.pointcut = buildPointcut();
public Pointcut getPointcut() {
return this.pointcut;
public Advice getAdvice() {
return this.advice;
public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
if (this.advice instanceof BeanFactoryAware) {
((BeanFactoryAware) this.advice).setBeanFactory(beanFactory);
protected Advice buildAdvice() {
return druidStatInterceptor;
protected Pointcut buildPointcut() {
Pointcut cpc = new AnnotationMatchingPointcut(Stat.class, true);
Pointcut mpc = AnnotationMatchingPointcut.forMethodAnnotation(Stat.class);
ComposablePointcut result = new ComposablePointcut(cpc).union(mpc);
return result;
public class DruidStatNamespaceHandler extends NamespaceHandlerSupport {
public void init() {
registerBeanDefinitionParser("annotation-driven", new DruidStatBeanDefinitionParser());
public class DruidStatBeanDefinitionParser implements BeanDefinitionParser {
public static final String STAT_ANNOTATION_PROCESSOR_BEAN_NAME = "com.alibaba.druid.support.spring.stat.annotation.internalStatAnnotationBeanPostProcessor";
public static final String STAT_ANNOTATION_PROCESSOR_BEAN_CLASS = "com.alibaba.druid.support.spring.stat.annotation.StatAnnotationBeanPostProcessor";
public static final String STAT_ANNOTATION_ADVICE_BEAN_NAME = "com.alibaba.druid.support.spring.stat.DruidStatInterceptor";
public static final String STAT_ANNOTATION_ADVICE_BEAN_CLASS = "druid-stat-interceptor";
public BeanDefinition parse(Element element, ParserContext parserContext) {
Object source = parserContext.extractSource(element);
CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);
parserContext.pushContainingComponent(compDefinition);
BeanDefinitionRegistry registry = parserContext.getRegistry();
if (registry.containsBeanDefinition(STAT_ANNOTATION_PROCESSOR_BEAN_NAME)) {
parserContext.getReaderContext().error(
"Only one DruidStatBeanDefinitionParser may exist within the context.", source);
BeanDefinitionBuilder builder = BeanDefinitionBuilder
.genericBeanDefinition(STAT_ANNOTATION_PROCESSOR_BEAN_CLASS);
builder.getRawBeanDefinition().setSource(source);
registerComponent(parserContext, builder, STAT_ANNOTATION_PROCESSOR_BEAN_NAME);
if (!registry.containsBeanDefinition(STAT_ANNOTATION_ADVICE_BEAN_NAME)) {
BeanDefinitionBuilder builder = BeanDefinitionBuilder
.genericBeanDefinition(STAT_ANNOTATION_ADVICE_BEAN_CLASS);
builder.getRawBeanDefinition().setSource(source);
registerComponent(parserContext, builder, STAT_ANNOTATION_ADVICE_BEAN_NAME);
parserContext.popAndRegisterContainingComponent();
return null;
private static void registerComponent(ParserContext parserContext, BeanDefinitionBuilder builder,
String beanName) {
builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
parserContext.getRegistry().registerBeanDefinition(beanName, builder.getBeanDefinition());
BeanDefinitionHolder holder = new BeanDefinitionHolder(builder.getBeanDefinition(), beanName);
parserContext.registerComponent(new BeanComponentDefinition(holder));
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:/com/alibaba/druid/stat/spring-config-stat-annotation.xml" })
public class StatAnnotationTest extends TestCase {
private UserService userService;
public void test_0() throws InterruptedException{
userService.save();
List<Map<String, Object>> result = SpringStatManager.getInstance().getMethodStatData();
Assert.assertNotNull(result);
Assert.assertEquals(1, result.size());
Map<String, Object> statItem = result.get(0);
Assert.assertEquals("com.alibaba.druid.stat.spring.UserService", statItem.get("Class"));
Assert.assertEquals("save()", statItem.get("Method"));
Assert.assertEquals(1L, statItem.get("ExecuteCount"));
public static final String STAT_ANNOTATION_ADVICE_BEAN_NAME = "druid-stat-interceptor";
public static final String STAT_ANNOTATION_ADVICE_BEAN_CLASS = "com.alibaba.druid.support.spring.stat.DruidStatInterceptor";
LOG.error("init datasource error, url: " + this.getUrl(), ex);
LOG.error("create connection error, url: " + jdbcUrl, e);
LOG.error("create connection error, url: " + jdbcUrl, e);
LOG.error("fill connection error, url: " + this.jdbcUrl, e);
return false;
public void endVisit(MySqlSetTransactionIsolationLevelStatement x) {
String paramSql = "SET @@autocommit = ?";
Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);
String paramSql = "SET @@global.sort_buffer_size = ?, @@sort_buffer_size = ?";
Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);
endOfComment = isEOF();
endOfComment = isEOF();
endOfComment = isEOF();
endOfComment = isEOF();
endOfComment = isEOF();
endOfComment = isEOF();
private boolean          allowComment = true;
private int              varIndex     = -1;
protected boolean        hasComment   = false;
protected boolean        endOfComment = false;
public boolean isEndOfComment() {
return endOfComment;
} else if (lexer.token() == Token.END) {
alias = lexer.stringVal();
lexer.nextToken();
boolean endOfComment = false;
if (lastToken != Token.EOF && config.isStrictSyntaxCheck()) {
endOfComment = parser.getLexer().isEndOfComment();
if (!endOfComment) {
visitor.getConfig().setSelectUnionCheck(false);
Assert.assertFalse(WallUtils.isValidateMySql("select 1, 2, 3 from t where id  = ? union select 1, 2, 3 --", config));
provider.getConfig().setSelectUnionCheck(true);
Assert.assertFalse(provider.checkValid("SELECT 1 FROM t WHERE 1 = '1'''''''''''''UNION SELECT '2' --;")); 
provider.getConfig().setSelectUnionCheck(true);
" UNION ALL SELECT 2 FROM dual --";
sql = "SELECT a from t where c=1 UNION ALL SELECT 2 FROM dual --";
provider.getConfig().setSelectUnionCheck(true);
provider.setBlackListEnable(false);
provider.setWhiteListEnable(false);
Assert.assertTrue(provider.checkValid(
Assert.assertFalse(provider.checkValid(
"SELECT FID, FNAME FROM T WHERE C=1 UNION SELECT 1, 'AAA' --"));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select 1, 2", config)); 
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select 1, 2 --", config));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t union select 1, 2", config)); 
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select null, '1', 2 --", config));
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select c1, c2", config)); 
config)); 
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from (select 1 as f1, 2 as f2) t union select 'u1', 'u2' --", config)); 
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where id=1 union select 'u1' as u1, 'u2' as u2",  config)); 
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateOracle("select f1, f2 from t where c=1 union select 1, 2",config));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where c=1 union select 1, 2 --",config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where f1=1 union select 1, 2", config));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where f1=1 union select 1, 2 --", config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateOracle("select f1, f2 from t where f1=1 union select 1, 2", config));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where f1=1 union select 1, 2 --", config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateMySql("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1",
config));
Assert.assertFalse(WallUtils.isValidateMySql("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1 --",
config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateOracle("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1",
config));
Assert.assertFalse(WallUtils.isValidateOracle("select f1, f2 from t where f1 = 1 union select 1, 2 where 1 = 1 --",
config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateMySql("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X)",
config));
Assert.assertFalse(WallUtils.isValidateMySql("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X) -- ",
config));
WallConfig config = new WallConfig();
config.setSelectUnionCheck(true);
Assert.assertTrue(WallUtils.isValidateOracle("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X)",
config));
Assert.assertFalse(WallUtils.isValidateOracle("SELECT id, product FROM T1 t where id=1 UNION (SELECT * FROM (SELECT 1,'x') X) -- ",
config));
connectionLog("{conn " + connection.getId() + "} setSavepoint-" + savepointToString(savepoint));
connectionLog("{conn " + connection.getId() + "} rollback -> " + savepointToString(savePoint));
protected String savepointToString(Savepoint savePoint) {
String savePointString = null;
savePointString = savePoint.getSavepointName();
} catch (SQLException e) {
savePointString = String.valueOf(savePoint.getSavepointId());
} catch (SQLException e1) {
savePointString = savePoint.toString();
return savePointString;
private String dbType;
public SQLStatementImpl(String dbType){
this.dbType = dbType;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
return SQLUtils.toSQLString(this, dbType);
public SQLAlterTableStatement() {
public SQLAlterTableStatement(String dbType) {
super (dbType);
public SQLCallStatement() {
public SQLCallStatement(String dbType) {
super (dbType);
public SQLCreateDatabaseStatement(String dbType){
super (dbType);
public SQLCreateIndexStatement(String dbType){
super (dbType);
public SQLCreateTableStatement(String dbType){
super (dbType);
public SQLCreateTriggerStatement() {
public SQLCreateTriggerStatement(String dbType) {
super (dbType);
public SQLCreateViewStatement(String dbType){
super (dbType);
public SQLDeleteStatement(String dbType){
super (dbType);
public SQLDropDatabaseStatement() {
public SQLDropDatabaseStatement(String dbType) {
super (dbType);
public SQLDropFunctionStatement() {
public SQLDropFunctionStatement(String dbType) {
super (dbType);
public SQLDropIndexStatement() {
public SQLDropIndexStatement(String dbType) {
super (dbType);
public SQLDropProcedureStatement() {
public SQLDropProcedureStatement(String dbType) {
super (dbType);
public SQLDropSequenceStatement() {
public SQLDropSequenceStatement(String dbType) {
super (dbType);
public SQLDropTableSpaceStatement() {
public SQLDropTableSpaceStatement(String dbType) {
super (dbType);
public SQLDropTableStatement(String dbType){
super (dbType);
public SQLDropTableStatement(SQLName name, String dbType){
this(new SQLExprTableSource(name), dbType);
this (name, null);
this (tableSource, null);
public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){
this (dbType);
public SQLDropTriggerStatement() {
public SQLDropTriggerStatement(String dbType) {
super (dbType);
public SQLDropUserStatement() {
public SQLDropUserStatement(String dbType) {
super (dbType);
public SQLDropViewStatement(String dbType){
super (dbType);
public SQLExplainStatement() {
public SQLExplainStatement(String dbType) {
super (dbType);
public SQLGrantStatement() {
public SQLGrantStatement(String dbType) {
super (dbType);
public SQLReleaseSavePointStatement() {
public SQLReleaseSavePointStatement(String dbType) {
super (dbType);
public SQLRollbackStatement() {
public SQLRollbackStatement(String dbType) {
super (dbType);
public SQLSavePointStatement() {
public SQLSavePointStatement(String dbType) {
super (dbType);
public SQLSelectStatement(String dbType){
super (dbType);
public SQLSelectStatement(SQLSelect select, String dbType){
this(dbType);
this.setSelect(select);
public SQLSetStatement(String dbType){
super (dbType);
this(target, value, null);
public SQLSetStatement(SQLExpr target, SQLExpr value, String dbType){
super (dbType);
public SQLTruncateStatement() {
public SQLTruncateStatement(String dbType) {
super (dbType);
public SQLUpdateStatement(String dbType){
super (dbType);
public SQLUseStatement() {
public SQLUseStatement(String dbType) {
super (dbType);
public DB2StatementImpl() {
super(JdbcConstants.DB2);
public MySqlAlterTableStatement() {
super (JdbcConstants.MYSQL);
public MySqlCreateIndexStatement() {
super (JdbcConstants.MYSQL);
super (JdbcConstants.MYSQL);
public MySqlDeleteStatement() {
super (JdbcConstants.MYSQL);
super (JdbcConstants.MYSQL);
public MySqlStatementImpl() {
super(JdbcConstants.MYSQL);
public MySqlUpdateStatement() {
super (JdbcConstants.MYSQL);
return new SQLSelectStatement(selectParser.select(), JdbcConstants.MYSQL);
SQLSetStatement stmt = new SQLSetStatement(getDbType());
SQLCreateDatabaseStatement stmt = new SQLCreateDatabaseStatement(JdbcConstants.MYSQL);
public OdpsCreateTableStatement() {
super (JdbcConstants.ODPS);
public OdpsInsertStatement() {
super (JdbcConstants.ODPS);
public OdpsShowPartitionsStmt() {
super (JdbcConstants.ODPS);
public OdpsShowStatisticStmt() {
super (JdbcConstants.ODPS);
public OracleAlterTableStatement() {
super (JdbcConstants.ORACLE);
public OracleCreateIndexStatement() {
super (JdbcConstants.ORACLE);
public OracleCreateTableStatement() {
super (JdbcConstants.ORACLE);
super (JdbcConstants.ORACLE);
public OracleExplainStatement() {
super (JdbcConstants.ORACLE);
public OracleStatementImpl() {
super(JdbcConstants.ORACLE);
super (JdbcConstants.ORACLE);
SQLSelectStatement stmt = new SQLSelectStatement(new OracleSelectParser(this.exprParser).select(), JdbcConstants.ORACLE);
statementList.add(stmt);
SQLSetStatement stmt = new SQLSetStatement(binaryOpExpr.getLeft(), binaryOpExpr.getRight(), getDbType());
SQLSetStatement stmt = new SQLSetStatement(variant, value, getDbType());
public PGDeleteStatement() {
super (JdbcConstants.POSTGRESQL);
super(JdbcConstants.POSTGRESQL);
super(select, JdbcConstants.POSTGRESQL);
public PGUpdateStatement(){
super (JdbcConstants.POSTGRESQL);
public SQLServerUpdateStatement(){
super (JdbcConstants.SQL_SERVER);
SQLSetStatement stmt = new SQLSetStatement(getDbType());
return new SQLCreateTableStatement(getDbType());
public SQLExprParser(String sql, String dbType){
super(sql, dbType);
public SQLExprParser(Lexer lexer, String dbType){
super(lexer, dbType);
protected String      dbType;
public SQLParser(String sql, String dbType){
this(new Lexer(sql), dbType);
public SQLParser(String sql){
this(sql, null);
this(lexer, null);
public SQLParser(Lexer lexer, String dbType){
this.dbType = dbType;
public String getDbType() {
return dbType;
protected void printError(Token token) {
+ lexer.stringVal());
this(sql, null);
public SQLStatementParser(String sql, String dbType){
this(new SQLExprParser(sql, dbType));
super(exprParser.getLexer(), exprParser.getDbType());
SQLRollbackStatement stmt = new SQLRollbackStatement(getDbType());
SQLUseStatement stmt = new SQLUseStatement(getDbType());
SQLGrantStatement stmt = new SQLGrantStatement(getDbType());
SQLSavePointStatement stmt = new SQLSavePointStatement(getDbType());
SQLReleaseSavePointStatement stmt = new SQLReleaseSavePointStatement(getDbType());
SQLDropTableStatement stmt = new SQLDropTableStatement(getDbType());
SQLDropSequenceStatement stmt = new SQLDropSequenceStatement(getDbType());
SQLDropTriggerStatement stmt = new SQLDropTriggerStatement(getDbType());
SQLDropViewStatement stmt = new SQLDropViewStatement(getDbType());
SQLDropDatabaseStatement stmt = new SQLDropDatabaseStatement(getDbType());
SQLDropFunctionStatement stmt = new SQLDropFunctionStatement(getDbType());
SQLDropTableSpaceStatement stmt = new SQLDropTableSpaceStatement(getDbType());
SQLDropProcedureStatement stmt = new SQLDropProcedureStatement(getDbType());
SQLTruncateStatement stmt = new SQLTruncateStatement(getDbType());
SQLDropUserStatement stmt = new SQLDropUserStatement(getDbType());
SQLDropIndexStatement stmt = new SQLDropIndexStatement(getDbType());
SQLCallStatement stmt = new SQLCallStatement(getDbType());
SQLSetStatement stmt = new SQLSetStatement(getDbType());
SQLCreateTriggerStatement stmt = new SQLCreateTriggerStatement(getDbType());
SQLCreateDatabaseStatement stmt = new SQLCreateDatabaseStatement(getDbType());
SQLCreateIndexStatement stmt = new SQLCreateIndexStatement(getDbType());
return new SQLUpdateStatement(getDbType());
SQLDeleteStatement deleteStatement = new SQLDeleteStatement(getDbType());
SQLCreateViewStatement createView = new SQLCreateViewStatement(getDbType());
SQLExplainStatement explain = new SQLExplainStatement(getDbType());
if (lexer.token == Token.HINT) {
public class Issue_685 extends TestCase {
public void test_for_issue() throws Exception {
OracleStatementParser parser = new OracleStatementParser("select upper(*) from aa order by now()");
SQLStatement st = parser.parseStatement();
st.toString();
public String toString() {
return SQLUtils.toSQLString(this);
SQLExpr bangExpr = primary();
} else if (identifierEquals("RLIKE")) {
lexer.nextToken();
rightExp = equality();
rightExp = relationalRest(rightExp);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.RLike, rightExp);
} else if (identifierEquals("RLIKE")) {
lexer.nextToken();
SQLExpr rightExp = primary();
rightExp = relationalRest(rightExp);
return new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotRLike, rightExp);
public class OrTest extends TestCase {
public void test_xx() throws Exception {
String sql = "select * from t where not match('', '') or (c > 0 and d >0)";
List<SQLStatement>  stmtList = SQLUtils.parseStatements(sql, null);
SQLStatement stmt = stmtList.get(0);
System.out.println(stmt.toString());
Assert.assertEquals("SELECT !1 + 1;", text);
protected SQLExpr parseAliasExpr(String alias) {
return new SQLCharExpr(alias);
sqlExpr = parseAliasExpr(lexer.stringVal());
protected SQLExpr parseAliasExpr(String alias) {
return new SQLIdentifierExpr('"' + alias + '"');
public class OdpsDoubleQuoteTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT my_udtf(1,2,3) as (a, b, c) from employee t1 WHERE t1.name = "aaa";";
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
OdpsSchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("employee")));
Assert.assertTrue(visitor.getColumns().contains(new Column("employee", "name")));
Assignment(":=", 169)
protected SQLExpr     expr;
protected SQLDataType dataType;
public abstract class PGExprImpl extends SQLExprImpl implements PGExpr {
public abstract void accept0(PGASTVisitor visitor);
protected void accept0(SQLASTVisitor visitor) {
accept0((PGASTVisitor) visitor);
public class PGTypeCastExpr extends SQLCastExpr implements PGExpr {
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.expr);
acceptChild(visitor, this.dataType);
visitor.endVisit(this);
protected void accept0(SQLASTVisitor visitor) {
accept0((PGASTVisitor) visitor);
SQLDataType dataType = this.parseDataType();
PGTypeCastExpr castExpr = new PGTypeCastExpr();
castExpr.setExpr(expr);
castExpr.setDataType(dataType);
void endVisit(PGTypeCastExpr x);
boolean visit(PGTypeCastExpr x);
@Override
public boolean visit(PGTypeCastExpr x) {
return true;
@Override
public void endVisit(PGTypeCastExpr x) {
@Override
public void endVisit(PGTypeCastExpr x) {
@Override
public boolean visit(PGTypeCastExpr x) {
x.getExpr().accept(this);
print("::");
x.getDataType().accept(this);
return false;
@Override
public boolean visit(PGTypeCastExpr x) {
x.getExpr().accept(this);
return false;
@Override
public void endVisit(PGTypeCastExpr x) {
public class PGSelectTest11 extends PGTest {
public void test_0() throws Exception {
String sql = "select "xxx"::varchar as xx from xxx;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public interface SQLSelectQuery extends SQLObject {
public class SQLSelectQueryBlock extends SQLObjectImpl implements SQLSelectQuery {
public class SQLUnionQuery extends SQLObjectImpl implements SQLSelectQuery {
public class PGArrayExpr extends PGExprImpl {
private List<SQLExpr> values = new ArrayList<SQLExpr>();
public List<SQLExpr> getValues() {
return values;
public void setValues(List<SQLExpr> values) {
this.values = values;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, values);
visitor.endVisit(this);
public int hashCode() {
return values.hashCode();
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
PGArrayExpr other = (PGArrayExpr) obj;
if (values == null) {
if (other.values != null) return false;
} else if (!values.equals(other.values)) return false;
return true;
public class PGValuesQuery extends PGSQLObjectImpl implements SQLSelectQuery {
private List<SQLExpr> values = new ArrayList<SQLExpr>();
public List<SQLExpr> getValues() {
return values;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, values);
visitor.endVisit(this);
public SQLExpr primary() {
if (lexer.token() == Token.ARRAY) {
lexer.nextToken();
PGArrayExpr array = new PGArrayExpr();
accept(Token.LBRACKET);
this.exprList(array.getValues(), array);
accept(Token.RBRACKET);
return primaryRest(array);
return super.primary();
map.put("ARRAY", Token.ARRAY);
} else if (lexer.token() == Token.VALUES) {
query = this.parseSelect();
PGSelectParser selectParser = createSQLSelectParser();
SQLSelect select = selectParser.select();
return new PGSelectStatement(select);
if (lexer.token() == Token.DELETE) {
PGDeleteStatement stmt = this.parseDeleteStatement();
stmt.setWith(with);
return stmt;
if (lexer.token() == Token.VALUES) {
lexer.nextToken();
accept(Token.LPAREN);
PGValuesQuery valuesQuery = new PGValuesQuery();
this.exprParser.exprList(valuesQuery.getValues(), valuesQuery);
accept(Token.RPAREN);
return queryRest(valuesQuery);
void endVisit(PGValuesQuery x);
boolean visit(PGValuesQuery x);
void endVisit(PGArrayExpr x);
boolean visit(PGArrayExpr x);
@Override
public void endVisit(PGValuesQuery x) {
@Override
public boolean visit(PGValuesQuery x) {
return true;
@Override
public void endVisit(PGArrayExpr x) {
@Override
public boolean visit(PGArrayExpr x) {
return true;
if (x.isRecursive()) {
print(" RECURSIVE ");
@Override
public void endVisit(PGValuesQuery x) {
@Override
public boolean visit(PGValuesQuery x) {
print("VALUES(");
printAndAccept(x.getValues(), ", ");
print(")");
return false;
@Override
public void endVisit(PGArrayExpr x) {
@Override
public boolean visit(PGArrayExpr x) {
print("ARRAY[");
printAndAccept(x.getValues(), ", ");
print("]");
return false;
@Override
public void endVisit(PGValuesQuery x) {
@Override
public boolean visit(PGValuesQuery x) {
return true;
@Override
public void endVisit(PGArrayExpr x) {
@Override
public boolean visit(PGArrayExpr x) {
return true;
sqlExpr = parseAny();
sqlExpr = parseSome();
sqlExpr = parseAll();
protected SQLExpr parseAll() {
SQLExpr sqlExpr;
lexer.nextToken();
SQLAllExpr allExpr = new SQLAllExpr();
accept(Token.LPAREN);
SQLSelect allSubQuery = createSelectParser().select();
allExpr.setSubQuery(allSubQuery);
accept(Token.RPAREN);
allSubQuery.setParent(allExpr);
sqlExpr = allExpr;
return sqlExpr;
protected SQLExpr parseSome() {
SQLExpr sqlExpr;
lexer.nextToken();
SQLSomeExpr someExpr = new SQLSomeExpr();
accept(Token.LPAREN);
SQLSelect someSubQuery = createSelectParser().select();
someExpr.setSubQuery(someSubQuery);
accept(Token.RPAREN);
someSubQuery.setParent(someExpr);
sqlExpr = someExpr;
return sqlExpr;
protected SQLExpr parseAny() {
SQLExpr sqlExpr;
lexer.nextToken();
if (lexer.token() == Token.LPAREN) {
accept(Token.LPAREN);
if (lexer.token() == Token.IDENTIFIER) {
SQLExpr expr = this.expr();
SQLMethodInvokeExpr methodInvokeExpr = new SQLMethodInvokeExpr("ANY");
methodInvokeExpr.addParameter(expr);
accept(Token.RPAREN);
return methodInvokeExpr;
SQLAnyExpr anyExpr = new SQLAnyExpr();
SQLSelect anySubQuery = createSelectParser().select();
anyExpr.setSubQuery(anySubQuery);
accept(Token.RPAREN);
anySubQuery.setParent(anyExpr);
sqlExpr = anyExpr;
sqlExpr = new SQLIdentifierExpr("ANY");
return sqlExpr;
ARRAY("ARRAY"),
public class PGDeleteTest6 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH moved_rows AS ("
+ "    DELETE FROM products"
+ "    WHERE"
+ "        "date" >= '2010-10-01' AND"
+ "        "date" < '2010-11-01'"
+ "    RETURNING *"
+ "INSERT INTO products_logn"
+ "SELECT * FROM moved_rows;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getColumns().size() == 1);
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("products", "date")));
public class PGDeleteTest7 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH t AS ("
+ "    DELETE FROM foo"
+ "DELETE FROM bar;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("foo")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("bar")));
Assert.assertTrue(visitor.getColumns().size() == 0);
public class PGDeleteTest8 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE included_parts(sub_part, part) AS ("
+ "    SELECT sub_part, part FROM parts WHERE part = 'our_product'"
+ "  UNION ALL"
+ "    SELECT p.sub_part, p.part"
+ "    FROM included_parts pr, parts p"
+ "    WHERE p.part = pr.sub_part"
+ "DELETE FROM partsn"
+ "  WHERE part IN (SELECT part FROM included_parts);";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("parts")));
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("included_parts")));
Assert.assertTrue(visitor.getColumns().size() == 4);
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("parts", "part")));
public class PGSelectTest12 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH regional_sales AS ("
+ "        SELECT region, SUM(amount) AS total_sales"
+ "        FROM orders"
+ "        GROUP BY region"
+ "     ), top_regions AS ("
+ "        SELECT region"
+ "        FROM regional_sales"
+ "        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)"
+ "     )n"
+ "SELECT region,"
+ "       product,"
+ "       SUM(quantity) AS product_units,"
+ "       SUM(amount) AS product_salesn"
+ "FROM ordersn"
+ "WHERE region IN (SELECT region FROM top_regions)n"
+ "GROUP BY region, product;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(4, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public class PGSelectTest13 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE t(n) AS ("
+ "    VALUES (1)"
+ "  UNION ALL"
+ "    SELECT n+1 FROM t WHERE n < 100"
+ "SELECT sum(n) FROM t;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public class PGSelectTest14 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE included_parts(sub_part, part, quantity) AS ("
+ "    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'"
+ "  UNION ALL"
+ "    SELECT p.sub_part, p.part, p.quantity"
+ "    FROM included_parts pr, parts p"
+ "    WHERE p.part = pr.sub_part"
+ "SELECT sub_part, SUM(quantity) as total_quantityn"
+ "FROM included_partsn"
+ "GROUP BY sub_part";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(5, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public class PGSelectTest15 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE search_graph(id, link, data, depth) AS ("
+ "        SELECT g.id, g.link, g.data, 1"
+ "        FROM graph g"
+ "      UNION ALL"
+ "        SELECT g.id, g.link, g.data, sg.depth + 1"
+ "        FROM graph g, search_graph sg"
+ "        WHERE g.id = sg.link"
+ "SELECT * FROM search_graph;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(6, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public class PGSelectTest16 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS ("
+ "        SELECT g.id, g.link, g.data, 1,"
+ "          ARRAY[g.id],"
+ "          false"
+ "        FROM graph g"
+ "      UNION ALL"
+ "        SELECT g.id, g.link, g.data, sg.depth + 1,"
+ "          path || g.id,"
+ "          g.id = ANY(path)"
+ "        FROM graph g, search_graph sg"
+ "        WHERE g.id = sg.link AND NOT cycle"
+ "SELECT * FROM search_graph;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(8, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public class PGSelectTest17 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS ("
+ "        SELECT g.id, g.link, g.data, 1,"
+ "          ARRAY[ROW(g.f1, g.f2)],"
+ "          false"
+ "        FROM graph g"
+ "      UNION ALL"
+ "        SELECT g.id, g.link, g.data, sg.depth + 1,"
+ "          path || ROW(g.f1, g.f2),"
+ "          ROW(g.f1, g.f2) = ANY(path)"
+ "        FROM graph g, search_graph sg"
+ "        WHERE g.id = sg.link AND NOT cycle"
+ "SELECT * FROM search_graph;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(10, visitor.getColumns().size());
Assert.assertEquals(2, visitor.getTables().size());
public class PGSelectTest18 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH RECURSIVE t(n) AS ("
+ "    SELECT 1"
+ "  UNION ALL"
+ "    SELECT n+1 FROM t"
+ "SELECT n FROM t LIMIT 100;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public class PGSelectTest19 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH t AS ("
+ "    UPDATE products SET price = price * 1.05"
+ "    RETURNING *"
+ "SELECT * FROM products;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
public class PGSelectTest20 extends PGTest {
public void test_0() throws Exception {
String sql = "WITH t AS ("
+ "    UPDATE products SET price = price * 1.05"
+ "    RETURNING *"
+ "SELECT * FROM t;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
} else if (item instanceof SQLCharExpr) {
if (((SQLCharExpr) item).getText().length() > 5) {
chrCount = 0;
continue;
if (chrCount >= 4) {
addViolation(visitor, ErrorCode.EVIL_CONCAT, "evil concat", x);
if (!hasSpecial) {
initBuff(bufPos);
arraycopy(mark + 1, buf, 0, bufPos);
hasSpecial = true;
public class Issue_697 extends TestCase {
public void test_for_issue() throws Exception {
String sql = "insert into tag_rule_detail(id, gmt_create, gmt_modified, group_id, priority, rule_condition, rule_action) values(1010102, now(), now(), 10101, 0, 'flow=''trustLogin''', 'be:login,dev:pc, env:web, type:trust_login, from:$loginfrom, result:true') ;n"
+ "insert into tag_rule_detail(id, gmt_create, gmt_modified, group_id, priority, rule_condition, rule_action) values(1010103, now(), now(), 10101, 0, 'flow=''Ctr''', 'be:login,dev:pc, env:web, type:ctr, from:$loginfrom, result:true') ;";
String expected = "INSERT INTO tag_rule_detail (id, gmt_create, gmt_modified, group_id, priority"
+ "nt, rule_condition, rule_action)"
+ "nVALUES (1010102, now(), now(), 10101, 0"
+ "nt, 'flow=''trustLogin''', 'be:login,dev:pc, env:web, type:trust_login, from:$loginfrom, result:true');"
+ "nINSERT INTO tag_rule_detail (id, gmt_create, gmt_modified, group_id, priority"
+ "nt, rule_condition, rule_action)"
+ "nVALUES (1010103, now(), now(), 10101, 0"
+ "nt, 'flow=''Ctr''', 'be:login,dev:pc, env:web, type:ctr, from:$loginfrom, result:true');n";
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.print(";");
visitor.println();
System.out.println(out.toString());
Assert.assertEquals(expected, out.toString());
public void scanNumber() {
mark = pos;
if (ch == '-') {
ch = charAt(++pos);
for (;;) {
if (ch >= '0' && ch <= '9') {
ch = charAt(++pos);
boolean isDouble = false;
if (ch == '.') {
if (charAt(pos + 1) == '.') {
token = Token.LITERAL_INT;
ch = charAt(++pos);
isDouble = true;
for (;;) {
if (ch >= '0' && ch <= '9') {
ch = charAt(++pos);
if (ch == 'e' || ch == 'E') {
ch = charAt(++pos);
if (ch == '+' || ch == '-') {
ch = charAt(++pos);
for (;;) {
if (ch >= '0' && ch <= '9') {
ch = charAt(++pos);
isDouble = true;
if (isDouble) {
token = Token.LITERAL_FLOAT;
if (isFirstIdentifierChar(ch) && !(ch == 'b' && bufPos == 1 && charAt(pos - 1) == '0')) {
for (;;) {
ch = charAt(++pos);
if (!isIdentifierChar(ch)) {
stringVal = addSymbol();
token = Token.IDENTIFIER;
token = Token.LITERAL_INT;
if (isDigit(ch) && !isFirstIdentifierChar(charAt(pos - 2))) {
sql += " or id=0";
sql += " and id=0";
public class IdentifierTest extends TestCase {
public void test_0() throws Exception {
String sql = "SELECT t.1c FROM tab t";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT t.1cnFROM tab t;", text);
public void test_1() throws Exception {
String sql = "SELECT tid,seller_nick,jdp_response from 2df1479e96cb4ac8b57f2502b5425bb5";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT tid, seller_nick, jdp_responsenFROM 2df1479e96cb4ac8b57f2502b5425bb5;", text);
public void test_2() throws Exception {
String sql = "SELECT 1 ^ 1";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT 1 ^ 1;", text);
public void test_3() throws Exception {
String sql = "SELECT 1 ^ 0";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT 1 ^ 0;", text);
public void test_4() throws Exception {
String sql = "SELECT 1 << 2";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT 1 << 2;", text);
public void test_5() throws Exception {
String sql = "SELECT 4 >> 2";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT 4 >> 2;", text);
public void test_6() throws Exception {
String sql = "SELECT 5 & ~1";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT 5 & ~1;", text);
public void test_7() throws Exception {
String sql = "SELECT BIT_COUNT(29), BIT_COUNT(b'101010');";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT BIT_COUNT(29), BIT_COUNT(b'101010');", text);
public void test_8() throws Exception {
String sql = "SET @v2 = CAST(0b1000001 AS UNSIGNED), @v3 = 0b1000001+0;";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SET @v2 = CAST(b'1000001' AS UNSIGNED), @v3 = b'1000001' + 0;", text);
public void test_9() throws Exception {
String sql = "SELECT b+0, BIN(b+0), OCT(b+0), HEX(b+0) FROM t;";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("SELECT b + 0, BIN(b + 0), OCT(b + 0), HEX(b + 0)nFROM t;", text);
private String output(List<SQLStatement> stmtList) {
StringBuilder out = new StringBuilder();
for (SQLStatement stmt : stmtList) {
stmt.accept(new MySqlOutputVisitor(out));
out.append(";");
return out.toString();
private List<SQLExpr>  setList                   = new ArrayList<SQLExpr>();
private List<SQLExpr>  columns                   = new ArrayList<SQLExpr>();
public List<SQLExpr> getColumns() {
return columns;
public void setColumns(List<SQLExpr> columns) {
this.columns = columns;
public void setSetList(List<SQLExpr> setList) {
this.setList = setList;
lexer.nextToken();
if (identifierEquals("TERMINATED")) {
lexer.nextToken();
accept(Token.BY);
stmt.setColumnsTerminatedBy((SQLLiteralExpr) this.exprParser.expr());
if (identifierEquals("OPTIONALLY")) {
stmt.setColumnsEnclosedOptionally(true);
lexer.nextToken();
if (identifierEquals("ENCLOSED")) {
lexer.nextToken();
accept(Token.BY);
stmt.setColumnsEnclosedBy((SQLLiteralExpr) this.exprParser.expr());
if (identifierEquals("ESCAPED")) {
lexer.nextToken();
accept(Token.BY);
stmt.setColumnsEscaped((SQLLiteralExpr) this.exprParser.expr());
lexer.nextToken();
if (identifierEquals("STARTING")) {
lexer.nextToken();
accept(Token.BY);
stmt.setLinesStartingBy((SQLLiteralExpr) this.exprParser.expr());
if (identifierEquals("TERMINATED")) {
lexer.nextToken();
accept(Token.BY);
stmt.setLinesTerminatedBy((SQLLiteralExpr) this.exprParser.expr());
lexer.nextToken();
stmt.setIgnoreLinesNumber((SQLLiteralExpr) this.exprParser.expr());
acceptIdentifier("LINES");
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
this.exprParser.exprList(stmt.getColumns(), stmt);
accept(Token.RPAREN);
lexer.nextToken();
this.exprParser.exprList(stmt.getSetList(), stmt);
if(x.getIgnoreLinesNumber() != null) {
print(" IGNORE ");
x.getIgnoreLinesNumber().accept(this);
print(" LINES");
if (x.getColumns().size() != 0) {
print(" (");
printAndAccept(x.getColumns(), ", ");
print(")");
public void test_1() throws Exception {
String sql = "LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test COLUMNS TERMINATED BY ',' LINES STARTING BY 'xxx';",
public void test_2() throws Exception {
String sql = "LOAD DATA INFILE '/home/Order.txt' INTO TABLE Orders (Order_Number, Order_Date, Customer_ID);";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("LOAD DATA INFILE '/home/Order.txt' INTO TABLE Orders (Order_Number, Order_Date, Customer_ID);",
public void test_3() throws Exception {
String sql = "LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY 'rn' IGNORE 1 LINES;";
SQLStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
String text = output(stmtList);
Assert.assertEquals("LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name COLUMNS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY 'rn' IGNORE 1 LINES;",
if (!isHint && !isAllowComment() && !isSafeComment(stringVal)) {
if (token != Token.HINT && !isAllowComment() && !isSafeComment(stringVal)) {
if (!isAllowComment() && (isEOF() || !isSafeComment(stringVal))) {
throw new NotAllowCommentException();
protected boolean isSafeComment(String comment) {
if (comment == null) {
return true;
comment = comment.toLowerCase();
if (comment.indexOf("select") != -1 
|| comment.indexOf("delete") != -1 
|| comment.indexOf("insert") != -1 
|| comment.indexOf("update") != -1 
|| comment.indexOf("into") != -1 
|| comment.indexOf("where") != -1 
|| comment.indexOf("or") != -1 
|| comment.indexOf("and") != -1 
|| comment.indexOf("union") != -1 
|| comment.indexOf(''') != -1 
|| comment.indexOf('=') != -1 
|| comment.indexOf('>') != -1 
|| comment.indexOf('<') != -1 
|| comment.indexOf('&') != -1 
|| comment.indexOf('|') != -1 
|| comment.indexOf('^') != -1 
return false;
return true;
Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT * from t where a=1  and b=1"));
private String sql = "select f1 from t where a=1  and b=1 ";
visitor.setSqlEndOfComment(endOfComment);
boolean isSqlEndOfComment();
void setSqlEndOfComment(boolean sqlEndOfComment);
private final List<Violation> violations      = new ArrayList<Violation>();
private boolean               sqlModified     = false;
private boolean               sqlEndOfComment = false;
public boolean isSqlEndOfComment() {
return this.sqlEndOfComment;
public void setSqlEndOfComment(boolean sqlEndOfComment) {
this.sqlEndOfComment = sqlEndOfComment;
private final List<Violation> violations      = new ArrayList<Violation>();
private boolean               sqlModified     = false;
private boolean               sqlEndOfComment = false;
public boolean isSqlEndOfComment() {
return this.sqlEndOfComment;
public void setSqlEndOfComment(boolean sqlEndOfComment) {
this.sqlEndOfComment = sqlEndOfComment;
private final List<Violation> violations      = new ArrayList<Violation>();
private boolean               sqlModified     = false;
private boolean               sqlEndOfComment = false;
@Override
public boolean isSqlEndOfComment() {
return this.sqlEndOfComment;
@Override
public void setSqlEndOfComment(boolean sqlEndOfComment) {
this.sqlEndOfComment = sqlEndOfComment;
private final List<Violation> violations      = new ArrayList<Violation>();
private boolean               sqlModified     = false;
private boolean               sqlEndOfComment = false;
public boolean isSqlEndOfComment() {
return this.sqlEndOfComment;
public void setSqlEndOfComment(boolean sqlEndOfComment) {
this.sqlEndOfComment = sqlEndOfComment;
private final List<Violation> violations      = new ArrayList<Violation>();
private boolean               sqlModified     = false;
private boolean               sqlEndOfComment = false;
@Override
public boolean isSqlEndOfComment() {
return this.sqlEndOfComment;
@Override
public void setSqlEndOfComment(boolean sqlEndOfComment) {
this.sqlEndOfComment = sqlEndOfComment;
if (visitor.getConfig().isSelectWhereAlwayTrueCheck() && visitor.isSqlEndOfComment()
&& !isSimpleConstExpr(where)) {
if (visitor.getConfig().isSelectHavingAlwayTrueCheck() && visitor.isSqlEndOfComment()
&& !isSimpleConstExpr(x)) {
if (config.isDeleteWhereAlwayTrueCheck() && visitor.isSqlEndOfComment() && !isSimpleConstExpr(where)) {
if (config.isUpdateWhereAlayTrueCheck() && visitor.isSqlEndOfComment()&& !isSimpleConstExpr(where)) {
if (current.hasPartAlwayTrue() && !visitor.getConfig().isConditionAndAlwayTrueAllow()) {
if (((x.getOperator() == SQLUnionOperator.UNION || x.getOperator() == SQLUnionOperator.UNION_ALL || x.getOperator() == SQLUnionOperator.DISTINCT)
&& visitor.getConfig().isSelectUnionCheck() && visitor.isSqlEndOfComment())
String sql = "SELECT * FROM mp_Sites WHERE SiteID = -1 OR -1 = -1 --ORDER BY SiteID LIMIT 1 ";
String sql = "select cid,title,id,img,fan from duoduo_mall where cid = cid and 1=1 --order by sort desc limit 17 ";
String sql = "select count(1) as cot from w36ma_picking where (picking_no='' or ''='') and (DATE_FORMAT(create_time,'%Y-%m-%d') = '' or ''='') --";
String sql = " select pg.*,an1.w36ma_name as create_name, an2.w36ma_name as print_name, an2.w36ma_name as receive_name, an2.w36ma_name as products_name, an2.w36ma_name as warehouse_name from w36ma_picking as pg left join iweb_admin as an1 on pg.create_name_id=an1.id left join iweb_admin as an2 on pg.print_name_id=an2.id left join iweb_admin as an3 on pg.receive_name_id=an3.id left join iweb_admin as an4 on pg.products_name_id=an4.id left join iweb_admin as an5 on pg.warehouse_name_id=an5.id where (pg.picking_no='' or ''='') and (DATE_FORMAT(pg.create_time,'%Y-%m-%d') = '' or ''='') --limit 0,20 ";
String sql = "SELECT * FROM `oammxncom2014`.`ecs_free_bank` where id=1 or 1='1' --";
public class WallDeleteWhereTest2 extends TestCase {
private String sql = "DELETE FROM T WHERE id = 0 or 1 = 1 --";
private String sql1 = "DELETE FROM T WHERE id = 0 or 1 = 1 #and c=1";
public void test_check_true() throws Exception {
WallConfig config = new WallConfig();
config.setDeleteWhereAlwayTrueCheck(true);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
Assert.assertFalse(WallUtils.isValidateMySql(sql1, config));
public void test_check_false() throws Exception {
WallConfig config = new WallConfig();
config.setDeleteWhereAlwayTrueCheck(false);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
Assert.assertTrue(WallUtils.isValidateMySql(sql1, config));
public class WallHavingTest6 extends TestCase {
private String sql = "SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region HAVING SUM(area)>1000000 or 1 = 1 --";
private String sql1 = "SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region HAVING SUM(area)>1000000 or 1 = 1 #and c=1";
public void test_check_true() throws Exception {
WallConfig config = new WallConfig();
config.setSelectHavingAlwayTrueCheck(true);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
Assert.assertFalse(WallUtils.isValidateMySql(sql1, config));
public void test_check_false() throws Exception {
WallConfig config = new WallConfig();
config.setSelectHavingAlwayTrueCheck(false);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
Assert.assertTrue(WallUtils.isValidateMySql(sql1, config));
public class WallSelectWhereTest6 extends TestCase {
private String sql = "SELECT * FROM T WHERE id = 0 or 1 = 1 --";
private String sql1 = "SELECT * FROM T WHERE id = 0 or 1 = 1 #and c=1";
public void test_check_true() throws Exception {
WallConfig config = new WallConfig();
config.setSelectWhereAlwayTrueCheck(true);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
Assert.assertFalse(WallUtils.isValidateMySql(sql1, config));
public void test_check_false() throws Exception {
WallConfig config = new WallConfig();
config.setSelectWhereAlwayTrueCheck(false);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
Assert.assertTrue(WallUtils.isValidateMySql(sql1, config));
public class WallUpdateWhereTest1 extends TestCase {
private String sql  = "update wx_shop set shop_view = shop_view + 1 where id = 118 OR 69=69 LIMIT 100 --";
private String sql1 = "update wx_shop set shop_view = shop_view + 1 where id = 118 OR 69=69 LIMIT 100 #and c=1";
public void test_check_true() throws Exception {
WallConfig config = new WallConfig();
config.setUpdateWhereAlayTrueCheck(true);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
Assert.assertFalse(WallUtils.isValidateMySql(sql1, config));
public void test_check_false() throws Exception {
WallConfig config = new WallConfig();
config.setUpdateWhereAlayTrueCheck(false);
config.setConditionAndAlwayTrueAllow(true);
config.setCommentAllow(true);
Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
Assert.assertTrue(WallUtils.isValidateMySql(sql1, config));
public class DruidDataSource extends DruidAbstractDataSource
implements DruidDataSourceMBean
, ManagedDataSource
, Referenceable
, Closeable
, Cloneable
, ConnectionPoolDataSource
, MBeanRegistration {
public class SQLTimestampExpr extends SQLExprImpl {
protected String  literal;
protected String  timeZone;
protected boolean withTimeZone = false;
public SQLTimestampExpr(){
public String getLiteral() {
return literal;
public void setLiteral(String literal) {
this.literal = literal;
public String getTimeZone() {
return this.timeZone;
public void setTimeZone(String timeZone) {
this.timeZone = timeZone;
public boolean isWithTimeZone() {
return withTimeZone;
public void setWithTimeZone(boolean withTimeZone) {
this.withTimeZone = withTimeZone;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((literal == null) ? 0 : literal.hashCode());
result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
result = prime * result + (withTimeZone ? 1231 : 1237);
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLTimestampExpr other = (SQLTimestampExpr) obj;
if (literal == null) {
if (other.literal != null) {
return false;
} else if (!literal.equals(other.literal)) {
return false;
if (timeZone == null) {
if (other.timeZone != null) {
return false;
} else if (!timeZone.equals(other.timeZone)) {
return false;
if (withTimeZone != other.withTimeZone) {
return false;
return true;
protected void accept0(SQLASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public String toString() {
return SQLUtils.toSQLString(this, null);
SQLTimestampExpr timestamp = new SQLTimestampExpr();
if (expr.getClass() == SQLIdentifierExpr.class) {
String ident = ((SQLIdentifierExpr)expr).getName();
if ("TIMESTAMP".equalsIgnoreCase(ident)) {
if (lexer.token() != Token.LITERAL_ALIAS 
&& lexer.token() != Token.LITERAL_CHARS 
&& lexer.token() != Token.WITH) {
return new SQLIdentifierExpr("TIMESTAMP");
SQLTimestampExpr timestamp = new SQLTimestampExpr();
if (lexer.token() == Token.WITH) {
lexer.nextToken();
acceptIdentifier("TIME");
acceptIdentifier("ZONE");
timestamp.setWithTimeZone(true);
String literal = lexer.stringVal();
timestamp.setLiteral(literal);
accept(Token.LITERAL_CHARS);
if (identifierEquals("AT")) {
lexer.nextToken();
acceptIdentifier("TIME");
acceptIdentifier("ZONE");
String timezone = lexer.stringVal();
timestamp.setTimeZone(timezone);
accept(Token.LITERAL_CHARS);
return primaryRest(timestamp);
public boolean visit(SQLTimestampExpr x) {
print("TIMESTAMP ");
if (x.isWithTimeZone()) {
print(" WITH TIME ZONE ");
print(''');
print(x.getLiteral());
print(''');
if (x.getTimeZone() != null) {
print(" AT TIME ZONE '");
print(x.getTimeZone());
print(''');
return false;
void endVisit(SQLTimestampExpr x);
boolean visit(SQLTimestampExpr x);
public void endVisit(SQLTimestampExpr x) {
public boolean visit(SQLTimestampExpr x) {
return true;
for (int i = 0; i < fields.size(); ++i) {
SQLTimestampExpr exprA, exprB, exprC;
exprA = (SQLTimestampExpr) parser.expr();
exprB = (SQLTimestampExpr) parser.expr();
exprC = (SQLTimestampExpr) parser.expr();
Assert.assertEquals(new SQLTimestampExpr(), new SQLTimestampExpr());
Assert.assertEquals(new SQLTimestampExpr().hashCode(), new SQLTimestampExpr().hashCode());
new SQLTimestampExpr().accept(adapter);
public class BooleanTest extends PGTest {
public void test_0() throws Exception {
String sql = "INSERT INTO test1 VALUES (TRUE, 'sic est');";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test1")));
Assert.assertEquals(0, visitor.getColumns().size());
public class TimestampTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "TIMESTAMP '2004-10-19 10:23:54+02'";
PGExprParser parser = new PGExprParser(sql);
SQLTimestampExpr expr = (SQLTimestampExpr) parser.expr();
System.out.println(expr.toString());
public void test_timestamp_with_timezone() throws Exception {
String sql = "TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'";
PGExprParser parser = new PGExprParser(sql);
SQLTimestampExpr expr = (SQLTimestampExpr) parser.expr();
System.out.println(expr.toString());
private SQLObject           on;
public SQLGrantStatement(){
public SQLGrantStatement(String dbType){
super(dbType);
private SQLObjectType objectType;
private SQLExpr       maxQueriesPerHour;
private SQLExpr       maxUpdatesPerHour;
private SQLExpr       maxConnectionsPerHour;
private SQLExpr       maxUserConnections;
private boolean       adminOption;
private SQLExpr       identifiedBy;
public SQLObjectType getObjectType() {
public void setObjectType(SQLObjectType objectType) {
public SQLObject getOn() {
public void setOn(SQLObject on) {
on.setParent(this);
public enum SQLObjectType {
TABLE, FUNCTION, PROCEDURE, U
public class SQLRevokeStatement extends SQLStatementImpl {
private final List<SQLExpr> privileges = new ArrayList<SQLExpr>();
private SQLObject           on;
private SQLExpr             from;
private SQLObjectType       objectType;
public SQLRevokeStatement(){
public SQLRevokeStatement(String dbType){
super(dbType);
public SQLObject getOn() {
return on;
public void setOn(SQLObject on) {
this.on = on;
public SQLExpr getFrom() {
return from;
public void setFrom(SQLExpr from) {
this.from = from;
public List<SQLExpr> getPrivileges() {
return privileges;
public SQLObjectType getObjectType() {
return objectType;
public void setObjectType(SQLObjectType objectType) {
this.objectType = objectType;
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, on);
acceptChild(visitor, from);
visitor.endVisit(this);
if (lexer.token() == Token.REVOKE) {
statementList.add(this.parseRevoke());
map.put("REVOKE", Token.REVOKE);
case REVOK
case REVOK
if (lexer.token() == Token.REVOKE) {
SQLStatement stmt = parseRevoke();
statementList.add(stmt);
continue;
parsePrivileages(stmt.getPrivileges(), stmt);
if (lexer.token() == Token.ON) {
lexer.nextToken();
if (lexer.token() == Token.PROCEDURE) {
lexer.nextToken();
stmt.setObjectType(SQLObjectType.PROCEDURE);
} else if (lexer.token() == Token.FUNCTION) {
lexer.nextToken();
stmt.setObjectType(SQLObjectType.FUNCTION);
} else if (lexer.token() == Token.TABLE) {
lexer.nextToken();
stmt.setObjectType(SQLObjectType.TABLE);
} else if (lexer.token() == Token.USER) {
lexer.nextToken();
stmt.setObjectType(SQLObjectType.USER);
SQLExpr expr = this.exprParser.expr();
if (stmt.getObjectType() == SQLObjectType.TABLE || stmt.getObjectType() == null) {
stmt.setOn(new SQLExprTableSource(expr));
stmt.setOn(expr);
if (lexer.token() == Token.TO) {
lexer.nextToken();
stmt.setTo(this.exprParser.expr());
if (lexer.token() == Token.WITH) {
lexer.nextToken();
for (;;) {
if (identifierEquals("MAX_QUERIES_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxQueriesPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_UPDATES_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxUpdatesPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_CONNECTIONS_PER_HOUR")) {
lexer.nextToken();
stmt.setMaxConnectionsPerHour(this.exprParser.primary());
continue;
if (identifierEquals("MAX_USER_CONNECTIONS")) {
lexer.nextToken();
stmt.setMaxUserConnections(this.exprParser.primary());
continue;
if (identifierEquals("ADMIN")) {
lexer.nextToken();
acceptIdentifier("OPTION");
stmt.setAdminOption(true);
if (lexer.token() == Token.IDENTIFIED) {
lexer.nextToken();
accept(Token.BY);
stmt.setIdentifiedBy(this.exprParser.expr());
return stmt;
protected void parsePrivileages(List<SQLExpr> privileges, SQLObject parent) {
expr.setParent(parent);
privileges.add(expr);
public SQLRevokeStatement parseRevoke() {
accept(Token.REVOKE);
SQLRevokeStatement stmt = new SQLRevokeStatement(getDbType());
parsePrivileages(stmt.getPrivileges(), stmt);
stmt.setObjectType(SQLObjectType.PROCEDURE);
stmt.setObjectType(SQLObjectType.FUNCTION);
stmt.setObjectType(SQLObjectType.TABLE);
stmt.setObjectType(SQLObjectType.USER);
SQLExpr expr = this.exprParser.expr();
if (stmt.getObjectType() == SQLObjectType.TABLE || stmt.getObjectType() == null) {
stmt.setOn(new SQLExprTableSource(expr));
stmt.setOn(expr);
if (lexer.token() == Token.FROM) {
stmt.setFrom(this.exprParser.expr());
REVOKE("REVOKE"),
public boolean visit(SQLRevokeStatement x) {
print("ROVOKE ");
printAndAccept(x.getPrivileges(), ", ");
if (x.getOn() != null) {
print(" ON ");
if (x.getObjectType() != null) {
print(x.getObjectType().name());
print(' ');
x.getOn().accept(this);
if (x.getFrom() != null) {
print(" FROM ");
x.getFrom().accept(this);
return false;
void endVisit(SQLRevokeStatement x);
boolean visit(SQLRevokeStatement x);
public void endVisit(SQLRevokeStatement x) {
public boolean visit(SQLRevokeStatement x) {
return true;
if (x.getOn() != null && (x.getObjectType() == null || x.getObjectType() == SQLObjectType.TABLE)) {
x.getOn().accept(this);
return false;
@Override
public boolean visit(SQLRevokeStatement x) {
if (x.getOn() != null) {
x.getOn().accept(this);
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("p4p_pro")));
Assert.assertEquals(1, visitor.getTables().size());
public class PGGrantTest0 extends PGTest {
public void test_0 () throws Exception {
String sql = "GRANT UPDATE ON accounts TO joe;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("accounts")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("accounts")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("accounts")).getAlterCount() == 0);
Assert.assertTrue(visitor.getColumns().size() == 0);
public class PGRovokeTest0 extends PGTest {
public void test_0 () throws Exception {
String sql = "REVOKE ALL ON accounts FROM PUBLIC;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("accounts")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("accounts")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("accounts")).getAlterCount() == 0);
Assert.assertTrue(visitor.getColumns().size() == 0);
public boolean visit(SQLCharExpr x) {
if (x.getText() != null && x.getText().length() == 0) {
print("NULL");
super.visit(x);
return false;
if (x.getText() == null) {
SQLExpr expr = x.getExpr();
boolean needQuote = false;
if (expr instanceof SQLBinaryOpExpr) {
SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) expr;
switch (binaryOpExpr.getOperator()) {
case BooleanAnd
case BooleanOr
case BooleanXor
needQuote = true;
if (needQuote) {
print('(');
expr.accept(this);
if (needQuote) {
print(')');
if (x.isConnectByRoot()) {
if (x.isOrReplace()) {
public class SQLServerSelectTest17 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT CIM_ASSET_TYPE.ID"
+ "nFROM CIM_ASSET_TYPE"
+ "nWHERE CIM_ASSET_TYPE.DEL_STATUS = '0'"
+ "nAND NOT ("
+ "nCIM_ASSET_TYPE.MODEL_TABLE IS NULL"
+ "nOR CIM_ASSET_TYPE.MODEL_TABLE = ''"
String expect = "SELECT CIM_ASSET_TYPE.ID"
+ "nFROM CIM_ASSET_TYPE"
+ "nWHERE CIM_ASSET_TYPE.DEL_STATUS = '0'"
+ "ntAND NOT (CIM_ASSET_TYPE.MODEL_TABLE IS NULL"
+ "ntOR CIM_ASSET_TYPE.MODEL_TABLE = '')";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
TABLE, FUNCTION, PROCEDURE, USER, DATAB
protected List<SQLHint>           hints;
public class SQLServerSelect extends SQLSelect implements SQLServerObject {
private boolean      forBrowse;
private List<String> forXmlOptions = new ArrayList<String>(4);
public boolean isForBrowse() {
return forBrowse;
public void setForBrowse(boolean forBrowse) {
this.forBrowse = forBrowse;
public List<String> getForXmlOptions() {
return forXmlOptions;
public void setForXmlOptions(List<String> forXmlOptions) {
this.forXmlOptions = forXmlOptions;
@Override
protected void accept0(SQLASTVisitor visitor) {
this.accept0((SQLServerASTVisitor) visitor);
@Override
public void accept0(SQLServerASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.query);
acceptChild(visitor, this.orderBy);
acceptChild(visitor, this.hints);
visitor.endVisit(this);
@Override
public int hashCode() {
final int prime = 31;
int result = super.hashCode();
result = prime * result + (forBrowse ? 1231 : 1237);
result = prime * result + ((forXmlOptions == null) ? 0 : forXmlOptions.hashCode());
return result;
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (!super.equals(obj)) {
return false;
if (getClass() != obj.getClass()) {
return false;
SQLServerSelect other = (SQLServerSelect) obj;
if (forBrowse != other.forBrowse) {
return false;
if (forXmlOptions == null) {
if (other.forXmlOptions != null) {
return false;
} else if (!forXmlOptions.equals(other.forXmlOptions)) {
return false;
return true;
public SQLSelect select() {
if (lexer.token() == Token.FOR) {
lexer.nextToken();
if (identifierEquals("BROWSE")) {
lexer.nextToken();
select.setForBrowse(true);
} else if (identifierEquals("XML")) {
lexer.nextToken();
for (;;) {
if (identifierEquals("AUTO") 
|| identifierEquals("TYPE") 
|| identifierEquals("XMLSCHEMA") 
select.getForXmlOptions().add(lexer.stringVal());
lexer.nextToken();
} else if (identifierEquals("ELEMENTS")) {
lexer.nextToken();
if (identifierEquals("XSINIL")) {
lexer.nextToken();
select.getForXmlOptions().add("ELEMENTS XSINIL");
select.getForXmlOptions().add("ELEMENTS");
if (lexer.token() == Token.COMMA) {
lexer.nextToken();
continue;
throw new ParserException("syntax error, not support option : " + lexer.token());
public SQLSelectQuery query() {
boolean visit(SQLServerSelect x);
void endVisit(SQLServerSelect x);
@Override
public boolean visit(SQLServerSelect x) {
return true;
@Override
public void endVisit(SQLServerSelect x) {
@Override
protected void printGrantOn(SQLGrantStatement x) {
if (x.getOn() != null) {
print(" ON ");
if (x.getObjectType() != null) {
print(x.getObjectType().name());
print("::");
x.getOn().accept(this);
@Override
public void endVisit(SQLServerSelect x) {
@Override
public boolean visit(SQLServerSelect x) {
super.visit(x);
if (x.isForBrowse()) {
println();
print("FOR BROWSE");
if (x.getForXmlOptions().size() > 0) {
println();
print("FOR XML ");
for (int i = 0; i < x.getForXmlOptions().size(); ++i) {
if (i != 0) {
print(", ");
print(x.getForXmlOptions().get(i));
return false;
@Override
public boolean visit(SQLServerSelect x) {
return super.visit(x);
@Override
public void endVisit(SQLServerSelect x) {
} else if (lexer.token() == Token.DATABASE) {
lexer.nextToken();
stmt.setObjectType(SQLObjectType.DATABASE);
if (stmt.getObjectType() != null && lexer.token() == Token.COLONCOLON) {
lexer.nextToken(); 
} else if (identifierEquals("CONTROL")) { 
lexer.nextToken();
privilege = "CONTROL";
} else if (identifierEquals("IMPERSONATE")) { 
lexer.nextToken();
privilege = "IMPERSONATE";
printGrantOn(x);
protected void printGrantOn(SQLGrantStatement x) {
if (x.getOn() != null) {
print(" ON ");
if (x.getObjectType() != null) {
print(x.getObjectType().name());
print(' ');
x.getOn().accept(this);
public class OdpsListResourcesTest extends TestCase {
public void test_0() throws Exception {
exec_test("bvt/parser/odps-3.sql");
public void exec_test(String resource) throws Exception {
System.out.println(resource);
InputStream is = null;
is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
Reader reader = new InputStreamReader(is, "UTF-8");
String input = Utils.read(reader);
JdbcUtils.close(reader);
String[] items = input.split("---------------------------");
String sql = items[0].trim();
String expect = items[1].trim();
OdpsStatementParser parser = new OdpsStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
Assert.assertEquals(1, statementList.size());
SchemaStatVisitor visitor = new OdpsSchemaStatVisitor();
stmt.accept(visitor);
System.out.println(sql);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println();
System.out.println("---------------------------");
System.out.println(SQLUtils.toOdpsString(stmt));
void mergValidate(String sql, String expect) {
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
Assert.assertEquals(1, statementList.size());
StringBuilder out = new StringBuilder();
MySqlParameterizedOutputVisitor visitor = new MySqlParameterizedOutputVisitor(out);
statemen.accept(visitor);
System.out.println(out.toString());
Assert.assertEquals(expect, out.toString());
public class SQLServerSelectTest18 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT T0.[Address], T0.[Address] "
+ "FROM [dbo].[CRD1] T0 " 
+ "WHERE T0.[CardCode] = (@P1) AND T0.[AdresType] = (@P2) " 
+ "ORDER BY T0.[Address] " 
+ "FOR BROWSE"; 
String expect = "SELECT T0.[Address], T0.[Address]"
+ "nFROM [dbo].[CRD1] T0"
+ "nWHERE T0.[CardCode] = @P1"
+ "ntAND T0.[AdresType] = @P2"
+ "nORDER BY T0.[Address]"
+ "nFOR BROWSE";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerSelectTest19 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT p.BusinessEntityID, FirstName, LastName, PhoneNumber AS Phone"
+ "nFROM Person.Person AS p"
+ "nJOIN Person.PersonPhone AS pph ON p.BusinessEntityID  = pph.BusinessEntityID"
+ "nWHERE LastName LIKE 'G%'"
+ "nORDER BY LastName, FirstName "
+ "nFOR XML AUTO, TYPE, XMLSCHEMA, ELEMENTS XSINIL;"; 
String expect = "SELECT p.BusinessEntityID, FirstName, LastName, PhoneNumber AS Phone"
+ "nFROM Person.Person p"
+ "ntJOIN Person.PersonPhone pph ON p.BusinessEntityID = pph.BusinessEntityID"
+ "nWHERE LastName LIKE 'G%'"
+ "nORDER BY LastName, FirstName"
+ "nFOR XML , TYPE, XMLSCHEMA, ELEMENTS XSINIL";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerGrantTest_0 extends TestCase {
public void test_grants() throws Exception {
String sql = "grant all on database::TestDataBase to User1";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("GRANT ALL ON DATABASE::TestDataBase TO User1", output);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class SQLServerGrantTest_1 extends TestCase {
public void test_grants() throws Exception {
String sql = "GRANT CONTROL ON USER::Wanida TO RolandX;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("GRANT CONTROL ON USER::Wanida TO RolandX", output);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
public class SQLServerGrantTest_2 extends TestCase {
public void test_grants() throws Exception {
String sql = "GRANT IMPERSONATE ON USER::HamithaL TO AccountsPayable17;";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
SQLServerSchemaStatVisitor visitor = new SQLServerSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
String output = SQLUtils.toSQLString(stmt, JdbcConstants.SQL_SERVER);
Assert.assertEquals("GRANT IMPERSONATE ON USER::HamithaL TO AccountsPayable17", output);
Assert.assertEquals(0, visitor.getTables().size());
Assert.assertEquals(0, visitor.getColumns().size());
new SQLNumberExpr(offset), 
JdbcConstants.DB2);
new SQLNumberExpr(count + offset), 
JdbcConstants.DB2);
SQLBinaryOpExpr pageCondition = new SQLBinaryOpExpr(gt, SQLBinaryOperator.BooleanAnd, lteq, JdbcConstants.DB2);
new SQLNumberExpr(offset), 
JdbcConstants.SQL_SERVER
new SQLNumberExpr(count + offset), 
JdbcConstants.SQL_SERVER);
SQLBinaryOpExpr pageCondition = new SQLBinaryOpExpr(gt, SQLBinaryOperator.BooleanAnd, lteq, JdbcConstants.SQL_SERVER);
new SQLNumberExpr(count), 
JdbcConstants.ORACLE
condition, 
JdbcConstants.ORACLE
new SQLNumberExpr(count + offset), 
JdbcConstants.ORACLE));
new SQLNumberExpr(offset), 
JdbcConstants.ORACLE));
private String            dbType;
public SQLBinaryOpExpr(String dbType){
this.dbType = dbType;
public SQLBinaryOpExpr(SQLExpr left, SQLBinaryOperator operator, SQLExpr right){
this(left, operator, right, null);
public SQLBinaryOpExpr(SQLExpr left, SQLBinaryOperator operator, SQLExpr right, String dbType){
this.dbType = dbType;
public String getDbType() {
return dbType;
public void setDbType(String dbType) {
this.dbType = dbType;
return SQLUtils.toSQLString(this, getDbType());
public boolean isLogical() {
return this == BooleanAnd || this == BooleanOr || this == BooleanXor;
NOT("NOT"),
Pound("#") 
return new SQLBinaryOpExpr(expr, SQLBinaryOperator.RegExp, rightExp, JdbcConstants.MYSQL);
return new SQLBinaryOpExpr(expr, SQLBinaryOperator.Modulus, rightExp, JdbcConstants.MYSQL);
return new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotRegExp, rightExp, JdbcConstants.MYSQL);
new SQLIdentifierExpr(collate), JdbcConstants.MYSQL);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, JdbcConstants.MYSQL);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, JdbcConstants.MYSQL);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Add, rightExp, JdbcConstants.MYSQL);
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Subtract, rightExp, JdbcConstants.MYSQL);
this.dbType = JdbcConstants.ORACLE;
this.dbType = JdbcConstants.ORACLE;
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.IsNot, rightExpr, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Is, rightExpr, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Equality, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotEqual, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Assignment, right, getDbType());
public class PGBoxExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGBoxExpr other = (PGBoxExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public enum PGDateField {
MICROSECONDS,
MILLENNIUM,
MILLISECONDS,
TIMEZONE_HOUR,
TIMEZONE_MINUTE,
public String toString() {
return SQLUtils.toPGString(this);
public class PGExtractExpr extends PGExprImpl {
private PGDateField field;
private SQLExpr     source;
public PGDateField getField() {
return field;
public void setField(PGDateField field) {
this.field = field;
public SQLExpr getSource() {
return source;
public void setSource(SQLExpr source) {
this.source = source;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, source);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((field == null) ? 0 : field.hashCode());
result = prime * result + ((source == null) ? 0 : source.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGExtractExpr other = (PGExtractExpr) obj;
if (field != other.field) {
return false;
if (source == null) {
if (other.source != null) {
return false;
} else if (!source.equals(other.source)) {
return false;
return true;
public class PGPointExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGPointExpr other = (PGPointExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public String toString() {
return SQLUtils.toPGString(this);
this.dbType = JdbcConstants.POSTGRESQL;
this.dbType = JdbcConstants.POSTGRESQL;
} else if (lexer.token() == Token.POUND) {
lexer.nextToken();
if (lexer.token() == Token.LBRACE) {
lexer.nextToken();
String varName = lexer.stringVal();
lexer.nextToken();
accept(Token.RBRACE);
SQLVariantRefExpr expr = new SQLVariantRefExpr("#{" + varName + "}");
return primaryRest(expr);
SQLExpr value = this.primary();
SQLUnaryExpr expr = new SQLUnaryExpr(SQLUnaryOperator.Pound, value);
return primaryRest(expr);
} else if ("EXTRACT".equalsIgnoreCase(ident)) {
accept(Token.LPAREN);
PGExtractExpr extract = new PGExtractExpr();
String fieldName = lexer.stringVal();
PGDateField field = PGDateField.valueOf(fieldName.toUpperCase());
lexer.nextToken();
extract.setField(field);
accept(Token.FROM);
SQLExpr source = this.expr();
extract.setSource(source);
accept(Token.RPAREN);
return primaryRest(extract);
} else if ("POINT".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGPointExpr point = new PGPointExpr();
point.setValue(value);
return primaryRest(point);
} else if ("BOX".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGBoxExpr box = new PGBoxExpr();
box.setValue(value);
return primaryRest(box);
public void scanSharp() {
token = Token.POUND;
scanChar();
void endVisit(PGExtractExpr x);
boolean visit(PGExtractExpr x);
void endVisit(PGBoxExpr x);
boolean visit(PGBoxExpr x);
void endVisit(PGPointExpr x);
boolean visit(PGPointExpr x);
@Override
public void endVisit(PGExtractExpr x) {
@Override
public boolean visit(PGExtractExpr x) {
return true;
@Override
public void endVisit(PGBoxExpr x) {
@Override
public boolean visit(PGBoxExpr x) {
return true;
@Override
public void endVisit(PGPointExpr x) {
@Override
public boolean visit(PGPointExpr x) {
return true;
@Override
public void endVisit(PGExtractExpr x) {
@Override
public boolean visit(PGExtractExpr x) {
print("EXTRACT (");
print(x.getField().name());
print(" FROM ");
x.getSource().accept(this);
print(")");
return false;
@Override
public boolean visit(PGBoxExpr x) {
print("BOX ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGBoxExpr x) {
@Override
public boolean visit(PGPointExpr x) {
print("POINT ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGPointExpr x) {
@Override
public void endVisit(PGExtractExpr x) {
@Override
public boolean visit(PGExtractExpr x) {
return true;
@Override
public void endVisit(PGBoxExpr x) {
@Override
public boolean visit(PGBoxExpr x) {
return true;
@Override
public void endVisit(PGPointExpr x) {
@Override
public boolean visit(PGPointExpr x) {
return true;
this.dbType = JdbcConstants.SQL_SERVER;
this.dbType = JdbcConstants.SQL_SERVER;
if (ch == '/') {
scanChar();
token = Token.BARBARSLASH;
token = Token.BARBAR;
} else if (ch == '/') {
scanChar();
token = Token.BARSLASH;
} else if (ch == '!') {
scanChar();
token = Token.BANGBANG; 
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseXor, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Multiply, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Divide, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Modulus, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseAnd, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BitwiseOr, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Equality, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotEqual, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Assignment, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Add, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Concat, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Subtract, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LeftShift, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.RightShift, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanAnd, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, op, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrEqual, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrEqualOrGreaterThan, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, op, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.GreaterThanOrEqual, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotLessThan, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotGreaterThan, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.LessThanOrGreater, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Like, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Escape, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.RLike, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.IsNot, rightExpr, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Is, rightExpr, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotLike, rightExp, getDbType());
expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.Escape, rightExp, getDbType());
return new SQLBinaryOpExpr(expr, SQLBinaryOperator.NotRLike, rightExp, getDbType());
BANGBANG("!!"),
BARBARSLASH("||/"),
BARSLASH("|/"),
MONKEYS_AT("@"),
POUND("#")
needQuote = binaryOpExpr.getOperator().isLogical();
public class PGInsertTest6_multi extends PGTest {
public void test_0() throws Exception {
String sql = "INSERT INTO products (product_no, name, price) VALUES"
+ "n    (1, 'Cheese', 9.99),"
+ "n    (2, 'Bread', 1.99),"
+ "n    (3, 'Milk', 2.99);";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("products", "product_no")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("products", "name")));
Assert.assertTrue(visitor.getColumns().contains(new TableStat.Column("products", "price")));
public class BitsTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "44::bit(10)";
PGExprParser parser = new PGExprParser(sql);
PGTypeCastExpr expr = (PGTypeCastExpr) parser.expr();
System.out.println(expr.toString());
public class BoxTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "box '((0,0),(1,1))' + point '(2.0,0)'";
PGExprParser parser = new PGExprParser(sql);
SQLBinaryOpExpr binaryExpr = (SQLBinaryOpExpr) parser.expr();
PGBoxExpr box = (PGBoxExpr) binaryExpr.getLeft();
PGPointExpr point = (PGPointExpr) binaryExpr.getRight();
Assert.assertEquals("BOX '((0,0),(1,1))' + POINT '(2.0,0)'", binaryExpr.toString());
public class ExtractTest_Year extends PGTest {
public void test_timestamp() throws Exception {
String sql = "EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40')";
PGExprParser parser = new PGExprParser(sql);
PGExtractExpr expr = (PGExtractExpr) parser.expr();
System.out.println(expr.toString());
public class PolygonTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "# '((1,0),(0,1),(-1,0))'";
PGExprParser parser = new PGExprParser(sql);
SQLUnaryExpr unaryExpr = (SQLUnaryExpr) parser.expr();
Assert.assertEquals(SQLUnaryOperator.Pound, unaryExpr.getOperator());
public class PGCidrExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGCidrExpr other = (PGCidrExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public class PGCircleExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGCircleExpr other = (PGCircleExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public class PGInetExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGInetExpr other = (PGInetExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public class PGLineSegmentsExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGLineSegmentsExpr other = (PGLineSegmentsExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public class PGMacAddrExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGMacAddrExpr other = (PGMacAddrExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
public class PGPolygonExpr extends PGExprImpl {
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, value);
visitor.endVisit(this);
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
PGPolygonExpr other = (PGPolygonExpr) obj;
if (value == null) {
if (other.value != null) {
return false;
} else if (!value.equals(other.value)) {
return false;
return true;
} else if ("macaddr".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGMacAddrExpr macaddr = new PGMacAddrExpr();
macaddr.setValue(value);
return primaryRest(macaddr);
} else if ("inet".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGInetExpr inet = new PGInetExpr();
inet.setValue(value);
return primaryRest(inet);
} else if ("cidr".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGCidrExpr cidr = new PGCidrExpr();
cidr.setValue(value);
return primaryRest(cidr);
} else if ("polygon".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGPolygonExpr polygon = new PGPolygonExpr();
polygon.setValue(value);
return primaryRest(polygon);
} else if ("circle".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGCircleExpr circle = new PGCircleExpr();
circle.setValue(value);
return primaryRest(circle);
} else if ("lseg".equalsIgnoreCase(ident)) {
SQLExpr value = this.primary();
PGLineSegmentsExpr lseg = new PGLineSegmentsExpr();
lseg.setValue(value);
return primaryRest(lseg);
void endVisit(PGMacAddrExpr x);
boolean visit(PGMacAddrExpr x);
void endVisit(PGInetExpr x);
boolean visit(PGInetExpr x);
void endVisit(PGCidrExpr x);
boolean visit(PGCidrExpr x);
void endVisit(PGPolygonExpr x);
boolean visit(PGPolygonExpr x);
void endVisit(PGCircleExpr x);
boolean visit(PGCircleExpr x);
void endVisit(PGLineSegmentsExpr x);
boolean visit(PGLineSegmentsExpr x);
@Override
public void endVisit(PGMacAddrExpr x) {
@Override
public boolean visit(PGMacAddrExpr x) {
return true;
@Override
public void endVisit(PGInetExpr x) {
@Override
public boolean visit(PGInetExpr x) {
return true;
@Override
public void endVisit(PGCidrExpr x) {
@Override
public boolean visit(PGCidrExpr x) {
return true;
@Override
public void endVisit(PGPolygonExpr x) {
@Override
public boolean visit(PGPolygonExpr x) {
return true;
@Override
public void endVisit(PGCircleExpr x) {
@Override
public boolean visit(PGCircleExpr x) {
return true;
@Override
public void endVisit(PGLineSegmentsExpr x) {
@Override
public boolean visit(PGLineSegmentsExpr x) {
return true;
@Override
public boolean visit(PGMacAddrExpr x) {
print("macaddr ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGMacAddrExpr x) {
@Override
public boolean visit(PGInetExpr x) {
print("inet ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGInetExpr x) {
@Override
public boolean visit(PGCidrExpr x) {
print("cidr ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGCidrExpr x) {
@Override
public boolean visit(PGPolygonExpr x) {
print("polygon ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGPolygonExpr x) {
@Override
public boolean visit(PGCircleExpr x) {
print("circle ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGCircleExpr x) {
@Override
public boolean visit(PGLineSegmentsExpr x) {
print("lseg ");
x.getValue().accept(this);
return false;
@Override
public void endVisit(PGLineSegmentsExpr x) {
@Override
public boolean visit(PGMacAddrExpr x) {
return true;
@Override
public void endVisit(PGMacAddrExpr x) {
@Override
public boolean visit(PGInetExpr x) {
return true;
@Override
public void endVisit(PGInetExpr x) {
@Override
public boolean visit(PGCidrExpr x) {
return true;
@Override
public void endVisit(PGCidrExpr x) {
@Override
public boolean visit(PGPolygonExpr x) {
return true;
@Override
public void endVisit(PGPolygonExpr x) {
@Override
public boolean visit(PGCircleExpr x) {
return true;
@Override
public void endVisit(PGCircleExpr x) {
@Override
public boolean visit(PGLineSegmentsExpr x) {
return true;
@Override
public void endVisit(PGLineSegmentsExpr x) {
public class CidrTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "cidr '10.1.0.0/16'";
PGExprParser parser = new PGExprParser(sql);
PGCidrExpr expr = (PGCidrExpr) parser.expr();
Assert.assertEquals("cidr '10.1.0.0/16'", expr.toString());
public class CircleTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "circle '((0,0),2)'";
PGExprParser parser = new PGExprParser(sql);
PGCircleExpr expr = (PGCircleExpr) parser.expr();
Assert.assertEquals("circle '((0,0),2)'", expr.toString());
public class InetTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "inet '0.0.0.255'";
PGExprParser parser = new PGExprParser(sql);
PGInetExpr expr = (PGInetExpr) parser.expr();
Assert.assertEquals("inet '0.0.0.255'", expr.toString());
public class LineSegmentsTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "lseg '((-1,0),(1,0))'";
PGExprParser parser = new PGExprParser(sql);
PGLineSegmentsExpr expr = (PGLineSegmentsExpr) parser.expr();
Assert.assertEquals("lseg '((-1,0),(1,0))'", expr.toString());
public class MacAddrTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "macaddr '12:34:56:78:90:ab'";
PGExprParser parser = new PGExprParser(sql);
PGMacAddrExpr expr = (PGMacAddrExpr) parser.expr();
Assert.assertEquals("macaddr '12:34:56:78:90:ab'", expr.toString());
public class PolygonTest2 extends PGTest {
public void test_timestamp() throws Exception {
String sql = "polygon '((0,0),(1,1))'";
PGExprParser parser = new PGExprParser(sql);
PGPolygonExpr expr = (PGPolygonExpr) parser.expr();
Assert.assertEquals("polygon '((0,0),(1,1))'", expr.toString());
public class SQLBinaryExpr extends SQLExprImpl implements SQLLiteralExpr {
public SQLBinaryExpr(){
public SQLBinaryExpr(String value){
public void accept0(SQLASTVisitor visitor) {
SQLBinaryExpr other = (SQLBinaryExpr) obj;
private boolean             setNotNull;
private boolean             dropNotNull;
private SQLExpr             setDefault;
private boolean             dropDefault;
acceptChild(visitor, setDefault);
public boolean isSetNotNull() {
return setNotNull;
public void setSetNotNull(boolean setNotNull) {
this.setNotNull = setNotNull;
public boolean isDropNotNull() {
return dropNotNull;
public void setDropNotNull(boolean dropNotNull) {
this.dropNotNull = dropNotNull;
public SQLExpr getSetDefault() {
return setDefault;
public void setSetDefault(SQLExpr setDefault) {
this.setDefault = setDefault;
public boolean isDropDefault() {
return dropDefault;
public void setDropDefault(boolean dropDefault) {
this.dropDefault = dropDefault;
private boolean       cascade = false;
public boolean isCascade() {
return cascade;
public void setCascade(boolean cascade) {
this.cascade = cascade;
public class SQLAlterTableRename extends SQLObjectImpl implements SQLAlterTableItem {
protected SQLExpr to;
public SQLExpr getTo() {
return to;
public void setTo(SQLExpr to) {
this.to = to;
to.setParent(this);
protected void accept0(SQLASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, to);
visitor.endVisit(this);
expr = new SQLBinaryExpr(charValue);
expr = new SQLBinaryExpr(binaryString.substring(1));
public boolean visit(SQLBinaryExpr x) {
public class PGAlterTableAlterColumnSetNotNull {
} else if (ident.equalsIgnoreCase("b") && lexer.token() == Token.LITERAL_CHARS) {
String charValue = lexer.stringVal();
lexer.nextToken();
expr = new SQLBinaryExpr(charValue);
return primaryRest(expr);
protected SQLAlterTableAlterColumn parseAlterColumn() {
accept(Token.COLUMN);
SQLColumnDefinition column = this.exprParser.parseColumn();
SQLAlterTableAlterColumn alterColumn = new SQLAlterTableAlterColumn();
alterColumn.setColumn(column);
if (column.getDataType() == null && column.getConstraints().size() == 0) {
if (lexer.token() == Token.SET) {
lexer.nextToken();
if (lexer.token() == Token.NOT) {
lexer.nextToken();
accept(Token.NULL);
alterColumn.setSetNotNull(true);
accept(Token.DEFAULT);
SQLExpr defaultValue = this.exprParser.expr();
alterColumn.setSetDefault(defaultValue);
} else if (lexer.token() == Token.DROP) {
lexer.nextToken();
if (lexer.token() == Token.NOT) {
lexer.nextToken();
accept(Token.NULL);
alterColumn.setDropNotNull(true);
accept(Token.DEFAULT);
alterColumn.setDropDefault(true);
return alterColumn;
public boolean visit(SQLBinaryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
@Override
public boolean visit(SQLBinaryExpr x) {
print("B'");
print(x.getValue());
print(''');
return false;
if(lexer.token() != Token.SET 
&& lexer.token() != Token.DROP) {
column.setDataType(parseDataType());
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
this.names(fk.getReferencedColumns(), fk);
accept(Token.RPAREN);
} else if (lexer.token() == Token.COLUMN) {
lexer.nextToken();
SQLAlterTableAddColumn item = parseAlterTableAddColumn();
stmt.getItems().add(item);
} else if (lexer.token() == Token.CHECK) {
SQLCheck check = this.exprParser.parseCheck();
SQLAlterTableAddConstraint item = new SQLAlterTableAddConstraint(check);
stmt.getItems().add(item);
} else if (lexer.token() == Token.CONSTRAINT) {
SQLConstraint constraint = this.exprParser.parseConstaint();
SQLAlterTableAddConstraint item = new SQLAlterTableAddConstraint(constraint);
stmt.getItems().add(item);
} else if (lexer.token() == Token.FOREIGN) {
SQLConstraint constraint = this.exprParser.parseForeignKey();
SQLAlterTableAddConstraint item = new SQLAlterTableAddConstraint(constraint);
stmt.getItems().add(item);
SQLAlterTableAlterColumn alterColumn = parseAlterColumn();
} else if (identifierEquals("RENAME")) {
stmt.getItems().add(parseAlterTableRename());
protected SQLAlterTableItem parseAlterTableRename() {
acceptIdentifier("RENAME");
if (lexer.token() == Token.COLUMN) {
lexer.nextToken();
SQLAlterTableRenameColumn renameColumn = new SQLAlterTableRenameColumn();
renameColumn.setColumn(this.exprParser.name());
accept(Token.TO);
renameColumn.setTo(this.exprParser.name());
return renameColumn;
if (lexer.token() == Token.TO) {
lexer.nextToken();
SQLAlterTableRename item = new SQLAlterTableRename();
item.setTo(this.exprParser.name());
return item;
throw new ParserException("TODO " + lexer.token() + " " + lexer.stringVal());
protected SQLAlterTableAlterColumn parseAlterColumn() {
lexer.nextToken();
SQLColumnDefinition column = this.exprParser.parseColumn();
SQLAlterTableAlterColumn alterColumn = new SQLAlterTableAlterColumn();
alterColumn.setColumn(column);
return alterColumn;
if(lexer.token == Token.CASCADE) {
item.setCascade(true);
lexer.nextToken();
if (x.isCascade()) {
print(" CASCADE");
if (x.isSetNotNull()) { 
print(" SET NOT NULL");
if (x.isDropNotNull()) { 
print(" DROP NOT NULL");
if (x.getSetDefault() != null) { 
print(" SET DEFAULT ");
x.getSetDefault().accept(this);
if (x.isDropDefault()) { 
print(" DROP DEFAULT");
if (x.getReferencedColumns().size() > 0) {
print(" (");
printAndAccept(x.getReferencedColumns(), ", ");
print(")");
public boolean visit(SQLBinaryExpr x) {
print("b'");
print(x.getValue());
print(''');
return false;
public boolean visit(SQLAlterTableRename x) {
print("RENAME TO ");
x.getTo().accept(this);
return false;
void endVisit(SQLBinaryExpr x);
boolean visit(SQLBinaryExpr x);
void endVisit(SQLAlterTableRename x);
boolean visit(SQLAlterTableRename x);
public void endVisit(SQLBinaryExpr x) {
public boolean visit(SQLBinaryExpr x) {
return true;
public void endVisit(SQLAlterTableRename x) {
public boolean visit(SQLAlterTableRename x) {
return true;
public boolean visit(SQLBinaryExpr x) {
return SQLEvalVisitorUtils.visit(this, x);
public static boolean visit(SQLEvalVisitor visitor, SQLBinaryExpr x) {
for (SQLName column : x.getReferencingColumns()) {
@Override
public boolean visit(SQLAlterTableRename x) {
return false;
Assert.assertEquals("expect activeCount zero", 0, dataSource.getActiveCount());
SQLBinaryExpr exprA, exprB, exprC;
exprA = (SQLBinaryExpr) parser.expr();
exprB = (SQLBinaryExpr) parser.expr();
exprC = (SQLBinaryExpr) parser.expr();
Assert.assertEquals(new SQLBinaryExpr(), new SQLBinaryExpr());
Assert.assertEquals(new SQLBinaryExpr().hashCode(), new SQLBinaryExpr().hashCode());
new SQLBinaryExpr().accept(adapter);
Assert.assertEquals(2, visitor.getColumns().size());
Assert.assertEquals(6, visitor.getColumns().size());
new SQLAlterTableRename().accept(adapter);
public class BitStringTest extends PGTest {
public void test_timestamp() throws Exception {
String sql = "B'101'";
PGExprParser parser = new PGExprParser(sql);
SQLBinaryExpr expr = (SQLBinaryExpr) parser.expr();
Assert.assertEquals("B'101'", SQLUtils.toSQLString(expr, JdbcConstants.POSTGRESQL));
public class PGAlterTableAddCheck0 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ADD CHECK (name <> '');";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableAddColumnTest0 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ADD COLUMN description text;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableAddColumnTest1 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ADD COLUMN description text CHECK (description <> '');";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableAddFk0 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableAddUnique0 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableDropColumnTest0 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products DROP COLUMN description;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableDropColumnTest1 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products DROP COLUMN description CASCADE;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableDropConstraint extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products DROP CONSTRAINT some_name;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 0);
public class PGAlterTableDropDefault extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ALTER COLUMN price DROP DEFAULT;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals("ALTER TABLE products"
+ "ntALTER COLUMN price DROP DEFAULT", stmt.toString());
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableDropNotNull extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals("ALTER TABLE products"
+ "ntALTER COLUMN product_no DROP NOT NULL", stmt.toString());
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableRenameTest extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products RENAME TO items;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 0);
public class PGAlterTableRenameTest1 extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products RENAME COLUMN product_no TO product_number;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 2);
public class PGAlterTableSetDefault extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals("ALTER TABLE products"
+ "ntALTER COLUMN price SET DEFAULT 7.77", stmt.toString());
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class PGAlterTableSetNotNull extends PGTest {
public void test_0 () throws Exception {
String sql = "ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement stmt = statementList.get(0);
print(statementList);
Assert.assertEquals("ALTER TABLE products"
+ "ntALTER COLUMN product_no SET NOT NULL", stmt.toString());
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
stmt.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getDropCount() == 0);
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getAlterCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
public class OdpsSetLabelStatement extends OdpsStatementImpl {
private String         label;
private SQLExpr        user;
private SQLTableSource table;
private List<SQLName>  columns = new ArrayList<SQLName>();
protected void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, user);
visitor.endVisit(this);
public String getLabel() {
return label;
public void setLabel(String label) {
this.label = label;
public SQLExpr getUser() {
return user;
public void setUser(SQLExpr user) {
this.user = user;
user.setParent(this);
public SQLTableSource getTable() {
return table;
public void setTable(SQLTableSource table) {
this.table = table;
table.setParent(this);
public List<SQLName> getColumns() {
return columns;
public abstract class OdpsStatementImpl extends SQLStatementImpl {
protected void accept0(SQLASTVisitor visitor) {
accept0((OdpsASTVisitor) visitor);
protected abstract void accept0(OdpsASTVisitor visitor);
public String toString() {
return SQLUtils.toOdpsString(this);
public void scanIdentifier() {
final char first = ch;
final boolean firstFlag = isFirstIdentifierChar(first);
if (!firstFlag) {
throw new ParserException("illegal identifier");
mark = pos;
bufPos = 1;
for (;;) {
ch = charAt(++pos);
if (!isIdentifierChar(ch)) {
this.ch = charAt(pos);
if (ch == '@') { 
for (;;) {
ch = charAt(++pos);
if (ch != '-' && ch != '.' && !isIdentifierChar(ch)) {
this.ch = charAt(pos);
stringVal = addSymbol();
Token tok = keywods.getKeyword(stringVal);
if (tok != null) {
token = tok;
token = Token.IDENTIFIER;
public SQLStatement parseSet() {
accept(Token.SET);
if (identifierEquals("LABEL")) {
lexer.nextToken();
OdpsSetLabelStatement stmt = new OdpsSetLabelStatement();
stmt.setLabel(lexer.stringVal());
lexer.nextToken();
accept(Token.TO);
if (lexer.token() == Token.USER) {
lexer.nextToken();
SQLName name = this.exprParser.name();
stmt.setUser(name);
return stmt;
accept(Token.TABLE);
SQLExpr expr = this.exprParser.name();
stmt.setTable(new SQLExprTableSource(expr));
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
this.exprParser.names(stmt.getColumns(), stmt);
accept(Token.RPAREN);
return stmt;
SQLSetStatement stmt = new SQLSetStatement(getDbType());
parseAssignItems(stmt.getItems(), stmt);
return stmt;
void endVisit(OdpsSetLabelStatement x);
boolean visit(OdpsSetLabelStatement x);
public void endVisit(OdpsSetLabelStatement x) {
public boolean visit(OdpsSetLabelStatement x) {
print("SET LABEL ");
print(x.getLabel());
print(" TO ");
if (x.getUser() != null) {
print("USER ");
x.getUser().accept(this);
} else if (x.getTable() != null) {
print("TABLE ");
x.getTable().accept(this);
if (x.getColumns().size() > 0) {
print("(");
printAndAccept(x.getColumns(), ", ");
print(")");
return false;
public void endVisit(OdpsSetLabelStatement x) {
public boolean visit(OdpsSetLabelStatement x) {
if (x.getTable() != null) {
x.getTable().accept(this);
return false;
public class OdpsSetLabelTest extends TestCase {
public void test_odps() throws Exception {
String sql = "SET LABEL S3 TO USER aliyun$abc@alibaba-inc.com";
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("SET LABEL S3 TO USER aliyun$abc@alibaba-inc.com", output);
public class OdpsSetLabelTest2 extends TestCase {
public void test_odps() throws Exception {
String sql = "SET LABEL S3 TO TABLE xx(f1,f2)";
OdpsStatementParser parser = new OdpsStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
parser.match(Token.EOF);
String output = SQLUtils.toOdpsString(stmt);
Assert.assertEquals("SET LABEL S3 TO TABLE xx(f1, f2)", output);
for (int i = 0; i < statementList.size(); i++) {
if (i > 0) {
public static String translateOracleToMySql(String sql) {
List<SQLStatement> stmtList = toStatementList(sql, JdbcConstants.ORACLE);
StringBuilder out = new StringBuilder();
OracleToMySqlOutputVisitor visitor = new OracleToMySqlOutputVisitor(out, false);
for (int i = 0; i < stmtList.size(); ++i) {
stmtList.get(i).accept(visitor);
String mysqlSql = out.toString();
return mysqlSql;
public String toString() {
return SQLUtils.toOracleString(this);
public String toString () {
return SQLUtils.toOracleString(this);
public String toString() {
return SQLUtils.toOracleString(this);
public String toString () {
return SQLUtils.toOracleString(this);
public String toString () {
return SQLUtils.toOracleString(this);
public class OracleToMySqlOutputVisitor extends OracleOutputVisitor {
public OracleToMySqlOutputVisitor(Appendable appender, boolean printPostSemi){
super(appender, printPostSemi);
public OracleToMySqlOutputVisitor(Appendable appender){
super(appender);
public boolean visit(OracleSelectQueryBlock x) {
boolean parentIsSelectStatment = false;
if (x.getParent() instanceof SQLSelect) {
SQLSelect select = (SQLSelect) x.getParent();
if (select.getParent() instanceof SQLSelectStatement) {
parentIsSelectStatment = true;
if (!parentIsSelectStatment) {
return super.visit(x);
if (x.getWhere() instanceof SQLBinaryOpExpr 
&& x.getFrom() instanceof SQLSubqueryTableSource 
int rownum;
String ident;
SQLBinaryOpExpr where = (SQLBinaryOpExpr) x.getWhere();
if (where.getRight() instanceof SQLIntegerExpr && where.getLeft() instanceof SQLIdentifierExpr) {
rownum = ((SQLIntegerExpr) where.getRight()).getNumber().intValue();
ident = ((SQLIdentifierExpr) where.getLeft()).getName();
return super.visit(x);
SQLSelect select = ((SQLSubqueryTableSource) x.getFrom()).getSelect();
SQLSelectQueryBlock queryBlock = null;
SQLSelect subSelect = null;
SQLBinaryOpExpr subWhere = null;
boolean isSubQueryRowNumMapping = false;
if (select.getQuery() instanceof SQLSelectQueryBlock) {
queryBlock = (SQLSelectQueryBlock) select.getQuery();
if (queryBlock.getWhere() instanceof SQLBinaryOpExpr) {
subWhere = (SQLBinaryOpExpr) queryBlock.getWhere();
for (SQLSelectItem selectItem : queryBlock.getSelectList()) {
if (isRowNumber(selectItem.getExpr())) {
if (where.getLeft() instanceof SQLIdentifierExpr
&& ((SQLIdentifierExpr) where.getLeft()).getName().equals(selectItem.getAlias())) {
isSubQueryRowNumMapping = true;
SQLTableSource subTableSource = queryBlock.getFrom();
if (subTableSource instanceof SQLSubqueryTableSource) {
subSelect = ((SQLSubqueryTableSource) subTableSource).getSelect();
if ("ROWNUM".equalsIgnoreCase(ident)) {
SQLBinaryOperator op = where.getOperator();
Integer limit = null;
if (op == SQLBinaryOperator.LessThanOrEqual) {
limit = rownum;
} else if (op == SQLBinaryOperator.LessThan) {
limit = rownum - 1;
if (limit != null) {
select.accept(this);
println();
print("LIMIT ");
print(limit);
return false;
} else if (isSubQueryRowNumMapping) {
SQLBinaryOperator op = where.getOperator();
SQLBinaryOperator subOp = subWhere.getOperator();
if (isRowNumber(subWhere.getLeft()) 
&& subWhere.getRight() instanceof SQLIntegerExpr) {
int subRownum = ((SQLIntegerExpr) subWhere.getRight()).getNumber().intValue();
Integer offset = null;
if (op == SQLBinaryOperator.GreaterThanOrEqual) {
offset = rownum + 1;
} else if (op == SQLBinaryOperator.GreaterThan) {
offset = rownum;
if (offset != null) {
Integer limit = null;
if (subOp == SQLBinaryOperator.LessThanOrEqual) {
limit = subRownum - offset;
} else if (subOp == SQLBinaryOperator.LessThan) {
limit = subRownum - 1 - offset;
if (limit != null) {
subSelect.accept(this);
println();
print("LIMIT ");
print(offset);
print(", ");
print(limit);
return false;
return super.visit(x);
static boolean isRowNumber(SQLExpr expr) {
if (expr instanceof SQLIdentifierExpr) {
String lownerName = ((SQLIdentifierExpr) expr).getLowerName();
return "rownum".equals(lownerName);
return false;
public class OracleToMySql_PageTest extends TestCase {
public void test_page() throws Exception {
String sql = "SELECT XX.*, ROWNUM AS RN" + 
"nFROM (SELECT *" + 
"ntFROM t" + 
"ntORDER BY id" + 
"nt) XX" + 
"nWHERE ROWNUM <= 10";
String mysqlSql = SQLUtils.translateOracleToMySql(sql);
Assert.assertEquals("SELECT *"
+ "nFROM t"
+ "nORDER BY id"
+ "nLIMIT 10", mysqlSql);
System.out.println(mysqlSql);
public class OracleToMySql_PageTest1 extends TestCase {
public void test_page() throws Exception {
String sql = "SELECT *" + 
"nFROM (SELECT XX.*, ROWNUM AS RN" + 
"ntFROM (SELECT *" + 
"nttFROM t" + 
"nttORDER BY id" + 
"ntt) XX" + 
"ntWHERE ROWNUM <= 20" + 
"nt) XXX" + 
"nWHERE RN > 10";
String mysqlSql = SQLUtils.translateOracleToMySql(sql);
Assert.assertEquals("SELECT *"
+ "nFROM t"
+ "nORDER BY id"
+ "nLIMIT 10, 10", mysqlSql);
System.out.println(mysqlSql);
public class OracleToMySql_PageTest2 extends TestCase {
public void test_page() throws Exception {
String sql = "SELECT XX.*, ROWNUM AS RN" + 
"nFROM (SELECT *" + 
"ntFROM t" + 
"ntORDER BY id" + 
"nt) XX" + 
"nWHERE ROWNUM < 10";
String mysqlSql = SQLUtils.translateOracleToMySql(sql);
Assert.assertEquals("SELECT *"
+ "nFROM t"
+ "nORDER BY id"
+ "nLIMIT 9", mysqlSql);
System.out.println(mysqlSql);
.append(", maxActive " + maxActive)
public class MySqlSetTransactionStatement extends MySqlStatementImpl {
private String  isolationLevel;
private String  accessModel;
public String getIsolationLevel() {
return isolationLevel;
public void setIsolationLevel(String isolationLevel) {
this.isolationLevel = isolationLevel;
public String getAccessModel() {
return accessModel;
public void setAccessModel(String accessModel) {
this.accessModel = accessModel;
MySqlSetTransactionStatement stmt = new MySqlSetTransactionStatement();
lexer.nextToken();
if(identifierEquals("ISOLATION")) {
acceptIdentifier("LEVEL");
if (identifierEquals(READ)) {
if (identifierEquals("UNCOMMITTED")) {
stmt.setIsolationLevel("READ UNCOMMITTED");
lexer.nextToken();
} else if (identifierEquals(WRITE)) {
stmt.setIsolationLevel("READ WRITE");
lexer.nextToken();
} else if (identifierEquals("ONLY")) {
stmt.setIsolationLevel("READ ONLY");
lexer.nextToken();
} else if (identifierEquals("COMMITTED")) {
stmt.setIsolationLevel("READ COMMITTED");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
} else if (identifierEquals("SERIALIZABLE")) {
stmt.setIsolationLevel("SERIALIZABLE");
} else if (identifierEquals("REPEATABLE")) {
if (identifierEquals(READ)) {
stmt.setIsolationLevel("REPEATABLE READ");
lexer.nextToken();
throw new ParserException("UNKOWN TRANSACTION LEVEL : " + lexer.stringVal());
} else if (identifierEquals(READ)) {
if (identifierEquals("ONLY")) {
stmt.setAccessModel("ONLY");
lexer.nextToken();
} else if (identifierEquals("WRITE")) {
stmt.setAccessModel("WRITE");
throw new ParserException("UNKOWN ACCESS MODEL : " + lexer.stringVal());
boolean visit(MySqlSetTransactionStatement x);
void endVisit(MySqlSetTransactionStatement x);
public boolean visit(MySqlSetTransactionStatement x) {
public void endVisit(MySqlSetTransactionStatement x) {
public boolean visit(MySqlSetTransactionStatement x) {
print("SET TRANSACTION ");
print("SET GLOBAL TRANSACTION ");
print("SET SESSION TRANSACTION ");
if (x.getIsolationLevel() != null) {
print("ISOLATION LEVEL ");
print(x.getIsolationLevel());
if (x.getAccessModel() != null) {
print("READ ");
print(x.getAccessModel());
public void endVisit(MySqlSetTransactionStatement x) {
public boolean visit(MySqlSetTransactionStatement x) {
public void endVisit(MySqlSetTransactionStatement x) {
if (select.getParent() instanceof SQLSelectStatement || select.getParent() instanceof  SQLSubqueryTableSource) {
public class SQLServerCommitStatement extends SQLServerObjectImpl implements SQLServerStatement {
private boolean work = false;
private SQLExpr transactionName;
private SQLExpr delayedDurability;
public boolean isWork() {
return work;
public void setWork(boolean work) {
this.work = work;
@Override
public void accept0(SQLServerASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public SQLExpr getTransactionName() {
return transactionName;
public void setTransactionName(SQLExpr transactionName) {
this.transactionName = transactionName;
public SQLExpr getDelayedDurability() {
return delayedDurability;
public void setDelayedDurability(SQLExpr delayedDurability) {
this.delayedDurability = delayedDurability;
public class SQLServerRollbackStatement extends SQLRollbackStatement implements SQLServerStatement {
private boolean work = false;
private SQLExpr name;
public boolean isWork() {
return work;
public void setWork(boolean work) {
this.work = work;
@Override
public void accept0(SQLASTVisitor visitor) {
if (visitor instanceof SQLServerASTVisitor) {
accept0((SQLServerASTVisitor) visitor);
throw new IllegalArgumentException("not support visitor type : " + visitor.getClass().getName());
public void accept0(SQLServerASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public SQLExpr getName() {
return name;
public void setName(SQLExpr name) {
this.name = name;
if (lexer.token() == Token.COMMIT) {
statementList.add(this.parseCommit());
return true;
public SQLServerCommitStatement parseCommit() {
acceptIdentifier("COMMIT");
SQLServerCommitStatement stmt = new SQLServerCommitStatement();
if (identifierEquals("WORK")) {
lexer.nextToken();
stmt.setWork(true);
if (identifierEquals("TRAN") || identifierEquals("TRANSACTION")) {
lexer.nextToken();
if (lexer.token() == Token.IDENTIFIER || lexer.token() == Token.VARIANT) {
stmt.setTransactionName(this.exprParser.expr());
if (lexer.token() == Token.WITH) {
lexer.nextToken();
accept(Token.LPAREN);
acceptIdentifier("DELAYED_DURABILITY");
accept(Token.EQ);
stmt.setDelayedDurability(this.exprParser.expr());
accept(Token.RPAREN);
return stmt;
public SQLServerRollbackStatement parseRollback() {
acceptIdentifier("ROLLBACK");
SQLServerRollbackStatement stmt = new SQLServerRollbackStatement();
if (identifierEquals("WORK")) {
lexer.nextToken();
stmt.setWork(true);
if (identifierEquals("TRAN") || identifierEquals("TRANSACTION")) {
lexer.nextToken();
if (lexer.token() == Token.IDENTIFIER || lexer.token() == Token.VARIANT) {
stmt.setName(this.exprParser.expr());
return stmt;
boolean visit(SQLServerCommitStatement x);
void endVisit(SQLServerCommitStatement x);
boolean visit(SQLServerRollbackStatement x);
void endVisit(SQLServerRollbackStatement x);
@Override
public boolean visit(SQLServerCommitStatement x) {
return true;
@Override
public void endVisit(SQLServerCommitStatement x) {
@Override
public boolean visit(SQLServerRollbackStatement x) {
return true;
@Override
public void endVisit(SQLServerRollbackStatement x) {
@Override
public boolean visit(SQLServerCommitStatement x) {
print("COMMIT");
if (x.isWork()) {
print(" WORK");
print(" TRANSACTION");
if (x.getTransactionName() != null) {
print(" ");
x.getTransactionName().accept(this);
if (x.getDelayedDurability() != null) {
print(" WITH ( DELAYED_DURABILITY = ");
x.getDelayedDurability().accept(this);
print(" )");
return false;
@Override
public void endVisit(SQLServerCommitStatement x) {
@Override
public boolean visit(SQLServerRollbackStatement x) {
print("ROLLBACK");
if (x.isWork()) {
print(" WORK");
print(" TRANSACTION");
if (x.getName() != null) {
print(" ");
x.getName().accept(this);
return false;
@Override
public void endVisit(SQLServerRollbackStatement x) {
@Override
public boolean visit(SQLServerCommitStatement x) {
return true;
@Override
public void endVisit(SQLServerCommitStatement x) {
@Override
public boolean visit(SQLServerRollbackStatement x) {
return true;
@Override
public void endVisit(SQLServerRollbackStatement x) {
MySqlSetTransactionStatement set = (MySqlSetTransactionStatement) parser.parseStatementList().get(0);
MySqlSetTransactionStatement set = (MySqlSetTransactionStatement) parser.parseStatementList().get(0);
MySqlSetTransactionStatement set = (MySqlSetTransactionStatement) parser.parseStatementList().get(0);
MySqlSetTransactionStatement set = (MySqlSetTransactionStatement) parser.parseStatementList().get(0);
new MySqlSetTransactionStatement().accept(adapter);
public void test_page1() throws Exception {
String sql = "select * from t_xiaoxi where rowid in(select rid from (select rownum rn,rid from(select rowid rid,cid from t_xiaoxi  order by cid desc) where rownum<10000) where rn>9980) order by cid desc;";
String mysqlSql = SQLUtils.translateOracleToMySql(sql);
System.out.println(mysqlSql);
public class SQLServerCommitTest extends TestCase {
public void test_0() {
String sql = "COMMIT WORK";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("COMMIT WORK", text);
public void test_1() {
String sql = "COMMIT TRAN";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("COMMIT TRANSACTION", text);
public void test_2() {
String sql = "COMMIT TRANSACTION @tran_name_variable  WITH ( DELAYED_DURABILITY = OFF )";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("COMMIT TRANSACTION @tran_name_variable WITH ( DELAYED_DURABILITY = OFF )", text);
public class SQLServerRollbackTest extends TestCase {
public void test_0() {
String sql = "ROLLBACK WORK";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("ROLLBACK WORK", text);
public void test_1() {
String sql = "ROLLBACK TRAN";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("ROLLBACK TRANSACTION", text);
public void test_2() {
String sql = "ROLLBACK TRANSACTION @tran_name_variable";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
List<SQLStatement> stmtList = parser.parseStatementList();
Assert.assertEquals(1, stmtList.size());
String text = SQLUtils.toSQLString(stmtList, JdbcUtils.SQL_SERVER);
Assert.assertEquals("ROLLBACK TRANSACTION @tran_name_variable", text);
public final static int RevisionVersion = 11;
if ((ch == '/' && charAt(pos + 1) == '/')
|| (ch == '-' && charAt(pos + 1) == '-')) {
scanSingleLineComment();
} else if (ch == '/' && charAt(pos + 1) == '*') {
scanMultiLineComment();
private void scanMultiLineComment() {
scanChar();
scanChar();
for (;;) {
if (ch == '*' && charAt(pos + 1) == '/') {
scanChar();
stringVal = subString(mark, bufPos);
token = Token.MULTI_LINE_COMMENT;
hasComment = true;
private void scanSingleLineComment() {
scanChar();
scanChar();
mark = pos;
bufPos = 0;
for (;;) {
if (ch == 'r') {
if (charAt(pos + 1) == 'n') {
if (ch == 'n') {
scanChar();
stringVal = subString(mark, bufPos);
token = Token.LINE_COMMENT;
hasComment = true;
public void test_2() throws Exception {
String sql = "
Lexer lexer = new Lexer(sql);
lexer.nextToken();
assertEquals("hello world", lexer.stringVal());
sql = "hello nworld";
lexer = new Lexer(sql);
lexer.nextToken();
assertEquals("hello nworld", lexer.stringVal());
sql = "--hello worldn";
lexer = new Lexer(sql);
lexer.nextToken();
assertEquals("hello world", lexer.stringVal());
private SQLExprTableSource      inherits;
super(dbType);
public SQLExprTableSource getInherits() {
return inherits;
public void setInherits(SQLExprTableSource inherits) {
if (inherits != null) {
inherits.setParent(this);
this.inherits = inherits;
this.acceptChild(visitor, inherits);
public class PGCreateTableStatement extends SQLCreateTableStatement {
private SQLExprTableSource inherits;
public PGCreateTableStatement(){
super(JdbcConstants.POSTGRESQL);
if (identifierEquals("INHERITS")) {
lexer.nextToken();
accept(Token.LPAREN);
SQLName inherits = this.exprParser.name();
createTable.setInherits(new SQLExprTableSource(inherits));
accept(Token.RPAREN);
if (x.getInherits() != null) {
print(" INHERITS (");
x.getInherits().accept(this);
print(")");
if (x.getInherits() != null) {
x.getInherits().accept(this);
public class PGCreateTableTest_5 extends PGTest {
public void test_0() throws Exception {
String sql = "CREATE TABLE products (" + 
"  state           char(2)" + 
") INHERITS (cities);";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("products")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("products")).getCreateCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 1);
} else if (realDriverClassName.equals("org.postgresql.Driver")) {
this.exceptionSorter = new PGExceptionSorter();
public class PGExceptionSorter implements ExceptionSorter {
public boolean isExceptionFatal(SQLException e) {
String sqlState = e.getSQLState();
if (sqlState == null) {
return false;
if (sqlState.startsWith("08")) {
return true;
return false;
public void configFromProperties(Properties properties) {
map.put("IF", Token.IF);
public class PGDropTableIfExistsTest extends PGTest {
public void test_0 () throws Exception {
String sql = "DROP TABLE IF EXISTS t_report_1_19";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("t_report_1_19")));
Assert.assertTrue(visitor.getTables().get(new TableStat.Name("t_report_1_19")).getDropCount() == 1);
Assert.assertTrue(visitor.getColumns().size() == 0);
getLog().warn("register druid-driver mbean error", ex);
LOG.warn("register druid-driver mbean error", ex);
private static final long serialVersionUID     = -2227528634302168877L;
private static final Log  LOG                  = LogFactory.getLog(OracleValidConnectionChecker.class);
private int               timeout              = 1;
private String            defaultValidateQuery = "SELECT 'x' FROM DUAL";
public void setTimeout(int seconds) {
this.timeout = seconds;
if (validateQuery == null || validateQuery.isEmpty()) {
validateQuery = this.defaultValidateQuery;
stmt.setQueryTimeout(timeout);
public class Bug_for_order extends TestCase {
public void test_bug_for_xuershan() throws Exception {
String sql = "select * from order";
String format = SQLUtils.formatMySql(sql);
public class MySqlSelectTest_21 extends MysqlTest {
public void test_0() throws Exception {
String sql = "select * from order where a=1 order by b";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(1, visitor.getOrderByColumns().size());
public void test_1() throws Exception {
String sql = "select order from t where a=1 order by b";
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
System.out.println("orderBy : " + visitor.getOrderByColumns());
Assert.assertEquals(1, visitor.getTables().size());
Assert.assertEquals(3, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getConditions().size());
Assert.assertEquals(1, visitor.getOrderByColumns().size());
|| x instanceof SQLSetStatement 
|| x instanceof SQLServerSetStatement) {
} else if (x instanceof MySqlCommitStatement || x instanceof SQLServerCommitStatement) {
lock.lock();
lock.lock();
synchronized (pooledConnection) {
if (pooledConnection.isDisable()) {
return oracleConn.pingDatabase();
private SQLExpr      rowCount;
private SQLExpr      offset;
public SQLExpr getRowCount() {
return rowCount;
public void setRowCount(SQLExpr rowCount) {
if (rowCount != null) {
rowCount.setParent(this);
this.rowCount = rowCount;
public SQLExpr getOffset() {
return offset;
public void setOffset(SQLExpr offset) {
if (offset != null) {
offset.setParent(this);
this.offset = offset;
acceptChild(visitor, this.offset);
acceptChild(visitor, this.rowCount);
result = prime * result + ((offset == null) ? 0 : offset.hashCode());
result = prime * result + ((rowCount == null) ? 0 : rowCount.hashCode());
if (this == obj) return true;
if (!super.equals(obj)) return false;
if (getClass() != obj.getClass()) return false;
if (forBrowse != other.forBrowse) return false;
if (other.forXmlOptions != null) return false;
} else if (!forXmlOptions.equals(other.forXmlOptions)) return false;
if (offset == null) {
if (other.offset != null) return false;
} else if (!offset.equals(other.offset)) return false;
if (rowCount == null) {
if (other.rowCount != null) return false;
} else if (!rowCount.equals(other.rowCount)) return false;
if (identifierEquals("OFFSET")) {
lexer.nextToken();
SQLExpr offset = this.expr();
acceptIdentifier("ROWS");
select.setOffset(offset);
if (identifierEquals("FETCH")) {
lexer.nextToken();
acceptIdentifier("NEXT");
SQLExpr rowCount = expr();
acceptIdentifier("ROWS");
acceptIdentifier("ONLY");
select.setRowCount(rowCount);
if (x.getOffset() != null) {
println();
print("OFFSET ");
x.getOffset().accept(this);
print(" ROWS");
if (x.getRowCount() != null) {
print(" FETCH NEXT ");
x.getRowCount().accept(this);
print(" ROWS ONLY");
public void f_test_recycle_error_interrupt() throws Exception {
public class SQLServerSelectTest20 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT First_Name + ' ' + Last Name FROM Employees ORDER BY First_Name OFFSET 10 ROWS;"; 
String expect = "SELECT First_Name + ' ' + Last AS Name" 
+ "nFROM Employees" 
+ "nORDER BY First_Name" 
+ "nOFFSET 10 ROWS";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
public class SQLServerSelectTest21 extends TestCase {
public void test_simple() throws Exception {
String sql = "SELECT First_Name + ' ' + Last Name FROM Employees ORDER BY First_Name OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;"; 
String expect = "SELECT First_Name + ' ' + Last AS Name" 
+ "nFROM Employees" 
+ "nORDER BY First_Name" 
+ "nOFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY";
SQLServerStatementParser parser = new SQLServerStatementParser(sql);
SQLStatement stmt = parser.parseStatementList().get(0);
String text = TestUtils.outputSqlServer(stmt);
Assert.assertEquals(expect, text);
System.out.println(text);
final boolean asyncCloseEnabled;
if (holder != null) {
asyncCloseEnabled = holder.getDataSource().isAsyncCloseConnectionEnable();
asyncCloseEnabled = false;
if (asyncCloseEnabled) {
public static final String DM                = "dm";
public static final String DM_DRIVER         = "dm.jdbc.driver.DmDriver";
} else if (rawUrl.startsWith("jdbc:dm:")) {
return JdbcConstants.DM_DRIVER;
} else if (rawUrl.startsWith("jdbc:dm:")) {
return JdbcConstants.DM;
public static final String KINGBASE          = "kingbase";
public static final String KINGBASE_DRIVER   = "com.kingbase.Driver";
} else if (rawUrl.startsWith("jdbc:kingbase:")) {
return JdbcConstants.KINGBASE_DRIVER;
} else if (rawUrl.startsWith("jdbc:kingbase:")) {
return JdbcConstants.KINGBASE;
String className = e.getClass().getName();
if ("com.mysql.jdbc.CommunicationsException".equals(className)) {
return true;
jdbcUrl = "jdbc:oracle:thin:@a.b.c.d:1521:xx";
user = "a";
password = "b";
final String sqlState = e.getSQLState();
public void test_true_3() throws Exception {
MySqlExceptionSorter sorter = new MySqlExceptionSorter();
Assert.assertTrue(sorter.isExceptionFatal(new com.mysql.jdbc.CommunicationsException(null, 0, 0, null)));
if (realDriverClassName.equals(JdbcConstants.MYSQL_DRIVER)) {
} else if (realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER)) {
} else if (realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER)) {
} else if (realDriverClassName.equals(JdbcConstants.POSTGRESQL_DRIVER)) {
this.validConnectionChecker = new PGValidConnectionChecker();
public class PGValidConnectionChecker extends ValidConnectionCheckerAdapter implements ValidConnectionChecker, Serializable {
private static final long serialVersionUID     = -2227528634302168877L;
private static final Log  LOG                  = LogFactory.getLog(PGValidConnectionChecker.class);
private String            defaultValidateQuery = "SELECT 'x' FROM DUAL";
public PGValidConnectionChecker(){
configFromProperties(System.getProperties());
public boolean isValidConnection(Connection conn, String validateQuery, int validationQueryTimeout) {
if (validateQuery == null || validateQuery.isEmpty()) {
validateQuery = this.defaultValidateQuery;
if (conn.isClosed()) {
return false;
} catch (SQLException ex) {
return false;
if (conn instanceof DruidPooledConnection) {
conn = ((DruidPooledConnection) conn).getConnection();
if (conn instanceof ConnectionProxy) {
conn = ((ConnectionProxy) conn).getRawObject();
Statement stmt = null;
ResultSet rs = null;
stmt = conn.createStatement();
rs = stmt.executeQuery(validateQuery);
return true;
} catch (SQLException e) {
return false;
} catch (Exception e) {
LOG.warn("Unexpected error in ping", e);
return false;
} finally {
JdbcUtils.close(rs);
JdbcUtils.close(stmt);
} catch (Exception e) {
LOG.warn("Unexpected error in pingDatabase", e);
return false;
public static final String POSTGRESQL_DRIVER = "org.postgresql.Driver";
public static final String SQL_SERVER_DRIVER = "com.microsoft.jdbc.sqlserver.SQLServerDriver";
} else if (realDriverClassName.equals(JdbcConstants.POSTGRESQL_DRIVER)) {
public class PGExceptionSorterTest extends TestCase {
public void test_pg() throws Exception {
PGExceptionSorter exSorter = new PGExceptionSorter();
PSQLException ex = new PSQLException(GT.tr("Expected an EOF from server, got: {0}", new Integer(0)),
PSQLState.COMMUNICATION_ERROR);
Assert.assertTrue(exSorter.isExceptionFatal(ex));
public void setValuesList(List<ValuesClause> valuesList) {
this.valuesList = valuesList;
public boolean isLowPriority() {
boolean hasSpecial = false;
if(ch == '\') {
hasSpecial = true;
if (ch == '"' && charAt(pos - 1) != '\') {
if (!hasSpecial) {
stringVal = subString(mark + 1, bufPos);
stringVal = new String(buf, 0, bufPos);
public class Bug_for_ruiyi extends TestCase {
public void test_for_issue() throws Exception {
String sql = "insert into icshall_guide(id,gmt_create,gmt_modified,subject,content,cat_id)"
+ "values (8,now(),now(),"Why my payment is deducted incorrectly?/ Why my payment is deducted twice?","
+ ""{\"id\":1,\"title\":\"Have you contacted your card issuer to double check instead of only checking online?\","
+ "\"type\":\"START\","
+ "\"currentLevel\":1,"
+ "\"name\":\"name1\","
+ "\"values\":[{\"id\":2,"
+ "\"title\":\"Yes\","
+ "\"type\":\"MIDWAY\","
+ "\"currentLevel\":2,"
+ "\"value\":1,"
+ "\"childs\":[{\"id\":3,"
+ "\"title\":\"If it is deducted twice, please contact the online service with the official bank statement.\","
+ "\"type\":\"END\"," + "\"currentLevel\":3}]}," + "{\"id\":4,"
+ "\"title\":\"No\"," + "\"type\":\"MIDWAY\"," + "\"currentLevel\":2,"
+ "\"value\":1," + "\"childs\":[{\"id\":5,"
+ "\"title\":\"Please contact your card issuer to double confirm.\","
+ "\"type\":\"END\"," + "\"currentLevel\":3}]}]}",607)";
String expected = "INSERT INTO icshall_guide (id, gmt_create, gmt_modified, subject, content"
+ "nt, cat_id)"
+ "nVALUES (8, now(), now(), 'Why my payment is deducted incorrectly?/ Why my payment is deducted twice?', '{"id":1,"title":"Have you contacted your card issuer to double check instead of only checking online?","type":"START","currentLevel":1,"name":"name1","values":[{"id":2,"title":"Yes","type":"MIDWAY","currentLevel":2,"value":1,"childs":[{"id":3,"title":"If it is deducted twice, please contact the online service with the official bank statement.","type":"END","currentLevel":3}]},{"id":4,"title":"No","type":"MIDWAY","currentLevel":2,"value":1,"childs":[{"id":5,"title":"Please contact your card issuer to double confirm.","type":"END","currentLevel":3}]}]}'"
+ "nt, 607);n";
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.print(";");
visitor.println();
Assert.assertEquals(expected, out.toString());
private int times = 3;
for (int i = 0; i < 1000; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
for (int i = 0; i < times; i++) {
public void test_14() throws Exception {
String sql = "SELECT COUNT(*) FROM `jfz_futures_department` `t` WHERE (((((t.state=1) AND (t.city='2005')) AND (t.mode_weekend=1)) AND (t.service_stock=1)) AND (t.software_program=1)) AND (1=0 OR (t.lat BETWEEN 31.201582181818 AND 31.237945818182 AND t.lng BETWEEN 121.43558877778 AND 121.48003322222) OR (t.lat BETWEEN 31.389604181818 AND 31.425967818182 AND t.lng BETWEEN 121.33426577778 AND 121.37871022222) OR (t.lat BETWEEN 31.376165181818 AND 31.412528818182 AND t.lng BETWEEN 121.34206277778 AND 121.38650722222) OR (t.lat BETWEEN 31.351904181818 AND 31.388267818182 AND t.lng BETWEEN 121.34012277778 AND 121.38456722222) OR (t.lat BETWEEN 31.345213181818 AND 31.381576818182 AND t.lng BETWEEN 121.34662677778 AND 121.39107122222) OR (t.lat BETWEEN 31.332292181818 AND 31.368655818182 AND t.lng BETWEEN 121.35711877778 AND 121.40156322222) OR (t.lat BETWEEN 31.307896181818 AND 31.344259818182 AND t.lng BETWEEN 121.37307277778 AND 121.41751722222) OR (t.lat BETWEEN 31.309006181818 AND 31.345369818182 AND t.lng BETWEEN 121.38302577778 AND 121.42747022222) OR (t.lat BETWEEN 31.303238181818 AND 31.339601818182 AND t.lng BETWEEN 121.39258377778 AND 121.43702822222) OR (t.lat BETWEEN 31.291669181818 AND 31.328032818182 AND t.lng BETWEEN 121.39793777778 AND 121.44238222222) OR (t.lat BETWEEN 31.281487181818 AND 31.317850818182 AND t.lng BETWEEN 121.40074077778 AND 121.44518522222) OR (t.lat BETWEEN 31.272909181818 AND 31.309272818182 AND t.lng BETWEEN 121.40584277778 AND 121.45028722222) OR (t.lat BETWEEN 31.261892181818 AND 31.298255818182 AND t.lng BETWEEN 121.40727977778 AND 121.45172422222) OR (t.lat BETWEEN 31.251923181818 AND 31.288286818182 AND t.lng BETWEEN 121.40681277778 AND 121.45125722222) OR (t.lat BETWEEN 31.244268181818 AND 31.280631818182 AND t.lng BETWEEN 121.40616577778 AND 121.45061022222) OR (t.lat BETWEEN 31.234541181818 AND 31.270904818182 AND t.lng BETWEEN 121.41410277778 AND 121.45854722222) OR (t.lat BETWEEN 31.227938181818 AND 31.264301818182 AND t.lng BETWEEN 121.42255077778 AND 121.46699522222) OR (t.lat BETWEEN 31.222164181818 AND 31.258527818182 AND t.lng BETWEEN 121.42657577778 AND 121.47102022222) OR (t.lat BETWEEN 31.210987181818 AND 31.247350818182 AND t.lng BETWEEN 121.43297177778 AND 121.47741622222) OR (t.lat BETWEEN 31.187516181818 AND 31.223879818182 AND t.lng BETWEEN 121.43404977778 AND 121.47849422222) OR (t.lat BETWEEN 31.179300181818 AND 31.215663818182 AND t.lng BETWEEN 121.43872077778 AND 121.48316522222) OR (t.lat BETWEEN 31.173029181818 AND 31.209392818182 AND t.lng BETWEEN 121.44116377778 AND 121.48560822222) OR (t.lat BETWEEN 31.159652181818 AND 31.196015818182 AND t.lng BETWEEN 121.45787277778 AND 121.50231722222) OR (t.lat BETWEEN 31.162062181818 AND 31.198425818182 AND t.lng BETWEEN 121.47034077778 AND 121.51478522222) OR (t.lat BETWEEN 31.165769181818 AND 31.202132818182 AND t.lng BETWEEN 121.47896477778 AND 121.52340922222) OR (t.lat BETWEEN 31.169507181818 AND 31.205870818182 AND t.lng BETWEEN 121.48510877778 AND 121.52955322222) OR (t.lat BETWEEN 31.172936181818 AND 31.209299818182 AND t.lng BETWEEN 121.49423577778 AND 121.53868022222) OR (t.lat BETWEEN 31.175130181818 AND 31.211493818182 AND t.lng BETWEEN 121.50947077778 AND 121.55391522222) OR (t.lat BETWEEN 31.175346181818 AND 31.211709818182 AND t.lng BETWEEN 121.52427477778 AND 121.56871922222) OR (t.lat BETWEEN 31.181153181818 AND 31.217516818182 AND t.lng BETWEEN 121.53430077778 AND 121.57874522222) OR (t.lat BETWEEN 31.191099181818 AND 31.227462818182 AND t.lng BETWEEN 121.54166677778 AND 121.58611122222) OR (t.lat BETWEEN 31.199345181818 AND 31.235708818182 AND t.lng BETWEEN 121.54698477778 AND 121.59142922222))";
for (int i = 0; i < times; i++) {
System.out.println("--14--use time" + this.evaluate(sql, "mysql", 1000l));
public final static int RevisionVersion = 12;
if (objectName != null) {
DruidDataSource.this.setObjectName(objectName);
DruidDataSource.this.mbeanRegistered = true;
if (dataSource == null || name == null) {
return null;
if (mbeanServer == null) {
return null;
text = text.replace("\", "\\");
if (x.getDistinctOn() != null && x.getDistinctOn().size() > 0) {
public class Bug_for_weizhi extends TestCase {
public void test_for_issue() throws Exception {
String sql = "insert into aaa values(1,2,'\\');";
String expected = "INSERT INTO aaanVALUES (1, 2, '\\');";
StringBuilder out = new StringBuilder();
MySqlOutputVisitor visitor = new MySqlOutputVisitor(out);
MySqlStatementParser parser = new MySqlStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
for (SQLStatement statement : statementList) {
statement.accept(visitor);
visitor.print(";");
System.out.println(out.toString());
Assert.assertEquals(expected, out.toString());
String e = "SELECT 'new*n*line' REGEXP 'new\*.\*line';";
Assert.assertEquals("SELECT 'new*n*line' REGEXP 'new\\*.\\*line';", text);
Assert.assertEquals("SELECT filename, filename LIKE '%\\'nFROM t1;", text);
public class PGSelectTest21 extends PGTest {
public void test_0() throws Exception {
String sql = "SELECT DISTINCT(type) FROM dbmis2_databases";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals("SELECT DISTINCT typenFROM dbmis2_databases", output(statementList));
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertEquals(1, visitor.getColumns().size());
Assert.assertEquals(1, visitor.getTables().size());
boolean checkCondition = visitor != null
&& (!visitor.getConfig().isConstArithmeticAllow()
|| !visitor.getConfig().isConditionOpBitwseAllow() || !visitor.getConfig().isConditionOpXorAllow());
} else if (!checkCondition) {
Object leftResult = getValue(visitor, x.getLeft());
Object rightResult = getValue(visitor, x.getRight());
if (x.getOperator() == SQLBinaryOperator.Like && leftResult instanceof String && leftResult.equals(rightResult)) {
addViolation(visitor, ErrorCode.SAME_CONST_LIKE, "same const like", x);
if (x.getOperator() == SQLBinaryOperator.Like || x.getOperator() == SQLBinaryOperator.NotLike) {
public class Issue_728 extends TestCase {
public void test1() throws Exception {
String sql = "select * from city_list where city_id = 3-1";
WallConfig config = new WallConfig();
config.setConstArithmeticAllow(false);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void test2() throws Exception {
String sql = "SELECT * from city_list where 2 = case when 2=1 then 1 else 2 END";
WallConfig config = new WallConfig();
config.setCaseConditionConstAllow(false);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
public void test3() throws Exception {
String sql = "SELECT * from city_list where city_id = 1 & 2";
WallConfig config = new WallConfig();
config.setConditionOpBitwseAllow(false);
Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
if (ch == EOI) {
throw new ParserException("unterminated  comment.");
if (ch == EOI) {
throw new ParserException("syntax error at end of input.");
public class PGCommentTest extends PGTest {
public void test_0() {
String sql = "multiline comment test"
+ ".rn multiline comment test select * from a;";
PGSQLStatementParser parser;
parser = new PGSQLStatementParser(sql);
parser.parseStatementList();
} catch (Exception e) {
assertTrue(e instanceof ParserException);
public void test_1() {
String sql = "select a.id,--single line comment test a.name from a;";
PGSQLStatementParser parser;
parser = new PGSQLStatementParser(sql);
parser.parseStatementList();
} catch (Exception e) {
assertTrue(e instanceof ParserException);
public void test_2() throws Exception {
String sql = "multiline comment test"
+ ".rn multiline comment test*"
+ "/select --single line comment testrna.id,"
+ "multiline comment test"
+ "a.name from a;";
PGSQLStatementParser parser = new PGSQLStatementParser(sql);
List<SQLStatement> statementList = parser.parseStatementList();
SQLStatement statemen = statementList.get(0);
print(statementList);
Assert.assertEquals(1, statementList.size());
PGSchemaStatVisitor visitor = new PGSchemaStatVisitor();
statemen.accept(visitor);
System.out.println("Tables : " + visitor.getTables());
System.out.println("fields : " + visitor.getColumns());
System.out.println("coditions : " + visitor.getConditions());
Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("a")));
public static final String[] AGGREGATE_FUNCTIONS = {
public class PGIntervalExpr extends SQLExprImpl implements SQLLiteralExpr,PGExpr{
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public boolean equals(Object o) {
return false;
public int hashCode() {
protected void accept0(SQLASTVisitor visitor) {
this.accept0((PGASTVisitor) visitor);
protected SQLExpr parseInterval() {
accept(Token.INTERVAL);
PGIntervalExpr intervalExpr=new PGIntervalExpr();
if (lexer.token() != Token.LITERAL_CHARS) {
return new SQLIdentifierExpr("INTERVAL");
intervalExpr.setValue(new SQLCharExpr(lexer.stringVal()));
lexer.nextToken();
return intervalExpr;
void endVisit(PGIntervalExpr x);
boolean visit(PGIntervalExpr x);
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
return true;
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
print("INTERVAL ");
x.getValue().accept(this);
return true;
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
return true;
public class PGIntervalSQLTest extends TestCase{
public void testIntrevalSQL(){
String sql1="select timestamp '2001-09-28 01:00' + interval '23 hours'";
String sql1Result="SELECT TIMESTAMP '2001-09-28 01:00' + INTERVAL '23 hours'";
equal(sql1,sql1Result);
String sql2="select interval '1 day' - interval '1 hour'";
String sql2Result="SELECT INTERVAL '1 day' - INTERVAL '1 hour'";
equal(sql2,sql2Result);
String sql3="select date_part('month', interval '2 years 3 months')";
String sql3Result="SELECT date_part('month', INTERVAL '2 years 3 months')";
equal(sql3,sql3Result);
private void equal(String targetSql,String resultSql){
PGSQLStatementParser parser=new PGSQLStatementParser(targetSql);
PGSelectStatement statement = parser.parseSelect();
Assert.assertTrue(statement.toString().equals(resultSql));
public void testIntervalSQL(){
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
PGIntervalExpr that = (PGIntervalExpr) o;
if (value != null ? !value.equals(that.value) : that.value != null) return false;
return true;
return value != null ? value.hashCode() : 0;
if (JdbcUtils.ODPS.equals(dbType)) {
return new OdpsOutputVisitor(out);
public class OdpsSelectQueryBlock extends SQLSelectQueryBlock {
private SQLOrderBy orderBy;
private SQLExpr    limit;
public OdpsSelectQueryBlock(){
public SQLOrderBy getOrderBy() {
return orderBy;
public void setOrderBy(SQLOrderBy orderBy) {
this.orderBy = orderBy;
public SQLExpr getLimit() {
return limit;
public void setLimit(SQLExpr limit) {
if (limit != null) {
limit.setParent(this);
this.limit = limit;
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((limit == null) ? 0 : limit.hashCode());
return result;
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null) return false;
if (getClass() != obj.getClass()) return false;
OdpsSelectQueryBlock other = (OdpsSelectQueryBlock) obj;
if (limit == null) {
if (other.limit != null) return false;
} else if (!limit.equals(other.limit)) return false;
return true;
protected void accept0(SQLASTVisitor visitor) {
if (visitor instanceof OdpsASTVisitor) {
accept0((OdpsASTVisitor) visitor);
super.accept0(visitor);
public void accept0(OdpsASTVisitor visitor) {
if (visitor.visit(this)) {
acceptChild(visitor, this.selectList);
acceptChild(visitor, this.from);
acceptChild(visitor, this.where);
acceptChild(visitor, this.groupBy);
acceptChild(visitor, this.orderBy);
acceptChild(visitor, this.limit);
acceptChild(visitor, this.into);
visitor.endVisit(this);
map.put("LIMIT", Token.LIMIT);
public SQLSelectQuery query() {
if (lexer.token() == Token.LPAREN) {
lexer.nextToken();
SQLSelectQuery select = query();
accept(Token.RPAREN);
return queryRest(select);
accept(Token.SELECT);
if (lexer.token() == Token.COMMENT) {
lexer.nextToken();
OdpsSelectQueryBlock queryBlock = new OdpsSelectQueryBlock();
if (lexer.token() == Token.DISTINCT) {
queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);
lexer.nextToken();
} else if (lexer.token() == Token.UNIQUE) {
queryBlock.setDistionOption(SQLSetQuantifier.UNIQUE);
lexer.nextToken();
} else if (lexer.token() == Token.ALL) {
queryBlock.setDistionOption(SQLSetQuantifier.ALL);
lexer.nextToken();
parseSelectList(queryBlock);
parseFrom(queryBlock);
parseWhere(queryBlock);
parseGroupBy(queryBlock);
queryBlock.setOrderBy(this.exprParser.parseOrderBy());
if (lexer.token() == Token.LIMIT) {
lexer.nextToken();
queryBlock.setLimit(this.expr());
return queryRest(queryBlock);
public SQLSelectStatement parseSelect() {
OdpsSelectParser selectParser = new OdpsSelectParser(this.exprParser);
return new SQLSelectStatement(selectParser.select(), JdbcConstants.ODPS);
void endVisit(OdpsSelectQueryBlock x);
boolean visit(OdpsSelectQueryBlock x);
print("INSERT INTO TABLE ");
return false;
public void endVisit(OdpsSelectQueryBlock x) {
public boolean visit(OdpsSelectQueryBlock x) {
print("SELECT ");
if (SQLSetQuantifier.ALL == x.getDistionOption()) {
print("ALL ");
} else if (SQLSetQuantifier.DISTINCT == x.getDistionOption()) {
print("DISTINCT ");
} else if (SQLSetQuantifier.UNIQUE == x.getDistionOption()) {
print("UNIQUE ");
printSelectList(x.getSelectList());
if (x.getFrom() != null) {
println();
print("FROM ");
x.getFrom().accept(this);
if (x.getWhere() != null) {
println();
print("WHERE ");
x.getWhere().setParent(x);
x.getWhere().accept(this);
if (x.getGroupBy() != null) {
println();
x.getGroupBy().accept(this);
if (x.getOrderBy() != null) {
println();
x.getOrderBy().accept(this);
if (x.getLimit() != null) {
println();
print("LIMIT ");
x.getLimit().accept(this);
return false;
public boolean visit(SQLOrderBy x) {
int itemSize = x.getItems().size();
if (itemSize > 0) {
print("ORDER BY ");
incrementIndent();
for (int i = 0; i < itemSize; ++i) {
if (i != 0) {
println(", ");
x.getItems().get(i).accept(this);
decrementIndent();
public void endVisit(OdpsSelectQueryBlock x) {
public boolean visit(OdpsSelectQueryBlock x) {
return this.visit((SQLSelectQueryBlock) x);
if (JdbcUtils.ODPS.equals(dbType)) {
return new OdpsStatementParser(sql);
public final static int RevisionVersion = 13;
return toOdpsString(sqlObject);
public class PGIntervalExpr extends SQLExprImpl implements SQLLiteralExpr,PGExpr{
private SQLExpr value;
public SQLExpr getValue() {
return value;
public void setValue(SQLExpr value) {
this.value = value;
public void accept0(PGASTVisitor visitor) {
visitor.visit(this);
visitor.endVisit(this);
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
PGIntervalExpr that = (PGIntervalExpr) o;
if (value != null ? !value.equals(that.value) : that.value != null) return false;
return true;
public int hashCode() {
return value != null ? value.hashCode() : 0;
protected void accept0(SQLASTVisitor visitor) {
this.accept0((PGASTVisitor) visitor);
protected SQLExpr parseInterval() {
accept(Token.INTERVAL);
PGIntervalExpr intervalExpr=new PGIntervalExpr();
if (lexer.token() != Token.LITERAL_CHARS) {
return new SQLIdentifierExpr("INTERVAL");
intervalExpr.setValue(new SQLCharExpr(lexer.stringVal()));
lexer.nextToken();
return intervalExpr;
void endVisit(PGIntervalExpr x);
boolean visit(PGIntervalExpr x);
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
return true;
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
print("INTERVAL ");
x.getValue().accept(this);
return true;
@Override
public void endVisit(PGIntervalExpr x) {
@Override
public boolean visit(PGIntervalExpr x) {
return true;
public class PGIntervalSQLTest extends TestCase{
public void testIntervalSQL(){
String sql1="select timestamp '2001-09-28 01:00' + interval '23 hours'";
String sql1Result="SELECT TIMESTAMP '2001-09-28 01:00' + INTERVAL '23 hours'";
equal(sql1,sql1Result);
String sql2="select interval '1 day' - interval '1 hour'";
String sql2Result="SELECT INTERVAL '1 day' - INTERVAL '1 hour'";
equal(sql2,sql2Result);
String sql3="select date_part('month', interval '2 years 3 months')";
String sql3Result="SELECT date_part('month', INTERVAL '2 years 3 months')";
equal(sql3,sql3Result);
private void equal(String targetSql,String resultSql){
PGSQLStatementParser parser=new PGSQLStatementParser(targetSql);
PGSelectStatement statement = parser.parseSelect();
Assert.assertTrue(statement.toString().equals(resultSql));
